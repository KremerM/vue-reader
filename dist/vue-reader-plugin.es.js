import { getCurrentScope as Hy, onScopeDispose as Ky, unref as x, getCurrentInstance as ht, onMounted as Tt, nextTick as rt, watch as ke, ref as K, computed as F, openBlock as V, createElementBlock as se, createElementVNode as ae, warn as qy, inject as tt, isRef as on, shallowRef as Mn, onBeforeUnmount as Sn, onBeforeMount as ld, provide as Gt, defineComponent as be, mergeProps as qn, renderSlot as De, toRef as Tn, onUnmounted as Wo, useAttrs as hv, useSlots as Ho, withDirectives as $t, createCommentVNode as ye, Fragment as Ft, normalizeClass as ee, createBlock as Ce, withCtx as de, resolveDynamicComponent as In, withModifiers as ft, createVNode as ve, toDisplayString as st, normalizeStyle as it, vShow as Yn, Transition as gr, reactive as Pn, onUpdated as Dl, cloneVNode as Gy, Text as pv, Comment as vv, Teleport as mv, readonly as Yy, onDeactivated as Xy, createTextVNode as cn, toRaw as yi, vModelCheckbox as nl, toRefs as hn, vModelRadio as gv, toHandlers as Zy, markRaw as Ur, effectScope as yv, renderList as Gn, withKeys as vn, triggerRef as Gs, resolveComponent as Dt, resolveDirective as ud, vModelText as Qy, createSlots as Gu, h as et, watchEffect as oo, TransitionGroup as Jy, createApp as eb, isReactive as Bl, version as bv, pushScopeId as wv, popScopeId as _v } from "vue";
const jr = (t, e, { checkForDefaultPrevented: n = !0 } = {}) => (i) => {
  const s = t == null ? void 0 : t(i);
  if (n === !1 || !s)
    return e == null ? void 0 : e(i);
};
var tb = !1;
function ha(t, e, n) {
  return Array.isArray(t) ? (t.length = Math.max(t.length, e), t.splice(e, 1, n), n) : (t[e] = n, n);
}
function fu(t, e) {
  if (Array.isArray(t)) {
    t.splice(e, 1);
    return;
  }
  delete t[e];
}
var Mf;
const Et = typeof window < "u", nb = (t) => typeof t < "u", rb = (t) => typeof t == "function", ib = (t) => typeof t == "string", rl = () => {
}, Ev = Et && ((Mf = window == null ? void 0 : window.navigator) == null ? void 0 : Mf.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function cd(t) {
  return typeof t == "function" ? t() : x(t);
}
function sb(t, e) {
  function n(...r) {
    return new Promise((i, s) => {
      Promise.resolve(t(() => e.apply(this, r), { fn: e, thisArg: this, args: r })).then(i).catch(s);
    });
  }
  return n;
}
function ob(t, e = !0, n = !0, r = !1) {
  let i = 0, s, o = !0, a = rl, l;
  const u = () => {
    s && (clearTimeout(s), s = void 0, a(), a = rl);
  };
  return (d) => {
    const h = cd(t), v = Date.now() - i, y = () => l = d();
    return u(), h <= 0 ? (i = Date.now(), y()) : (v > h && (n || !o) ? (i = Date.now(), y()) : e && (l = new Promise((b, p) => {
      a = r ? p : b, s = setTimeout(() => {
        i = Date.now(), o = !0, b(y()), u();
      }, Math.max(0, h - v));
    })), !n && !s && (s = setTimeout(() => o = !0, h)), o = !1, l);
  };
}
function ab(t) {
  return t;
}
function dd(t) {
  return Hy() ? (Ky(t), !0) : !1;
}
function lb(t, e = 200, n = !1, r = !0, i = !1) {
  return sb(ob(e, n, r, i), t);
}
function ub(t, e = !0) {
  ht() ? Tt(t) : e ? t() : rt(t);
}
function pi(t) {
  var e;
  const n = cd(t);
  return (e = n == null ? void 0 : n.$el) != null ? e : n;
}
const fd = Et ? window : void 0;
function bn(...t) {
  let e, n, r, i;
  if (ib(t[0]) || Array.isArray(t[0]) ? ([n, r, i] = t, e = fd) : [e, n, r, i] = t, !e)
    return rl;
  Array.isArray(n) || (n = [n]), Array.isArray(r) || (r = [r]);
  const s = [], o = () => {
    s.forEach((c) => c()), s.length = 0;
  }, a = (c, d, h, v) => (c.addEventListener(d, h, v), () => c.removeEventListener(d, h, v)), l = ke(() => [pi(e), cd(i)], ([c, d]) => {
    o(), c && s.push(...n.flatMap((h) => r.map((v) => a(c, h, v, d))));
  }, { immediate: !0, flush: "post" }), u = () => {
    l(), o();
  };
  return dd(u), u;
}
let zf = !1;
function cb(t, e, n = {}) {
  const { window: r = fd, ignore: i = [], capture: s = !0, detectIframe: o = !1 } = n;
  if (!r)
    return;
  Ev && !zf && (zf = !0, Array.from(r.document.body.children).forEach((h) => h.addEventListener("click", rl)));
  let a = !0;
  const l = (h) => i.some((v) => {
    if (typeof v == "string")
      return Array.from(r.document.querySelectorAll(v)).some((y) => y === h.target || h.composedPath().includes(y));
    {
      const y = pi(v);
      return y && (h.target === y || h.composedPath().includes(y));
    }
  }), c = [
    bn(r, "click", (h) => {
      const v = pi(t);
      if (!(!v || v === h.target || h.composedPath().includes(v))) {
        if (h.detail === 0 && (a = !l(h)), !a) {
          a = !0;
          return;
        }
        e(h);
      }
    }, { passive: !0, capture: s }),
    bn(r, "pointerdown", (h) => {
      const v = pi(t);
      v && (a = !h.composedPath().includes(v) && !l(h));
    }, { passive: !0 }),
    o && bn(r, "blur", (h) => {
      var v;
      const y = pi(t);
      ((v = r.document.activeElement) == null ? void 0 : v.tagName) === "IFRAME" && !(y != null && y.contains(r.document.activeElement)) && e(h);
    })
  ].filter(Boolean);
  return () => c.forEach((h) => h());
}
function db(t, e = !1) {
  const n = K(), r = () => n.value = !!t();
  return r(), ub(r, e), n;
}
function fb(t) {
  return JSON.parse(JSON.stringify(t));
}
const Ff = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, jf = "__vueuse_ssr_handlers__";
Ff[jf] = Ff[jf] || {};
var Uf = Object.getOwnPropertySymbols, hb = Object.prototype.hasOwnProperty, pb = Object.prototype.propertyIsEnumerable, vb = (t, e) => {
  var n = {};
  for (var r in t)
    hb.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && Uf)
    for (var r of Uf(t))
      e.indexOf(r) < 0 && pb.call(t, r) && (n[r] = t[r]);
  return n;
};
function Cs(t, e, n = {}) {
  const r = n, { window: i = fd } = r, s = vb(r, ["window"]);
  let o;
  const a = db(() => i && "ResizeObserver" in i), l = () => {
    o && (o.disconnect(), o = void 0);
  }, u = ke(() => pi(t), (d) => {
    l(), a.value && i && d && (o = new ResizeObserver(e), o.observe(d, s));
  }, { immediate: !0, flush: "post" }), c = () => {
    l(), u();
  };
  return dd(c), {
    isSupported: a,
    stop: c
  };
}
var Vf;
(function(t) {
  t.UP = "UP", t.RIGHT = "RIGHT", t.DOWN = "DOWN", t.LEFT = "LEFT", t.NONE = "NONE";
})(Vf || (Vf = {}));
var mb = Object.defineProperty, Wf = Object.getOwnPropertySymbols, gb = Object.prototype.hasOwnProperty, yb = Object.prototype.propertyIsEnumerable, Hf = (t, e, n) => e in t ? mb(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, bb = (t, e) => {
  for (var n in e || (e = {}))
    gb.call(e, n) && Hf(t, n, e[n]);
  if (Wf)
    for (var n of Wf(e))
      yb.call(e, n) && Hf(t, n, e[n]);
  return t;
};
const wb = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
bb({
  linear: ab
}, wb);
function _b(t, e, n, r = {}) {
  var i, s, o;
  const {
    clone: a = !1,
    passive: l = !1,
    eventName: u,
    deep: c = !1,
    defaultValue: d
  } = r, h = ht(), v = n || (h == null ? void 0 : h.emit) || ((i = h == null ? void 0 : h.$emit) == null ? void 0 : i.bind(h)) || ((o = (s = h == null ? void 0 : h.proxy) == null ? void 0 : s.$emit) == null ? void 0 : o.bind(h == null ? void 0 : h.proxy));
  let y = u;
  e || (e = "modelValue"), y = u || y || `update:${e.toString()}`;
  const b = (f) => a ? rb(a) ? a(f) : fb(f) : f, p = () => nb(t[e]) ? b(t[e]) : d;
  if (l) {
    const f = p(), m = K(f);
    return ke(() => t[e], (g) => m.value = b(g)), ke(m, (g) => {
      (g !== t[e] || c) && v(y, g);
    }, { deep: c }), m;
  } else
    return F({
      get() {
        return p();
      },
      set(f) {
        v(y, f);
      }
    });
}
const Eb = () => Et && /firefox/i.test(window.navigator.userAgent), Sb = (t, e) => {
  if (!Et || !t || !e)
    return !1;
  const n = t.getBoundingClientRect();
  let r;
  return e instanceof Element ? r = e.getBoundingClientRect() : r = {
    top: 0,
    right: window.innerWidth,
    bottom: window.innerHeight,
    left: 0
  }, n.top < r.bottom && n.bottom > r.top && n.right > r.left && n.left < r.right;
};
process.env.NODE_ENV !== "production" && Object.freeze({});
process.env.NODE_ENV !== "production" && Object.freeze([]);
const en = () => {
}, xb = Object.prototype.hasOwnProperty, Or = (t, e) => xb.call(t, e), Nr = Array.isArray, mn = (t) => typeof t == "function", qt = (t) => typeof t == "string", wn = (t) => t !== null && typeof t == "object", Cb = Object.prototype.toString, Sv = (t) => Cb.call(t), hu = (t) => Sv(t).slice(8, -1), Kf = (t) => Sv(t) === "[object Object]", xv = (t) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (n) => e[n] || (e[n] = t(n));
}, kb = /-(\w)/g, Tb = xv((t) => t.replace(kb, (e, n) => n ? n.toUpperCase() : "")), Ob = /\B([A-Z])/g, Nb = xv((t) => t.replace(Ob, "-$1").toLowerCase());
var Ab = typeof global == "object" && global && global.Object === Object && global;
const Cv = Ab;
var Ib = typeof self == "object" && self && self.Object === Object && self, Rb = Cv || Ib || Function("return this")();
const yr = Rb;
var Lb = yr.Symbol;
const nr = Lb;
var kv = Object.prototype, Pb = kv.hasOwnProperty, $b = kv.toString, Ys = nr ? nr.toStringTag : void 0;
function Db(t) {
  var e = Pb.call(t, Ys), n = t[Ys];
  try {
    t[Ys] = void 0;
    var r = !0;
  } catch {
  }
  var i = $b.call(t);
  return r && (e ? t[Ys] = n : delete t[Ys]), i;
}
var Bb = Object.prototype, Mb = Bb.toString;
function zb(t) {
  return Mb.call(t);
}
var Fb = "[object Null]", jb = "[object Undefined]", qf = nr ? nr.toStringTag : void 0;
function Hi(t) {
  return t == null ? t === void 0 ? jb : Fb : qf && qf in Object(t) ? Db(t) : zb(t);
}
function Ar(t) {
  return t != null && typeof t == "object";
}
var Ub = "[object Symbol]";
function Ml(t) {
  return typeof t == "symbol" || Ar(t) && Hi(t) == Ub;
}
function Tv(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length, i = Array(r); ++n < r; )
    i[n] = e(t[n], n, t);
  return i;
}
var Vb = Array.isArray;
const jn = Vb;
var Wb = 1 / 0, Gf = nr ? nr.prototype : void 0, Yf = Gf ? Gf.toString : void 0;
function Ov(t) {
  if (typeof t == "string")
    return t;
  if (jn(t))
    return Tv(t, Ov) + "";
  if (Ml(t))
    return Yf ? Yf.call(t) : "";
  var e = t + "";
  return e == "0" && 1 / t == -Wb ? "-0" : e;
}
var Hb = /\s/;
function Kb(t) {
  for (var e = t.length; e-- && Hb.test(t.charAt(e)); )
    ;
  return e;
}
var qb = /^\s+/;
function Gb(t) {
  return t && t.slice(0, Kb(t) + 1).replace(qb, "");
}
function Rn(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var Xf = 0 / 0, Yb = /^[-+]0x[0-9a-f]+$/i, Xb = /^0b[01]+$/i, Zb = /^0o[0-7]+$/i, Qb = parseInt;
function Yu(t) {
  if (typeof t == "number")
    return t;
  if (Ml(t))
    return Xf;
  if (Rn(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = Rn(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = Gb(t);
  var n = Xb.test(t);
  return n || Zb.test(t) ? Qb(t.slice(2), n ? 2 : 8) : Yb.test(t) ? Xf : +t;
}
var Zf = 1 / 0, Jb = 17976931348623157e292;
function ew(t) {
  if (!t)
    return t === 0 ? t : 0;
  if (t = Yu(t), t === Zf || t === -Zf) {
    var e = t < 0 ? -1 : 1;
    return e * Jb;
  }
  return t === t ? t : 0;
}
function tw(t) {
  var e = ew(t), n = e % 1;
  return e === e ? n ? e - n : e : 0;
}
function hd(t) {
  return t;
}
var nw = "[object AsyncFunction]", rw = "[object Function]", iw = "[object GeneratorFunction]", sw = "[object Proxy]";
function pd(t) {
  if (!Rn(t))
    return !1;
  var e = Hi(t);
  return e == rw || e == iw || e == nw || e == sw;
}
var ow = yr["__core-js_shared__"];
const pu = ow;
var Qf = function() {
  var t = /[^.]+$/.exec(pu && pu.keys && pu.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
}();
function aw(t) {
  return !!Qf && Qf in t;
}
var lw = Function.prototype, uw = lw.toString;
function Ki(t) {
  if (t != null) {
    try {
      return uw.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
var cw = /[\\^$.*+?()[\]{}|]/g, dw = /^\[object .+?Constructor\]$/, fw = Function.prototype, hw = Object.prototype, pw = fw.toString, vw = hw.hasOwnProperty, mw = RegExp(
  "^" + pw.call(vw).replace(cw, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function gw(t) {
  if (!Rn(t) || aw(t))
    return !1;
  var e = pd(t) ? mw : dw;
  return e.test(Ki(t));
}
function yw(t, e) {
  return t == null ? void 0 : t[e];
}
function qi(t, e) {
  var n = yw(t, e);
  return gw(n) ? n : void 0;
}
var bw = qi(yr, "WeakMap");
const Xu = bw;
var Jf = Object.create, ww = function() {
  function t() {
  }
  return function(e) {
    if (!Rn(e))
      return {};
    if (Jf)
      return Jf(e);
    t.prototype = e;
    var n = new t();
    return t.prototype = void 0, n;
  };
}();
const _w = ww;
function Ew(t, e, n) {
  switch (n.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, n[0]);
    case 2:
      return t.call(e, n[0], n[1]);
    case 3:
      return t.call(e, n[0], n[1], n[2]);
  }
  return t.apply(e, n);
}
function Nv(t, e) {
  var n = -1, r = t.length;
  for (e || (e = Array(r)); ++n < r; )
    e[n] = t[n];
  return e;
}
var Sw = 800, xw = 16, Cw = Date.now;
function kw(t) {
  var e = 0, n = 0;
  return function() {
    var r = Cw(), i = xw - (r - n);
    if (n = r, i > 0) {
      if (++e >= Sw)
        return arguments[0];
    } else
      e = 0;
    return t.apply(void 0, arguments);
  };
}
function Tw(t) {
  return function() {
    return t;
  };
}
var Ow = function() {
  try {
    var t = qi(Object, "defineProperty");
    return t({}, "", {}), t;
  } catch {
  }
}();
const il = Ow;
var Nw = il ? function(t, e) {
  return il(t, "toString", {
    configurable: !0,
    enumerable: !1,
    value: Tw(e),
    writable: !0
  });
} : hd;
const Aw = Nw;
var Iw = kw(Aw);
const Av = Iw;
function Rw(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length; ++n < r && e(t[n], n, t) !== !1; )
    ;
  return t;
}
function Lw(t, e, n, r) {
  for (var i = t.length, s = n + (r ? 1 : -1); r ? s-- : ++s < i; )
    if (e(t[s], s, t))
      return s;
  return -1;
}
var Pw = 9007199254740991, $w = /^(?:0|[1-9]\d*)$/;
function zl(t, e) {
  var n = typeof t;
  return e = e ?? Pw, !!e && (n == "number" || n != "symbol" && $w.test(t)) && t > -1 && t % 1 == 0 && t < e;
}
function vd(t, e, n) {
  e == "__proto__" && il ? il(t, e, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : t[e] = n;
}
function Ko(t, e) {
  return t === e || t !== t && e !== e;
}
var Dw = Object.prototype, Bw = Dw.hasOwnProperty;
function md(t, e, n) {
  var r = t[e];
  (!(Bw.call(t, e) && Ko(r, n)) || n === void 0 && !(e in t)) && vd(t, e, n);
}
function qo(t, e, n, r) {
  var i = !n;
  n || (n = {});
  for (var s = -1, o = e.length; ++s < o; ) {
    var a = e[s], l = r ? r(n[a], t[a], a, n, t) : void 0;
    l === void 0 && (l = t[a]), i ? vd(n, a, l) : md(n, a, l);
  }
  return n;
}
var eh = Math.max;
function Iv(t, e, n) {
  return e = eh(e === void 0 ? t.length - 1 : e, 0), function() {
    for (var r = arguments, i = -1, s = eh(r.length - e, 0), o = Array(s); ++i < s; )
      o[i] = r[e + i];
    i = -1;
    for (var a = Array(e + 1); ++i < e; )
      a[i] = r[i];
    return a[e] = n(o), Ew(t, this, a);
  };
}
function Mw(t, e) {
  return Av(Iv(t, e, hd), t + "");
}
var zw = 9007199254740991;
function gd(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= zw;
}
function zs(t) {
  return t != null && gd(t.length) && !pd(t);
}
function Fw(t, e, n) {
  if (!Rn(n))
    return !1;
  var r = typeof e;
  return (r == "number" ? zs(n) && zl(e, n.length) : r == "string" && e in n) ? Ko(n[e], t) : !1;
}
function jw(t) {
  return Mw(function(e, n) {
    var r = -1, i = n.length, s = i > 1 ? n[i - 1] : void 0, o = i > 2 ? n[2] : void 0;
    for (s = t.length > 3 && typeof s == "function" ? (i--, s) : void 0, o && Fw(n[0], n[1], o) && (s = i < 3 ? void 0 : s, i = 1), e = Object(e); ++r < i; ) {
      var a = n[r];
      a && t(e, a, r, s);
    }
    return e;
  });
}
var Uw = Object.prototype;
function yd(t) {
  var e = t && t.constructor, n = typeof e == "function" && e.prototype || Uw;
  return t === n;
}
function Vw(t, e) {
  for (var n = -1, r = Array(t); ++n < t; )
    r[n] = e(n);
  return r;
}
var Ww = "[object Arguments]";
function th(t) {
  return Ar(t) && Hi(t) == Ww;
}
var Rv = Object.prototype, Hw = Rv.hasOwnProperty, Kw = Rv.propertyIsEnumerable, qw = th(function() {
  return arguments;
}()) ? th : function(t) {
  return Ar(t) && Hw.call(t, "callee") && !Kw.call(t, "callee");
};
const wo = qw;
function Gw() {
  return !1;
}
var Lv = typeof exports == "object" && exports && !exports.nodeType && exports, nh = Lv && typeof module == "object" && module && !module.nodeType && module, Yw = nh && nh.exports === Lv, rh = Yw ? yr.Buffer : void 0, Xw = rh ? rh.isBuffer : void 0, Zw = Xw || Gw;
const _o = Zw;
var Qw = "[object Arguments]", Jw = "[object Array]", e1 = "[object Boolean]", t1 = "[object Date]", n1 = "[object Error]", r1 = "[object Function]", i1 = "[object Map]", s1 = "[object Number]", o1 = "[object Object]", a1 = "[object RegExp]", l1 = "[object Set]", u1 = "[object String]", c1 = "[object WeakMap]", d1 = "[object ArrayBuffer]", f1 = "[object DataView]", h1 = "[object Float32Array]", p1 = "[object Float64Array]", v1 = "[object Int8Array]", m1 = "[object Int16Array]", g1 = "[object Int32Array]", y1 = "[object Uint8Array]", b1 = "[object Uint8ClampedArray]", w1 = "[object Uint16Array]", _1 = "[object Uint32Array]", jt = {};
jt[h1] = jt[p1] = jt[v1] = jt[m1] = jt[g1] = jt[y1] = jt[b1] = jt[w1] = jt[_1] = !0;
jt[Qw] = jt[Jw] = jt[d1] = jt[e1] = jt[f1] = jt[t1] = jt[n1] = jt[r1] = jt[i1] = jt[s1] = jt[o1] = jt[a1] = jt[l1] = jt[u1] = jt[c1] = !1;
function E1(t) {
  return Ar(t) && gd(t.length) && !!jt[Hi(t)];
}
function bd(t) {
  return function(e) {
    return t(e);
  };
}
var Pv = typeof exports == "object" && exports && !exports.nodeType && exports, ao = Pv && typeof module == "object" && module && !module.nodeType && module, S1 = ao && ao.exports === Pv, vu = S1 && Cv.process, x1 = function() {
  try {
    var t = ao && ao.require && ao.require("util").types;
    return t || vu && vu.binding && vu.binding("util");
  } catch {
  }
}();
const ks = x1;
var ih = ks && ks.isTypedArray, C1 = ih ? bd(ih) : E1;
const wd = C1;
var k1 = Object.prototype, T1 = k1.hasOwnProperty;
function $v(t, e) {
  var n = jn(t), r = !n && wo(t), i = !n && !r && _o(t), s = !n && !r && !i && wd(t), o = n || r || i || s, a = o ? Vw(t.length, String) : [], l = a.length;
  for (var u in t)
    (e || T1.call(t, u)) && !(o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (u == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (u == "offset" || u == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (u == "buffer" || u == "byteLength" || u == "byteOffset") || // Skip index properties.
    zl(u, l))) && a.push(u);
  return a;
}
function Dv(t, e) {
  return function(n) {
    return t(e(n));
  };
}
var O1 = Dv(Object.keys, Object);
const N1 = O1;
var A1 = Object.prototype, I1 = A1.hasOwnProperty;
function R1(t) {
  if (!yd(t))
    return N1(t);
  var e = [];
  for (var n in Object(t))
    I1.call(t, n) && n != "constructor" && e.push(n);
  return e;
}
function Go(t) {
  return zs(t) ? $v(t) : R1(t);
}
function L1(t) {
  var e = [];
  if (t != null)
    for (var n in Object(t))
      e.push(n);
  return e;
}
var P1 = Object.prototype, $1 = P1.hasOwnProperty;
function D1(t) {
  if (!Rn(t))
    return L1(t);
  var e = yd(t), n = [];
  for (var r in t)
    r == "constructor" && (e || !$1.call(t, r)) || n.push(r);
  return n;
}
function Yo(t) {
  return zs(t) ? $v(t, !0) : D1(t);
}
var B1 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, M1 = /^\w*$/;
function _d(t, e) {
  if (jn(t))
    return !1;
  var n = typeof t;
  return n == "number" || n == "symbol" || n == "boolean" || t == null || Ml(t) ? !0 : M1.test(t) || !B1.test(t) || e != null && t in Object(e);
}
var z1 = qi(Object, "create");
const Eo = z1;
function F1() {
  this.__data__ = Eo ? Eo(null) : {}, this.size = 0;
}
function j1(t) {
  var e = this.has(t) && delete this.__data__[t];
  return this.size -= e ? 1 : 0, e;
}
var U1 = "__lodash_hash_undefined__", V1 = Object.prototype, W1 = V1.hasOwnProperty;
function H1(t) {
  var e = this.__data__;
  if (Eo) {
    var n = e[t];
    return n === U1 ? void 0 : n;
  }
  return W1.call(e, t) ? e[t] : void 0;
}
var K1 = Object.prototype, q1 = K1.hasOwnProperty;
function G1(t) {
  var e = this.__data__;
  return Eo ? e[t] !== void 0 : q1.call(e, t);
}
var Y1 = "__lodash_hash_undefined__";
function X1(t, e) {
  var n = this.__data__;
  return this.size += this.has(t) ? 0 : 1, n[t] = Eo && e === void 0 ? Y1 : e, this;
}
function Mi(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
Mi.prototype.clear = F1;
Mi.prototype.delete = j1;
Mi.prototype.get = H1;
Mi.prototype.has = G1;
Mi.prototype.set = X1;
function Z1() {
  this.__data__ = [], this.size = 0;
}
function Fl(t, e) {
  for (var n = t.length; n--; )
    if (Ko(t[n][0], e))
      return n;
  return -1;
}
var Q1 = Array.prototype, J1 = Q1.splice;
function e_(t) {
  var e = this.__data__, n = Fl(e, t);
  if (n < 0)
    return !1;
  var r = e.length - 1;
  return n == r ? e.pop() : J1.call(e, n, 1), --this.size, !0;
}
function t_(t) {
  var e = this.__data__, n = Fl(e, t);
  return n < 0 ? void 0 : e[n][1];
}
function n_(t) {
  return Fl(this.__data__, t) > -1;
}
function r_(t, e) {
  var n = this.__data__, r = Fl(n, t);
  return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this;
}
function ii(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
ii.prototype.clear = Z1;
ii.prototype.delete = e_;
ii.prototype.get = t_;
ii.prototype.has = n_;
ii.prototype.set = r_;
var i_ = qi(yr, "Map");
const So = i_;
function s_() {
  this.size = 0, this.__data__ = {
    hash: new Mi(),
    map: new (So || ii)(),
    string: new Mi()
  };
}
function o_(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
function jl(t, e) {
  var n = t.__data__;
  return o_(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map;
}
function a_(t) {
  var e = jl(this, t).delete(t);
  return this.size -= e ? 1 : 0, e;
}
function l_(t) {
  return jl(this, t).get(t);
}
function u_(t) {
  return jl(this, t).has(t);
}
function c_(t, e) {
  var n = jl(this, t), r = n.size;
  return n.set(t, e), this.size += n.size == r ? 0 : 1, this;
}
function si(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
si.prototype.clear = s_;
si.prototype.delete = a_;
si.prototype.get = l_;
si.prototype.has = u_;
si.prototype.set = c_;
var d_ = "Expected a function";
function Ed(t, e) {
  if (typeof t != "function" || e != null && typeof e != "function")
    throw new TypeError(d_);
  var n = function() {
    var r = arguments, i = e ? e.apply(this, r) : r[0], s = n.cache;
    if (s.has(i))
      return s.get(i);
    var o = t.apply(this, r);
    return n.cache = s.set(i, o) || s, o;
  };
  return n.cache = new (Ed.Cache || si)(), n;
}
Ed.Cache = si;
var f_ = 500;
function h_(t) {
  var e = Ed(t, function(r) {
    return n.size === f_ && n.clear(), r;
  }), n = e.cache;
  return e;
}
var p_ = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, v_ = /\\(\\)?/g, m_ = h_(function(t) {
  var e = [];
  return t.charCodeAt(0) === 46 && e.push(""), t.replace(p_, function(n, r, i, s) {
    e.push(i ? s.replace(v_, "$1") : r || n);
  }), e;
});
const g_ = m_;
function y_(t) {
  return t == null ? "" : Ov(t);
}
function Ul(t, e) {
  return jn(t) ? t : _d(t, e) ? [t] : g_(y_(t));
}
var b_ = 1 / 0;
function Xo(t) {
  if (typeof t == "string" || Ml(t))
    return t;
  var e = t + "";
  return e == "0" && 1 / t == -b_ ? "-0" : e;
}
function Sd(t, e) {
  e = Ul(e, t);
  for (var n = 0, r = e.length; t != null && n < r; )
    t = t[Xo(e[n++])];
  return n && n == r ? t : void 0;
}
function Cn(t, e, n) {
  var r = t == null ? void 0 : Sd(t, e);
  return r === void 0 ? n : r;
}
function xd(t, e) {
  for (var n = -1, r = e.length, i = t.length; ++n < r; )
    t[i + n] = e[n];
  return t;
}
var sh = nr ? nr.isConcatSpreadable : void 0;
function w_(t) {
  return jn(t) || wo(t) || !!(sh && t && t[sh]);
}
function Cd(t, e, n, r, i) {
  var s = -1, o = t.length;
  for (n || (n = w_), i || (i = []); ++s < o; ) {
    var a = t[s];
    e > 0 && n(a) ? e > 1 ? Cd(a, e - 1, n, r, i) : xd(i, a) : r || (i[i.length] = a);
  }
  return i;
}
function __(t) {
  var e = t == null ? 0 : t.length;
  return e ? Cd(t, 1) : [];
}
function E_(t) {
  return Av(Iv(t, void 0, __), t + "");
}
var S_ = Dv(Object.getPrototypeOf, Object);
const kd = S_;
var x_ = "[object Object]", C_ = Function.prototype, k_ = Object.prototype, Bv = C_.toString, T_ = k_.hasOwnProperty, O_ = Bv.call(Object);
function N_(t) {
  if (!Ar(t) || Hi(t) != x_)
    return !1;
  var e = kd(t);
  if (e === null)
    return !0;
  var n = T_.call(e, "constructor") && e.constructor;
  return typeof n == "function" && n instanceof n && Bv.call(n) == O_;
}
function A_() {
  this.__data__ = new ii(), this.size = 0;
}
function I_(t) {
  var e = this.__data__, n = e.delete(t);
  return this.size = e.size, n;
}
function R_(t) {
  return this.__data__.get(t);
}
function L_(t) {
  return this.__data__.has(t);
}
var P_ = 200;
function $_(t, e) {
  var n = this.__data__;
  if (n instanceof ii) {
    var r = n.__data__;
    if (!So || r.length < P_ - 1)
      return r.push([t, e]), this.size = ++n.size, this;
    n = this.__data__ = new si(r);
  }
  return n.set(t, e), this.size = n.size, this;
}
function pr(t) {
  var e = this.__data__ = new ii(t);
  this.size = e.size;
}
pr.prototype.clear = A_;
pr.prototype.delete = I_;
pr.prototype.get = R_;
pr.prototype.has = L_;
pr.prototype.set = $_;
function D_(t, e) {
  return t && qo(e, Go(e), t);
}
function B_(t, e) {
  return t && qo(e, Yo(e), t);
}
var Mv = typeof exports == "object" && exports && !exports.nodeType && exports, oh = Mv && typeof module == "object" && module && !module.nodeType && module, M_ = oh && oh.exports === Mv, ah = M_ ? yr.Buffer : void 0, lh = ah ? ah.allocUnsafe : void 0;
function zv(t, e) {
  if (e)
    return t.slice();
  var n = t.length, r = lh ? lh(n) : new t.constructor(n);
  return t.copy(r), r;
}
function z_(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length, i = 0, s = []; ++n < r; ) {
    var o = t[n];
    e(o, n, t) && (s[i++] = o);
  }
  return s;
}
function Fv() {
  return [];
}
var F_ = Object.prototype, j_ = F_.propertyIsEnumerable, uh = Object.getOwnPropertySymbols, U_ = uh ? function(t) {
  return t == null ? [] : (t = Object(t), z_(uh(t), function(e) {
    return j_.call(t, e);
  }));
} : Fv;
const Td = U_;
function V_(t, e) {
  return qo(t, Td(t), e);
}
var W_ = Object.getOwnPropertySymbols, H_ = W_ ? function(t) {
  for (var e = []; t; )
    xd(e, Td(t)), t = kd(t);
  return e;
} : Fv;
const jv = H_;
function K_(t, e) {
  return qo(t, jv(t), e);
}
function Uv(t, e, n) {
  var r = e(t);
  return jn(t) ? r : xd(r, n(t));
}
function Zu(t) {
  return Uv(t, Go, Td);
}
function q_(t) {
  return Uv(t, Yo, jv);
}
var G_ = qi(yr, "DataView");
const Qu = G_;
var Y_ = qi(yr, "Promise");
const Ju = Y_;
var X_ = qi(yr, "Set");
const ec = X_;
var ch = "[object Map]", Z_ = "[object Object]", dh = "[object Promise]", fh = "[object Set]", hh = "[object WeakMap]", ph = "[object DataView]", Q_ = Ki(Qu), J_ = Ki(So), eE = Ki(Ju), tE = Ki(ec), nE = Ki(Xu), Oi = Hi;
(Qu && Oi(new Qu(new ArrayBuffer(1))) != ph || So && Oi(new So()) != ch || Ju && Oi(Ju.resolve()) != dh || ec && Oi(new ec()) != fh || Xu && Oi(new Xu()) != hh) && (Oi = function(t) {
  var e = Hi(t), n = e == Z_ ? t.constructor : void 0, r = n ? Ki(n) : "";
  if (r)
    switch (r) {
      case Q_:
        return ph;
      case J_:
        return ch;
      case eE:
        return dh;
      case tE:
        return fh;
      case nE:
        return hh;
    }
  return e;
});
const xo = Oi;
var rE = Object.prototype, iE = rE.hasOwnProperty;
function sE(t) {
  var e = t.length, n = new t.constructor(e);
  return e && typeof t[0] == "string" && iE.call(t, "index") && (n.index = t.index, n.input = t.input), n;
}
var oE = yr.Uint8Array;
const sl = oE;
function Od(t) {
  var e = new t.constructor(t.byteLength);
  return new sl(e).set(new sl(t)), e;
}
function aE(t, e) {
  var n = e ? Od(t.buffer) : t.buffer;
  return new t.constructor(n, t.byteOffset, t.byteLength);
}
var lE = /\w*$/;
function uE(t) {
  var e = new t.constructor(t.source, lE.exec(t));
  return e.lastIndex = t.lastIndex, e;
}
var vh = nr ? nr.prototype : void 0, mh = vh ? vh.valueOf : void 0;
function cE(t) {
  return mh ? Object(mh.call(t)) : {};
}
function Vv(t, e) {
  var n = e ? Od(t.buffer) : t.buffer;
  return new t.constructor(n, t.byteOffset, t.length);
}
var dE = "[object Boolean]", fE = "[object Date]", hE = "[object Map]", pE = "[object Number]", vE = "[object RegExp]", mE = "[object Set]", gE = "[object String]", yE = "[object Symbol]", bE = "[object ArrayBuffer]", wE = "[object DataView]", _E = "[object Float32Array]", EE = "[object Float64Array]", SE = "[object Int8Array]", xE = "[object Int16Array]", CE = "[object Int32Array]", kE = "[object Uint8Array]", TE = "[object Uint8ClampedArray]", OE = "[object Uint16Array]", NE = "[object Uint32Array]";
function AE(t, e, n) {
  var r = t.constructor;
  switch (e) {
    case bE:
      return Od(t);
    case dE:
    case fE:
      return new r(+t);
    case wE:
      return aE(t, n);
    case _E:
    case EE:
    case SE:
    case xE:
    case CE:
    case kE:
    case TE:
    case OE:
    case NE:
      return Vv(t, n);
    case hE:
      return new r();
    case pE:
    case gE:
      return new r(t);
    case vE:
      return uE(t);
    case mE:
      return new r();
    case yE:
      return cE(t);
  }
}
function Wv(t) {
  return typeof t.constructor == "function" && !yd(t) ? _w(kd(t)) : {};
}
var IE = "[object Map]";
function RE(t) {
  return Ar(t) && xo(t) == IE;
}
var gh = ks && ks.isMap, LE = gh ? bd(gh) : RE;
const PE = LE;
var $E = "[object Set]";
function DE(t) {
  return Ar(t) && xo(t) == $E;
}
var yh = ks && ks.isSet, BE = yh ? bd(yh) : DE;
const ME = BE;
var zE = 1, FE = 2, jE = 4, Hv = "[object Arguments]", UE = "[object Array]", VE = "[object Boolean]", WE = "[object Date]", HE = "[object Error]", Kv = "[object Function]", KE = "[object GeneratorFunction]", qE = "[object Map]", GE = "[object Number]", qv = "[object Object]", YE = "[object RegExp]", XE = "[object Set]", ZE = "[object String]", QE = "[object Symbol]", JE = "[object WeakMap]", e2 = "[object ArrayBuffer]", t2 = "[object DataView]", n2 = "[object Float32Array]", r2 = "[object Float64Array]", i2 = "[object Int8Array]", s2 = "[object Int16Array]", o2 = "[object Int32Array]", a2 = "[object Uint8Array]", l2 = "[object Uint8ClampedArray]", u2 = "[object Uint16Array]", c2 = "[object Uint32Array]", zt = {};
zt[Hv] = zt[UE] = zt[e2] = zt[t2] = zt[VE] = zt[WE] = zt[n2] = zt[r2] = zt[i2] = zt[s2] = zt[o2] = zt[qE] = zt[GE] = zt[qv] = zt[YE] = zt[XE] = zt[ZE] = zt[QE] = zt[a2] = zt[l2] = zt[u2] = zt[c2] = !0;
zt[HE] = zt[Kv] = zt[JE] = !1;
function La(t, e, n, r, i, s) {
  var o, a = e & zE, l = e & FE, u = e & jE;
  if (n && (o = i ? n(t, r, i, s) : n(t)), o !== void 0)
    return o;
  if (!Rn(t))
    return t;
  var c = jn(t);
  if (c) {
    if (o = sE(t), !a)
      return Nv(t, o);
  } else {
    var d = xo(t), h = d == Kv || d == KE;
    if (_o(t))
      return zv(t, a);
    if (d == qv || d == Hv || h && !i) {
      if (o = l || h ? {} : Wv(t), !a)
        return l ? K_(t, B_(o, t)) : V_(t, D_(o, t));
    } else {
      if (!zt[d])
        return i ? t : {};
      o = AE(t, d, a);
    }
  }
  s || (s = new pr());
  var v = s.get(t);
  if (v)
    return v;
  s.set(t, o), ME(t) ? t.forEach(function(p) {
    o.add(La(p, e, n, p, t, s));
  }) : PE(t) && t.forEach(function(p, f) {
    o.set(f, La(p, e, n, f, t, s));
  });
  var y = u ? l ? q_ : Zu : l ? Yo : Go, b = c ? void 0 : y(t);
  return Rw(b || t, function(p, f) {
    b && (f = p, p = t[f]), md(o, f, La(p, e, n, f, t, s));
  }), o;
}
var d2 = 1, f2 = 4;
function bh(t) {
  return La(t, d2 | f2);
}
var h2 = "__lodash_hash_undefined__";
function p2(t) {
  return this.__data__.set(t, h2), this;
}
function v2(t) {
  return this.__data__.has(t);
}
function ol(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.__data__ = new si(); ++e < n; )
    this.add(t[e]);
}
ol.prototype.add = ol.prototype.push = p2;
ol.prototype.has = v2;
function m2(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length; ++n < r; )
    if (e(t[n], n, t))
      return !0;
  return !1;
}
function g2(t, e) {
  return t.has(e);
}
var y2 = 1, b2 = 2;
function Gv(t, e, n, r, i, s) {
  var o = n & y2, a = t.length, l = e.length;
  if (a != l && !(o && l > a))
    return !1;
  var u = s.get(t), c = s.get(e);
  if (u && c)
    return u == e && c == t;
  var d = -1, h = !0, v = n & b2 ? new ol() : void 0;
  for (s.set(t, e), s.set(e, t); ++d < a; ) {
    var y = t[d], b = e[d];
    if (r)
      var p = o ? r(b, y, d, e, t, s) : r(y, b, d, t, e, s);
    if (p !== void 0) {
      if (p)
        continue;
      h = !1;
      break;
    }
    if (v) {
      if (!m2(e, function(f, m) {
        if (!g2(v, m) && (y === f || i(y, f, n, r, s)))
          return v.push(m);
      })) {
        h = !1;
        break;
      }
    } else if (!(y === b || i(y, b, n, r, s))) {
      h = !1;
      break;
    }
  }
  return s.delete(t), s.delete(e), h;
}
function w2(t) {
  var e = -1, n = Array(t.size);
  return t.forEach(function(r, i) {
    n[++e] = [i, r];
  }), n;
}
function _2(t) {
  var e = -1, n = Array(t.size);
  return t.forEach(function(r) {
    n[++e] = r;
  }), n;
}
var E2 = 1, S2 = 2, x2 = "[object Boolean]", C2 = "[object Date]", k2 = "[object Error]", T2 = "[object Map]", O2 = "[object Number]", N2 = "[object RegExp]", A2 = "[object Set]", I2 = "[object String]", R2 = "[object Symbol]", L2 = "[object ArrayBuffer]", P2 = "[object DataView]", wh = nr ? nr.prototype : void 0, mu = wh ? wh.valueOf : void 0;
function $2(t, e, n, r, i, s, o) {
  switch (n) {
    case P2:
      if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
        return !1;
      t = t.buffer, e = e.buffer;
    case L2:
      return !(t.byteLength != e.byteLength || !s(new sl(t), new sl(e)));
    case x2:
    case C2:
    case O2:
      return Ko(+t, +e);
    case k2:
      return t.name == e.name && t.message == e.message;
    case N2:
    case I2:
      return t == e + "";
    case T2:
      var a = w2;
    case A2:
      var l = r & E2;
      if (a || (a = _2), t.size != e.size && !l)
        return !1;
      var u = o.get(t);
      if (u)
        return u == e;
      r |= S2, o.set(t, e);
      var c = Gv(a(t), a(e), r, i, s, o);
      return o.delete(t), c;
    case R2:
      if (mu)
        return mu.call(t) == mu.call(e);
  }
  return !1;
}
var D2 = 1, B2 = Object.prototype, M2 = B2.hasOwnProperty;
function z2(t, e, n, r, i, s) {
  var o = n & D2, a = Zu(t), l = a.length, u = Zu(e), c = u.length;
  if (l != c && !o)
    return !1;
  for (var d = l; d--; ) {
    var h = a[d];
    if (!(o ? h in e : M2.call(e, h)))
      return !1;
  }
  var v = s.get(t), y = s.get(e);
  if (v && y)
    return v == e && y == t;
  var b = !0;
  s.set(t, e), s.set(e, t);
  for (var p = o; ++d < l; ) {
    h = a[d];
    var f = t[h], m = e[h];
    if (r)
      var g = o ? r(m, f, h, e, t, s) : r(f, m, h, t, e, s);
    if (!(g === void 0 ? f === m || i(f, m, n, r, s) : g)) {
      b = !1;
      break;
    }
    p || (p = h == "constructor");
  }
  if (b && !p) {
    var w = t.constructor, _ = e.constructor;
    w != _ && "constructor" in t && "constructor" in e && !(typeof w == "function" && w instanceof w && typeof _ == "function" && _ instanceof _) && (b = !1);
  }
  return s.delete(t), s.delete(e), b;
}
var F2 = 1, _h = "[object Arguments]", Eh = "[object Array]", pa = "[object Object]", j2 = Object.prototype, Sh = j2.hasOwnProperty;
function U2(t, e, n, r, i, s) {
  var o = jn(t), a = jn(e), l = o ? Eh : xo(t), u = a ? Eh : xo(e);
  l = l == _h ? pa : l, u = u == _h ? pa : u;
  var c = l == pa, d = u == pa, h = l == u;
  if (h && _o(t)) {
    if (!_o(e))
      return !1;
    o = !0, c = !1;
  }
  if (h && !c)
    return s || (s = new pr()), o || wd(t) ? Gv(t, e, n, r, i, s) : $2(t, e, l, n, r, i, s);
  if (!(n & F2)) {
    var v = c && Sh.call(t, "__wrapped__"), y = d && Sh.call(e, "__wrapped__");
    if (v || y) {
      var b = v ? t.value() : t, p = y ? e.value() : e;
      return s || (s = new pr()), i(b, p, n, r, s);
    }
  }
  return h ? (s || (s = new pr()), z2(t, e, n, r, i, s)) : !1;
}
function Vl(t, e, n, r, i) {
  return t === e ? !0 : t == null || e == null || !Ar(t) && !Ar(e) ? t !== t && e !== e : U2(t, e, n, r, Vl, i);
}
var V2 = 1, W2 = 2;
function H2(t, e, n, r) {
  var i = n.length, s = i, o = !r;
  if (t == null)
    return !s;
  for (t = Object(t); i--; ) {
    var a = n[i];
    if (o && a[2] ? a[1] !== t[a[0]] : !(a[0] in t))
      return !1;
  }
  for (; ++i < s; ) {
    a = n[i];
    var l = a[0], u = t[l], c = a[1];
    if (o && a[2]) {
      if (u === void 0 && !(l in t))
        return !1;
    } else {
      var d = new pr();
      if (r)
        var h = r(u, c, l, t, e, d);
      if (!(h === void 0 ? Vl(c, u, V2 | W2, r, d) : h))
        return !1;
    }
  }
  return !0;
}
function Yv(t) {
  return t === t && !Rn(t);
}
function K2(t) {
  for (var e = Go(t), n = e.length; n--; ) {
    var r = e[n], i = t[r];
    e[n] = [r, i, Yv(i)];
  }
  return e;
}
function Xv(t, e) {
  return function(n) {
    return n == null ? !1 : n[t] === e && (e !== void 0 || t in Object(n));
  };
}
function q2(t) {
  var e = K2(t);
  return e.length == 1 && e[0][2] ? Xv(e[0][0], e[0][1]) : function(n) {
    return n === t || H2(n, t, e);
  };
}
function G2(t, e) {
  return t != null && e in Object(t);
}
function Y2(t, e, n) {
  e = Ul(e, t);
  for (var r = -1, i = e.length, s = !1; ++r < i; ) {
    var o = Xo(e[r]);
    if (!(s = t != null && n(t, o)))
      break;
    t = t[o];
  }
  return s || ++r != i ? s : (i = t == null ? 0 : t.length, !!i && gd(i) && zl(o, i) && (jn(t) || wo(t)));
}
function Zv(t, e) {
  return t != null && Y2(t, e, G2);
}
var X2 = 1, Z2 = 2;
function Q2(t, e) {
  return _d(t) && Yv(e) ? Xv(Xo(t), e) : function(n) {
    var r = Cn(n, t);
    return r === void 0 && r === e ? Zv(n, t) : Vl(e, r, X2 | Z2);
  };
}
function J2(t) {
  return function(e) {
    return e == null ? void 0 : e[t];
  };
}
function eS(t) {
  return function(e) {
    return Sd(e, t);
  };
}
function tS(t) {
  return _d(t) ? J2(Xo(t)) : eS(t);
}
function Qv(t) {
  return typeof t == "function" ? t : t == null ? hd : typeof t == "object" ? jn(t) ? Q2(t[0], t[1]) : q2(t) : tS(t);
}
function nS(t) {
  return function(e, n, r) {
    for (var i = -1, s = Object(e), o = r(e), a = o.length; a--; ) {
      var l = o[t ? a : ++i];
      if (n(s[l], l, s) === !1)
        break;
    }
    return e;
  };
}
var rS = nS();
const Jv = rS;
function iS(t, e) {
  return t && Jv(t, e, Go);
}
function sS(t, e) {
  return function(n, r) {
    if (n == null)
      return n;
    if (!zs(n))
      return t(n, r);
    for (var i = n.length, s = e ? i : -1, o = Object(n); (e ? s-- : ++s < i) && r(o[s], s, o) !== !1; )
      ;
    return n;
  };
}
var oS = sS(iS);
const aS = oS;
var lS = function() {
  return yr.Date.now();
};
const gu = lS;
var uS = "Expected a function", cS = Math.max, dS = Math.min;
function Xr(t, e, n) {
  var r, i, s, o, a, l, u = 0, c = !1, d = !1, h = !0;
  if (typeof t != "function")
    throw new TypeError(uS);
  e = Yu(e) || 0, Rn(n) && (c = !!n.leading, d = "maxWait" in n, s = d ? cS(Yu(n.maxWait) || 0, e) : s, h = "trailing" in n ? !!n.trailing : h);
  function v(E) {
    var C = r, T = i;
    return r = i = void 0, u = E, o = t.apply(T, C), o;
  }
  function y(E) {
    return u = E, a = setTimeout(f, e), c ? v(E) : o;
  }
  function b(E) {
    var C = E - l, T = E - u, k = e - C;
    return d ? dS(k, s - T) : k;
  }
  function p(E) {
    var C = E - l, T = E - u;
    return l === void 0 || C >= e || C < 0 || d && T >= s;
  }
  function f() {
    var E = gu();
    if (p(E))
      return m(E);
    a = setTimeout(f, b(E));
  }
  function m(E) {
    return a = void 0, h && r ? v(E) : (r = i = void 0, o);
  }
  function g() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = i = a = void 0;
  }
  function w() {
    return a === void 0 ? o : m(gu());
  }
  function _() {
    var E = gu(), C = p(E);
    if (r = arguments, i = this, l = E, C) {
      if (a === void 0)
        return y(l);
      if (d)
        return clearTimeout(a), a = setTimeout(f, e), v(l);
    }
    return a === void 0 && (a = setTimeout(f, e)), o;
  }
  return _.cancel = g, _.flush = w, _;
}
function tc(t, e, n) {
  (n !== void 0 && !Ko(t[e], n) || n === void 0 && !(e in t)) && vd(t, e, n);
}
function fS(t) {
  return Ar(t) && zs(t);
}
function nc(t, e) {
  if (!(e === "constructor" && typeof t[e] == "function") && e != "__proto__")
    return t[e];
}
function hS(t) {
  return qo(t, Yo(t));
}
function pS(t, e, n, r, i, s, o) {
  var a = nc(t, n), l = nc(e, n), u = o.get(l);
  if (u) {
    tc(t, n, u);
    return;
  }
  var c = s ? s(a, l, n + "", t, e, o) : void 0, d = c === void 0;
  if (d) {
    var h = jn(l), v = !h && _o(l), y = !h && !v && wd(l);
    c = l, h || v || y ? jn(a) ? c = a : fS(a) ? c = Nv(a) : v ? (d = !1, c = zv(l, !0)) : y ? (d = !1, c = Vv(l, !0)) : c = [] : N_(l) || wo(l) ? (c = a, wo(a) ? c = hS(a) : (!Rn(a) || pd(a)) && (c = Wv(l))) : d = !1;
  }
  d && (o.set(l, c), i(c, l, r, s, o), o.delete(l)), tc(t, n, c);
}
function em(t, e, n, r, i) {
  t !== e && Jv(e, function(s, o) {
    if (i || (i = new pr()), Rn(s))
      pS(t, e, o, n, em, r, i);
    else {
      var a = r ? r(nc(t, o), s, o + "", t, e, i) : void 0;
      a === void 0 && (a = s), tc(t, o, a);
    }
  }, Yo);
}
var vS = Math.max, mS = Math.min;
function gS(t, e, n) {
  var r = t == null ? 0 : t.length;
  if (!r)
    return -1;
  var i = r - 1;
  return n !== void 0 && (i = tw(n), i = n < 0 ? vS(r + i, 0) : mS(i, r - 1)), Lw(t, Qv(e), i, !0);
}
function yS(t, e) {
  var n = -1, r = zs(t) ? Array(t.length) : [];
  return aS(t, function(i, s, o) {
    r[++n] = e(i, s, o);
  }), r;
}
function bS(t, e) {
  var n = jn(t) ? Tv : yS;
  return n(t, Qv(e));
}
function wS(t, e) {
  return Cd(bS(t, e), 1);
}
function al(t) {
  for (var e = -1, n = t == null ? 0 : t.length, r = {}; ++e < n; ) {
    var i = t[e];
    r[i[0]] = i[1];
  }
  return r;
}
function ll(t, e) {
  return Vl(t, e);
}
function er(t) {
  return t == null;
}
function _S(t) {
  return t === void 0;
}
var ES = jw(function(t, e, n) {
  em(t, e, n);
});
const tm = ES;
function nm(t, e, n, r) {
  if (!Rn(t))
    return t;
  e = Ul(e, t);
  for (var i = -1, s = e.length, o = s - 1, a = t; a != null && ++i < s; ) {
    var l = Xo(e[i]), u = n;
    if (l === "__proto__" || l === "constructor" || l === "prototype")
      return t;
    if (i != o) {
      var c = a[l];
      u = r ? r(c, l, a) : void 0, u === void 0 && (u = Rn(c) ? c : zl(e[i + 1]) ? [] : {});
    }
    md(a, l, u), a = a[l];
  }
  return t;
}
function SS(t, e, n) {
  for (var r = -1, i = e.length, s = {}; ++r < i; ) {
    var o = e[r], a = Sd(t, o);
    n(a, o) && nm(s, Ul(o, t), a);
  }
  return s;
}
function xS(t, e) {
  return SS(t, e, function(n, r) {
    return Zv(t, r);
  });
}
var CS = E_(function(t, e) {
  return t == null ? {} : xS(t, e);
});
const kS = CS;
function TS(t, e, n) {
  return t == null ? t : nm(t, e, n);
}
var OS = "Expected a function";
function yu(t, e, n) {
  var r = !0, i = !0;
  if (typeof t != "function")
    throw new TypeError(OS);
  return Rn(n) && (r = "leading" in n ? !!n.leading : r, i = "trailing" in n ? !!n.trailing : i), Xr(t, e, {
    leading: r,
    maxWait: e,
    trailing: i
  });
}
const Er = (t) => t === void 0, Zr = (t) => typeof t == "boolean", gt = (t) => typeof t == "number", zi = (t) => typeof Element > "u" ? !1 : t instanceof Element, NS = (t) => qt(t) ? !Number.isNaN(Number(t)) : !1, AS = (t = "") => t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d"), rc = (t) => Object.keys(t), IS = (t) => Object.entries(t), RS = (t, e, n) => ({
  get value() {
    return Cn(t, e, n);
  },
  set value(r) {
    TS(t, e, r);
  }
});
class rm extends Error {
  constructor(e) {
    super(e), this.name = "ElementPlusError";
  }
}
function Gi(t, e) {
  throw new rm(`[${t}] ${e}`);
}
function Vt(t, e) {
  if (process.env.NODE_ENV !== "production") {
    const n = qt(t) ? new rm(`[${t}] ${e}`) : t;
    console.warn(n);
  }
}
const LS = "utils/dom/style", im = (t = "") => t.split(" ").filter((e) => !!e.trim()), Pa = (t, e) => {
  if (!t || !e)
    return !1;
  if (e.includes(" "))
    throw new Error("className should not contain space.");
  return t.classList.contains(e);
}, Co = (t, e) => {
  !t || !e.trim() || t.classList.add(...im(e));
}, Sr = (t, e) => {
  !t || !e.trim() || t.classList.remove(...im(e));
}, fs = (t, e) => {
  var n;
  if (!Et || !t || !e)
    return "";
  let r = Tb(e);
  r === "float" && (r = "cssFloat");
  try {
    const i = t.style[r];
    if (i)
      return i;
    const s = (n = document.defaultView) == null ? void 0 : n.getComputedStyle(t, "");
    return s ? s[r] : "";
  } catch {
    return t.style[r];
  }
};
function ul(t, e = "px") {
  if (!t)
    return "";
  if (gt(t) || NS(t))
    return `${t}${e}`;
  if (qt(t))
    return t;
  Vt(LS, "binding value must be a string or number");
}
const PS = (t, e) => {
  if (!Et)
    return !1;
  const n = {
    undefined: "overflow",
    true: "overflow-y",
    false: "overflow-x"
  }[String(e)], r = fs(t, n);
  return ["scroll", "auto", "overlay"].some((i) => r.includes(i));
}, $S = (t, e) => {
  if (!Et)
    return;
  let n = t;
  for (; n; ) {
    if ([window, document, document.documentElement].includes(n))
      return window;
    if (PS(n, e))
      return n;
    n = n.parentNode;
  }
  return n;
};
function DS(t, e) {
  if (!Et)
    return;
  if (!e) {
    t.scrollTop = 0;
    return;
  }
  const n = [];
  let r = e.offsetParent;
  for (; r !== null && t !== r && t.contains(r); )
    n.push(r), r = r.offsetParent;
  const i = e.offsetTop + n.reduce((l, u) => l + u.offsetTop, 0), s = i + e.offsetHeight, o = t.scrollTop, a = o + t.clientHeight;
  i < o ? t.scrollTop = i : s > a && (t.scrollTop = s - t.clientHeight);
}
/*! Element Plus Icons Vue v2.1.0 */
var Ot = (t, e) => {
  let n = t.__vccOpts || t;
  for (let [r, i] of e)
    n[r] = i;
  return n;
}, BS = {
  name: "ArrowDown"
}, MS = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, zS = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
  },
  null,
  -1
  /* HOISTED */
), FS = [
  zS
];
function jS(t, e, n, r, i, s) {
  return V(), se("svg", MS, FS);
}
var Nd = /* @__PURE__ */ Ot(BS, [["render", jS], ["__file", "arrow-down.vue"]]), US = {
  name: "ArrowLeft"
}, VS = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, WS = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
  },
  null,
  -1
  /* HOISTED */
), HS = [
  WS
];
function KS(t, e, n, r, i, s) {
  return V(), se("svg", VS, HS);
}
var qS = /* @__PURE__ */ Ot(US, [["render", KS], ["__file", "arrow-left.vue"]]), GS = {
  name: "ArrowRight"
}, YS = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, XS = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
  },
  null,
  -1
  /* HOISTED */
), ZS = [
  XS
];
function QS(t, e, n, r, i, s) {
  return V(), se("svg", YS, ZS);
}
var Ad = /* @__PURE__ */ Ot(GS, [["render", QS], ["__file", "arrow-right.vue"]]), JS = {
  name: "ArrowUp"
}, ex = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, tx = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0z"
  },
  null,
  -1
  /* HOISTED */
), nx = [
  tx
];
function rx(t, e, n, r, i, s) {
  return V(), se("svg", ex, nx);
}
var sm = /* @__PURE__ */ Ot(JS, [["render", rx], ["__file", "arrow-up.vue"]]), ix = {
  name: "Back"
}, sx = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, ox = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M224 480h640a32 32 0 1 1 0 64H224a32 32 0 0 1 0-64z"
  },
  null,
  -1
  /* HOISTED */
), ax = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "m237.248 512 265.408 265.344a32 32 0 0 1-45.312 45.312l-288-288a32 32 0 0 1 0-45.312l288-288a32 32 0 1 1 45.312 45.312L237.248 512z"
  },
  null,
  -1
  /* HOISTED */
), lx = [
  ox,
  ax
];
function ux(t, e, n, r, i, s) {
  return V(), se("svg", sx, lx);
}
var cx = /* @__PURE__ */ Ot(ix, [["render", ux], ["__file", "back.vue"]]), dx = {
  name: "CaretRight"
}, fx = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, hx = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M384 192v640l384-320.064z"
  },
  null,
  -1
  /* HOISTED */
), px = [
  hx
];
function vx(t, e, n, r, i, s) {
  return V(), se("svg", fx, px);
}
var mx = /* @__PURE__ */ Ot(dx, [["render", vx], ["__file", "caret-right.vue"]]), gx = {
  name: "Check"
}, yx = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, bx = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
  },
  null,
  -1
  /* HOISTED */
), wx = [
  bx
];
function _x(t, e, n, r, i, s) {
  return V(), se("svg", yx, wx);
}
var om = /* @__PURE__ */ Ot(gx, [["render", _x], ["__file", "check.vue"]]), Ex = {
  name: "CircleCheck"
}, Sx = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, xx = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
  },
  null,
  -1
  /* HOISTED */
), Cx = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
  },
  null,
  -1
  /* HOISTED */
), kx = [
  xx,
  Cx
];
function Tx(t, e, n, r, i, s) {
  return V(), se("svg", Sx, kx);
}
var Id = /* @__PURE__ */ Ot(Ex, [["render", Tx], ["__file", "circle-check.vue"]]), Ox = {
  name: "CircleClose"
}, Nx = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, Ax = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248L466.752 512z"
  },
  null,
  -1
  /* HOISTED */
), Ix = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
  },
  null,
  -1
  /* HOISTED */
), Rx = [
  Ax,
  Ix
];
function Lx(t, e, n, r, i, s) {
  return V(), se("svg", Nx, Rx);
}
var Wl = /* @__PURE__ */ Ot(Ox, [["render", Lx], ["__file", "circle-close.vue"]]), Px = {
  name: "Close"
}, $x = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, Dx = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
  },
  null,
  -1
  /* HOISTED */
), Bx = [
  Dx
];
function Mx(t, e, n, r, i, s) {
  return V(), se("svg", $x, Bx);
}
var ko = /* @__PURE__ */ Ot(Px, [["render", Mx], ["__file", "close.vue"]]), zx = {
  name: "Delete"
}, Fx = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, jx = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V256zm448-64v-64H416v64h192zM224 896h576V256H224v640zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32zm192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32z"
  },
  null,
  -1
  /* HOISTED */
), Ux = [
  jx
];
function Vx(t, e, n, r, i, s) {
  return V(), se("svg", Fx, Ux);
}
var am = /* @__PURE__ */ Ot(zx, [["render", Vx], ["__file", "delete.vue"]]), Wx = {
  name: "Document"
}, Hx = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, Kx = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M832 384H576V128H192v768h640V384zm-26.496-64L640 154.496V320h165.504zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32zm160 448h384v64H320v-64zm0-192h160v64H320v-64zm0 384h384v64H320v-64z"
  },
  null,
  -1
  /* HOISTED */
), qx = [
  Kx
];
function Gx(t, e, n, r, i, s) {
  return V(), se("svg", Hx, qx);
}
var Yx = /* @__PURE__ */ Ot(Wx, [["render", Gx], ["__file", "document.vue"]]), Xx = {
  name: "Download"
}, Zx = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, Qx = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M160 832h704a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64zm384-253.696 236.288-236.352 45.248 45.248L508.8 704 192 387.2l45.248-45.248L480 584.704V128h64v450.304z"
  },
  null,
  -1
  /* HOISTED */
), Jx = [
  Qx
];
function eC(t, e, n, r, i, s) {
  return V(), se("svg", Zx, Jx);
}
var tC = /* @__PURE__ */ Ot(Xx, [["render", eC], ["__file", "download.vue"]]), nC = {
  name: "FullScreen"
}, rC = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, iC = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64v.064zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64l-192 .192zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64l192-.192zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64v-.064z"
  },
  null,
  -1
  /* HOISTED */
), sC = [
  iC
];
function oC(t, e, n, r, i, s) {
  return V(), se("svg", rC, sC);
}
var lm = /* @__PURE__ */ Ot(nC, [["render", oC], ["__file", "full-screen.vue"]]), aC = {
  name: "Grid"
}, lC = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, uC = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M640 384v256H384V384h256zm64 0h192v256H704V384zm-64 512H384V704h256v192zm64 0V704h192v192H704zm-64-768v192H384V128h256zm64 0h192v192H704V128zM320 384v256H128V384h192zm0 512H128V704h192v192zm0-768v192H128V128h192z"
  },
  null,
  -1
  /* HOISTED */
), cC = [
  uC
];
function dC(t, e, n, r, i, s) {
  return V(), se("svg", lC, cC);
}
var fC = /* @__PURE__ */ Ot(aC, [["render", dC], ["__file", "grid.vue"]]), hC = {
  name: "Hide"
}, pC = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, vC = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2L371.2 588.8ZM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
  },
  null,
  -1
  /* HOISTED */
), mC = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
  },
  null,
  -1
  /* HOISTED */
), gC = [
  vC,
  mC
];
function yC(t, e, n, r, i, s) {
  return V(), se("svg", pC, gC);
}
var bC = /* @__PURE__ */ Ot(hC, [["render", yC], ["__file", "hide.vue"]]), wC = {
  name: "Loading"
}, _C = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, EC = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32zm0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32zm448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32zm-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32zM195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0zm-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
  },
  null,
  -1
  /* HOISTED */
), SC = [
  EC
];
function xC(t, e, n, r, i, s) {
  return V(), se("svg", _C, SC);
}
var Hl = /* @__PURE__ */ Ot(wC, [["render", xC], ["__file", "loading.vue"]]), CC = {
  name: "Minus"
}, kC = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, TC = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64z"
  },
  null,
  -1
  /* HOISTED */
), OC = [
  TC
];
function NC(t, e, n, r, i, s) {
  return V(), se("svg", kC, OC);
}
var AC = /* @__PURE__ */ Ot(CC, [["render", NC], ["__file", "minus.vue"]]), IC = {
  name: "Operation"
}, RC = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, LC = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M389.44 768a96.064 96.064 0 0 1 181.12 0H896v64H570.56a96.064 96.064 0 0 1-181.12 0H128v-64h261.44zm192-288a96.064 96.064 0 0 1 181.12 0H896v64H762.56a96.064 96.064 0 0 1-181.12 0H128v-64h453.44zm-320-288a96.064 96.064 0 0 1 181.12 0H896v64H442.56a96.064 96.064 0 0 1-181.12 0H128v-64h133.44z"
  },
  null,
  -1
  /* HOISTED */
), PC = [
  LC
];
function $C(t, e, n, r, i, s) {
  return V(), se("svg", RC, PC);
}
var DC = /* @__PURE__ */ Ot(IC, [["render", $C], ["__file", "operation.vue"]]), BC = {
  name: "Picture"
}, MC = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, zC = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M160 160v704h704V160H160zm-32-64h768a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H128a32 32 0 0 1-32-32V128a32 32 0 0 1 32-32z"
  },
  null,
  -1
  /* HOISTED */
), FC = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M384 288q64 0 64 64t-64 64q-64 0-64-64t64-64zM185.408 876.992l-50.816-38.912L350.72 556.032a96 96 0 0 1 134.592-17.856l1.856 1.472 122.88 99.136a32 32 0 0 0 44.992-4.864l216-269.888 49.92 39.936-215.808 269.824-.256.32a96 96 0 0 1-135.04 14.464l-122.88-99.072-.64-.512a32 32 0 0 0-44.8 5.952L185.408 876.992z"
  },
  null,
  -1
  /* HOISTED */
), jC = [
  zC,
  FC
];
function UC(t, e, n, r, i, s) {
  return V(), se("svg", MC, jC);
}
var VC = /* @__PURE__ */ Ot(BC, [["render", UC], ["__file", "picture.vue"]]), WC = {
  name: "Plus"
}, HC = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, KC = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64h352z"
  },
  null,
  -1
  /* HOISTED */
), qC = [
  KC
];
function GC(t, e, n, r, i, s) {
  return V(), se("svg", HC, qC);
}
var um = /* @__PURE__ */ Ot(WC, [["render", GC], ["__file", "plus.vue"]]), YC = {
  name: "Reading"
}, XC = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, ZC = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "m512 863.36 384-54.848v-638.72L525.568 222.72a96 96 0 0 1-27.136 0L128 169.792v638.72l384 54.848zM137.024 106.432l370.432 52.928a32 32 0 0 0 9.088 0l370.432-52.928A64 64 0 0 1 960 169.792v638.72a64 64 0 0 1-54.976 63.36l-388.48 55.488a32 32 0 0 1-9.088 0l-388.48-55.488A64 64 0 0 1 64 808.512v-638.72a64 64 0 0 1 73.024-63.36z"
  },
  null,
  -1
  /* HOISTED */
), QC = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M480 192h64v704h-64z"
  },
  null,
  -1
  /* HOISTED */
), JC = [
  ZC,
  QC
];
function ek(t, e, n, r, i, s) {
  return V(), se("svg", XC, JC);
}
var tk = /* @__PURE__ */ Ot(YC, [["render", ek], ["__file", "reading.vue"]]), nk = {
  name: "RefreshLeft"
}, rk = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, ik = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z"
  },
  null,
  -1
  /* HOISTED */
), sk = [
  ik
];
function ok(t, e, n, r, i, s) {
  return V(), se("svg", rk, sk);
}
var ak = /* @__PURE__ */ Ot(nk, [["render", ok], ["__file", "refresh-left.vue"]]), lk = {
  name: "RefreshRight"
}, uk = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, ck = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z"
  },
  null,
  -1
  /* HOISTED */
), dk = [
  ck
];
function fk(t, e, n, r, i, s) {
  return V(), se("svg", uk, dk);
}
var hk = /* @__PURE__ */ Ot(lk, [["render", fk], ["__file", "refresh-right.vue"]]), pk = {
  name: "ScaleToOriginal"
}, vk = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, mk = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M813.176 180.706a60.235 60.235 0 0 1 60.236 60.235v481.883a60.235 60.235 0 0 1-60.236 60.235H210.824a60.235 60.235 0 0 1-60.236-60.235V240.94a60.235 60.235 0 0 1 60.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0 0 90.353 240.94v481.883a120.47 120.47 0 0 0 120.47 120.47h602.353a120.47 120.47 0 0 0 120.471-120.47V240.94a120.47 120.47 0 0 0-120.47-120.47zm-120.47 180.705a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 0 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zm-361.412 0a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 1 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zM512 361.412a30.118 30.118 0 0 0-30.118 30.117v30.118a30.118 30.118 0 0 0 60.236 0V391.53A30.118 30.118 0 0 0 512 361.412zM512 512a30.118 30.118 0 0 0-30.118 30.118v30.117a30.118 30.118 0 0 0 60.236 0v-30.117A30.118 30.118 0 0 0 512 512z"
  },
  null,
  -1
  /* HOISTED */
), gk = [
  mk
];
function yk(t, e, n, r, i, s) {
  return V(), se("svg", vk, gk);
}
var bk = /* @__PURE__ */ Ot(pk, [["render", yk], ["__file", "scale-to-original.vue"]]), wk = {
  name: "Search"
}, _k = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, Ek = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704z"
  },
  null,
  -1
  /* HOISTED */
), Sk = [
  Ek
];
function xk(t, e, n, r, i, s) {
  return V(), se("svg", _k, Sk);
}
var Ck = /* @__PURE__ */ Ot(wk, [["render", xk], ["__file", "search.vue"]]), kk = {
  name: "View"
}, Tk = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, Ok = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352zm0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448zm0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160z"
  },
  null,
  -1
  /* HOISTED */
), Nk = [
  Ok
];
function Ak(t, e, n, r, i, s) {
  return V(), se("svg", Tk, Nk);
}
var Ik = /* @__PURE__ */ Ot(kk, [["render", Ak], ["__file", "view.vue"]]), Rk = {
  name: "WarningFilled"
}, Lk = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, Pk = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256zm0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4z"
  },
  null,
  -1
  /* HOISTED */
), $k = [
  Pk
];
function Dk(t, e, n, r, i, s) {
  return V(), se("svg", Lk, $k);
}
var Bk = /* @__PURE__ */ Ot(Rk, [["render", Dk], ["__file", "warning-filled.vue"]]), Mk = {
  name: "ZoomIn"
}, zk = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, Fk = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zm-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64h96z"
  },
  null,
  -1
  /* HOISTED */
), jk = [
  Fk
];
function Uk(t, e, n, r, i, s) {
  return V(), se("svg", zk, jk);
}
var cm = /* @__PURE__ */ Ot(Mk, [["render", Uk], ["__file", "zoom-in.vue"]]), Vk = {
  name: "ZoomOut"
}, Wk = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, Hk = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zM352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64z"
  },
  null,
  -1
  /* HOISTED */
), Kk = [
  Hk
];
function qk(t, e, n, r, i, s) {
  return V(), se("svg", Wk, Kk);
}
var Gk = /* @__PURE__ */ Ot(Vk, [["render", qk], ["__file", "zoom-out.vue"]]);
const dm = "__epPropKey", Pe = (t) => t, Yk = (t) => wn(t) && !!t[dm], Kl = (t, e) => {
  if (!wn(t) || Yk(t))
    return t;
  const { values: n, required: r, default: i, type: s, validator: o } = t, l = {
    type: s,
    required: !!r,
    validator: n || o ? (u) => {
      let c = !1, d = [];
      if (n && (d = Array.from(n), Or(t, "default") && d.push(i), c || (c = d.includes(u))), o && (c || (c = o(u))), !c && d.length > 0) {
        const h = [...new Set(d)].map((v) => JSON.stringify(v)).join(", ");
        qy(`Invalid prop: validation failed${e ? ` for prop "${e}"` : ""}. Expected one of [${h}], got value ${JSON.stringify(u)}.`);
      }
      return c;
    } : void 0,
    [dm]: !0
  };
  return Or(t, "default") && (l.default = i), l;
}, ut = (t) => al(Object.entries(t).map(([e, n]) => [
  e,
  Kl(n, e)
])), bi = Pe([
  String,
  Object,
  Function
]), fm = {
  validating: Hl,
  success: Id,
  error: Wl
}, nn = (t, e) => {
  if (t.install = (n) => {
    for (const r of [t, ...Object.values(e ?? {})])
      n.component(r.name, r);
  }, e)
    for (const [n, r] of Object.entries(e))
      t[n] = r;
  return t;
}, Xk = (t, e) => (t.install = (n) => {
  n.directive(e, t);
}, t), sr = (t) => (t.install = en, t), sn = {
  tab: "Tab",
  enter: "Enter",
  space: "Space",
  left: "ArrowLeft",
  up: "ArrowUp",
  right: "ArrowRight",
  down: "ArrowDown",
  esc: "Escape",
  delete: "Delete",
  backspace: "Backspace",
  numpadEnter: "NumpadEnter",
  pageUp: "PageUp",
  pageDown: "PageDown",
  home: "Home",
  end: "End"
}, Pt = "update:modelValue", Yi = "change", Li = "input", Rd = ["", "default", "small", "large"], Zk = {
  large: 40,
  default: 32,
  small: 24
}, Qk = (t) => Zk[t || "default"], Jk = (t) => ["", ...Rd].includes(t), hm = (t) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(t), eT = (t) => Et ? window.requestAnimationFrame(t) : setTimeout(t, 16), Ts = (t) => t, tT = ["class", "style"], nT = /^on[A-Z]/, pm = (t = {}) => {
  const { excludeListeners: e = !1, excludeKeys: n } = t, r = F(() => ((n == null ? void 0 : n.value) || []).concat(tT)), i = ht();
  return i ? F(() => {
    var s;
    return al(Object.entries((s = i.proxy) == null ? void 0 : s.$attrs).filter(([o]) => !r.value.includes(o) && !(e && nT.test(o))));
  }) : (Vt("use-attrs", "getCurrentInstance() returned null. useAttrs() must be called at the top of a setup function"), F(() => ({})));
}, vm = ({ from: t, replacement: e, scope: n, version: r, ref: i, type: s = "API" }, o) => {
  ke(() => x(o), (a) => {
    a && Vt(n, `[${s}] ${t} is about to be deprecated in version ${r}, please use ${e} instead.
For more detail, please visit: ${i}
`);
  }, {
    immediate: !0
  });
};
var rT = {
  name: "en",
  el: {
    colorpicker: {
      confirm: "OK",
      clear: "Clear",
      defaultLabel: "color picker",
      description: "current color is {color}. press enter to select a new color."
    },
    datepicker: {
      now: "Now",
      today: "Today",
      cancel: "Cancel",
      clear: "Clear",
      confirm: "OK",
      dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
      monthTablePrompt: "Use the arrow keys and enter to select the month",
      yearTablePrompt: "Use the arrow keys and enter to select the year",
      selectedDate: "Selected date",
      selectDate: "Select date",
      selectTime: "Select time",
      startDate: "Start Date",
      startTime: "Start Time",
      endDate: "End Date",
      endTime: "End Time",
      prevYear: "Previous Year",
      nextYear: "Next Year",
      prevMonth: "Previous Month",
      nextMonth: "Next Month",
      year: "",
      month1: "January",
      month2: "February",
      month3: "March",
      month4: "April",
      month5: "May",
      month6: "June",
      month7: "July",
      month8: "August",
      month9: "September",
      month10: "October",
      month11: "November",
      month12: "December",
      week: "week",
      weeks: {
        sun: "Sun",
        mon: "Mon",
        tue: "Tue",
        wed: "Wed",
        thu: "Thu",
        fri: "Fri",
        sat: "Sat"
      },
      weeksFull: {
        sun: "Sunday",
        mon: "Monday",
        tue: "Tuesday",
        wed: "Wednesday",
        thu: "Thursday",
        fri: "Friday",
        sat: "Saturday"
      },
      months: {
        jan: "Jan",
        feb: "Feb",
        mar: "Mar",
        apr: "Apr",
        may: "May",
        jun: "Jun",
        jul: "Jul",
        aug: "Aug",
        sep: "Sep",
        oct: "Oct",
        nov: "Nov",
        dec: "Dec"
      }
    },
    inputNumber: {
      decrease: "decrease number",
      increase: "increase number"
    },
    select: {
      loading: "Loading",
      noMatch: "No matching data",
      noData: "No data",
      placeholder: "Select"
    },
    dropdown: {
      toggleDropdown: "Toggle Dropdown"
    },
    cascader: {
      noMatch: "No matching data",
      loading: "Loading",
      placeholder: "Select",
      noData: "No data"
    },
    pagination: {
      goto: "Go to",
      pagesize: "/page",
      total: "Total {total}",
      pageClassifier: "",
      page: "Page",
      prev: "Go to previous page",
      next: "Go to next page",
      currentPage: "page {pager}",
      prevPages: "Previous {pager} pages",
      nextPages: "Next {pager} pages",
      deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
    },
    dialog: {
      close: "Close this dialog"
    },
    drawer: {
      close: "Close this dialog"
    },
    messagebox: {
      title: "Message",
      confirm: "OK",
      cancel: "Cancel",
      error: "Illegal input",
      close: "Close this dialog"
    },
    upload: {
      deleteTip: "press delete to remove",
      delete: "Delete",
      preview: "Preview",
      continue: "Continue"
    },
    slider: {
      defaultLabel: "slider between {min} and {max}",
      defaultRangeStartLabel: "pick start value",
      defaultRangeEndLabel: "pick end value"
    },
    table: {
      emptyText: "No Data",
      confirmFilter: "Confirm",
      resetFilter: "Reset",
      clearFilter: "All",
      sumText: "Sum"
    },
    tree: {
      emptyText: "No Data"
    },
    transfer: {
      noMatch: "No matching data",
      noData: "No data",
      titles: ["List 1", "List 2"],
      filterPlaceholder: "Enter keyword",
      noCheckedFormat: "{total} items",
      hasCheckedFormat: "{checked}/{total} checked"
    },
    image: {
      error: "FAILED"
    },
    pageHeader: {
      title: "Back"
    },
    popconfirm: {
      confirmButtonText: "Yes",
      cancelButtonText: "No"
    }
  }
};
const iT = (t) => (e, n) => sT(e, n, x(t)), sT = (t, e, n) => Cn(n, t, t).replace(/\{(\w+)\}/g, (r, i) => {
  var s;
  return `${(s = e == null ? void 0 : e[i]) != null ? s : `{${i}}`}`;
}), oT = (t) => {
  const e = F(() => x(t).name), n = on(t) ? t : K(t);
  return {
    lang: e,
    locale: n,
    t: iT(t)
  };
}, mm = Symbol("localeContextKey"), or = (t) => {
  const e = t || tt(mm, K());
  return oT(F(() => e.value || rT));
}, $a = "el", aT = "is-", ki = (t, e, n, r, i) => {
  let s = `${t}-${e}`;
  return n && (s += `-${n}`), r && (s += `__${r}`), i && (s += `--${i}`), s;
}, gm = Symbol("namespaceContextKey"), Ld = (t) => {
  const e = t || (ht() ? tt(gm, K($a)) : K($a));
  return F(() => x(e) || $a);
}, Fe = (t, e) => {
  const n = Ld(e);
  return {
    namespace: n,
    b: (b = "") => ki(n.value, t, b, "", ""),
    e: (b) => b ? ki(n.value, t, "", b, "") : "",
    m: (b) => b ? ki(n.value, t, "", "", b) : "",
    be: (b, p) => b && p ? ki(n.value, t, b, p, "") : "",
    em: (b, p) => b && p ? ki(n.value, t, "", b, p) : "",
    bm: (b, p) => b && p ? ki(n.value, t, b, "", p) : "",
    bem: (b, p, f) => b && p && f ? ki(n.value, t, b, p, f) : "",
    is: (b, ...p) => {
      const f = p.length >= 1 ? p[0] : !0;
      return b && f ? `${aT}${b}` : "";
    },
    cssVar: (b) => {
      const p = {};
      for (const f in b)
        b[f] && (p[`--${n.value}-${f}`] = b[f]);
      return p;
    },
    cssVarName: (b) => `--${n.value}-${b}`,
    cssVarBlock: (b) => {
      const p = {};
      for (const f in b)
        b[f] && (p[`--${n.value}-${t}-${f}`] = b[f]);
      return p;
    },
    cssVarBlockName: (b) => `--${n.value}-${t}-${b}`
  };
}, lT = Kl({
  type: Pe(Boolean),
  default: null
}), uT = Kl({
  type: Pe(Function)
}), ym = (t) => {
  const e = `update:${t}`, n = `onUpdate:${t}`, r = [e], i = {
    [t]: lT,
    [n]: uT
  };
  return {
    useModelToggle: ({
      indicator: o,
      toggleReason: a,
      shouldHideWhenRouteChanges: l,
      shouldProceed: u,
      onShow: c,
      onHide: d
    }) => {
      const h = ht(), { emit: v } = h, y = h.props, b = F(() => mn(y[n])), p = F(() => y[t] === null), f = (C) => {
        o.value !== !0 && (o.value = !0, a && (a.value = C), mn(c) && c(C));
      }, m = (C) => {
        o.value !== !1 && (o.value = !1, a && (a.value = C), mn(d) && d(C));
      }, g = (C) => {
        if (y.disabled === !0 || mn(u) && !u())
          return;
        const T = b.value && Et;
        T && v(e, !0), (p.value || !T) && f(C);
      }, w = (C) => {
        if (y.disabled === !0 || !Et)
          return;
        const T = b.value && Et;
        T && v(e, !1), (p.value || !T) && m(C);
      }, _ = (C) => {
        Zr(C) && (y.disabled && C ? b.value && v(e, !1) : o.value !== C && (C ? f() : m()));
      }, E = () => {
        o.value ? w() : g();
      };
      return ke(() => y[t], _), l && h.appContext.config.globalProperties.$route !== void 0 && ke(() => ({
        ...h.proxy.$route
      }), () => {
        l.value && o.value && w();
      }), Tt(() => {
        _(y[t]);
      }), {
        hide: w,
        show: g,
        toggle: E,
        hasUpdateHandler: b
      };
    },
    useModelToggleProps: i,
    useModelToggleEmits: r
  };
};
ym("modelValue");
const bm = (t) => {
  const e = ht();
  return F(() => {
    var n, r;
    return (r = (n = e == null ? void 0 : e.proxy) == null ? void 0 : n.$props) == null ? void 0 : r[t];
  });
};
var zn = "top", rr = "bottom", ir = "right", Fn = "left", Pd = "auto", Zo = [zn, rr, ir, Fn], Os = "start", To = "end", cT = "clippingParents", wm = "viewport", Xs = "popper", dT = "reference", xh = Zo.reduce(function(t, e) {
  return t.concat([e + "-" + Os, e + "-" + To]);
}, []), Fs = [].concat(Zo, [Pd]).reduce(function(t, e) {
  return t.concat([e, e + "-" + Os, e + "-" + To]);
}, []), fT = "beforeRead", hT = "read", pT = "afterRead", vT = "beforeMain", mT = "main", gT = "afterMain", yT = "beforeWrite", bT = "write", wT = "afterWrite", _T = [fT, hT, pT, vT, mT, gT, yT, bT, wT];
function Ir(t) {
  return t ? (t.nodeName || "").toLowerCase() : null;
}
function br(t) {
  if (t == null)
    return window;
  if (t.toString() !== "[object Window]") {
    var e = t.ownerDocument;
    return e && e.defaultView || window;
  }
  return t;
}
function Ns(t) {
  var e = br(t).Element;
  return t instanceof e || t instanceof Element;
}
function tr(t) {
  var e = br(t).HTMLElement;
  return t instanceof e || t instanceof HTMLElement;
}
function $d(t) {
  if (typeof ShadowRoot > "u")
    return !1;
  var e = br(t).ShadowRoot;
  return t instanceof e || t instanceof ShadowRoot;
}
function ET(t) {
  var e = t.state;
  Object.keys(e.elements).forEach(function(n) {
    var r = e.styles[n] || {}, i = e.attributes[n] || {}, s = e.elements[n];
    !tr(s) || !Ir(s) || (Object.assign(s.style, r), Object.keys(i).forEach(function(o) {
      var a = i[o];
      a === !1 ? s.removeAttribute(o) : s.setAttribute(o, a === !0 ? "" : a);
    }));
  });
}
function ST(t) {
  var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
  return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
    Object.keys(e.elements).forEach(function(r) {
      var i = e.elements[r], s = e.attributes[r] || {}, o = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), a = o.reduce(function(l, u) {
        return l[u] = "", l;
      }, {});
      !tr(i) || !Ir(i) || (Object.assign(i.style, a), Object.keys(s).forEach(function(l) {
        i.removeAttribute(l);
      }));
    });
  };
}
var _m = { name: "applyStyles", enabled: !0, phase: "write", fn: ET, effect: ST, requires: ["computeStyles"] };
function xr(t) {
  return t.split("-")[0];
}
var Pi = Math.max, cl = Math.min, As = Math.round;
function Is(t, e) {
  e === void 0 && (e = !1);
  var n = t.getBoundingClientRect(), r = 1, i = 1;
  if (tr(t) && e) {
    var s = t.offsetHeight, o = t.offsetWidth;
    o > 0 && (r = As(n.width) / o || 1), s > 0 && (i = As(n.height) / s || 1);
  }
  return { width: n.width / r, height: n.height / i, top: n.top / i, right: n.right / r, bottom: n.bottom / i, left: n.left / r, x: n.left / r, y: n.top / i };
}
function Dd(t) {
  var e = Is(t), n = t.offsetWidth, r = t.offsetHeight;
  return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), { x: t.offsetLeft, y: t.offsetTop, width: n, height: r };
}
function Em(t, e) {
  var n = e.getRootNode && e.getRootNode();
  if (t.contains(e))
    return !0;
  if (n && $d(n)) {
    var r = e;
    do {
      if (r && t.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function Qr(t) {
  return br(t).getComputedStyle(t);
}
function xT(t) {
  return ["table", "td", "th"].indexOf(Ir(t)) >= 0;
}
function Si(t) {
  return ((Ns(t) ? t.ownerDocument : t.document) || window.document).documentElement;
}
function ql(t) {
  return Ir(t) === "html" ? t : t.assignedSlot || t.parentNode || ($d(t) ? t.host : null) || Si(t);
}
function Ch(t) {
  return !tr(t) || Qr(t).position === "fixed" ? null : t.offsetParent;
}
function CT(t) {
  var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
  if (n && tr(t)) {
    var r = Qr(t);
    if (r.position === "fixed")
      return null;
  }
  var i = ql(t);
  for ($d(i) && (i = i.host); tr(i) && ["html", "body"].indexOf(Ir(i)) < 0; ) {
    var s = Qr(i);
    if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || e && s.willChange === "filter" || e && s.filter && s.filter !== "none")
      return i;
    i = i.parentNode;
  }
  return null;
}
function Qo(t) {
  for (var e = br(t), n = Ch(t); n && xT(n) && Qr(n).position === "static"; )
    n = Ch(n);
  return n && (Ir(n) === "html" || Ir(n) === "body" && Qr(n).position === "static") ? e : n || CT(t) || e;
}
function Bd(t) {
  return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
}
function lo(t, e, n) {
  return Pi(t, cl(e, n));
}
function kT(t, e, n) {
  var r = lo(t, e, n);
  return r > n ? n : r;
}
function Sm() {
  return { top: 0, right: 0, bottom: 0, left: 0 };
}
function xm(t) {
  return Object.assign({}, Sm(), t);
}
function Cm(t, e) {
  return e.reduce(function(n, r) {
    return n[r] = t, n;
  }, {});
}
var TT = function(t, e) {
  return t = typeof t == "function" ? t(Object.assign({}, e.rects, { placement: e.placement })) : t, xm(typeof t != "number" ? t : Cm(t, Zo));
};
function OT(t) {
  var e, n = t.state, r = t.name, i = t.options, s = n.elements.arrow, o = n.modifiersData.popperOffsets, a = xr(n.placement), l = Bd(a), u = [Fn, ir].indexOf(a) >= 0, c = u ? "height" : "width";
  if (!(!s || !o)) {
    var d = TT(i.padding, n), h = Dd(s), v = l === "y" ? zn : Fn, y = l === "y" ? rr : ir, b = n.rects.reference[c] + n.rects.reference[l] - o[l] - n.rects.popper[c], p = o[l] - n.rects.reference[l], f = Qo(s), m = f ? l === "y" ? f.clientHeight || 0 : f.clientWidth || 0 : 0, g = b / 2 - p / 2, w = d[v], _ = m - h[c] - d[y], E = m / 2 - h[c] / 2 + g, C = lo(w, E, _), T = l;
    n.modifiersData[r] = (e = {}, e[T] = C, e.centerOffset = C - E, e);
  }
}
function NT(t) {
  var e = t.state, n = t.options, r = n.element, i = r === void 0 ? "[data-popper-arrow]" : r;
  i != null && (typeof i == "string" && (i = e.elements.popper.querySelector(i), !i) || !Em(e.elements.popper, i) || (e.elements.arrow = i));
}
var AT = { name: "arrow", enabled: !0, phase: "main", fn: OT, effect: NT, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
function Rs(t) {
  return t.split("-")[1];
}
var IT = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
function RT(t) {
  var e = t.x, n = t.y, r = window, i = r.devicePixelRatio || 1;
  return { x: As(e * i) / i || 0, y: As(n * i) / i || 0 };
}
function kh(t) {
  var e, n = t.popper, r = t.popperRect, i = t.placement, s = t.variation, o = t.offsets, a = t.position, l = t.gpuAcceleration, u = t.adaptive, c = t.roundOffsets, d = t.isFixed, h = o.x, v = h === void 0 ? 0 : h, y = o.y, b = y === void 0 ? 0 : y, p = typeof c == "function" ? c({ x: v, y: b }) : { x: v, y: b };
  v = p.x, b = p.y;
  var f = o.hasOwnProperty("x"), m = o.hasOwnProperty("y"), g = Fn, w = zn, _ = window;
  if (u) {
    var E = Qo(n), C = "clientHeight", T = "clientWidth";
    if (E === br(n) && (E = Si(n), Qr(E).position !== "static" && a === "absolute" && (C = "scrollHeight", T = "scrollWidth")), E = E, i === zn || (i === Fn || i === ir) && s === To) {
      w = rr;
      var k = d && E === _ && _.visualViewport ? _.visualViewport.height : E[C];
      b -= k - r.height, b *= l ? 1 : -1;
    }
    if (i === Fn || (i === zn || i === rr) && s === To) {
      g = ir;
      var N = d && E === _ && _.visualViewport ? _.visualViewport.width : E[T];
      v -= N - r.width, v *= l ? 1 : -1;
    }
  }
  var I = Object.assign({ position: a }, u && IT), P = c === !0 ? RT({ x: v, y: b }) : { x: v, y: b };
  if (v = P.x, b = P.y, l) {
    var D;
    return Object.assign({}, I, (D = {}, D[w] = m ? "0" : "", D[g] = f ? "0" : "", D.transform = (_.devicePixelRatio || 1) <= 1 ? "translate(" + v + "px, " + b + "px)" : "translate3d(" + v + "px, " + b + "px, 0)", D));
  }
  return Object.assign({}, I, (e = {}, e[w] = m ? b + "px" : "", e[g] = f ? v + "px" : "", e.transform = "", e));
}
function LT(t) {
  var e = t.state, n = t.options, r = n.gpuAcceleration, i = r === void 0 ? !0 : r, s = n.adaptive, o = s === void 0 ? !0 : s, a = n.roundOffsets, l = a === void 0 ? !0 : a, u = { placement: xr(e.placement), variation: Rs(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: i, isFixed: e.options.strategy === "fixed" };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, kh(Object.assign({}, u, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: o, roundOffsets: l })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, kh(Object.assign({}, u, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: l })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement });
}
var km = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: LT, data: {} }, va = { passive: !0 };
function PT(t) {
  var e = t.state, n = t.instance, r = t.options, i = r.scroll, s = i === void 0 ? !0 : i, o = r.resize, a = o === void 0 ? !0 : o, l = br(e.elements.popper), u = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return s && u.forEach(function(c) {
    c.addEventListener("scroll", n.update, va);
  }), a && l.addEventListener("resize", n.update, va), function() {
    s && u.forEach(function(c) {
      c.removeEventListener("scroll", n.update, va);
    }), a && l.removeEventListener("resize", n.update, va);
  };
}
var Tm = { name: "eventListeners", enabled: !0, phase: "write", fn: function() {
}, effect: PT, data: {} }, $T = { left: "right", right: "left", bottom: "top", top: "bottom" };
function Da(t) {
  return t.replace(/left|right|bottom|top/g, function(e) {
    return $T[e];
  });
}
var DT = { start: "end", end: "start" };
function Th(t) {
  return t.replace(/start|end/g, function(e) {
    return DT[e];
  });
}
function Md(t) {
  var e = br(t), n = e.pageXOffset, r = e.pageYOffset;
  return { scrollLeft: n, scrollTop: r };
}
function zd(t) {
  return Is(Si(t)).left + Md(t).scrollLeft;
}
function BT(t) {
  var e = br(t), n = Si(t), r = e.visualViewport, i = n.clientWidth, s = n.clientHeight, o = 0, a = 0;
  return r && (i = r.width, s = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (o = r.offsetLeft, a = r.offsetTop)), { width: i, height: s, x: o + zd(t), y: a };
}
function MT(t) {
  var e, n = Si(t), r = Md(t), i = (e = t.ownerDocument) == null ? void 0 : e.body, s = Pi(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), o = Pi(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), a = -r.scrollLeft + zd(t), l = -r.scrollTop;
  return Qr(i || n).direction === "rtl" && (a += Pi(n.clientWidth, i ? i.clientWidth : 0) - s), { width: s, height: o, x: a, y: l };
}
function Fd(t) {
  var e = Qr(t), n = e.overflow, r = e.overflowX, i = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + i + r);
}
function Om(t) {
  return ["html", "body", "#document"].indexOf(Ir(t)) >= 0 ? t.ownerDocument.body : tr(t) && Fd(t) ? t : Om(ql(t));
}
function uo(t, e) {
  var n;
  e === void 0 && (e = []);
  var r = Om(t), i = r === ((n = t.ownerDocument) == null ? void 0 : n.body), s = br(r), o = i ? [s].concat(s.visualViewport || [], Fd(r) ? r : []) : r, a = e.concat(o);
  return i ? a : a.concat(uo(ql(o)));
}
function ic(t) {
  return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height });
}
function zT(t) {
  var e = Is(t);
  return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e;
}
function Oh(t, e) {
  return e === wm ? ic(BT(t)) : Ns(e) ? zT(e) : ic(MT(Si(t)));
}
function FT(t) {
  var e = uo(ql(t)), n = ["absolute", "fixed"].indexOf(Qr(t).position) >= 0, r = n && tr(t) ? Qo(t) : t;
  return Ns(r) ? e.filter(function(i) {
    return Ns(i) && Em(i, r) && Ir(i) !== "body";
  }) : [];
}
function jT(t, e, n) {
  var r = e === "clippingParents" ? FT(t) : [].concat(e), i = [].concat(r, [n]), s = i[0], o = i.reduce(function(a, l) {
    var u = Oh(t, l);
    return a.top = Pi(u.top, a.top), a.right = cl(u.right, a.right), a.bottom = cl(u.bottom, a.bottom), a.left = Pi(u.left, a.left), a;
  }, Oh(t, s));
  return o.width = o.right - o.left, o.height = o.bottom - o.top, o.x = o.left, o.y = o.top, o;
}
function Nm(t) {
  var e = t.reference, n = t.element, r = t.placement, i = r ? xr(r) : null, s = r ? Rs(r) : null, o = e.x + e.width / 2 - n.width / 2, a = e.y + e.height / 2 - n.height / 2, l;
  switch (i) {
    case zn:
      l = { x: o, y: e.y - n.height };
      break;
    case rr:
      l = { x: o, y: e.y + e.height };
      break;
    case ir:
      l = { x: e.x + e.width, y: a };
      break;
    case Fn:
      l = { x: e.x - n.width, y: a };
      break;
    default:
      l = { x: e.x, y: e.y };
  }
  var u = i ? Bd(i) : null;
  if (u != null) {
    var c = u === "y" ? "height" : "width";
    switch (s) {
      case Os:
        l[u] = l[u] - (e[c] / 2 - n[c] / 2);
        break;
      case To:
        l[u] = l[u] + (e[c] / 2 - n[c] / 2);
        break;
    }
  }
  return l;
}
function Oo(t, e) {
  e === void 0 && (e = {});
  var n = e, r = n.placement, i = r === void 0 ? t.placement : r, s = n.boundary, o = s === void 0 ? cT : s, a = n.rootBoundary, l = a === void 0 ? wm : a, u = n.elementContext, c = u === void 0 ? Xs : u, d = n.altBoundary, h = d === void 0 ? !1 : d, v = n.padding, y = v === void 0 ? 0 : v, b = xm(typeof y != "number" ? y : Cm(y, Zo)), p = c === Xs ? dT : Xs, f = t.rects.popper, m = t.elements[h ? p : c], g = jT(Ns(m) ? m : m.contextElement || Si(t.elements.popper), o, l), w = Is(t.elements.reference), _ = Nm({ reference: w, element: f, strategy: "absolute", placement: i }), E = ic(Object.assign({}, f, _)), C = c === Xs ? E : w, T = { top: g.top - C.top + b.top, bottom: C.bottom - g.bottom + b.bottom, left: g.left - C.left + b.left, right: C.right - g.right + b.right }, k = t.modifiersData.offset;
  if (c === Xs && k) {
    var N = k[i];
    Object.keys(T).forEach(function(I) {
      var P = [ir, rr].indexOf(I) >= 0 ? 1 : -1, D = [zn, rr].indexOf(I) >= 0 ? "y" : "x";
      T[I] += N[D] * P;
    });
  }
  return T;
}
function UT(t, e) {
  e === void 0 && (e = {});
  var n = e, r = n.placement, i = n.boundary, s = n.rootBoundary, o = n.padding, a = n.flipVariations, l = n.allowedAutoPlacements, u = l === void 0 ? Fs : l, c = Rs(r), d = c ? a ? xh : xh.filter(function(y) {
    return Rs(y) === c;
  }) : Zo, h = d.filter(function(y) {
    return u.indexOf(y) >= 0;
  });
  h.length === 0 && (h = d);
  var v = h.reduce(function(y, b) {
    return y[b] = Oo(t, { placement: b, boundary: i, rootBoundary: s, padding: o })[xr(b)], y;
  }, {});
  return Object.keys(v).sort(function(y, b) {
    return v[y] - v[b];
  });
}
function VT(t) {
  if (xr(t) === Pd)
    return [];
  var e = Da(t);
  return [Th(t), e, Th(e)];
}
function WT(t) {
  var e = t.state, n = t.options, r = t.name;
  if (!e.modifiersData[r]._skip) {
    for (var i = n.mainAxis, s = i === void 0 ? !0 : i, o = n.altAxis, a = o === void 0 ? !0 : o, l = n.fallbackPlacements, u = n.padding, c = n.boundary, d = n.rootBoundary, h = n.altBoundary, v = n.flipVariations, y = v === void 0 ? !0 : v, b = n.allowedAutoPlacements, p = e.options.placement, f = xr(p), m = f === p, g = l || (m || !y ? [Da(p)] : VT(p)), w = [p].concat(g).reduce(function(ce, me) {
      return ce.concat(xr(me) === Pd ? UT(e, { placement: me, boundary: c, rootBoundary: d, padding: u, flipVariations: y, allowedAutoPlacements: b }) : me);
    }, []), _ = e.rects.reference, E = e.rects.popper, C = /* @__PURE__ */ new Map(), T = !0, k = w[0], N = 0; N < w.length; N++) {
      var I = w[N], P = xr(I), D = Rs(I) === Os, z = [zn, rr].indexOf(P) >= 0, G = z ? "width" : "height", J = Oo(e, { placement: I, boundary: c, rootBoundary: d, altBoundary: h, padding: u }), M = z ? D ? ir : Fn : D ? rr : zn;
      _[G] > E[G] && (M = Da(M));
      var U = Da(M), j = [];
      if (s && j.push(J[P] <= 0), a && j.push(J[M] <= 0, J[U] <= 0), j.every(function(ce) {
        return ce;
      })) {
        k = I, T = !1;
        break;
      }
      C.set(I, j);
    }
    if (T)
      for (var re = y ? 3 : 1, fe = function(ce) {
        var me = w.find(function(_e) {
          var ze = C.get(_e);
          if (ze)
            return ze.slice(0, ce).every(function(Oe) {
              return Oe;
            });
        });
        if (me)
          return k = me, "break";
      }, Y = re; Y > 0; Y--) {
        var le = fe(Y);
        if (le === "break")
          break;
      }
    e.placement !== k && (e.modifiersData[r]._skip = !0, e.placement = k, e.reset = !0);
  }
}
var HT = { name: "flip", enabled: !0, phase: "main", fn: WT, requiresIfExists: ["offset"], data: { _skip: !1 } };
function Nh(t, e, n) {
  return n === void 0 && (n = { x: 0, y: 0 }), { top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x };
}
function Ah(t) {
  return [zn, ir, rr, Fn].some(function(e) {
    return t[e] >= 0;
  });
}
function KT(t) {
  var e = t.state, n = t.name, r = e.rects.reference, i = e.rects.popper, s = e.modifiersData.preventOverflow, o = Oo(e, { elementContext: "reference" }), a = Oo(e, { altBoundary: !0 }), l = Nh(o, r), u = Nh(a, i, s), c = Ah(l), d = Ah(u);
  e.modifiersData[n] = { referenceClippingOffsets: l, popperEscapeOffsets: u, isReferenceHidden: c, hasPopperEscaped: d }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": c, "data-popper-escaped": d });
}
var qT = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: KT };
function GT(t, e, n) {
  var r = xr(t), i = [Fn, zn].indexOf(r) >= 0 ? -1 : 1, s = typeof n == "function" ? n(Object.assign({}, e, { placement: t })) : n, o = s[0], a = s[1];
  return o = o || 0, a = (a || 0) * i, [Fn, ir].indexOf(r) >= 0 ? { x: a, y: o } : { x: o, y: a };
}
function YT(t) {
  var e = t.state, n = t.options, r = t.name, i = n.offset, s = i === void 0 ? [0, 0] : i, o = Fs.reduce(function(c, d) {
    return c[d] = GT(d, e.rects, s), c;
  }, {}), a = o[e.placement], l = a.x, u = a.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += u), e.modifiersData[r] = o;
}
var XT = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: YT };
function ZT(t) {
  var e = t.state, n = t.name;
  e.modifiersData[n] = Nm({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement });
}
var Am = { name: "popperOffsets", enabled: !0, phase: "read", fn: ZT, data: {} };
function QT(t) {
  return t === "x" ? "y" : "x";
}
function JT(t) {
  var e = t.state, n = t.options, r = t.name, i = n.mainAxis, s = i === void 0 ? !0 : i, o = n.altAxis, a = o === void 0 ? !1 : o, l = n.boundary, u = n.rootBoundary, c = n.altBoundary, d = n.padding, h = n.tether, v = h === void 0 ? !0 : h, y = n.tetherOffset, b = y === void 0 ? 0 : y, p = Oo(e, { boundary: l, rootBoundary: u, padding: d, altBoundary: c }), f = xr(e.placement), m = Rs(e.placement), g = !m, w = Bd(f), _ = QT(w), E = e.modifiersData.popperOffsets, C = e.rects.reference, T = e.rects.popper, k = typeof b == "function" ? b(Object.assign({}, e.rects, { placement: e.placement })) : b, N = typeof k == "number" ? { mainAxis: k, altAxis: k } : Object.assign({ mainAxis: 0, altAxis: 0 }, k), I = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, P = { x: 0, y: 0 };
  if (E) {
    if (s) {
      var D, z = w === "y" ? zn : Fn, G = w === "y" ? rr : ir, J = w === "y" ? "height" : "width", M = E[w], U = M + p[z], j = M - p[G], re = v ? -T[J] / 2 : 0, fe = m === Os ? C[J] : T[J], Y = m === Os ? -T[J] : -C[J], le = e.elements.arrow, ce = v && le ? Dd(le) : { width: 0, height: 0 }, me = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : Sm(), _e = me[z], ze = me[G], Oe = lo(0, C[J], ce[J]), Qe = g ? C[J] / 2 - re - Oe - _e - N.mainAxis : fe - Oe - _e - N.mainAxis, Be = g ? -C[J] / 2 + re + Oe + ze + N.mainAxis : Y + Oe + ze + N.mainAxis, He = e.elements.arrow && Qo(e.elements.arrow), ct = He ? w === "y" ? He.clientTop || 0 : He.clientLeft || 0 : 0, nt = (D = I == null ? void 0 : I[w]) != null ? D : 0, St = M + Qe - nt - ct, yt = M + Be - nt, It = lo(v ? cl(U, St) : U, M, v ? Pi(j, yt) : j);
      E[w] = It, P[w] = It - M;
    }
    if (a) {
      var ot, bt = w === "x" ? zn : Fn, Kt = w === "x" ? rr : ir, wt = E[_], xt = _ === "y" ? "height" : "width", lt = wt + p[bt], Ge = wt - p[Kt], Rt = [zn, Fn].indexOf(f) !== -1, we = (ot = I == null ? void 0 : I[_]) != null ? ot : 0, Ue = Rt ? lt : wt - C[xt] - T[xt] - we + N.altAxis, at = Rt ? wt + C[xt] + T[xt] - we - N.altAxis : Ge, Lt = v && Rt ? kT(Ue, wt, at) : lo(v ? Ue : lt, wt, v ? at : Ge);
      E[_] = Lt, P[_] = Lt - wt;
    }
    e.modifiersData[r] = P;
  }
}
var eO = { name: "preventOverflow", enabled: !0, phase: "main", fn: JT, requiresIfExists: ["offset"] };
function tO(t) {
  return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop };
}
function nO(t) {
  return t === br(t) || !tr(t) ? Md(t) : tO(t);
}
function rO(t) {
  var e = t.getBoundingClientRect(), n = As(e.width) / t.offsetWidth || 1, r = As(e.height) / t.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function iO(t, e, n) {
  n === void 0 && (n = !1);
  var r = tr(e), i = tr(e) && rO(e), s = Si(e), o = Is(t, i), a = { scrollLeft: 0, scrollTop: 0 }, l = { x: 0, y: 0 };
  return (r || !r && !n) && ((Ir(e) !== "body" || Fd(s)) && (a = nO(e)), tr(e) ? (l = Is(e, !0), l.x += e.clientLeft, l.y += e.clientTop) : s && (l.x = zd(s))), { x: o.left + a.scrollLeft - l.x, y: o.top + a.scrollTop - l.y, width: o.width, height: o.height };
}
function sO(t) {
  var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
  t.forEach(function(s) {
    e.set(s.name, s);
  });
  function i(s) {
    n.add(s.name);
    var o = [].concat(s.requires || [], s.requiresIfExists || []);
    o.forEach(function(a) {
      if (!n.has(a)) {
        var l = e.get(a);
        l && i(l);
      }
    }), r.push(s);
  }
  return t.forEach(function(s) {
    n.has(s.name) || i(s);
  }), r;
}
function oO(t) {
  var e = sO(t);
  return _T.reduce(function(n, r) {
    return n.concat(e.filter(function(i) {
      return i.phase === r;
    }));
  }, []);
}
function aO(t) {
  var e;
  return function() {
    return e || (e = new Promise(function(n) {
      Promise.resolve().then(function() {
        e = void 0, n(t());
      });
    })), e;
  };
}
function lO(t) {
  var e = t.reduce(function(n, r) {
    var i = n[r.name];
    return n[r.name] = i ? Object.assign({}, i, r, { options: Object.assign({}, i.options, r.options), data: Object.assign({}, i.data, r.data) }) : r, n;
  }, {});
  return Object.keys(e).map(function(n) {
    return e[n];
  });
}
var Ih = { placement: "bottom", modifiers: [], strategy: "absolute" };
function Rh() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return !e.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function jd(t) {
  t === void 0 && (t = {});
  var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, i = e.defaultOptions, s = i === void 0 ? Ih : i;
  return function(o, a, l) {
    l === void 0 && (l = s);
    var u = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Ih, s), modifiersData: {}, elements: { reference: o, popper: a }, attributes: {}, styles: {} }, c = [], d = !1, h = { state: u, setOptions: function(b) {
      var p = typeof b == "function" ? b(u.options) : b;
      y(), u.options = Object.assign({}, s, u.options, p), u.scrollParents = { reference: Ns(o) ? uo(o) : o.contextElement ? uo(o.contextElement) : [], popper: uo(a) };
      var f = oO(lO([].concat(r, u.options.modifiers)));
      return u.orderedModifiers = f.filter(function(m) {
        return m.enabled;
      }), v(), h.update();
    }, forceUpdate: function() {
      if (!d) {
        var b = u.elements, p = b.reference, f = b.popper;
        if (Rh(p, f)) {
          u.rects = { reference: iO(p, Qo(f), u.options.strategy === "fixed"), popper: Dd(f) }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function(T) {
            return u.modifiersData[T.name] = Object.assign({}, T.data);
          });
          for (var m = 0; m < u.orderedModifiers.length; m++) {
            if (u.reset === !0) {
              u.reset = !1, m = -1;
              continue;
            }
            var g = u.orderedModifiers[m], w = g.fn, _ = g.options, E = _ === void 0 ? {} : _, C = g.name;
            typeof w == "function" && (u = w({ state: u, options: E, name: C, instance: h }) || u);
          }
        }
      }
    }, update: aO(function() {
      return new Promise(function(b) {
        h.forceUpdate(), b(u);
      });
    }), destroy: function() {
      y(), d = !0;
    } };
    if (!Rh(o, a))
      return h;
    h.setOptions(l).then(function(b) {
      !d && l.onFirstUpdate && l.onFirstUpdate(b);
    });
    function v() {
      u.orderedModifiers.forEach(function(b) {
        var p = b.name, f = b.options, m = f === void 0 ? {} : f, g = b.effect;
        if (typeof g == "function") {
          var w = g({ state: u, name: p, instance: h, options: m }), _ = function() {
          };
          c.push(w || _);
        }
      });
    }
    function y() {
      c.forEach(function(b) {
        return b();
      }), c = [];
    }
    return h;
  };
}
jd();
var uO = [Tm, Am, km, _m];
jd({ defaultModifiers: uO });
var cO = [Tm, Am, km, _m, XT, HT, eO, AT, qT], Im = jd({ defaultModifiers: cO });
const dO = (t, e, n = {}) => {
  const r = {
    name: "updateState",
    enabled: !0,
    phase: "write",
    fn: ({ state: l }) => {
      const u = fO(l);
      Object.assign(o.value, u);
    },
    requires: ["computeStyles"]
  }, i = F(() => {
    const { onFirstUpdate: l, placement: u, strategy: c, modifiers: d } = x(n);
    return {
      onFirstUpdate: l,
      placement: u || "bottom",
      strategy: c || "absolute",
      modifiers: [
        ...d || [],
        r,
        { name: "applyStyles", enabled: !1 }
      ]
    };
  }), s = Mn(), o = K({
    styles: {
      popper: {
        position: x(i).strategy,
        left: "0",
        top: "0"
      },
      arrow: {
        position: "absolute"
      }
    },
    attributes: {}
  }), a = () => {
    s.value && (s.value.destroy(), s.value = void 0);
  };
  return ke(i, (l) => {
    const u = x(s);
    u && u.setOptions(l);
  }, {
    deep: !0
  }), ke([t, e], ([l, u]) => {
    a(), !(!l || !u) && (s.value = Im(l, u, x(i)));
  }), Sn(() => {
    a();
  }), {
    state: F(() => {
      var l;
      return { ...((l = x(s)) == null ? void 0 : l.state) || {} };
    }),
    styles: F(() => x(o).styles),
    attributes: F(() => x(o).attributes),
    update: () => {
      var l;
      return (l = x(s)) == null ? void 0 : l.update();
    },
    forceUpdate: () => {
      var l;
      return (l = x(s)) == null ? void 0 : l.forceUpdate();
    },
    instanceRef: F(() => x(s))
  };
};
function fO(t) {
  const e = Object.keys(t.elements), n = al(e.map((i) => [i, t.styles[i] || {}])), r = al(e.map((i) => [i, t.attributes[i]]));
  return {
    styles: n,
    attributes: r
  };
}
function Lh() {
  let t;
  const e = (r, i) => {
    n(), t = window.setTimeout(r, i);
  }, n = () => window.clearTimeout(t);
  return dd(() => n()), {
    registerTimeout: e,
    cancelTimeout: n
  };
}
const sc = {
  prefix: Math.floor(Math.random() * 1e4),
  current: 0
}, hO = Symbol("elIdInjection"), Rm = () => ht() ? tt(hO, sc) : sc, Jo = (t) => {
  const e = Rm();
  !Et && e === sc && Vt("IdInjection", `Looks like you are using server rendering, you must provide a id provider to ensure the hydration process to be succeed
usage: app.provide(ID_INJECTION_KEY, {
  prefix: number,
  current: number,
})`);
  const n = Ld();
  return F(() => x(t) || `${n.value}-id-${e.prefix}-${e.current++}`);
};
let hs = [];
const Ph = (t) => {
  const e = t;
  e.key === sn.esc && hs.forEach((n) => n(e));
}, pO = (t) => {
  Tt(() => {
    hs.length === 0 && document.addEventListener("keydown", Ph), Et && hs.push(t);
  }), Sn(() => {
    hs = hs.filter((e) => e !== t), hs.length === 0 && Et && document.removeEventListener("keydown", Ph);
  });
};
let $h;
const Lm = () => {
  const t = Ld(), e = Rm(), n = F(() => `${t.value}-popper-container-${e.prefix}`), r = F(() => `#${n.value}`);
  return {
    id: n,
    selector: r
  };
}, vO = (t) => {
  const e = document.createElement("div");
  return e.id = t, document.body.appendChild(e), e;
}, mO = () => {
  const { id: t, selector: e } = Lm();
  return ld(() => {
    Et && (process.env.NODE_ENV === "test" || !$h && !document.body.querySelector(e.value)) && ($h = vO(t.value));
  }), {
    id: t,
    selector: e
  };
}, gO = ut({
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  autoClose: {
    type: Number,
    default: 0
  }
}), Pm = ({
  showAfter: t,
  hideAfter: e,
  autoClose: n,
  open: r,
  close: i
}) => {
  const { registerTimeout: s } = Lh(), {
    registerTimeout: o,
    cancelTimeout: a
  } = Lh();
  return {
    onOpen: (c) => {
      s(() => {
        r(c);
        const d = x(n);
        gt(d) && d > 0 && o(() => {
          i(c);
        }, d);
      }, x(t));
    },
    onClose: (c) => {
      a(), s(() => {
        i(c);
      }, x(e));
    }
  };
}, $m = Symbol("elForwardRef"), yO = (t) => {
  Gt($m, {
    setForwardRef: (n) => {
      t.value = n;
    }
  });
}, bO = (t) => ({
  mounted(e) {
    t(e);
  },
  updated(e) {
    t(e);
  },
  unmounted() {
    t(null);
  }
}), Dh = K(0), Dm = 2e3, Bm = Symbol("zIndexContextKey"), Gl = (t) => {
  const e = t || (ht() ? tt(Bm, void 0) : void 0), n = F(() => {
    const s = x(e);
    return gt(s) ? s : Dm;
  }), r = F(() => n.value + Dh.value);
  return {
    initialZIndex: n,
    currentZIndex: r,
    nextZIndex: () => (Dh.value++, r.value)
  };
};
function wO(t) {
  const e = K();
  function n() {
    if (t.value == null)
      return;
    const { selectionStart: i, selectionEnd: s, value: o } = t.value;
    if (i == null || s == null)
      return;
    const a = o.slice(0, Math.max(0, i)), l = o.slice(Math.max(0, s));
    e.value = {
      selectionStart: i,
      selectionEnd: s,
      value: o,
      beforeTxt: a,
      afterTxt: l
    };
  }
  function r() {
    if (t.value == null || e.value == null)
      return;
    const { value: i } = t.value, { beforeTxt: s, afterTxt: o, selectionStart: a } = e.value;
    if (s == null || o == null || a == null)
      return;
    let l = i.length;
    if (i.endsWith(o))
      l = i.length - o.length;
    else if (i.startsWith(s))
      l = s.length;
    else {
      const u = s[a - 1], c = i.indexOf(u, a - 1);
      c !== -1 && (l = c + 1);
    }
    t.value.setSelectionRange(l, l);
  }
  return [n, r];
}
const Rr = Kl({
  type: String,
  values: Rd,
  required: !1
}), Mm = Symbol("size"), _O = () => {
  const t = tt(Mm, {});
  return F(() => x(t.size) || "");
};
function EO(t, { afterFocus: e, beforeBlur: n, afterBlur: r } = {}) {
  const i = ht(), { emit: s } = i, o = Mn(), a = K(!1), l = (d) => {
    a.value || (a.value = !0, s("focus", d), e == null || e());
  }, u = (d) => {
    var h;
    mn(n) && n(d) || d.relatedTarget && ((h = o.value) != null && h.contains(d.relatedTarget)) || (a.value = !1, s("blur", d), r == null || r());
  }, c = () => {
    var d;
    (d = t.value) == null || d.focus();
  };
  return ke(o, (d) => {
    d && d.setAttribute("tabindex", "-1");
  }), bn(o, "click", c), {
    wrapperRef: o,
    isFocused: a,
    handleFocus: l,
    handleBlur: u
  };
}
const zm = Symbol(), dl = K();
function Ud(t, e = void 0) {
  const n = ht() ? tt(zm, dl) : dl;
  return t ? F(() => {
    var r, i;
    return (i = (r = n.value) == null ? void 0 : r[t]) != null ? i : e;
  }) : n;
}
function SO(t, e) {
  const n = Ud(), r = Fe(t, F(() => {
    var a;
    return ((a = n.value) == null ? void 0 : a.namespace) || $a;
  })), i = or(F(() => {
    var a;
    return (a = n.value) == null ? void 0 : a.locale;
  })), s = Gl(F(() => {
    var a;
    return ((a = n.value) == null ? void 0 : a.zIndex) || Dm;
  })), o = F(() => {
    var a;
    return x(e) || ((a = n.value) == null ? void 0 : a.size) || "";
  });
  return xO(F(() => x(n) || {})), {
    ns: r,
    locale: i,
    zIndex: s,
    size: o
  };
}
const xO = (t, e, n = !1) => {
  var r;
  const i = !!ht(), s = i ? Ud() : void 0, o = (r = e == null ? void 0 : e.provide) != null ? r : i ? Gt : void 0;
  if (!o) {
    Vt("provideGlobalConfig", "provideGlobalConfig() can only be used inside setup().");
    return;
  }
  const a = F(() => {
    const l = x(t);
    return s != null && s.value ? CO(s.value, l) : l;
  });
  return o(zm, a), o(mm, F(() => a.value.locale)), o(gm, F(() => a.value.namespace)), o(Bm, F(() => a.value.zIndex)), o(Mm, {
    size: F(() => a.value.size || "")
  }), (n || !dl.value) && (dl.value = a.value), a;
}, CO = (t, e) => {
  var n;
  const r = [.../* @__PURE__ */ new Set([...rc(t), ...rc(e)])], i = {};
  for (const s of r)
    i[s] = (n = e[s]) != null ? n : t[s];
  return i;
};
var qe = (t, e) => {
  const n = t.__vccOpts || t;
  for (const [r, i] of e)
    n[r] = i;
  return n;
};
const kO = ut({
  size: {
    type: Pe([Number, String])
  },
  color: {
    type: String
  }
}), TO = be({
  name: "ElIcon",
  inheritAttrs: !1
}), OO = /* @__PURE__ */ be({
  ...TO,
  props: kO,
  setup(t) {
    const e = t, n = Fe("icon"), r = F(() => {
      const { size: i, color: s } = e;
      return !i && !s ? {} : {
        fontSize: Er(i) ? void 0 : ul(i),
        "--color": s
      };
    });
    return (i, s) => (V(), se("i", qn({
      class: x(n).b(),
      style: x(r)
    }, i.$attrs), [
      De(i.$slots, "default")
    ], 16));
  }
});
var NO = /* @__PURE__ */ qe(OO, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/icon/src/icon.vue"]]);
const _t = nn(NO), Vd = Symbol("formContextKey"), No = Symbol("formItemContextKey"), Lr = (t, e = {}) => {
  const n = K(void 0), r = e.prop ? n : bm("size"), i = e.global ? n : _O(), s = e.form ? { size: void 0 } : tt(Vd, void 0), o = e.formItem ? { size: void 0 } : tt(No, void 0);
  return F(() => r.value || x(t) || (o == null ? void 0 : o.size) || (s == null ? void 0 : s.size) || i.value || "");
}, Pr = (t) => {
  const e = bm("disabled"), n = tt(Vd, void 0);
  return F(() => e.value || x(t) || (n == null ? void 0 : n.disabled) || !1);
}, oi = () => {
  const t = tt(Vd, void 0), e = tt(No, void 0);
  return {
    form: t,
    formItem: e
  };
}, ea = (t, {
  formItemContext: e,
  disableIdGeneration: n,
  disableIdManagement: r
}) => {
  n || (n = K(!1)), r || (r = K(!1));
  const i = K();
  let s;
  const o = F(() => {
    var a;
    return !!(!t.label && e && e.inputIds && ((a = e.inputIds) == null ? void 0 : a.length) <= 1);
  });
  return Tt(() => {
    s = ke([Tn(t, "id"), n], ([a, l]) => {
      const u = a ?? (l ? void 0 : Jo().value);
      u !== i.value && (e != null && e.removeInputId && (i.value && e.removeInputId(i.value), !(r != null && r.value) && !l && u && e.addInputId(u)), i.value = u);
    }, { immediate: !0 });
  }), Wo(() => {
    s && s(), e != null && e.removeInputId && i.value && e.removeInputId(i.value);
  }), {
    isLabeledByFormItem: o,
    inputId: i
  };
};
let lr;
const AO = `
  height:0 !important;
  visibility:hidden !important;
  ${Eb() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`, IO = [
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "font-family",
  "font-weight",
  "font-size",
  "text-rendering",
  "text-transform",
  "width",
  "text-indent",
  "padding-left",
  "padding-right",
  "border-width",
  "box-sizing"
];
function RO(t) {
  const e = window.getComputedStyle(t), n = e.getPropertyValue("box-sizing"), r = Number.parseFloat(e.getPropertyValue("padding-bottom")) + Number.parseFloat(e.getPropertyValue("padding-top")), i = Number.parseFloat(e.getPropertyValue("border-bottom-width")) + Number.parseFloat(e.getPropertyValue("border-top-width"));
  return { contextStyle: IO.map((o) => `${o}:${e.getPropertyValue(o)}`).join(";"), paddingSize: r, borderSize: i, boxSizing: n };
}
function Bh(t, e = 1, n) {
  var r;
  lr || (lr = document.createElement("textarea"), document.body.appendChild(lr));
  const { paddingSize: i, borderSize: s, boxSizing: o, contextStyle: a } = RO(t);
  lr.setAttribute("style", `${a};${AO}`), lr.value = t.value || t.placeholder || "";
  let l = lr.scrollHeight;
  const u = {};
  o === "border-box" ? l = l + s : o === "content-box" && (l = l - i), lr.value = "";
  const c = lr.scrollHeight - i;
  if (gt(e)) {
    let d = c * e;
    o === "border-box" && (d = d + i + s), l = Math.max(d, l), u.minHeight = `${d}px`;
  }
  if (gt(n)) {
    let d = c * n;
    o === "border-box" && (d = d + i + s), l = Math.min(d, l);
  }
  return u.height = `${l}px`, (r = lr.parentNode) == null || r.removeChild(lr), lr = void 0, u;
}
const LO = ut({
  id: {
    type: String,
    default: void 0
  },
  size: Rr,
  disabled: Boolean,
  modelValue: {
    type: Pe([
      String,
      Number,
      Object
    ]),
    default: ""
  },
  type: {
    type: String,
    default: "text"
  },
  resize: {
    type: String,
    values: ["none", "both", "horizontal", "vertical"]
  },
  autosize: {
    type: Pe([Boolean, Object]),
    default: !1
  },
  autocomplete: {
    type: String,
    default: "off"
  },
  formatter: {
    type: Function
  },
  parser: {
    type: Function
  },
  placeholder: {
    type: String
  },
  form: {
    type: String
  },
  readonly: {
    type: Boolean,
    default: !1
  },
  clearable: {
    type: Boolean,
    default: !1
  },
  showPassword: {
    type: Boolean,
    default: !1
  },
  showWordLimit: {
    type: Boolean,
    default: !1
  },
  suffixIcon: {
    type: bi
  },
  prefixIcon: {
    type: bi
  },
  containerRole: {
    type: String,
    default: void 0
  },
  label: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  inputStyle: {
    type: Pe([Object, Array, String]),
    default: () => Ts({})
  },
  autofocus: {
    type: Boolean,
    default: !1
  }
}), PO = {
  [Pt]: (t) => qt(t),
  input: (t) => qt(t),
  change: (t) => qt(t),
  focus: (t) => t instanceof FocusEvent,
  blur: (t) => t instanceof FocusEvent,
  clear: () => !0,
  mouseleave: (t) => t instanceof MouseEvent,
  mouseenter: (t) => t instanceof MouseEvent,
  keydown: (t) => t instanceof Event,
  compositionstart: (t) => t instanceof CompositionEvent,
  compositionupdate: (t) => t instanceof CompositionEvent,
  compositionend: (t) => t instanceof CompositionEvent
}, $O = ["role"], DO = ["id", "type", "disabled", "formatter", "parser", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus"], BO = ["id", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus"], MO = be({
  name: "ElInput",
  inheritAttrs: !1
}), zO = /* @__PURE__ */ be({
  ...MO,
  props: LO,
  emits: PO,
  setup(t, { expose: e, emit: n }) {
    const r = t, i = hv(), s = Ho(), o = F(() => {
      const we = {};
      return r.containerRole === "combobox" && (we["aria-haspopup"] = i["aria-haspopup"], we["aria-owns"] = i["aria-owns"], we["aria-expanded"] = i["aria-expanded"]), we;
    }), a = F(() => [
      r.type === "textarea" ? p.b() : b.b(),
      b.m(v.value),
      b.is("disabled", y.value),
      b.is("exceed", ce.value),
      {
        [b.b("group")]: s.prepend || s.append,
        [b.bm("group", "append")]: s.append,
        [b.bm("group", "prepend")]: s.prepend,
        [b.m("prefix")]: s.prefix || r.prefixIcon,
        [b.m("suffix")]: s.suffix || r.suffixIcon || r.clearable || r.showPassword,
        [b.bm("suffix", "password-clear")]: re.value && fe.value
      },
      i.class
    ]), l = F(() => [
      b.e("wrapper"),
      b.is("focus", N.value)
    ]), u = pm({
      excludeKeys: F(() => Object.keys(o.value))
    }), { form: c, formItem: d } = oi(), { inputId: h } = ea(r, {
      formItemContext: d
    }), v = Lr(), y = Pr(), b = Fe("input"), p = Fe("textarea"), f = Mn(), m = Mn(), g = K(!1), w = K(!1), _ = K(!1), E = K(), C = Mn(r.inputStyle), T = F(() => f.value || m.value), { wrapperRef: k, isFocused: N, handleFocus: I, handleBlur: P } = EO(T, {
      afterBlur() {
        var we;
        r.validateEvent && ((we = d == null ? void 0 : d.validate) == null || we.call(d, "blur").catch((Ue) => Vt(Ue)));
      }
    }), D = F(() => {
      var we;
      return (we = c == null ? void 0 : c.statusIcon) != null ? we : !1;
    }), z = F(() => (d == null ? void 0 : d.validateState) || ""), G = F(() => z.value && fm[z.value]), J = F(() => _.value ? Ik : bC), M = F(() => [
      i.style,
      r.inputStyle
    ]), U = F(() => [
      r.inputStyle,
      C.value,
      { resize: r.resize }
    ]), j = F(() => er(r.modelValue) ? "" : String(r.modelValue)), re = F(() => r.clearable && !y.value && !r.readonly && !!j.value && (N.value || g.value)), fe = F(() => r.showPassword && !y.value && !r.readonly && !!j.value && (!!j.value || N.value)), Y = F(() => r.showWordLimit && !!u.value.maxlength && (r.type === "text" || r.type === "textarea") && !y.value && !r.readonly && !r.showPassword), le = F(() => j.value.length), ce = F(() => !!Y.value && le.value > Number(u.value.maxlength)), me = F(() => !!s.suffix || !!r.suffixIcon || re.value || r.showPassword || Y.value || !!z.value && D.value), [_e, ze] = wO(f);
    Cs(m, (we) => {
      if (Be(), !Y.value || r.resize !== "both")
        return;
      const Ue = we[0], { width: at } = Ue.contentRect;
      E.value = {
        right: `calc(100% - ${at + 15 + 6}px)`
      };
    });
    const Oe = () => {
      const { type: we, autosize: Ue } = r;
      if (!(!Et || we !== "textarea" || !m.value))
        if (Ue) {
          const at = wn(Ue) ? Ue.minRows : void 0, Lt = wn(Ue) ? Ue.maxRows : void 0, Zt = Bh(m.value, at, Lt);
          C.value = {
            overflowY: "hidden",
            ...Zt
          }, rt(() => {
            m.value.offsetHeight, C.value = Zt;
          });
        } else
          C.value = {
            minHeight: Bh(m.value).minHeight
          };
    }, Be = ((we) => {
      let Ue = !1;
      return () => {
        var at;
        if (Ue || !r.autosize)
          return;
        ((at = m.value) == null ? void 0 : at.offsetParent) === null || (we(), Ue = !0);
      };
    })(Oe), He = () => {
      const we = T.value, Ue = r.formatter ? r.formatter(j.value) : j.value;
      !we || we.value === Ue || (we.value = Ue);
    }, ct = async (we) => {
      _e();
      let { value: Ue } = we.target;
      if (r.formatter && (Ue = r.parser ? r.parser(Ue) : Ue), !w.value) {
        if (Ue === j.value) {
          He();
          return;
        }
        n(Pt, Ue), n("input", Ue), await rt(), He(), ze();
      }
    }, nt = (we) => {
      n("change", we.target.value);
    }, St = (we) => {
      n("compositionstart", we), w.value = !0;
    }, yt = (we) => {
      var Ue;
      n("compositionupdate", we);
      const at = (Ue = we.target) == null ? void 0 : Ue.value, Lt = at[at.length - 1] || "";
      w.value = !hm(Lt);
    }, It = (we) => {
      n("compositionend", we), w.value && (w.value = !1, ct(we));
    }, ot = () => {
      _.value = !_.value, bt();
    }, bt = async () => {
      var we;
      await rt(), (we = T.value) == null || we.focus();
    }, Kt = () => {
      var we;
      return (we = T.value) == null ? void 0 : we.blur();
    }, wt = (we) => {
      g.value = !1, n("mouseleave", we);
    }, xt = (we) => {
      g.value = !0, n("mouseenter", we);
    }, lt = (we) => {
      n("keydown", we);
    }, Ge = () => {
      var we;
      (we = T.value) == null || we.select();
    }, Rt = () => {
      n(Pt, ""), n("change", ""), n("clear"), n("input", "");
    };
    return ke(() => r.modelValue, () => {
      var we;
      rt(() => Oe()), r.validateEvent && ((we = d == null ? void 0 : d.validate) == null || we.call(d, "change").catch((Ue) => Vt(Ue)));
    }), ke(j, () => He()), ke(() => r.type, async () => {
      await rt(), He(), Oe();
    }), Tt(() => {
      !r.formatter && r.parser && Vt("ElInput", "If you set the parser, you also need to set the formatter."), He(), rt(Oe);
    }), e({
      input: f,
      textarea: m,
      ref: T,
      textareaStyle: U,
      autosize: Tn(r, "autosize"),
      focus: bt,
      blur: Kt,
      select: Ge,
      clear: Rt,
      resizeTextarea: Oe
    }), (we, Ue) => $t((V(), se("div", qn(x(o), {
      class: x(a),
      style: x(M),
      role: we.containerRole,
      onMouseenter: xt,
      onMouseleave: wt
    }), [
      ye(" input "),
      we.type !== "textarea" ? (V(), se(Ft, { key: 0 }, [
        ye(" prepend slot "),
        we.$slots.prepend ? (V(), se("div", {
          key: 0,
          class: ee(x(b).be("group", "prepend"))
        }, [
          De(we.$slots, "prepend")
        ], 2)) : ye("v-if", !0),
        ae("div", {
          ref_key: "wrapperRef",
          ref: k,
          class: ee(x(l))
        }, [
          ye(" prefix slot "),
          we.$slots.prefix || we.prefixIcon ? (V(), se("span", {
            key: 0,
            class: ee(x(b).e("prefix"))
          }, [
            ae("span", {
              class: ee(x(b).e("prefix-inner"))
            }, [
              De(we.$slots, "prefix"),
              we.prefixIcon ? (V(), Ce(x(_t), {
                key: 0,
                class: ee(x(b).e("icon"))
              }, {
                default: de(() => [
                  (V(), Ce(In(we.prefixIcon)))
                ]),
                _: 1
              }, 8, ["class"])) : ye("v-if", !0)
            ], 2)
          ], 2)) : ye("v-if", !0),
          ae("input", qn({
            id: x(h),
            ref_key: "input",
            ref: f,
            class: x(b).e("inner")
          }, x(u), {
            type: we.showPassword ? _.value ? "text" : "password" : we.type,
            disabled: x(y),
            formatter: we.formatter,
            parser: we.parser,
            readonly: we.readonly,
            autocomplete: we.autocomplete,
            tabindex: we.tabindex,
            "aria-label": we.label,
            placeholder: we.placeholder,
            style: we.inputStyle,
            form: r.form,
            autofocus: r.autofocus,
            onCompositionstart: St,
            onCompositionupdate: yt,
            onCompositionend: It,
            onInput: ct,
            onFocus: Ue[0] || (Ue[0] = (...at) => x(I) && x(I)(...at)),
            onBlur: Ue[1] || (Ue[1] = (...at) => x(P) && x(P)(...at)),
            onChange: nt,
            onKeydown: lt
          }), null, 16, DO),
          ye(" suffix slot "),
          x(me) ? (V(), se("span", {
            key: 1,
            class: ee(x(b).e("suffix"))
          }, [
            ae("span", {
              class: ee(x(b).e("suffix-inner"))
            }, [
              !x(re) || !x(fe) || !x(Y) ? (V(), se(Ft, { key: 0 }, [
                De(we.$slots, "suffix"),
                we.suffixIcon ? (V(), Ce(x(_t), {
                  key: 0,
                  class: ee(x(b).e("icon"))
                }, {
                  default: de(() => [
                    (V(), Ce(In(we.suffixIcon)))
                  ]),
                  _: 1
                }, 8, ["class"])) : ye("v-if", !0)
              ], 64)) : ye("v-if", !0),
              x(re) ? (V(), Ce(x(_t), {
                key: 1,
                class: ee([x(b).e("icon"), x(b).e("clear")]),
                onMousedown: ft(x(en), ["prevent"]),
                onClick: Rt
              }, {
                default: de(() => [
                  ve(x(Wl))
                ]),
                _: 1
              }, 8, ["class", "onMousedown"])) : ye("v-if", !0),
              x(fe) ? (V(), Ce(x(_t), {
                key: 2,
                class: ee([x(b).e("icon"), x(b).e("password")]),
                onClick: ot
              }, {
                default: de(() => [
                  (V(), Ce(In(x(J))))
                ]),
                _: 1
              }, 8, ["class"])) : ye("v-if", !0),
              x(Y) ? (V(), se("span", {
                key: 3,
                class: ee(x(b).e("count"))
              }, [
                ae("span", {
                  class: ee(x(b).e("count-inner"))
                }, st(x(le)) + " / " + st(x(u).maxlength), 3)
              ], 2)) : ye("v-if", !0),
              x(z) && x(G) && x(D) ? (V(), Ce(x(_t), {
                key: 4,
                class: ee([
                  x(b).e("icon"),
                  x(b).e("validateIcon"),
                  x(b).is("loading", x(z) === "validating")
                ])
              }, {
                default: de(() => [
                  (V(), Ce(In(x(G))))
                ]),
                _: 1
              }, 8, ["class"])) : ye("v-if", !0)
            ], 2)
          ], 2)) : ye("v-if", !0)
        ], 2),
        ye(" append slot "),
        we.$slots.append ? (V(), se("div", {
          key: 1,
          class: ee(x(b).be("group", "append"))
        }, [
          De(we.$slots, "append")
        ], 2)) : ye("v-if", !0)
      ], 64)) : (V(), se(Ft, { key: 1 }, [
        ye(" textarea "),
        ae("textarea", qn({
          id: x(h),
          ref_key: "textarea",
          ref: m,
          class: x(p).e("inner")
        }, x(u), {
          tabindex: we.tabindex,
          disabled: x(y),
          readonly: we.readonly,
          autocomplete: we.autocomplete,
          style: x(U),
          "aria-label": we.label,
          placeholder: we.placeholder,
          form: r.form,
          autofocus: r.autofocus,
          onCompositionstart: St,
          onCompositionupdate: yt,
          onCompositionend: It,
          onInput: ct,
          onFocus: Ue[2] || (Ue[2] = (...at) => x(I) && x(I)(...at)),
          onBlur: Ue[3] || (Ue[3] = (...at) => x(P) && x(P)(...at)),
          onChange: nt,
          onKeydown: lt
        }), null, 16, BO),
        x(Y) ? (V(), se("span", {
          key: 0,
          style: it(E.value),
          class: ee(x(b).e("count"))
        }, st(x(le)) + " / " + st(x(u).maxlength), 7)) : ye("v-if", !0)
      ], 64))
    ], 16, $O)), [
      [Yn, we.type !== "hidden"]
    ]);
  }
});
var FO = /* @__PURE__ */ qe(zO, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input/src/input.vue"]]);
const Yl = nn(FO), ys = 4, jO = {
  vertical: {
    offset: "offsetHeight",
    scroll: "scrollTop",
    scrollSize: "scrollHeight",
    size: "height",
    key: "vertical",
    axis: "Y",
    client: "clientY",
    direction: "top"
  },
  horizontal: {
    offset: "offsetWidth",
    scroll: "scrollLeft",
    scrollSize: "scrollWidth",
    size: "width",
    key: "horizontal",
    axis: "X",
    client: "clientX",
    direction: "left"
  }
}, UO = ({
  move: t,
  size: e,
  bar: n
}) => ({
  [n.size]: e,
  transform: `translate${n.axis}(${t}%)`
}), Fm = Symbol("scrollbarContextKey"), VO = ut({
  vertical: Boolean,
  size: String,
  move: Number,
  ratio: {
    type: Number,
    required: !0
  },
  always: Boolean
}), WO = "Thumb", HO = /* @__PURE__ */ be({
  __name: "thumb",
  props: VO,
  setup(t) {
    const e = t, n = tt(Fm), r = Fe("scrollbar");
    n || Gi(WO, "can not inject scrollbar context");
    const i = K(), s = K(), o = K({}), a = K(!1);
    let l = !1, u = !1, c = Et ? document.onselectstart : null;
    const d = F(() => jO[e.vertical ? "vertical" : "horizontal"]), h = F(() => UO({
      size: e.size,
      move: e.move,
      bar: d.value
    })), v = F(() => i.value[d.value.offset] ** 2 / n.wrapElement[d.value.scrollSize] / e.ratio / s.value[d.value.offset]), y = (E) => {
      var C;
      if (E.stopPropagation(), E.ctrlKey || [1, 2].includes(E.button))
        return;
      (C = window.getSelection()) == null || C.removeAllRanges(), p(E);
      const T = E.currentTarget;
      T && (o.value[d.value.axis] = T[d.value.offset] - (E[d.value.client] - T.getBoundingClientRect()[d.value.direction]));
    }, b = (E) => {
      if (!s.value || !i.value || !n.wrapElement)
        return;
      const C = Math.abs(E.target.getBoundingClientRect()[d.value.direction] - E[d.value.client]), T = s.value[d.value.offset] / 2, k = (C - T) * 100 * v.value / i.value[d.value.offset];
      n.wrapElement[d.value.scroll] = k * n.wrapElement[d.value.scrollSize] / 100;
    }, p = (E) => {
      E.stopImmediatePropagation(), l = !0, document.addEventListener("mousemove", f), document.addEventListener("mouseup", m), c = document.onselectstart, document.onselectstart = () => !1;
    }, f = (E) => {
      if (!i.value || !s.value || l === !1)
        return;
      const C = o.value[d.value.axis];
      if (!C)
        return;
      const T = (i.value.getBoundingClientRect()[d.value.direction] - E[d.value.client]) * -1, k = s.value[d.value.offset] - C, N = (T - k) * 100 * v.value / i.value[d.value.offset];
      n.wrapElement[d.value.scroll] = N * n.wrapElement[d.value.scrollSize] / 100;
    }, m = () => {
      l = !1, o.value[d.value.axis] = 0, document.removeEventListener("mousemove", f), document.removeEventListener("mouseup", m), _(), u && (a.value = !1);
    }, g = () => {
      u = !1, a.value = !!e.size;
    }, w = () => {
      u = !0, a.value = l;
    };
    Sn(() => {
      _(), document.removeEventListener("mouseup", m);
    });
    const _ = () => {
      document.onselectstart !== c && (document.onselectstart = c);
    };
    return bn(Tn(n, "scrollbarElement"), "mousemove", g), bn(Tn(n, "scrollbarElement"), "mouseleave", w), (E, C) => (V(), Ce(gr, {
      name: x(r).b("fade"),
      persisted: ""
    }, {
      default: de(() => [
        $t(ae("div", {
          ref_key: "instance",
          ref: i,
          class: ee([x(r).e("bar"), x(r).is(x(d).key)]),
          onMousedown: b
        }, [
          ae("div", {
            ref_key: "thumb",
            ref: s,
            class: ee(x(r).e("thumb")),
            style: it(x(h)),
            onMousedown: y
          }, null, 38)
        ], 34), [
          [Yn, E.always || a.value]
        ])
      ]),
      _: 1
    }, 8, ["name"]));
  }
});
var Mh = /* @__PURE__ */ qe(HO, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/thumb.vue"]]);
const KO = ut({
  always: {
    type: Boolean,
    default: !0
  },
  width: String,
  height: String,
  ratioX: {
    type: Number,
    default: 1
  },
  ratioY: {
    type: Number,
    default: 1
  }
}), qO = /* @__PURE__ */ be({
  __name: "bar",
  props: KO,
  setup(t, { expose: e }) {
    const n = t, r = K(0), i = K(0);
    return e({
      handleScroll: (o) => {
        if (o) {
          const a = o.offsetHeight - ys, l = o.offsetWidth - ys;
          i.value = o.scrollTop * 100 / a * n.ratioY, r.value = o.scrollLeft * 100 / l * n.ratioX;
        }
      }
    }), (o, a) => (V(), se(Ft, null, [
      ve(Mh, {
        move: r.value,
        ratio: o.ratioX,
        size: o.width,
        always: o.always
      }, null, 8, ["move", "ratio", "size", "always"]),
      ve(Mh, {
        move: i.value,
        ratio: o.ratioY,
        size: o.height,
        vertical: "",
        always: o.always
      }, null, 8, ["move", "ratio", "size", "always"])
    ], 64));
  }
});
var GO = /* @__PURE__ */ qe(qO, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/bar.vue"]]);
const YO = ut({
  height: {
    type: [String, Number],
    default: ""
  },
  maxHeight: {
    type: [String, Number],
    default: ""
  },
  native: {
    type: Boolean,
    default: !1
  },
  wrapStyle: {
    type: Pe([String, Object, Array]),
    default: ""
  },
  wrapClass: {
    type: [String, Array],
    default: ""
  },
  viewClass: {
    type: [String, Array],
    default: ""
  },
  viewStyle: {
    type: [String, Array, Object],
    default: ""
  },
  noresize: Boolean,
  tag: {
    type: String,
    default: "div"
  },
  always: Boolean,
  minSize: {
    type: Number,
    default: 20
  },
  id: String,
  role: String,
  ariaLabel: String,
  ariaOrientation: {
    type: String,
    values: ["horizontal", "vertical"]
  }
}), XO = {
  scroll: ({
    scrollTop: t,
    scrollLeft: e
  }) => [t, e].every(gt)
}, oc = "ElScrollbar", ZO = be({
  name: oc
}), QO = /* @__PURE__ */ be({
  ...ZO,
  props: YO,
  emits: XO,
  setup(t, { expose: e, emit: n }) {
    const r = t, i = Fe("scrollbar");
    let s, o;
    const a = K(), l = K(), u = K(), c = K("0"), d = K("0"), h = K(), v = K(1), y = K(1), b = F(() => {
      const C = {};
      return r.height && (C.height = ul(r.height)), r.maxHeight && (C.maxHeight = ul(r.maxHeight)), [r.wrapStyle, C];
    }), p = F(() => [
      r.wrapClass,
      i.e("wrap"),
      { [i.em("wrap", "hidden-default")]: !r.native }
    ]), f = F(() => [i.e("view"), r.viewClass]), m = () => {
      var C;
      l.value && ((C = h.value) == null || C.handleScroll(l.value), n("scroll", {
        scrollTop: l.value.scrollTop,
        scrollLeft: l.value.scrollLeft
      }));
    };
    function g(C, T) {
      wn(C) ? l.value.scrollTo(C) : gt(C) && gt(T) && l.value.scrollTo(C, T);
    }
    const w = (C) => {
      if (!gt(C)) {
        Vt(oc, "value must be a number");
        return;
      }
      l.value.scrollTop = C;
    }, _ = (C) => {
      if (!gt(C)) {
        Vt(oc, "value must be a number");
        return;
      }
      l.value.scrollLeft = C;
    }, E = () => {
      if (!l.value)
        return;
      const C = l.value.offsetHeight - ys, T = l.value.offsetWidth - ys, k = C ** 2 / l.value.scrollHeight, N = T ** 2 / l.value.scrollWidth, I = Math.max(k, r.minSize), P = Math.max(N, r.minSize);
      v.value = k / (C - k) / (I / (C - I)), y.value = N / (T - N) / (P / (T - P)), d.value = I + ys < C ? `${I}px` : "", c.value = P + ys < T ? `${P}px` : "";
    };
    return ke(() => r.noresize, (C) => {
      C ? (s == null || s(), o == null || o()) : ({ stop: s } = Cs(u, E), o = bn("resize", E));
    }, { immediate: !0 }), ke(() => [r.maxHeight, r.height], () => {
      r.native || rt(() => {
        var C;
        E(), l.value && ((C = h.value) == null || C.handleScroll(l.value));
      });
    }), Gt(Fm, Pn({
      scrollbarElement: a,
      wrapElement: l
    })), Tt(() => {
      r.native || rt(() => {
        E();
      });
    }), Dl(() => E()), e({
      wrapRef: l,
      update: E,
      scrollTo: g,
      setScrollTop: w,
      setScrollLeft: _,
      handleScroll: m
    }), (C, T) => (V(), se("div", {
      ref_key: "scrollbarRef",
      ref: a,
      class: ee(x(i).b())
    }, [
      ae("div", {
        ref_key: "wrapRef",
        ref: l,
        class: ee(x(p)),
        style: it(x(b)),
        onScroll: m
      }, [
        (V(), Ce(In(C.tag), {
          id: C.id,
          ref_key: "resizeRef",
          ref: u,
          class: ee(x(f)),
          style: it(C.viewStyle),
          role: C.role,
          "aria-label": C.ariaLabel,
          "aria-orientation": C.ariaOrientation
        }, {
          default: de(() => [
            De(C.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "class", "style", "role", "aria-label", "aria-orientation"]))
      ], 38),
      C.native ? ye("v-if", !0) : (V(), Ce(GO, {
        key: 0,
        ref_key: "barRef",
        ref: h,
        height: d.value,
        width: c.value,
        always: C.always,
        "ratio-x": y.value,
        "ratio-y": v.value
      }, null, 8, ["height", "width", "always", "ratio-x", "ratio-y"]))
    ], 2));
  }
});
var JO = /* @__PURE__ */ qe(QO, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/scrollbar.vue"]]);
const Wd = nn(JO), Hd = Symbol("popper"), jm = Symbol("popperContent"), eN = [
  "dialog",
  "grid",
  "group",
  "listbox",
  "menu",
  "navigation",
  "tooltip",
  "tree"
], Um = ut({
  role: {
    type: String,
    values: eN,
    default: "tooltip"
  }
}), tN = be({
  name: "ElPopper",
  inheritAttrs: !1
}), nN = /* @__PURE__ */ be({
  ...tN,
  props: Um,
  setup(t, { expose: e }) {
    const n = t, r = K(), i = K(), s = K(), o = K(), a = F(() => n.role), l = {
      triggerRef: r,
      popperInstanceRef: i,
      contentRef: s,
      referenceRef: o,
      role: a
    };
    return e(l), Gt(Hd, l), (u, c) => De(u.$slots, "default");
  }
});
var rN = /* @__PURE__ */ qe(nN, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/popper.vue"]]);
const Vm = ut({
  arrowOffset: {
    type: Number,
    default: 5
  }
}), iN = be({
  name: "ElPopperArrow",
  inheritAttrs: !1
}), sN = /* @__PURE__ */ be({
  ...iN,
  props: Vm,
  setup(t, { expose: e }) {
    const n = t, r = Fe("popper"), { arrowOffset: i, arrowRef: s, arrowStyle: o } = tt(jm, void 0);
    return ke(() => n.arrowOffset, (a) => {
      i.value = a;
    }), Sn(() => {
      s.value = void 0;
    }), e({
      arrowRef: s
    }), (a, l) => (V(), se("span", {
      ref_key: "arrowRef",
      ref: s,
      class: ee(x(r).e("arrow")),
      style: it(x(o)),
      "data-popper-arrow": ""
    }, null, 6));
  }
});
var oN = /* @__PURE__ */ qe(sN, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/arrow.vue"]]);
const bu = "ElOnlyChild", aN = be({
  name: bu,
  setup(t, {
    slots: e,
    attrs: n
  }) {
    var r;
    const i = tt($m), s = bO((r = i == null ? void 0 : i.setForwardRef) != null ? r : en);
    return () => {
      var o;
      const a = (o = e.default) == null ? void 0 : o.call(e, n);
      if (!a)
        return null;
      if (a.length > 1)
        return Vt(bu, "requires exact only one valid child."), null;
      const l = Wm(a);
      return l ? $t(Gy(l, n), [[s]]) : (Vt(bu, "no valid child node found"), null);
    };
  }
});
function Wm(t) {
  if (!t)
    return null;
  const e = t;
  for (const n of e) {
    if (wn(n))
      switch (n.type) {
        case vv:
          continue;
        case pv:
        case "svg":
          return zh(n);
        case Ft:
          return Wm(n.children);
        default:
          return n;
      }
    return zh(n);
  }
  return null;
}
function zh(t) {
  const e = Fe("only-child");
  return ve("span", {
    class: e.e("content")
  }, [t]);
}
const Hm = ut({
  virtualRef: {
    type: Pe(Object)
  },
  virtualTriggering: Boolean,
  onMouseenter: {
    type: Pe(Function)
  },
  onMouseleave: {
    type: Pe(Function)
  },
  onClick: {
    type: Pe(Function)
  },
  onKeydown: {
    type: Pe(Function)
  },
  onFocus: {
    type: Pe(Function)
  },
  onBlur: {
    type: Pe(Function)
  },
  onContextmenu: {
    type: Pe(Function)
  },
  id: String,
  open: Boolean
}), lN = be({
  name: "ElPopperTrigger",
  inheritAttrs: !1
}), uN = /* @__PURE__ */ be({
  ...lN,
  props: Hm,
  setup(t, { expose: e }) {
    const n = t, { role: r, triggerRef: i } = tt(Hd, void 0);
    yO(i);
    const s = F(() => a.value ? n.id : void 0), o = F(() => {
      if (r && r.value === "tooltip")
        return n.open && n.id ? n.id : void 0;
    }), a = F(() => {
      if (r && r.value !== "tooltip")
        return r.value;
    }), l = F(() => a.value ? `${n.open}` : void 0);
    let u;
    return Tt(() => {
      ke(() => n.virtualRef, (c) => {
        c && (i.value = pi(c));
      }, {
        immediate: !0
      }), ke(i, (c, d) => {
        u == null || u(), u = void 0, zi(c) && ([
          "onMouseenter",
          "onMouseleave",
          "onClick",
          "onKeydown",
          "onFocus",
          "onBlur",
          "onContextmenu"
        ].forEach((h) => {
          var v;
          const y = n[h];
          y && (c.addEventListener(h.slice(2).toLowerCase(), y), (v = d == null ? void 0 : d.removeEventListener) == null || v.call(d, h.slice(2).toLowerCase(), y));
        }), u = ke([s, o, a, l], (h) => {
          [
            "aria-controls",
            "aria-describedby",
            "aria-haspopup",
            "aria-expanded"
          ].forEach((v, y) => {
            er(h[y]) ? c.removeAttribute(v) : c.setAttribute(v, h[y]);
          });
        }, { immediate: !0 })), zi(d) && [
          "aria-controls",
          "aria-describedby",
          "aria-haspopup",
          "aria-expanded"
        ].forEach((h) => d.removeAttribute(h));
      }, {
        immediate: !0
      });
    }), Sn(() => {
      u == null || u(), u = void 0;
    }), e({
      triggerRef: i
    }), (c, d) => c.virtualTriggering ? ye("v-if", !0) : (V(), Ce(x(aN), qn({ key: 0 }, c.$attrs, {
      "aria-controls": x(s),
      "aria-describedby": x(o),
      "aria-expanded": x(l),
      "aria-haspopup": x(a)
    }), {
      default: de(() => [
        De(c.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"]));
  }
});
var cN = /* @__PURE__ */ qe(uN, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/trigger.vue"]]);
const wu = "focus-trap.focus-after-trapped", _u = "focus-trap.focus-after-released", dN = "focus-trap.focusout-prevented", Fh = {
  cancelable: !0,
  bubbles: !1
}, fN = {
  cancelable: !0,
  bubbles: !1
}, jh = "focusAfterTrapped", Uh = "focusAfterReleased", hN = Symbol("elFocusTrap"), Kd = K(), Xl = K(0), qd = K(0);
let ma = 0;
const Km = (t) => {
  const e = [], n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 || r === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); )
    e.push(n.currentNode);
  return e;
}, Vh = (t, e) => {
  for (const n of t)
    if (!pN(n, e))
      return n;
}, pN = (t, e) => {
  if (process.env.NODE_ENV === "test")
    return !1;
  if (getComputedStyle(t).visibility === "hidden")
    return !0;
  for (; t; ) {
    if (e && t === e)
      return !1;
    if (getComputedStyle(t).display === "none")
      return !0;
    t = t.parentElement;
  }
  return !1;
}, vN = (t) => {
  const e = Km(t), n = Vh(e, t), r = Vh(e.reverse(), t);
  return [n, r];
}, mN = (t) => t instanceof HTMLInputElement && "select" in t, ui = (t, e) => {
  if (t && t.focus) {
    const n = document.activeElement;
    t.focus({ preventScroll: !0 }), qd.value = window.performance.now(), t !== n && mN(t) && e && t.select();
  }
};
function Wh(t, e) {
  const n = [...t], r = t.indexOf(e);
  return r !== -1 && n.splice(r, 1), n;
}
const gN = () => {
  let t = [];
  return {
    push: (r) => {
      const i = t[0];
      i && r !== i && i.pause(), t = Wh(t, r), t.unshift(r);
    },
    remove: (r) => {
      var i, s;
      t = Wh(t, r), (s = (i = t[0]) == null ? void 0 : i.resume) == null || s.call(i);
    }
  };
}, yN = (t, e = !1) => {
  const n = document.activeElement;
  for (const r of t)
    if (ui(r, e), document.activeElement !== n)
      return;
}, Hh = gN(), bN = () => Xl.value > qd.value, ga = () => {
  Kd.value = "pointer", Xl.value = window.performance.now();
}, Kh = () => {
  Kd.value = "keyboard", Xl.value = window.performance.now();
}, wN = () => (Tt(() => {
  ma === 0 && (document.addEventListener("mousedown", ga), document.addEventListener("touchstart", ga), document.addEventListener("keydown", Kh)), ma++;
}), Sn(() => {
  ma--, ma <= 0 && (document.removeEventListener("mousedown", ga), document.removeEventListener("touchstart", ga), document.removeEventListener("keydown", Kh));
}), {
  focusReason: Kd,
  lastUserFocusTimestamp: Xl,
  lastAutomatedFocusTimestamp: qd
}), ya = (t) => new CustomEvent(dN, {
  ...fN,
  detail: t
}), _N = be({
  name: "ElFocusTrap",
  inheritAttrs: !1,
  props: {
    loop: Boolean,
    trapped: Boolean,
    focusTrapEl: Object,
    focusStartEl: {
      type: [Object, String],
      default: "first"
    }
  },
  emits: [
    jh,
    Uh,
    "focusin",
    "focusout",
    "focusout-prevented",
    "release-requested"
  ],
  setup(t, { emit: e }) {
    const n = K();
    let r, i;
    const { focusReason: s } = wN();
    pO((y) => {
      t.trapped && !o.paused && e("release-requested", y);
    });
    const o = {
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    }, a = (y) => {
      if (!t.loop && !t.trapped || o.paused)
        return;
      const { key: b, altKey: p, ctrlKey: f, metaKey: m, currentTarget: g, shiftKey: w } = y, { loop: _ } = t, E = b === sn.tab && !p && !f && !m, C = document.activeElement;
      if (E && C) {
        const T = g, [k, N] = vN(T);
        if (k && N) {
          if (!w && C === N) {
            const P = ya({
              focusReason: s.value
            });
            e("focusout-prevented", P), P.defaultPrevented || (y.preventDefault(), _ && ui(k, !0));
          } else if (w && [k, T].includes(C)) {
            const P = ya({
              focusReason: s.value
            });
            e("focusout-prevented", P), P.defaultPrevented || (y.preventDefault(), _ && ui(N, !0));
          }
        } else if (C === T) {
          const P = ya({
            focusReason: s.value
          });
          e("focusout-prevented", P), P.defaultPrevented || y.preventDefault();
        }
      }
    };
    Gt(hN, {
      focusTrapRef: n,
      onKeydown: a
    }), ke(() => t.focusTrapEl, (y) => {
      y && (n.value = y);
    }, { immediate: !0 }), ke([n], ([y], [b]) => {
      y && (y.addEventListener("keydown", a), y.addEventListener("focusin", c), y.addEventListener("focusout", d)), b && (b.removeEventListener("keydown", a), b.removeEventListener("focusin", c), b.removeEventListener("focusout", d));
    });
    const l = (y) => {
      e(jh, y);
    }, u = (y) => e(Uh, y), c = (y) => {
      const b = x(n);
      if (!b)
        return;
      const p = y.target, f = y.relatedTarget, m = p && b.contains(p);
      t.trapped || f && b.contains(f) || (r = f), m && e("focusin", y), !o.paused && t.trapped && (m ? i = p : ui(i, !0));
    }, d = (y) => {
      const b = x(n);
      if (!(o.paused || !b))
        if (t.trapped) {
          const p = y.relatedTarget;
          !er(p) && !b.contains(p) && setTimeout(() => {
            if (!o.paused && t.trapped) {
              const f = ya({
                focusReason: s.value
              });
              e("focusout-prevented", f), f.defaultPrevented || ui(i, !0);
            }
          }, 0);
        } else {
          const p = y.target;
          p && b.contains(p) || e("focusout", y);
        }
    };
    async function h() {
      await rt();
      const y = x(n);
      if (y) {
        Hh.push(o);
        const b = y.contains(document.activeElement) ? r : document.activeElement;
        if (r = b, !y.contains(b)) {
          const f = new Event(wu, Fh);
          y.addEventListener(wu, l), y.dispatchEvent(f), f.defaultPrevented || rt(() => {
            let m = t.focusStartEl;
            qt(m) || (ui(m), document.activeElement !== m && (m = "first")), m === "first" && yN(Km(y), !0), (document.activeElement === b || m === "container") && ui(y);
          });
        }
      }
    }
    function v() {
      const y = x(n);
      if (y) {
        y.removeEventListener(wu, l);
        const b = new CustomEvent(_u, {
          ...Fh,
          detail: {
            focusReason: s.value
          }
        });
        y.addEventListener(_u, u), y.dispatchEvent(b), !b.defaultPrevented && (s.value == "keyboard" || !bN() || y.contains(document.activeElement)) && ui(r ?? document.body), y.removeEventListener(_u, u), Hh.remove(o);
      }
    }
    return Tt(() => {
      t.trapped && h(), ke(() => t.trapped, (y) => {
        y ? h() : v();
      });
    }), Sn(() => {
      t.trapped && v();
    }), {
      onKeydown: a
    };
  }
});
function EN(t, e, n, r, i, s) {
  return De(t.$slots, "default", { handleKeydown: t.onKeydown });
}
var SN = /* @__PURE__ */ qe(_N, [["render", EN], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue"]]);
const xN = ["fixed", "absolute"], CN = ut({
  boundariesPadding: {
    type: Number,
    default: 0
  },
  fallbackPlacements: {
    type: Pe(Array),
    default: void 0
  },
  gpuAcceleration: {
    type: Boolean,
    default: !0
  },
  offset: {
    type: Number,
    default: 12
  },
  placement: {
    type: String,
    values: Fs,
    default: "bottom"
  },
  popperOptions: {
    type: Pe(Object),
    default: () => ({})
  },
  strategy: {
    type: String,
    values: xN,
    default: "absolute"
  }
}), qm = ut({
  ...CN,
  id: String,
  style: {
    type: Pe([String, Array, Object])
  },
  className: {
    type: Pe([String, Array, Object])
  },
  effect: {
    type: String,
    default: "dark"
  },
  visible: Boolean,
  enterable: {
    type: Boolean,
    default: !0
  },
  pure: Boolean,
  focusOnShow: {
    type: Boolean,
    default: !1
  },
  trapping: {
    type: Boolean,
    default: !1
  },
  popperClass: {
    type: Pe([String, Array, Object])
  },
  popperStyle: {
    type: Pe([String, Array, Object])
  },
  referenceEl: {
    type: Pe(Object)
  },
  triggerTargetEl: {
    type: Pe(Object)
  },
  stopPopperMouseEvent: {
    type: Boolean,
    default: !0
  },
  ariaLabel: {
    type: String,
    default: void 0
  },
  virtualTriggering: Boolean,
  zIndex: Number
}), kN = {
  mouseenter: (t) => t instanceof MouseEvent,
  mouseleave: (t) => t instanceof MouseEvent,
  focus: () => !0,
  blur: () => !0,
  close: () => !0
}, TN = (t, e = []) => {
  const { placement: n, strategy: r, popperOptions: i } = t, s = {
    placement: n,
    strategy: r,
    ...i,
    modifiers: [...NN(t), ...e]
  };
  return AN(s, i == null ? void 0 : i.modifiers), s;
}, ON = (t) => {
  if (Et)
    return pi(t);
};
function NN(t) {
  const { offset: e, gpuAcceleration: n, fallbackPlacements: r } = t;
  return [
    {
      name: "offset",
      options: {
        offset: [0, e ?? 12]
      }
    },
    {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    },
    {
      name: "flip",
      options: {
        padding: 5,
        fallbackPlacements: r
      }
    },
    {
      name: "computeStyles",
      options: {
        gpuAcceleration: n
      }
    }
  ];
}
function AN(t, e) {
  e && (t.modifiers = [...t.modifiers, ...e ?? []]);
}
const IN = 0, RN = (t) => {
  const { popperInstanceRef: e, contentRef: n, triggerRef: r, role: i } = tt(Hd, void 0), s = K(), o = K(), a = F(() => ({
    name: "eventListeners",
    enabled: !!t.visible
  })), l = F(() => {
    var f;
    const m = x(s), g = (f = x(o)) != null ? f : IN;
    return {
      name: "arrow",
      enabled: !_S(m),
      options: {
        element: m,
        padding: g
      }
    };
  }), u = F(() => ({
    onFirstUpdate: () => {
      y();
    },
    ...TN(t, [
      x(l),
      x(a)
    ])
  })), c = F(() => ON(t.referenceEl) || x(r)), { attributes: d, state: h, styles: v, update: y, forceUpdate: b, instanceRef: p } = dO(c, n, u);
  return ke(p, (f) => e.value = f), Tt(() => {
    ke(() => {
      var f;
      return (f = x(c)) == null ? void 0 : f.getBoundingClientRect();
    }, () => {
      y();
    });
  }), {
    attributes: d,
    arrowRef: s,
    contentRef: n,
    instanceRef: p,
    state: h,
    styles: v,
    role: i,
    forceUpdate: b,
    update: y
  };
}, LN = (t, {
  attributes: e,
  styles: n,
  role: r
}) => {
  const { nextZIndex: i } = Gl(), s = Fe("popper"), o = F(() => x(e).popper), a = K(gt(t.zIndex) ? t.zIndex : i()), l = F(() => [
    s.b(),
    s.is("pure", t.pure),
    s.is(t.effect),
    t.popperClass
  ]), u = F(() => [
    { zIndex: x(a) },
    x(n).popper,
    t.popperStyle || {}
  ]), c = F(() => r.value === "dialog" ? "false" : void 0), d = F(() => x(n).arrow || {});
  return {
    ariaModal: c,
    arrowStyle: d,
    contentAttrs: o,
    contentClass: l,
    contentStyle: u,
    contentZIndex: a,
    updateZIndex: () => {
      a.value = gt(t.zIndex) ? t.zIndex : i();
    }
  };
}, PN = (t, e) => {
  const n = K(!1), r = K();
  return {
    focusStartRef: r,
    trapped: n,
    onFocusAfterReleased: (u) => {
      var c;
      ((c = u.detail) == null ? void 0 : c.focusReason) !== "pointer" && (r.value = "first", e("blur"));
    },
    onFocusAfterTrapped: () => {
      e("focus");
    },
    onFocusInTrap: (u) => {
      t.visible && !n.value && (u.target && (r.value = u.target), n.value = !0);
    },
    onFocusoutPrevented: (u) => {
      t.trapping || (u.detail.focusReason === "pointer" && u.preventDefault(), n.value = !1);
    },
    onReleaseRequested: () => {
      n.value = !1, e("close");
    }
  };
}, $N = be({
  name: "ElPopperContent"
}), DN = /* @__PURE__ */ be({
  ...$N,
  props: qm,
  emits: kN,
  setup(t, { expose: e, emit: n }) {
    const r = t, {
      focusStartRef: i,
      trapped: s,
      onFocusAfterReleased: o,
      onFocusAfterTrapped: a,
      onFocusInTrap: l,
      onFocusoutPrevented: u,
      onReleaseRequested: c
    } = PN(r, n), { attributes: d, arrowRef: h, contentRef: v, styles: y, instanceRef: b, role: p, update: f } = RN(r), {
      ariaModal: m,
      arrowStyle: g,
      contentAttrs: w,
      contentClass: _,
      contentStyle: E,
      updateZIndex: C
    } = LN(r, {
      styles: y,
      attributes: d,
      role: p
    }), T = tt(No, void 0), k = K();
    Gt(jm, {
      arrowStyle: g,
      arrowRef: h,
      arrowOffset: k
    }), T && (T.addInputId || T.removeInputId) && Gt(No, {
      ...T,
      addInputId: en,
      removeInputId: en
    });
    let N;
    const I = (D = !0) => {
      f(), D && C();
    }, P = () => {
      I(!1), r.visible && r.focusOnShow ? s.value = !0 : r.visible === !1 && (s.value = !1);
    };
    return Tt(() => {
      ke(() => r.triggerTargetEl, (D, z) => {
        N == null || N(), N = void 0;
        const G = x(D || v.value), J = x(z || v.value);
        zi(G) && (N = ke([p, () => r.ariaLabel, m, () => r.id], (M) => {
          ["role", "aria-label", "aria-modal", "id"].forEach((U, j) => {
            er(M[j]) ? G.removeAttribute(U) : G.setAttribute(U, M[j]);
          });
        }, { immediate: !0 })), J !== G && zi(J) && ["role", "aria-label", "aria-modal", "id"].forEach((M) => {
          J.removeAttribute(M);
        });
      }, { immediate: !0 }), ke(() => r.visible, P, { immediate: !0 });
    }), Sn(() => {
      N == null || N(), N = void 0;
    }), e({
      popperContentRef: v,
      popperInstanceRef: b,
      updatePopper: I,
      contentStyle: E
    }), (D, z) => (V(), se("div", qn({
      ref_key: "contentRef",
      ref: v
    }, x(w), {
      style: x(E),
      class: x(_),
      tabindex: "-1",
      onMouseenter: z[0] || (z[0] = (G) => D.$emit("mouseenter", G)),
      onMouseleave: z[1] || (z[1] = (G) => D.$emit("mouseleave", G))
    }), [
      ve(x(SN), {
        trapped: x(s),
        "trap-on-focus-in": !0,
        "focus-trap-el": x(v),
        "focus-start-el": x(i),
        onFocusAfterTrapped: x(a),
        onFocusAfterReleased: x(o),
        onFocusin: x(l),
        onFocusoutPrevented: x(u),
        onReleaseRequested: x(c)
      }, {
        default: de(() => [
          De(D.$slots, "default")
        ]),
        _: 3
      }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
    ], 16));
  }
});
var BN = /* @__PURE__ */ qe(DN, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/content.vue"]]);
const MN = nn(rN), Gd = Symbol("elTooltip"), Kn = ut({
  ...gO,
  ...qm,
  appendTo: {
    type: Pe([String, Object])
  },
  content: {
    type: String,
    default: ""
  },
  rawContent: {
    type: Boolean,
    default: !1
  },
  persistent: Boolean,
  ariaLabel: String,
  visible: {
    type: Pe(Boolean),
    default: null
  },
  transition: String,
  teleported: {
    type: Boolean,
    default: !0
  },
  disabled: Boolean
}), Ao = ut({
  ...Hm,
  disabled: Boolean,
  trigger: {
    type: Pe([String, Array]),
    default: "hover"
  },
  triggerKeys: {
    type: Pe(Array),
    default: () => [sn.enter, sn.space]
  }
}), {
  useModelToggleProps: zN,
  useModelToggleEmits: FN,
  useModelToggle: jN
} = ym("visible"), UN = ut({
  ...Um,
  ...zN,
  ...Kn,
  ...Ao,
  ...Vm,
  showArrow: {
    type: Boolean,
    default: !0
  }
}), VN = [
  ...FN,
  "before-show",
  "before-hide",
  "show",
  "hide",
  "open",
  "close"
], WN = (t, e) => Nr(t) ? t.includes(e) : t === e, rs = (t, e, n) => (r) => {
  WN(x(t), e) && n(r);
}, HN = be({
  name: "ElTooltipTrigger"
}), KN = /* @__PURE__ */ be({
  ...HN,
  props: Ao,
  setup(t, { expose: e }) {
    const n = t, r = Fe("tooltip"), { controlled: i, id: s, open: o, onOpen: a, onClose: l, onToggle: u } = tt(Gd, void 0), c = K(null), d = () => {
      if (x(i) || n.disabled)
        return !0;
    }, h = Tn(n, "trigger"), v = jr(d, rs(h, "hover", a)), y = jr(d, rs(h, "hover", l)), b = jr(d, rs(h, "click", (w) => {
      w.button === 0 && u(w);
    })), p = jr(d, rs(h, "focus", a)), f = jr(d, rs(h, "focus", l)), m = jr(d, rs(h, "contextmenu", (w) => {
      w.preventDefault(), u(w);
    })), g = jr(d, (w) => {
      const { code: _ } = w;
      n.triggerKeys.includes(_) && (w.preventDefault(), u(w));
    });
    return e({
      triggerRef: c
    }), (w, _) => (V(), Ce(x(cN), {
      id: x(s),
      "virtual-ref": w.virtualRef,
      open: x(o),
      "virtual-triggering": w.virtualTriggering,
      class: ee(x(r).e("trigger")),
      onBlur: x(f),
      onClick: x(b),
      onContextmenu: x(m),
      onFocus: x(p),
      onMouseenter: x(v),
      onMouseleave: x(y),
      onKeydown: x(g)
    }, {
      default: de(() => [
        De(w.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]));
  }
});
var qN = /* @__PURE__ */ qe(KN, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/trigger.vue"]]);
const GN = be({
  name: "ElTooltipContent",
  inheritAttrs: !1
}), YN = /* @__PURE__ */ be({
  ...GN,
  props: Kn,
  setup(t, { expose: e }) {
    const n = t, { selector: r } = Lm(), i = Fe("tooltip"), s = K(null), o = K(!1), {
      controlled: a,
      id: l,
      open: u,
      trigger: c,
      onClose: d,
      onOpen: h,
      onShow: v,
      onHide: y,
      onBeforeShow: b,
      onBeforeHide: p
    } = tt(Gd, void 0), f = F(() => n.transition || `${i.namespace.value}-fade-in-linear`), m = F(() => process.env.NODE_ENV === "test" ? !0 : n.persistent);
    Sn(() => {
      o.value = !0;
    });
    const g = F(() => x(m) ? !0 : x(u)), w = F(() => n.disabled ? !1 : x(u)), _ = F(() => n.appendTo || r.value), E = F(() => {
      var M;
      return (M = n.style) != null ? M : {};
    }), C = F(() => !x(u)), T = () => {
      y();
    }, k = () => {
      if (x(a))
        return !0;
    }, N = jr(k, () => {
      n.enterable && x(c) === "hover" && h();
    }), I = jr(k, () => {
      x(c) === "hover" && d();
    }), P = () => {
      var M, U;
      (U = (M = s.value) == null ? void 0 : M.updatePopper) == null || U.call(M), b == null || b();
    }, D = () => {
      p == null || p();
    }, z = () => {
      v(), J = cb(F(() => {
        var M;
        return (M = s.value) == null ? void 0 : M.popperContentRef;
      }), () => {
        if (x(a))
          return;
        x(c) !== "hover" && d();
      });
    }, G = () => {
      n.virtualTriggering || d();
    };
    let J;
    return ke(() => x(u), (M) => {
      M || J == null || J();
    }, {
      flush: "post"
    }), ke(() => n.content, () => {
      var M, U;
      (U = (M = s.value) == null ? void 0 : M.updatePopper) == null || U.call(M);
    }), e({
      contentRef: s
    }), (M, U) => (V(), Ce(mv, {
      disabled: !M.teleported,
      to: x(_)
    }, [
      ve(gr, {
        name: x(f),
        onAfterLeave: T,
        onBeforeEnter: P,
        onAfterEnter: z,
        onBeforeLeave: D
      }, {
        default: de(() => [
          x(g) ? $t((V(), Ce(x(BN), qn({
            key: 0,
            id: x(l),
            ref_key: "contentRef",
            ref: s
          }, M.$attrs, {
            "aria-label": M.ariaLabel,
            "aria-hidden": x(C),
            "boundaries-padding": M.boundariesPadding,
            "fallback-placements": M.fallbackPlacements,
            "gpu-acceleration": M.gpuAcceleration,
            offset: M.offset,
            placement: M.placement,
            "popper-options": M.popperOptions,
            strategy: M.strategy,
            effect: M.effect,
            enterable: M.enterable,
            pure: M.pure,
            "popper-class": M.popperClass,
            "popper-style": [M.popperStyle, x(E)],
            "reference-el": M.referenceEl,
            "trigger-target-el": M.triggerTargetEl,
            visible: x(w),
            "z-index": M.zIndex,
            onMouseenter: x(N),
            onMouseleave: x(I),
            onBlur: G,
            onClose: x(d)
          }), {
            default: de(() => [
              o.value ? ye("v-if", !0) : De(M.$slots, "default", { key: 0 })
            ]),
            _: 3
          }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
            [Yn, x(w)]
          ]) : ye("v-if", !0)
        ]),
        _: 3
      }, 8, ["name"])
    ], 8, ["disabled", "to"]));
  }
});
var XN = /* @__PURE__ */ qe(YN, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/content.vue"]]);
const ZN = ["innerHTML"], QN = { key: 1 }, JN = be({
  name: "ElTooltip"
}), eA = /* @__PURE__ */ be({
  ...JN,
  props: UN,
  emits: VN,
  setup(t, { expose: e, emit: n }) {
    const r = t;
    mO();
    const i = Jo(), s = K(), o = K(), a = () => {
      var f;
      const m = x(s);
      m && ((f = m.popperInstanceRef) == null || f.update());
    }, l = K(!1), u = K(), { show: c, hide: d, hasUpdateHandler: h } = jN({
      indicator: l,
      toggleReason: u
    }), { onOpen: v, onClose: y } = Pm({
      showAfter: Tn(r, "showAfter"),
      hideAfter: Tn(r, "hideAfter"),
      autoClose: Tn(r, "autoClose"),
      open: c,
      close: d
    }), b = F(() => Zr(r.visible) && !h.value);
    Gt(Gd, {
      controlled: b,
      id: i,
      open: Yy(l),
      trigger: Tn(r, "trigger"),
      onOpen: (f) => {
        v(f);
      },
      onClose: (f) => {
        y(f);
      },
      onToggle: (f) => {
        x(l) ? y(f) : v(f);
      },
      onShow: () => {
        n("show", u.value);
      },
      onHide: () => {
        n("hide", u.value);
      },
      onBeforeShow: () => {
        n("before-show", u.value);
      },
      onBeforeHide: () => {
        n("before-hide", u.value);
      },
      updatePopper: a
    }), ke(() => r.disabled, (f) => {
      f && l.value && (l.value = !1);
    });
    const p = (f) => {
      var m, g;
      const w = (g = (m = o.value) == null ? void 0 : m.contentRef) == null ? void 0 : g.popperContentRef, _ = (f == null ? void 0 : f.relatedTarget) || document.activeElement;
      return w && w.contains(_);
    };
    return Xy(() => l.value && d()), e({
      popperRef: s,
      contentRef: o,
      isFocusInsideContent: p,
      updatePopper: a,
      onOpen: v,
      onClose: y,
      hide: d
    }), (f, m) => (V(), Ce(x(MN), {
      ref_key: "popperRef",
      ref: s,
      role: f.role
    }, {
      default: de(() => [
        ve(qN, {
          disabled: f.disabled,
          trigger: f.trigger,
          "trigger-keys": f.triggerKeys,
          "virtual-ref": f.virtualRef,
          "virtual-triggering": f.virtualTriggering
        }, {
          default: de(() => [
            f.$slots.default ? De(f.$slots, "default", { key: 0 }) : ye("v-if", !0)
          ]),
          _: 3
        }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
        ve(XN, {
          ref_key: "contentRef",
          ref: o,
          "aria-label": f.ariaLabel,
          "boundaries-padding": f.boundariesPadding,
          content: f.content,
          disabled: f.disabled,
          effect: f.effect,
          enterable: f.enterable,
          "fallback-placements": f.fallbackPlacements,
          "hide-after": f.hideAfter,
          "gpu-acceleration": f.gpuAcceleration,
          offset: f.offset,
          persistent: f.persistent,
          "popper-class": f.popperClass,
          "popper-style": f.popperStyle,
          placement: f.placement,
          "popper-options": f.popperOptions,
          pure: f.pure,
          "raw-content": f.rawContent,
          "reference-el": f.referenceEl,
          "trigger-target-el": f.triggerTargetEl,
          "show-after": f.showAfter,
          strategy: f.strategy,
          teleported: f.teleported,
          transition: f.transition,
          "virtual-triggering": f.virtualTriggering,
          "z-index": f.zIndex,
          "append-to": f.appendTo
        }, {
          default: de(() => [
            De(f.$slots, "content", {}, () => [
              f.rawContent ? (V(), se("span", {
                key: 0,
                innerHTML: f.content
              }, null, 8, ZN)) : (V(), se("span", QN, st(f.content), 1))
            ]),
            f.showArrow ? (V(), Ce(x(oN), {
              key: 0,
              "arrow-offset": f.arrowOffset
            }, null, 8, ["arrow-offset"])) : ye("v-if", !0)
          ]),
          _: 3
        }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
      ]),
      _: 3
    }, 8, ["role"]));
  }
});
var tA = /* @__PURE__ */ qe(eA, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/tooltip.vue"]]);
const Zl = nn(tA), Gm = Symbol("buttonGroupContextKey"), nA = (t, e) => {
  vm({
    from: "type.text",
    replacement: "link",
    version: "3.0.0",
    scope: "props",
    ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
  }, F(() => t.type === "text"));
  const n = tt(Gm, void 0), r = Ud("button"), { form: i } = oi(), s = Lr(F(() => n == null ? void 0 : n.size)), o = Pr(), a = K(), l = Ho(), u = F(() => t.type || (n == null ? void 0 : n.type) || ""), c = F(() => {
    var y, b, p;
    return (p = (b = t.autoInsertSpace) != null ? b : (y = r.value) == null ? void 0 : y.autoInsertSpace) != null ? p : !1;
  }), d = F(() => t.tag === "button" ? {
    ariaDisabled: o.value || t.loading,
    disabled: o.value || t.loading,
    autofocus: t.autofocus,
    type: t.nativeType
  } : {}), h = F(() => {
    var y;
    const b = (y = l.default) == null ? void 0 : y.call(l);
    if (c.value && (b == null ? void 0 : b.length) === 1) {
      const p = b[0];
      if ((p == null ? void 0 : p.type) === pv) {
        const f = p.children;
        return /^\p{Unified_Ideograph}{2}$/u.test(f.trim());
      }
    }
    return !1;
  });
  return {
    _disabled: o,
    _size: s,
    _type: u,
    _ref: a,
    _props: d,
    shouldAddSpace: h,
    handleClick: (y) => {
      t.nativeType === "reset" && (i == null || i.resetFields()), e("click", y);
    }
  };
}, rA = [
  "default",
  "primary",
  "success",
  "warning",
  "info",
  "danger",
  "text",
  ""
], iA = ["button", "submit", "reset"], ac = ut({
  size: Rr,
  disabled: Boolean,
  type: {
    type: String,
    values: rA,
    default: ""
  },
  icon: {
    type: bi
  },
  nativeType: {
    type: String,
    values: iA,
    default: "button"
  },
  loading: Boolean,
  loadingIcon: {
    type: bi,
    default: () => Hl
  },
  plain: Boolean,
  text: Boolean,
  link: Boolean,
  bg: Boolean,
  autofocus: Boolean,
  round: Boolean,
  circle: Boolean,
  color: String,
  dark: Boolean,
  autoInsertSpace: {
    type: Boolean,
    default: void 0
  },
  tag: {
    type: Pe([String, Object]),
    default: "button"
  }
}), sA = {
  click: (t) => t instanceof MouseEvent
};
function _n(t, e) {
  oA(t) && (t = "100%");
  var n = aA(t);
  return t = e === 360 ? t : Math.min(e, Math.max(0, parseFloat(t))), n && (t = parseInt(String(t * e), 10) / 100), Math.abs(t - e) < 1e-6 ? 1 : (e === 360 ? t = (t < 0 ? t % e + e : t % e) / parseFloat(String(e)) : t = t % e / parseFloat(String(e)), t);
}
function ba(t) {
  return Math.min(1, Math.max(0, t));
}
function oA(t) {
  return typeof t == "string" && t.indexOf(".") !== -1 && parseFloat(t) === 1;
}
function aA(t) {
  return typeof t == "string" && t.indexOf("%") !== -1;
}
function Ym(t) {
  return t = parseFloat(t), (isNaN(t) || t < 0 || t > 1) && (t = 1), t;
}
function wa(t) {
  return t <= 1 ? "".concat(Number(t) * 100, "%") : t;
}
function Ai(t) {
  return t.length === 1 ? "0" + t : String(t);
}
function lA(t, e, n) {
  return {
    r: _n(t, 255) * 255,
    g: _n(e, 255) * 255,
    b: _n(n, 255) * 255
  };
}
function qh(t, e, n) {
  t = _n(t, 255), e = _n(e, 255), n = _n(n, 255);
  var r = Math.max(t, e, n), i = Math.min(t, e, n), s = 0, o = 0, a = (r + i) / 2;
  if (r === i)
    o = 0, s = 0;
  else {
    var l = r - i;
    switch (o = a > 0.5 ? l / (2 - r - i) : l / (r + i), r) {
      case t:
        s = (e - n) / l + (e < n ? 6 : 0);
        break;
      case e:
        s = (n - t) / l + 2;
        break;
      case n:
        s = (t - e) / l + 4;
        break;
    }
    s /= 6;
  }
  return { h: s, s: o, l: a };
}
function Eu(t, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * (6 * n) : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t;
}
function uA(t, e, n) {
  var r, i, s;
  if (t = _n(t, 360), e = _n(e, 100), n = _n(n, 100), e === 0)
    i = n, s = n, r = n;
  else {
    var o = n < 0.5 ? n * (1 + e) : n + e - n * e, a = 2 * n - o;
    r = Eu(a, o, t + 1 / 3), i = Eu(a, o, t), s = Eu(a, o, t - 1 / 3);
  }
  return { r: r * 255, g: i * 255, b: s * 255 };
}
function Gh(t, e, n) {
  t = _n(t, 255), e = _n(e, 255), n = _n(n, 255);
  var r = Math.max(t, e, n), i = Math.min(t, e, n), s = 0, o = r, a = r - i, l = r === 0 ? 0 : a / r;
  if (r === i)
    s = 0;
  else {
    switch (r) {
      case t:
        s = (e - n) / a + (e < n ? 6 : 0);
        break;
      case e:
        s = (n - t) / a + 2;
        break;
      case n:
        s = (t - e) / a + 4;
        break;
    }
    s /= 6;
  }
  return { h: s, s: l, v: o };
}
function cA(t, e, n) {
  t = _n(t, 360) * 6, e = _n(e, 100), n = _n(n, 100);
  var r = Math.floor(t), i = t - r, s = n * (1 - e), o = n * (1 - i * e), a = n * (1 - (1 - i) * e), l = r % 6, u = [n, o, s, s, a, n][l], c = [a, n, n, o, s, s][l], d = [s, s, a, n, n, o][l];
  return { r: u * 255, g: c * 255, b: d * 255 };
}
function Yh(t, e, n, r) {
  var i = [
    Ai(Math.round(t).toString(16)),
    Ai(Math.round(e).toString(16)),
    Ai(Math.round(n).toString(16))
  ];
  return r && i[0].startsWith(i[0].charAt(1)) && i[1].startsWith(i[1].charAt(1)) && i[2].startsWith(i[2].charAt(1)) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("");
}
function dA(t, e, n, r, i) {
  var s = [
    Ai(Math.round(t).toString(16)),
    Ai(Math.round(e).toString(16)),
    Ai(Math.round(n).toString(16)),
    Ai(fA(r))
  ];
  return i && s[0].startsWith(s[0].charAt(1)) && s[1].startsWith(s[1].charAt(1)) && s[2].startsWith(s[2].charAt(1)) && s[3].startsWith(s[3].charAt(1)) ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0) + s[3].charAt(0) : s.join("");
}
function fA(t) {
  return Math.round(parseFloat(t) * 255).toString(16);
}
function Xh(t) {
  return Wn(t) / 255;
}
function Wn(t) {
  return parseInt(t, 16);
}
function hA(t) {
  return {
    r: t >> 16,
    g: (t & 65280) >> 8,
    b: t & 255
  };
}
var lc = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function pA(t) {
  var e = { r: 0, g: 0, b: 0 }, n = 1, r = null, i = null, s = null, o = !1, a = !1;
  return typeof t == "string" && (t = gA(t)), typeof t == "object" && (Mr(t.r) && Mr(t.g) && Mr(t.b) ? (e = lA(t.r, t.g, t.b), o = !0, a = String(t.r).substr(-1) === "%" ? "prgb" : "rgb") : Mr(t.h) && Mr(t.s) && Mr(t.v) ? (r = wa(t.s), i = wa(t.v), e = cA(t.h, r, i), o = !0, a = "hsv") : Mr(t.h) && Mr(t.s) && Mr(t.l) && (r = wa(t.s), s = wa(t.l), e = uA(t.h, r, s), o = !0, a = "hsl"), Object.prototype.hasOwnProperty.call(t, "a") && (n = t.a)), n = Ym(n), {
    ok: o,
    format: t.format || a,
    r: Math.min(255, Math.max(e.r, 0)),
    g: Math.min(255, Math.max(e.g, 0)),
    b: Math.min(255, Math.max(e.b, 0)),
    a: n
  };
}
var vA = "[-\\+]?\\d+%?", mA = "[-\\+]?\\d*\\.\\d+%?", vi = "(?:".concat(mA, ")|(?:").concat(vA, ")"), Su = "[\\s|\\(]+(".concat(vi, ")[,|\\s]+(").concat(vi, ")[,|\\s]+(").concat(vi, ")\\s*\\)?"), xu = "[\\s|\\(]+(".concat(vi, ")[,|\\s]+(").concat(vi, ")[,|\\s]+(").concat(vi, ")[,|\\s]+(").concat(vi, ")\\s*\\)?"), cr = {
  CSS_UNIT: new RegExp(vi),
  rgb: new RegExp("rgb" + Su),
  rgba: new RegExp("rgba" + xu),
  hsl: new RegExp("hsl" + Su),
  hsla: new RegExp("hsla" + xu),
  hsv: new RegExp("hsv" + Su),
  hsva: new RegExp("hsva" + xu),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function gA(t) {
  if (t = t.trim().toLowerCase(), t.length === 0)
    return !1;
  var e = !1;
  if (lc[t])
    t = lc[t], e = !0;
  else if (t === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  var n = cr.rgb.exec(t);
  return n ? { r: n[1], g: n[2], b: n[3] } : (n = cr.rgba.exec(t), n ? { r: n[1], g: n[2], b: n[3], a: n[4] } : (n = cr.hsl.exec(t), n ? { h: n[1], s: n[2], l: n[3] } : (n = cr.hsla.exec(t), n ? { h: n[1], s: n[2], l: n[3], a: n[4] } : (n = cr.hsv.exec(t), n ? { h: n[1], s: n[2], v: n[3] } : (n = cr.hsva.exec(t), n ? { h: n[1], s: n[2], v: n[3], a: n[4] } : (n = cr.hex8.exec(t), n ? {
    r: Wn(n[1]),
    g: Wn(n[2]),
    b: Wn(n[3]),
    a: Xh(n[4]),
    format: e ? "name" : "hex8"
  } : (n = cr.hex6.exec(t), n ? {
    r: Wn(n[1]),
    g: Wn(n[2]),
    b: Wn(n[3]),
    format: e ? "name" : "hex"
  } : (n = cr.hex4.exec(t), n ? {
    r: Wn(n[1] + n[1]),
    g: Wn(n[2] + n[2]),
    b: Wn(n[3] + n[3]),
    a: Xh(n[4] + n[4]),
    format: e ? "name" : "hex8"
  } : (n = cr.hex3.exec(t), n ? {
    r: Wn(n[1] + n[1]),
    g: Wn(n[2] + n[2]),
    b: Wn(n[3] + n[3]),
    format: e ? "name" : "hex"
  } : !1)))))))));
}
function Mr(t) {
  return !!cr.CSS_UNIT.exec(String(t));
}
var yA = (
  /** @class */
  function() {
    function t(e, n) {
      e === void 0 && (e = ""), n === void 0 && (n = {});
      var r;
      if (e instanceof t)
        return e;
      typeof e == "number" && (e = hA(e)), this.originalInput = e;
      var i = pA(e);
      this.originalInput = e, this.r = i.r, this.g = i.g, this.b = i.b, this.a = i.a, this.roundA = Math.round(100 * this.a) / 100, this.format = (r = n.format) !== null && r !== void 0 ? r : i.format, this.gradientType = n.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = i.ok;
    }
    return t.prototype.isDark = function() {
      return this.getBrightness() < 128;
    }, t.prototype.isLight = function() {
      return !this.isDark();
    }, t.prototype.getBrightness = function() {
      var e = this.toRgb();
      return (e.r * 299 + e.g * 587 + e.b * 114) / 1e3;
    }, t.prototype.getLuminance = function() {
      var e = this.toRgb(), n, r, i, s = e.r / 255, o = e.g / 255, a = e.b / 255;
      return s <= 0.03928 ? n = s / 12.92 : n = Math.pow((s + 0.055) / 1.055, 2.4), o <= 0.03928 ? r = o / 12.92 : r = Math.pow((o + 0.055) / 1.055, 2.4), a <= 0.03928 ? i = a / 12.92 : i = Math.pow((a + 0.055) / 1.055, 2.4), 0.2126 * n + 0.7152 * r + 0.0722 * i;
    }, t.prototype.getAlpha = function() {
      return this.a;
    }, t.prototype.setAlpha = function(e) {
      return this.a = Ym(e), this.roundA = Math.round(100 * this.a) / 100, this;
    }, t.prototype.isMonochrome = function() {
      var e = this.toHsl().s;
      return e === 0;
    }, t.prototype.toHsv = function() {
      var e = Gh(this.r, this.g, this.b);
      return { h: e.h * 360, s: e.s, v: e.v, a: this.a };
    }, t.prototype.toHsvString = function() {
      var e = Gh(this.r, this.g, this.b), n = Math.round(e.h * 360), r = Math.round(e.s * 100), i = Math.round(e.v * 100);
      return this.a === 1 ? "hsv(".concat(n, ", ").concat(r, "%, ").concat(i, "%)") : "hsva(".concat(n, ", ").concat(r, "%, ").concat(i, "%, ").concat(this.roundA, ")");
    }, t.prototype.toHsl = function() {
      var e = qh(this.r, this.g, this.b);
      return { h: e.h * 360, s: e.s, l: e.l, a: this.a };
    }, t.prototype.toHslString = function() {
      var e = qh(this.r, this.g, this.b), n = Math.round(e.h * 360), r = Math.round(e.s * 100), i = Math.round(e.l * 100);
      return this.a === 1 ? "hsl(".concat(n, ", ").concat(r, "%, ").concat(i, "%)") : "hsla(".concat(n, ", ").concat(r, "%, ").concat(i, "%, ").concat(this.roundA, ")");
    }, t.prototype.toHex = function(e) {
      return e === void 0 && (e = !1), Yh(this.r, this.g, this.b, e);
    }, t.prototype.toHexString = function(e) {
      return e === void 0 && (e = !1), "#" + this.toHex(e);
    }, t.prototype.toHex8 = function(e) {
      return e === void 0 && (e = !1), dA(this.r, this.g, this.b, this.a, e);
    }, t.prototype.toHex8String = function(e) {
      return e === void 0 && (e = !1), "#" + this.toHex8(e);
    }, t.prototype.toHexShortString = function(e) {
      return e === void 0 && (e = !1), this.a === 1 ? this.toHexString(e) : this.toHex8String(e);
    }, t.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    }, t.prototype.toRgbString = function() {
      var e = Math.round(this.r), n = Math.round(this.g), r = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(e, ", ").concat(n, ", ").concat(r, ")") : "rgba(".concat(e, ", ").concat(n, ", ").concat(r, ", ").concat(this.roundA, ")");
    }, t.prototype.toPercentageRgb = function() {
      var e = function(n) {
        return "".concat(Math.round(_n(n, 255) * 100), "%");
      };
      return {
        r: e(this.r),
        g: e(this.g),
        b: e(this.b),
        a: this.a
      };
    }, t.prototype.toPercentageRgbString = function() {
      var e = function(n) {
        return Math.round(_n(n, 255) * 100);
      };
      return this.a === 1 ? "rgb(".concat(e(this.r), "%, ").concat(e(this.g), "%, ").concat(e(this.b), "%)") : "rgba(".concat(e(this.r), "%, ").concat(e(this.g), "%, ").concat(e(this.b), "%, ").concat(this.roundA, ")");
    }, t.prototype.toName = function() {
      if (this.a === 0)
        return "transparent";
      if (this.a < 1)
        return !1;
      for (var e = "#" + Yh(this.r, this.g, this.b, !1), n = 0, r = Object.entries(lc); n < r.length; n++) {
        var i = r[n], s = i[0], o = i[1];
        if (e === o)
          return s;
      }
      return !1;
    }, t.prototype.toString = function(e) {
      var n = !!e;
      e = e ?? this.format;
      var r = !1, i = this.a < 1 && this.a >= 0, s = !n && i && (e.startsWith("hex") || e === "name");
      return s ? e === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (e === "rgb" && (r = this.toRgbString()), e === "prgb" && (r = this.toPercentageRgbString()), (e === "hex" || e === "hex6") && (r = this.toHexString()), e === "hex3" && (r = this.toHexString(!0)), e === "hex4" && (r = this.toHex8String(!0)), e === "hex8" && (r = this.toHex8String()), e === "name" && (r = this.toName()), e === "hsl" && (r = this.toHslString()), e === "hsv" && (r = this.toHsvString()), r || this.toHexString());
    }, t.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    }, t.prototype.clone = function() {
      return new t(this.toString());
    }, t.prototype.lighten = function(e) {
      e === void 0 && (e = 10);
      var n = this.toHsl();
      return n.l += e / 100, n.l = ba(n.l), new t(n);
    }, t.prototype.brighten = function(e) {
      e === void 0 && (e = 10);
      var n = this.toRgb();
      return n.r = Math.max(0, Math.min(255, n.r - Math.round(255 * -(e / 100)))), n.g = Math.max(0, Math.min(255, n.g - Math.round(255 * -(e / 100)))), n.b = Math.max(0, Math.min(255, n.b - Math.round(255 * -(e / 100)))), new t(n);
    }, t.prototype.darken = function(e) {
      e === void 0 && (e = 10);
      var n = this.toHsl();
      return n.l -= e / 100, n.l = ba(n.l), new t(n);
    }, t.prototype.tint = function(e) {
      return e === void 0 && (e = 10), this.mix("white", e);
    }, t.prototype.shade = function(e) {
      return e === void 0 && (e = 10), this.mix("black", e);
    }, t.prototype.desaturate = function(e) {
      e === void 0 && (e = 10);
      var n = this.toHsl();
      return n.s -= e / 100, n.s = ba(n.s), new t(n);
    }, t.prototype.saturate = function(e) {
      e === void 0 && (e = 10);
      var n = this.toHsl();
      return n.s += e / 100, n.s = ba(n.s), new t(n);
    }, t.prototype.greyscale = function() {
      return this.desaturate(100);
    }, t.prototype.spin = function(e) {
      var n = this.toHsl(), r = (n.h + e) % 360;
      return n.h = r < 0 ? 360 + r : r, new t(n);
    }, t.prototype.mix = function(e, n) {
      n === void 0 && (n = 50);
      var r = this.toRgb(), i = new t(e).toRgb(), s = n / 100, o = {
        r: (i.r - r.r) * s + r.r,
        g: (i.g - r.g) * s + r.g,
        b: (i.b - r.b) * s + r.b,
        a: (i.a - r.a) * s + r.a
      };
      return new t(o);
    }, t.prototype.analogous = function(e, n) {
      e === void 0 && (e = 6), n === void 0 && (n = 30);
      var r = this.toHsl(), i = 360 / n, s = [this];
      for (r.h = (r.h - (i * e >> 1) + 720) % 360; --e; )
        r.h = (r.h + i) % 360, s.push(new t(r));
      return s;
    }, t.prototype.complement = function() {
      var e = this.toHsl();
      return e.h = (e.h + 180) % 360, new t(e);
    }, t.prototype.monochromatic = function(e) {
      e === void 0 && (e = 6);
      for (var n = this.toHsv(), r = n.h, i = n.s, s = n.v, o = [], a = 1 / e; e--; )
        o.push(new t({ h: r, s: i, v: s })), s = (s + a) % 1;
      return o;
    }, t.prototype.splitcomplement = function() {
      var e = this.toHsl(), n = e.h;
      return [
        this,
        new t({ h: (n + 72) % 360, s: e.s, l: e.l }),
        new t({ h: (n + 216) % 360, s: e.s, l: e.l })
      ];
    }, t.prototype.onBackground = function(e) {
      var n = this.toRgb(), r = new t(e).toRgb(), i = n.a + r.a * (1 - n.a);
      return new t({
        r: (n.r * n.a + r.r * r.a * (1 - n.a)) / i,
        g: (n.g * n.a + r.g * r.a * (1 - n.a)) / i,
        b: (n.b * n.a + r.b * r.a * (1 - n.a)) / i,
        a: i
      });
    }, t.prototype.triad = function() {
      return this.polyad(3);
    }, t.prototype.tetrad = function() {
      return this.polyad(4);
    }, t.prototype.polyad = function(e) {
      for (var n = this.toHsl(), r = n.h, i = [this], s = 360 / e, o = 1; o < e; o++)
        i.push(new t({ h: (r + o * s) % 360, s: n.s, l: n.l }));
      return i;
    }, t.prototype.equals = function(e) {
      return this.toRgbString() === new t(e).toRgbString();
    }, t;
  }()
);
function ai(t, e = 20) {
  return t.mix("#141414", e).toString();
}
function bA(t) {
  const e = Pr(), n = Fe("button");
  return F(() => {
    let r = {};
    const i = t.color;
    if (i) {
      const s = new yA(i), o = t.dark ? s.tint(20).toString() : ai(s, 20);
      if (t.plain)
        r = n.cssVarBlock({
          "bg-color": t.dark ? ai(s, 90) : s.tint(90).toString(),
          "text-color": i,
          "border-color": t.dark ? ai(s, 50) : s.tint(50).toString(),
          "hover-text-color": `var(${n.cssVarName("color-white")})`,
          "hover-bg-color": i,
          "hover-border-color": i,
          "active-bg-color": o,
          "active-text-color": `var(${n.cssVarName("color-white")})`,
          "active-border-color": o
        }), e.value && (r[n.cssVarBlockName("disabled-bg-color")] = t.dark ? ai(s, 90) : s.tint(90).toString(), r[n.cssVarBlockName("disabled-text-color")] = t.dark ? ai(s, 50) : s.tint(50).toString(), r[n.cssVarBlockName("disabled-border-color")] = t.dark ? ai(s, 80) : s.tint(80).toString());
      else {
        const a = t.dark ? ai(s, 30) : s.tint(30).toString(), l = s.isDark() ? `var(${n.cssVarName("color-white")})` : `var(${n.cssVarName("color-black")})`;
        if (r = n.cssVarBlock({
          "bg-color": i,
          "text-color": l,
          "border-color": i,
          "hover-bg-color": a,
          "hover-text-color": l,
          "hover-border-color": a,
          "active-bg-color": o,
          "active-border-color": o
        }), e.value) {
          const u = t.dark ? ai(s, 50) : s.tint(50).toString();
          r[n.cssVarBlockName("disabled-bg-color")] = u, r[n.cssVarBlockName("disabled-text-color")] = t.dark ? "rgba(255, 255, 255, 0.5)" : `var(${n.cssVarName("color-white")})`, r[n.cssVarBlockName("disabled-border-color")] = u;
        }
      }
    }
    return r;
  });
}
const wA = be({
  name: "ElButton"
}), _A = /* @__PURE__ */ be({
  ...wA,
  props: ac,
  emits: sA,
  setup(t, { expose: e, emit: n }) {
    const r = t, i = bA(r), s = Fe("button"), { _ref: o, _size: a, _type: l, _disabled: u, _props: c, shouldAddSpace: d, handleClick: h } = nA(r, n);
    return e({
      ref: o,
      size: a,
      type: l,
      disabled: u,
      shouldAddSpace: d
    }), (v, y) => (V(), Ce(In(v.tag), qn({
      ref_key: "_ref",
      ref: o
    }, x(c), {
      class: [
        x(s).b(),
        x(s).m(x(l)),
        x(s).m(x(a)),
        x(s).is("disabled", x(u)),
        x(s).is("loading", v.loading),
        x(s).is("plain", v.plain),
        x(s).is("round", v.round),
        x(s).is("circle", v.circle),
        x(s).is("text", v.text),
        x(s).is("link", v.link),
        x(s).is("has-bg", v.bg)
      ],
      style: x(i),
      onClick: x(h)
    }), {
      default: de(() => [
        v.loading ? (V(), se(Ft, { key: 0 }, [
          v.$slots.loading ? De(v.$slots, "loading", { key: 0 }) : (V(), Ce(x(_t), {
            key: 1,
            class: ee(x(s).is("loading"))
          }, {
            default: de(() => [
              (V(), Ce(In(v.loadingIcon)))
            ]),
            _: 1
          }, 8, ["class"]))
        ], 64)) : v.icon || v.$slots.icon ? (V(), Ce(x(_t), { key: 1 }, {
          default: de(() => [
            v.icon ? (V(), Ce(In(v.icon), { key: 0 })) : De(v.$slots, "icon", { key: 1 })
          ]),
          _: 3
        })) : ye("v-if", !0),
        v.$slots.default ? (V(), se("span", {
          key: 2,
          class: ee({ [x(s).em("text", "expand")]: x(d) })
        }, [
          De(v.$slots, "default")
        ], 2)) : ye("v-if", !0)
      ]),
      _: 3
    }, 16, ["class", "style", "onClick"]));
  }
});
var EA = /* @__PURE__ */ qe(_A, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button.vue"]]);
const SA = {
  size: ac.size,
  type: ac.type
}, xA = be({
  name: "ElButtonGroup"
}), CA = /* @__PURE__ */ be({
  ...xA,
  props: SA,
  setup(t) {
    const e = t;
    Gt(Gm, Pn({
      size: Tn(e, "size"),
      type: Tn(e, "type")
    }));
    const n = Fe("button");
    return (r, i) => (V(), se("div", {
      class: ee(`${x(n).b("group")}`)
    }, [
      De(r.$slots, "default")
    ], 2));
  }
});
var Xm = /* @__PURE__ */ qe(CA, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button-group.vue"]]);
const Xi = nn(EA, {
  ButtonGroup: Xm
}), Zm = sr(Xm);
var gn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
const ci = /* @__PURE__ */ new Map();
let Zh;
Et && (document.addEventListener("mousedown", (t) => Zh = t), document.addEventListener("mouseup", (t) => {
  for (const e of ci.values())
    for (const { documentHandler: n } of e)
      n(t, Zh);
}));
function Qh(t, e) {
  let n = [];
  return Array.isArray(e.arg) ? n = e.arg : zi(e.arg) && n.push(e.arg), function(r, i) {
    const s = e.instance.popperRef, o = r.target, a = i == null ? void 0 : i.target, l = !e || !e.instance, u = !o || !a, c = t.contains(o) || t.contains(a), d = t === o, h = n.length && n.some((y) => y == null ? void 0 : y.contains(o)) || n.length && n.includes(a), v = s && (s.contains(o) || s.contains(a));
    l || u || c || d || h || v || e.value(r, i);
  };
}
const Qm = {
  beforeMount(t, e) {
    ci.has(t) || ci.set(t, []), ci.get(t).push({
      documentHandler: Qh(t, e),
      bindingFn: e.value
    });
  },
  updated(t, e) {
    ci.has(t) || ci.set(t, []);
    const n = ci.get(t), r = n.findIndex((s) => s.bindingFn === e.oldValue), i = {
      documentHandler: Qh(t, e),
      bindingFn: e.value
    };
    r >= 0 ? n.splice(r, 1, i) : n.push(i);
  },
  unmounted(t) {
    ci.delete(t);
  }
}, kA = 100, TA = 600, Jh = {
  beforeMount(t, e) {
    const n = e.value, { interval: r = kA, delay: i = TA } = mn(n) ? {} : n;
    let s, o;
    const a = () => mn(n) ? n() : n.handler(), l = () => {
      o && (clearTimeout(o), o = void 0), s && (clearInterval(s), s = void 0);
    };
    t.addEventListener("mousedown", (u) => {
      u.button === 0 && (l(), a(), document.addEventListener("mouseup", () => l(), {
        once: !0
      }), o = setTimeout(() => {
        s = setInterval(() => {
          a();
        }, r);
      }, i));
    });
  }
};
var ep = !1, Ni, uc, cc, Ba, Ma, Jm, za, dc, fc, hc, eg, pc, vc, tg, ng;
function Dn() {
  if (!ep) {
    ep = !0;
    var t = navigator.userAgent, e = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(t), n = /(Mac OS X)|(Windows)|(Linux)/.exec(t);
    if (pc = /\b(iPhone|iP[ao]d)/.exec(t), vc = /\b(iP[ao]d)/.exec(t), hc = /Android/i.exec(t), tg = /FBAN\/\w+;/i.exec(t), ng = /Mobile/i.exec(t), eg = !!/Win64/.exec(t), e) {
      Ni = e[1] ? parseFloat(e[1]) : e[5] ? parseFloat(e[5]) : NaN, Ni && document && document.documentMode && (Ni = document.documentMode);
      var r = /(?:Trident\/(\d+.\d+))/.exec(t);
      Jm = r ? parseFloat(r[1]) + 4 : Ni, uc = e[2] ? parseFloat(e[2]) : NaN, cc = e[3] ? parseFloat(e[3]) : NaN, Ba = e[4] ? parseFloat(e[4]) : NaN, Ba ? (e = /(?:Chrome\/(\d+\.\d+))/.exec(t), Ma = e && e[1] ? parseFloat(e[1]) : NaN) : Ma = NaN;
    } else
      Ni = uc = cc = Ma = Ba = NaN;
    if (n) {
      if (n[1]) {
        var i = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(t);
        za = i ? parseFloat(i[1].replace("_", ".")) : !0;
      } else
        za = !1;
      dc = !!n[2], fc = !!n[3];
    } else
      za = dc = fc = !1;
  }
}
var mc = { ie: function() {
  return Dn() || Ni;
}, ieCompatibilityMode: function() {
  return Dn() || Jm > Ni;
}, ie64: function() {
  return mc.ie() && eg;
}, firefox: function() {
  return Dn() || uc;
}, opera: function() {
  return Dn() || cc;
}, webkit: function() {
  return Dn() || Ba;
}, safari: function() {
  return mc.webkit();
}, chrome: function() {
  return Dn() || Ma;
}, windows: function() {
  return Dn() || dc;
}, osx: function() {
  return Dn() || za;
}, linux: function() {
  return Dn() || fc;
}, iphone: function() {
  return Dn() || pc;
}, mobile: function() {
  return Dn() || pc || vc || hc || ng;
}, nativeApp: function() {
  return Dn() || tg;
}, android: function() {
  return Dn() || hc;
}, ipad: function() {
  return Dn() || vc;
} }, OA = mc, _a = !!(typeof window < "u" && window.document && window.document.createElement), NA = { canUseDOM: _a, canUseWorkers: typeof Worker < "u", canUseEventListeners: _a && !!(window.addEventListener || window.attachEvent), canUseViewport: _a && !!window.screen, isInWorker: !_a }, rg = NA, ig;
rg.canUseDOM && (ig = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== !0);
function AA(t, e) {
  if (!rg.canUseDOM || e && !("addEventListener" in document))
    return !1;
  var n = "on" + t, r = n in document;
  if (!r) {
    var i = document.createElement("div");
    i.setAttribute(n, "return;"), r = typeof i[n] == "function";
  }
  return !r && ig && t === "wheel" && (r = document.implementation.hasFeature("Events.wheel", "3.0")), r;
}
var IA = AA, tp = 10, np = 40, rp = 800;
function sg(t) {
  var e = 0, n = 0, r = 0, i = 0;
  return "detail" in t && (n = t.detail), "wheelDelta" in t && (n = -t.wheelDelta / 120), "wheelDeltaY" in t && (n = -t.wheelDeltaY / 120), "wheelDeltaX" in t && (e = -t.wheelDeltaX / 120), "axis" in t && t.axis === t.HORIZONTAL_AXIS && (e = n, n = 0), r = e * tp, i = n * tp, "deltaY" in t && (i = t.deltaY), "deltaX" in t && (r = t.deltaX), (r || i) && t.deltaMode && (t.deltaMode == 1 ? (r *= np, i *= np) : (r *= rp, i *= rp)), r && !e && (e = r < 1 ? -1 : 1), i && !n && (n = i < 1 ? -1 : 1), { spinX: e, spinY: n, pixelX: r, pixelY: i };
}
sg.getEventType = function() {
  return OA.firefox() ? "DOMMouseScroll" : IA("wheel") ? "wheel" : "mousewheel";
};
var RA = sg;
/**
* Checks if an event is supported in the current execution environment.
*
* NOTE: This will not work correctly for non-generic events such as `change`,
* `reset`, `load`, `error`, and `select`.
*
* Borrows from Modernizr.
*
* @param {string} eventNameSuffix Event name, e.g. "click".
* @param {?boolean} capture Check if the capture phase is supported.
* @return {boolean} True if the event is supported.
* @internal
* @license Modernizr 3.0.0pre (Custom Build) | MIT
*/
const LA = function(t, e) {
  if (t && t.addEventListener) {
    const n = function(r) {
      const i = RA(r);
      e && Reflect.apply(e, this, [r, i]);
    };
    t.addEventListener("wheel", n, { passive: !0 });
  }
}, PA = {
  beforeMount(t, e) {
    LA(t, e.value);
  }
}, $A = ut({
  header: {
    type: String,
    default: ""
  },
  bodyStyle: {
    type: Pe([String, Object, Array]),
    default: ""
  },
  bodyClass: String,
  shadow: {
    type: String,
    values: ["always", "hover", "never"],
    default: "always"
  }
}), DA = be({
  name: "ElCard"
}), BA = /* @__PURE__ */ be({
  ...DA,
  props: $A,
  setup(t) {
    const e = Fe("card");
    return (n, r) => (V(), se("div", {
      class: ee([x(e).b(), x(e).is(`${n.shadow}-shadow`)])
    }, [
      n.$slots.header || n.header ? (V(), se("div", {
        key: 0,
        class: ee(x(e).e("header"))
      }, [
        De(n.$slots, "header", {}, () => [
          cn(st(n.header), 1)
        ])
      ], 2)) : ye("v-if", !0),
      ae("div", {
        class: ee([x(e).e("body"), n.bodyClass]),
        style: it(n.bodyStyle)
      }, [
        De(n.$slots, "default")
      ], 6)
    ], 2));
  }
});
var MA = /* @__PURE__ */ qe(BA, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/card/src/card.vue"]]);
const zA = nn(MA), og = {
  modelValue: {
    type: [Number, String, Boolean],
    default: void 0
  },
  label: {
    type: [String, Boolean, Number, Object],
    default: void 0
  },
  indeterminate: Boolean,
  disabled: Boolean,
  checked: Boolean,
  name: {
    type: String,
    default: void 0
  },
  trueLabel: {
    type: [String, Number],
    default: void 0
  },
  falseLabel: {
    type: [String, Number],
    default: void 0
  },
  id: {
    type: String,
    default: void 0
  },
  controls: {
    type: String,
    default: void 0
  },
  border: Boolean,
  size: Rr,
  tabindex: [String, Number],
  validateEvent: {
    type: Boolean,
    default: !0
  }
}, ag = {
  [Pt]: (t) => qt(t) || gt(t) || Zr(t),
  change: (t) => qt(t) || gt(t) || Zr(t)
}, js = Symbol("checkboxGroupContextKey"), FA = ({
  model: t,
  isChecked: e
}) => {
  const n = tt(js, void 0), r = F(() => {
    var s, o;
    const a = (s = n == null ? void 0 : n.max) == null ? void 0 : s.value, l = (o = n == null ? void 0 : n.min) == null ? void 0 : o.value;
    return !Er(a) && t.value.length >= a && !e.value || !Er(l) && t.value.length <= l && e.value;
  });
  return {
    isDisabled: Pr(F(() => (n == null ? void 0 : n.disabled.value) || r.value)),
    isLimitDisabled: r
  };
}, jA = (t, {
  model: e,
  isLimitExceeded: n,
  hasOwnLabel: r,
  isDisabled: i,
  isLabeledByFormItem: s
}) => {
  const o = tt(js, void 0), { formItem: a } = oi(), { emit: l } = ht();
  function u(y) {
    var b, p;
    return y === t.trueLabel || y === !0 ? (b = t.trueLabel) != null ? b : !0 : (p = t.falseLabel) != null ? p : !1;
  }
  function c(y, b) {
    l("change", u(y), b);
  }
  function d(y) {
    if (n.value)
      return;
    const b = y.target;
    l("change", u(b.checked), y);
  }
  async function h(y) {
    n.value || !r.value && !i.value && s.value && (y.composedPath().some((f) => f.tagName === "LABEL") || (e.value = u([!1, t.falseLabel].includes(e.value)), await rt(), c(e.value, y)));
  }
  const v = F(() => (o == null ? void 0 : o.validateEvent) || t.validateEvent);
  return ke(() => t.modelValue, () => {
    v.value && (a == null || a.validate("change").catch((y) => Vt(y)));
  }), {
    handleChange: d,
    onClickRoot: h
  };
}, UA = (t) => {
  const e = K(!1), { emit: n } = ht(), r = tt(js, void 0), i = F(() => Er(r) === !1), s = K(!1);
  return {
    model: F({
      get() {
        var a, l;
        return i.value ? (a = r == null ? void 0 : r.modelValue) == null ? void 0 : a.value : (l = t.modelValue) != null ? l : e.value;
      },
      set(a) {
        var l, u;
        i.value && Nr(a) ? (s.value = ((l = r == null ? void 0 : r.max) == null ? void 0 : l.value) !== void 0 && a.length > (r == null ? void 0 : r.max.value), s.value === !1 && ((u = r == null ? void 0 : r.changeEvent) == null || u.call(r, a))) : (n(Pt, a), e.value = a);
      }
    }),
    isGroup: i,
    isLimitExceeded: s
  };
}, VA = (t, e, { model: n }) => {
  const r = tt(js, void 0), i = K(!1), s = F(() => {
    const u = n.value;
    return Zr(u) ? u : Nr(u) ? wn(t.label) ? u.map(yi).some((c) => ll(c, t.label)) : u.map(yi).includes(t.label) : u != null ? u === t.trueLabel : !!u;
  }), o = Lr(F(() => {
    var u;
    return (u = r == null ? void 0 : r.size) == null ? void 0 : u.value;
  }), {
    prop: !0
  }), a = Lr(F(() => {
    var u;
    return (u = r == null ? void 0 : r.size) == null ? void 0 : u.value;
  })), l = F(() => !!e.default || !er(t.label));
  return {
    checkboxButtonSize: o,
    isChecked: s,
    isFocused: i,
    checkboxSize: a,
    hasOwnLabel: l
  };
}, WA = (t, { model: e }) => {
  function n() {
    Nr(e.value) && !e.value.includes(t.label) ? e.value.push(t.label) : e.value = t.trueLabel || !0;
  }
  t.checked && n();
}, lg = (t, e) => {
  const { formItem: n } = oi(), { model: r, isGroup: i, isLimitExceeded: s } = UA(t), {
    isFocused: o,
    isChecked: a,
    checkboxButtonSize: l,
    checkboxSize: u,
    hasOwnLabel: c
  } = VA(t, e, { model: r }), { isDisabled: d } = FA({ model: r, isChecked: a }), { inputId: h, isLabeledByFormItem: v } = ea(t, {
    formItemContext: n,
    disableIdGeneration: c,
    disableIdManagement: i
  }), { handleChange: y, onClickRoot: b } = jA(t, {
    model: r,
    isLimitExceeded: s,
    hasOwnLabel: c,
    isDisabled: d,
    isLabeledByFormItem: v
  });
  return WA(t, { model: r }), {
    inputId: h,
    isLabeledByFormItem: v,
    isChecked: a,
    isDisabled: d,
    isFocused: o,
    checkboxButtonSize: l,
    checkboxSize: u,
    hasOwnLabel: c,
    model: r,
    handleChange: y,
    onClickRoot: b
  };
}, HA = ["id", "indeterminate", "name", "tabindex", "disabled", "true-value", "false-value"], KA = ["id", "indeterminate", "disabled", "value", "name", "tabindex"], qA = be({
  name: "ElCheckbox"
}), GA = /* @__PURE__ */ be({
  ...qA,
  props: og,
  emits: ag,
  setup(t) {
    const e = t, n = Ho(), {
      inputId: r,
      isLabeledByFormItem: i,
      isChecked: s,
      isDisabled: o,
      isFocused: a,
      checkboxSize: l,
      hasOwnLabel: u,
      model: c,
      handleChange: d,
      onClickRoot: h
    } = lg(e, n), v = Fe("checkbox"), y = F(() => [
      v.b(),
      v.m(l.value),
      v.is("disabled", o.value),
      v.is("bordered", e.border),
      v.is("checked", s.value)
    ]), b = F(() => [
      v.e("input"),
      v.is("disabled", o.value),
      v.is("checked", s.value),
      v.is("indeterminate", e.indeterminate),
      v.is("focus", a.value)
    ]);
    return (p, f) => (V(), Ce(In(!x(u) && x(i) ? "span" : "label"), {
      class: ee(x(y)),
      "aria-controls": p.indeterminate ? p.controls : null,
      onClick: x(h)
    }, {
      default: de(() => [
        ae("span", {
          class: ee(x(b))
        }, [
          p.trueLabel || p.falseLabel ? $t((V(), se("input", {
            key: 0,
            id: x(r),
            "onUpdate:modelValue": f[0] || (f[0] = (m) => on(c) ? c.value = m : null),
            class: ee(x(v).e("original")),
            type: "checkbox",
            indeterminate: p.indeterminate,
            name: p.name,
            tabindex: p.tabindex,
            disabled: x(o),
            "true-value": p.trueLabel,
            "false-value": p.falseLabel,
            onChange: f[1] || (f[1] = (...m) => x(d) && x(d)(...m)),
            onFocus: f[2] || (f[2] = (m) => a.value = !0),
            onBlur: f[3] || (f[3] = (m) => a.value = !1),
            onClick: f[4] || (f[4] = ft(() => {
            }, ["stop"]))
          }, null, 42, HA)), [
            [nl, x(c)]
          ]) : $t((V(), se("input", {
            key: 1,
            id: x(r),
            "onUpdate:modelValue": f[5] || (f[5] = (m) => on(c) ? c.value = m : null),
            class: ee(x(v).e("original")),
            type: "checkbox",
            indeterminate: p.indeterminate,
            disabled: x(o),
            value: p.label,
            name: p.name,
            tabindex: p.tabindex,
            onChange: f[6] || (f[6] = (...m) => x(d) && x(d)(...m)),
            onFocus: f[7] || (f[7] = (m) => a.value = !0),
            onBlur: f[8] || (f[8] = (m) => a.value = !1),
            onClick: f[9] || (f[9] = ft(() => {
            }, ["stop"]))
          }, null, 42, KA)), [
            [nl, x(c)]
          ]),
          ae("span", {
            class: ee(x(v).e("inner"))
          }, null, 2)
        ], 2),
        x(u) ? (V(), se("span", {
          key: 0,
          class: ee(x(v).e("label"))
        }, [
          De(p.$slots, "default"),
          p.$slots.default ? ye("v-if", !0) : (V(), se(Ft, { key: 0 }, [
            cn(st(p.label), 1)
          ], 64))
        ], 2)) : ye("v-if", !0)
      ]),
      _: 3
    }, 8, ["class", "aria-controls", "onClick"]));
  }
});
var YA = /* @__PURE__ */ qe(GA, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox.vue"]]);
const XA = ["name", "tabindex", "disabled", "true-value", "false-value"], ZA = ["name", "tabindex", "disabled", "value"], QA = be({
  name: "ElCheckboxButton"
}), JA = /* @__PURE__ */ be({
  ...QA,
  props: og,
  emits: ag,
  setup(t) {
    const e = t, n = Ho(), {
      isFocused: r,
      isChecked: i,
      isDisabled: s,
      checkboxButtonSize: o,
      model: a,
      handleChange: l
    } = lg(e, n), u = tt(js, void 0), c = Fe("checkbox"), d = F(() => {
      var v, y, b, p;
      const f = (y = (v = u == null ? void 0 : u.fill) == null ? void 0 : v.value) != null ? y : "";
      return {
        backgroundColor: f,
        borderColor: f,
        color: (p = (b = u == null ? void 0 : u.textColor) == null ? void 0 : b.value) != null ? p : "",
        boxShadow: f ? `-1px 0 0 0 ${f}` : void 0
      };
    }), h = F(() => [
      c.b("button"),
      c.bm("button", o.value),
      c.is("disabled", s.value),
      c.is("checked", i.value),
      c.is("focus", r.value)
    ]);
    return (v, y) => (V(), se("label", {
      class: ee(x(h))
    }, [
      v.trueLabel || v.falseLabel ? $t((V(), se("input", {
        key: 0,
        "onUpdate:modelValue": y[0] || (y[0] = (b) => on(a) ? a.value = b : null),
        class: ee(x(c).be("button", "original")),
        type: "checkbox",
        name: v.name,
        tabindex: v.tabindex,
        disabled: x(s),
        "true-value": v.trueLabel,
        "false-value": v.falseLabel,
        onChange: y[1] || (y[1] = (...b) => x(l) && x(l)(...b)),
        onFocus: y[2] || (y[2] = (b) => r.value = !0),
        onBlur: y[3] || (y[3] = (b) => r.value = !1),
        onClick: y[4] || (y[4] = ft(() => {
        }, ["stop"]))
      }, null, 42, XA)), [
        [nl, x(a)]
      ]) : $t((V(), se("input", {
        key: 1,
        "onUpdate:modelValue": y[5] || (y[5] = (b) => on(a) ? a.value = b : null),
        class: ee(x(c).be("button", "original")),
        type: "checkbox",
        name: v.name,
        tabindex: v.tabindex,
        disabled: x(s),
        value: v.label,
        onChange: y[6] || (y[6] = (...b) => x(l) && x(l)(...b)),
        onFocus: y[7] || (y[7] = (b) => r.value = !0),
        onBlur: y[8] || (y[8] = (b) => r.value = !1),
        onClick: y[9] || (y[9] = ft(() => {
        }, ["stop"]))
      }, null, 42, ZA)), [
        [nl, x(a)]
      ]),
      v.$slots.default || v.label ? (V(), se("span", {
        key: 2,
        class: ee(x(c).be("button", "inner")),
        style: it(x(i) ? x(d) : void 0)
      }, [
        De(v.$slots, "default", {}, () => [
          cn(st(v.label), 1)
        ])
      ], 6)) : ye("v-if", !0)
    ], 2));
  }
});
var ug = /* @__PURE__ */ qe(JA, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-button.vue"]]);
const eI = ut({
  modelValue: {
    type: Pe(Array),
    default: () => []
  },
  disabled: Boolean,
  min: Number,
  max: Number,
  size: Rr,
  label: String,
  fill: String,
  textColor: String,
  tag: {
    type: String,
    default: "div"
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), tI = {
  [Pt]: (t) => Nr(t),
  change: (t) => Nr(t)
}, nI = be({
  name: "ElCheckboxGroup"
}), rI = /* @__PURE__ */ be({
  ...nI,
  props: eI,
  emits: tI,
  setup(t, { emit: e }) {
    const n = t, r = Fe("checkbox"), { formItem: i } = oi(), { inputId: s, isLabeledByFormItem: o } = ea(n, {
      formItemContext: i
    }), a = async (u) => {
      e(Pt, u), await rt(), e("change", u);
    }, l = F({
      get() {
        return n.modelValue;
      },
      set(u) {
        a(u);
      }
    });
    return Gt(js, {
      ...kS(hn(n), [
        "size",
        "min",
        "max",
        "disabled",
        "validateEvent",
        "fill",
        "textColor"
      ]),
      modelValue: l,
      changeEvent: a
    }), ke(() => n.modelValue, () => {
      n.validateEvent && (i == null || i.validate("change").catch((u) => Vt(u)));
    }), (u, c) => {
      var d;
      return V(), Ce(In(u.tag), {
        id: x(s),
        class: ee(x(r).b("group")),
        role: "group",
        "aria-label": x(o) ? void 0 : u.label || "checkbox-group",
        "aria-labelledby": x(o) ? (d = x(i)) == null ? void 0 : d.labelId : void 0
      }, {
        default: de(() => [
          De(u.$slots, "default")
        ]),
        _: 3
      }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
    };
  }
});
var cg = /* @__PURE__ */ qe(rI, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-group.vue"]]);
const Fi = nn(YA, {
  CheckboxButton: ug,
  CheckboxGroup: cg
});
sr(ug);
sr(cg);
const dg = ut({
  size: Rr,
  disabled: Boolean,
  label: {
    type: [String, Number, Boolean],
    default: ""
  }
}), iI = ut({
  ...dg,
  modelValue: {
    type: [String, Number, Boolean],
    default: ""
  },
  name: {
    type: String,
    default: ""
  },
  border: Boolean
}), fg = {
  [Pt]: (t) => qt(t) || gt(t) || Zr(t),
  [Yi]: (t) => qt(t) || gt(t) || Zr(t)
}, hg = Symbol("radioGroupKey"), pg = (t, e) => {
  const n = K(), r = tt(hg, void 0), i = F(() => !!r), s = F({
    get() {
      return i.value ? r.modelValue : t.modelValue;
    },
    set(c) {
      i.value ? r.changeEvent(c) : e && e(Pt, c), n.value.checked = t.modelValue === t.label;
    }
  }), o = Lr(F(() => r == null ? void 0 : r.size)), a = Pr(F(() => r == null ? void 0 : r.disabled)), l = K(!1), u = F(() => a.value || i.value && s.value !== t.label ? -1 : 0);
  return {
    radioRef: n,
    isGroup: i,
    radioGroup: r,
    focus: l,
    size: o,
    disabled: a,
    tabIndex: u,
    modelValue: s
  };
}, sI = ["value", "name", "disabled"], oI = be({
  name: "ElRadio"
}), aI = /* @__PURE__ */ be({
  ...oI,
  props: iI,
  emits: fg,
  setup(t, { emit: e }) {
    const n = t, r = Fe("radio"), { radioRef: i, radioGroup: s, focus: o, size: a, disabled: l, modelValue: u } = pg(n, e);
    function c() {
      rt(() => e("change", u.value));
    }
    return (d, h) => {
      var v;
      return V(), se("label", {
        class: ee([
          x(r).b(),
          x(r).is("disabled", x(l)),
          x(r).is("focus", x(o)),
          x(r).is("bordered", d.border),
          x(r).is("checked", x(u) === d.label),
          x(r).m(x(a))
        ])
      }, [
        ae("span", {
          class: ee([
            x(r).e("input"),
            x(r).is("disabled", x(l)),
            x(r).is("checked", x(u) === d.label)
          ])
        }, [
          $t(ae("input", {
            ref_key: "radioRef",
            ref: i,
            "onUpdate:modelValue": h[0] || (h[0] = (y) => on(u) ? u.value = y : null),
            class: ee(x(r).e("original")),
            value: d.label,
            name: d.name || ((v = x(s)) == null ? void 0 : v.name),
            disabled: x(l),
            type: "radio",
            onFocus: h[1] || (h[1] = (y) => o.value = !0),
            onBlur: h[2] || (h[2] = (y) => o.value = !1),
            onChange: c,
            onClick: h[3] || (h[3] = ft(() => {
            }, ["stop"]))
          }, null, 42, sI), [
            [gv, x(u)]
          ]),
          ae("span", {
            class: ee(x(r).e("inner"))
          }, null, 2)
        ], 2),
        ae("span", {
          class: ee(x(r).e("label")),
          onKeydown: h[4] || (h[4] = ft(() => {
          }, ["stop"]))
        }, [
          De(d.$slots, "default", {}, () => [
            cn(st(d.label), 1)
          ])
        ], 34)
      ], 2);
    };
  }
});
var lI = /* @__PURE__ */ qe(aI, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio.vue"]]);
const uI = ut({
  ...dg,
  name: {
    type: String,
    default: ""
  }
}), cI = ["value", "name", "disabled"], dI = be({
  name: "ElRadioButton"
}), fI = /* @__PURE__ */ be({
  ...dI,
  props: uI,
  setup(t) {
    const e = t, n = Fe("radio"), { radioRef: r, focus: i, size: s, disabled: o, modelValue: a, radioGroup: l } = pg(e), u = F(() => ({
      backgroundColor: (l == null ? void 0 : l.fill) || "",
      borderColor: (l == null ? void 0 : l.fill) || "",
      boxShadow: l != null && l.fill ? `-1px 0 0 0 ${l.fill}` : "",
      color: (l == null ? void 0 : l.textColor) || ""
    }));
    return (c, d) => {
      var h;
      return V(), se("label", {
        class: ee([
          x(n).b("button"),
          x(n).is("active", x(a) === c.label),
          x(n).is("disabled", x(o)),
          x(n).is("focus", x(i)),
          x(n).bm("button", x(s))
        ])
      }, [
        $t(ae("input", {
          ref_key: "radioRef",
          ref: r,
          "onUpdate:modelValue": d[0] || (d[0] = (v) => on(a) ? a.value = v : null),
          class: ee(x(n).be("button", "original-radio")),
          value: c.label,
          type: "radio",
          name: c.name || ((h = x(l)) == null ? void 0 : h.name),
          disabled: x(o),
          onFocus: d[1] || (d[1] = (v) => i.value = !0),
          onBlur: d[2] || (d[2] = (v) => i.value = !1),
          onClick: d[3] || (d[3] = ft(() => {
          }, ["stop"]))
        }, null, 42, cI), [
          [gv, x(a)]
        ]),
        ae("span", {
          class: ee(x(n).be("button", "inner")),
          style: it(x(a) === c.label ? x(u) : {}),
          onKeydown: d[4] || (d[4] = ft(() => {
          }, ["stop"]))
        }, [
          De(c.$slots, "default", {}, () => [
            cn(st(c.label), 1)
          ])
        ], 38)
      ], 2);
    };
  }
});
var vg = /* @__PURE__ */ qe(fI, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio-button.vue"]]);
const hI = ut({
  id: {
    type: String,
    default: void 0
  },
  size: Rr,
  disabled: Boolean,
  modelValue: {
    type: [String, Number, Boolean],
    default: ""
  },
  fill: {
    type: String,
    default: ""
  },
  label: {
    type: String,
    default: void 0
  },
  textColor: {
    type: String,
    default: ""
  },
  name: {
    type: String,
    default: void 0
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), pI = fg, vI = ["id", "aria-label", "aria-labelledby"], mI = be({
  name: "ElRadioGroup"
}), gI = /* @__PURE__ */ be({
  ...mI,
  props: hI,
  emits: pI,
  setup(t, { emit: e }) {
    const n = t, r = Fe("radio"), i = Jo(), s = K(), { formItem: o } = oi(), { inputId: a, isLabeledByFormItem: l } = ea(n, {
      formItemContext: o
    }), u = (d) => {
      e(Pt, d), rt(() => e("change", d));
    };
    Tt(() => {
      const d = s.value.querySelectorAll("[type=radio]"), h = d[0];
      !Array.from(d).some((v) => v.checked) && h && (h.tabIndex = 0);
    });
    const c = F(() => n.name || i.value);
    return Gt(hg, Pn({
      ...hn(n),
      changeEvent: u,
      name: c
    })), ke(() => n.modelValue, () => {
      n.validateEvent && (o == null || o.validate("change").catch((d) => Vt(d)));
    }), (d, h) => (V(), se("div", {
      id: x(a),
      ref_key: "radioGroupRef",
      ref: s,
      class: ee(x(r).b("group")),
      role: "radiogroup",
      "aria-label": x(l) ? void 0 : d.label || "radio-group",
      "aria-labelledby": x(l) ? x(o).labelId : void 0
    }, [
      De(d.$slots, "default")
    ], 10, vI));
  }
});
var mg = /* @__PURE__ */ qe(gI, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio-group.vue"]]);
nn(lI, {
  RadioButton: vg,
  RadioGroup: mg
});
const yI = sr(mg), bI = sr(vg), gg = ut({
  type: {
    type: String,
    values: ["success", "info", "warning", "danger", ""],
    default: ""
  },
  closable: Boolean,
  disableTransitions: Boolean,
  hit: Boolean,
  color: {
    type: String,
    default: ""
  },
  size: {
    type: String,
    values: Rd,
    default: ""
  },
  effect: {
    type: String,
    values: ["dark", "light", "plain"],
    default: "light"
  },
  round: Boolean
}), wI = {
  close: (t) => t instanceof MouseEvent,
  click: (t) => t instanceof MouseEvent
}, _I = be({
  name: "ElTag"
}), EI = /* @__PURE__ */ be({
  ..._I,
  props: gg,
  emits: wI,
  setup(t, { emit: e }) {
    const n = t, r = Lr(), i = Fe("tag"), s = F(() => {
      const { type: l, hit: u, effect: c, closable: d, round: h } = n;
      return [
        i.b(),
        i.is("closable", d),
        i.m(l),
        i.m(r.value),
        i.m(c),
        i.is("hit", u),
        i.is("round", h)
      ];
    }), o = (l) => {
      e("close", l);
    }, a = (l) => {
      e("click", l);
    };
    return (l, u) => l.disableTransitions ? (V(), se("span", {
      key: 0,
      class: ee(x(s)),
      style: it({ backgroundColor: l.color }),
      onClick: a
    }, [
      ae("span", {
        class: ee(x(i).e("content"))
      }, [
        De(l.$slots, "default")
      ], 2),
      l.closable ? (V(), Ce(x(_t), {
        key: 0,
        class: ee(x(i).e("close")),
        onClick: ft(o, ["stop"])
      }, {
        default: de(() => [
          ve(x(ko))
        ]),
        _: 1
      }, 8, ["class", "onClick"])) : ye("v-if", !0)
    ], 6)) : (V(), Ce(gr, {
      key: 1,
      name: `${x(i).namespace.value}-zoom-in-center`,
      appear: ""
    }, {
      default: de(() => [
        ae("span", {
          class: ee(x(s)),
          style: it({ backgroundColor: l.color }),
          onClick: a
        }, [
          ae("span", {
            class: ee(x(i).e("content"))
          }, [
            De(l.$slots, "default")
          ], 2),
          l.closable ? (V(), Ce(x(_t), {
            key: 0,
            class: ee(x(i).e("close")),
            onClick: ft(o, ["stop"])
          }, {
            default: de(() => [
              ve(x(ko))
            ]),
            _: 1
          }, 8, ["class", "onClick"])) : ye("v-if", !0)
        ], 6)
      ]),
      _: 3
    }, 8, ["name"]));
  }
});
var SI = /* @__PURE__ */ qe(EI, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tag/src/tag.vue"]]);
const xI = nn(SI), CI = be({
  name: "ElCollapseTransition"
}), kI = /* @__PURE__ */ be({
  ...CI,
  setup(t) {
    const e = Fe("collapse-transition"), n = (i) => {
      i.style.maxHeight = "", i.style.overflow = i.dataset.oldOverflow, i.style.paddingTop = i.dataset.oldPaddingTop, i.style.paddingBottom = i.dataset.oldPaddingBottom;
    }, r = {
      beforeEnter(i) {
        i.dataset || (i.dataset = {}), i.dataset.oldPaddingTop = i.style.paddingTop, i.dataset.oldPaddingBottom = i.style.paddingBottom, i.style.maxHeight = 0, i.style.paddingTop = 0, i.style.paddingBottom = 0;
      },
      enter(i) {
        i.dataset.oldOverflow = i.style.overflow, i.scrollHeight !== 0 ? i.style.maxHeight = `${i.scrollHeight}px` : i.style.maxHeight = 0, i.style.paddingTop = i.dataset.oldPaddingTop, i.style.paddingBottom = i.dataset.oldPaddingBottom, i.style.overflow = "hidden";
      },
      afterEnter(i) {
        i.style.maxHeight = "", i.style.overflow = i.dataset.oldOverflow;
      },
      enterCancelled(i) {
        n(i);
      },
      beforeLeave(i) {
        i.dataset || (i.dataset = {}), i.dataset.oldPaddingTop = i.style.paddingTop, i.dataset.oldPaddingBottom = i.style.paddingBottom, i.dataset.oldOverflow = i.style.overflow, i.style.maxHeight = `${i.scrollHeight}px`, i.style.overflow = "hidden";
      },
      leave(i) {
        i.scrollHeight !== 0 && (i.style.maxHeight = 0, i.style.paddingTop = 0, i.style.paddingBottom = 0);
      },
      afterLeave(i) {
        n(i);
      },
      leaveCancelled(i) {
        n(i);
      }
    };
    return (i, s) => (V(), Ce(gr, qn({
      name: x(e).b()
    }, Zy(r)), {
      default: de(() => [
        De(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["name"]));
  }
});
var Fa = /* @__PURE__ */ qe(kI, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/collapse-transition/src/collapse-transition.vue"]]);
Fa.install = (t) => {
  t.component(Fa.name, Fa);
};
const TI = Fa, OI = be({
  name: "ElContainer"
}), NI = /* @__PURE__ */ be({
  ...OI,
  props: {
    direction: {
      type: String
    }
  },
  setup(t) {
    const e = t, n = Ho(), r = Fe("container"), i = F(() => e.direction === "vertical" ? !0 : e.direction === "horizontal" ? !1 : n && n.default ? n.default().some((o) => {
      const a = o.type.name;
      return a === "ElHeader" || a === "ElFooter";
    }) : !1);
    return (s, o) => (V(), se("section", {
      class: ee([x(r).b(), x(r).is("vertical", x(i))])
    }, [
      De(s.$slots, "default")
    ], 2));
  }
});
var AI = /* @__PURE__ */ qe(NI, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/container.vue"]]);
const II = be({
  name: "ElAside"
}), RI = /* @__PURE__ */ be({
  ...II,
  props: {
    width: {
      type: String,
      default: null
    }
  },
  setup(t) {
    const e = t, n = Fe("aside"), r = F(() => e.width ? n.cssVarBlock({ width: e.width }) : {});
    return (i, s) => (V(), se("aside", {
      class: ee(x(n).b()),
      style: it(x(r))
    }, [
      De(i.$slots, "default")
    ], 6));
  }
});
var yg = /* @__PURE__ */ qe(RI, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/aside.vue"]]);
const LI = be({
  name: "ElFooter"
}), PI = /* @__PURE__ */ be({
  ...LI,
  props: {
    height: {
      type: String,
      default: null
    }
  },
  setup(t) {
    const e = t, n = Fe("footer"), r = F(() => e.height ? n.cssVarBlock({ height: e.height }) : {});
    return (i, s) => (V(), se("footer", {
      class: ee(x(n).b()),
      style: it(x(r))
    }, [
      De(i.$slots, "default")
    ], 6));
  }
});
var bg = /* @__PURE__ */ qe(PI, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/footer.vue"]]);
const $I = be({
  name: "ElHeader"
}), DI = /* @__PURE__ */ be({
  ...$I,
  props: {
    height: {
      type: String,
      default: null
    }
  },
  setup(t) {
    const e = t, n = Fe("header"), r = F(() => e.height ? n.cssVarBlock({
      height: e.height
    }) : {});
    return (i, s) => (V(), se("header", {
      class: ee(x(n).b()),
      style: it(x(r))
    }, [
      De(i.$slots, "default")
    ], 6));
  }
});
var wg = /* @__PURE__ */ qe(DI, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/header.vue"]]);
const BI = be({
  name: "ElMain"
}), MI = /* @__PURE__ */ be({
  ...BI,
  setup(t) {
    const e = Fe("main");
    return (n, r) => (V(), se("main", {
      class: ee(x(e).b())
    }, [
      De(n.$slots, "default")
    ], 2));
  }
});
var _g = /* @__PURE__ */ qe(MI, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/main.vue"]]);
const Eg = nn(AI, {
  Aside: yg,
  Footer: bg,
  Header: wg,
  Main: _g
});
sr(yg);
const zI = sr(bg), FI = sr(wg), Sg = sr(_g), jI = ut({
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  contentPosition: {
    type: String,
    values: ["left", "center", "right"],
    default: "center"
  },
  borderStyle: {
    type: Pe(String),
    default: "solid"
  }
}), UI = be({
  name: "ElDivider"
}), VI = /* @__PURE__ */ be({
  ...UI,
  props: jI,
  setup(t) {
    const e = t, n = Fe("divider"), r = F(() => n.cssVar({
      "border-style": e.borderStyle
    }));
    return (i, s) => (V(), se("div", {
      class: ee([x(n).b(), x(n).m(i.direction)]),
      style: it(x(r)),
      role: "separator"
    }, [
      i.$slots.default && i.direction !== "vertical" ? (V(), se("div", {
        key: 0,
        class: ee([x(n).e("text"), x(n).is(i.contentPosition)])
      }, [
        De(i.$slots, "default")
      ], 2)) : ye("v-if", !0)
    ], 6));
  }
});
var WI = /* @__PURE__ */ qe(VI, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/divider/src/divider.vue"]]);
const HI = nn(WI), KI = /* @__PURE__ */ be({
  inheritAttrs: !1
});
function qI(t, e, n, r, i, s) {
  return De(t.$slots, "default");
}
var GI = /* @__PURE__ */ qe(KI, [["render", qI], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection.vue"]]);
const YI = /* @__PURE__ */ be({
  name: "ElCollectionItem",
  inheritAttrs: !1
});
function XI(t, e, n, r, i, s) {
  return De(t.$slots, "default");
}
var ZI = /* @__PURE__ */ qe(YI, [["render", XI], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection-item.vue"]]);
const QI = "data-el-collection-item", JI = (t) => {
  const e = `El${t}Collection`, n = `${e}Item`, r = Symbol(e), i = Symbol(n), s = {
    ...GI,
    name: e,
    setup() {
      const a = K(null), l = /* @__PURE__ */ new Map();
      Gt(r, {
        itemMap: l,
        getItems: () => {
          const c = x(a);
          if (!c)
            return [];
          const d = Array.from(c.querySelectorAll(`[${QI}]`));
          return [...l.values()].sort((v, y) => d.indexOf(v.ref) - d.indexOf(y.ref));
        },
        collectionRef: a
      });
    }
  }, o = {
    ...ZI,
    name: n,
    setup(a, { attrs: l }) {
      const u = K(null), c = tt(r, void 0);
      Gt(i, {
        collectionItemRef: u
      }), Tt(() => {
        const d = x(u);
        d && c.itemMap.set(d, {
          ref: d,
          ...l
        });
      }), Sn(() => {
        const d = x(u);
        c.itemMap.delete(d);
      });
    }
  };
  return {
    COLLECTION_INJECTION_KEY: r,
    COLLECTION_ITEM_INJECTION_KEY: i,
    ElCollection: s,
    ElCollectionItem: o
  };
}, Cu = ut({
  trigger: Ao.trigger,
  effect: {
    ...Kn.effect,
    default: "light"
  },
  type: {
    type: Pe(String)
  },
  placement: {
    type: Pe(String),
    default: "bottom"
  },
  popperOptions: {
    type: Pe(Object),
    default: () => ({})
  },
  id: String,
  size: {
    type: String,
    default: ""
  },
  splitButton: Boolean,
  hideOnClick: {
    type: Boolean,
    default: !0
  },
  loop: {
    type: Boolean,
    default: !0
  },
  showTimeout: {
    type: Number,
    default: 150
  },
  hideTimeout: {
    type: Number,
    default: 150
  },
  tabindex: {
    type: Pe([Number, String]),
    default: 0
  },
  maxHeight: {
    type: Pe([Number, String]),
    default: ""
  },
  popperClass: {
    type: String,
    default: ""
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  role: {
    type: String,
    default: "menu"
  },
  buttonProps: {
    type: Pe(Object)
  },
  teleported: Kn.teleported
});
ut({
  command: {
    type: [Object, String, Number],
    default: () => ({})
  },
  disabled: Boolean,
  divided: Boolean,
  textValue: String,
  icon: {
    type: bi
  }
});
ut({
  onKeydown: { type: Pe(Function) }
});
JI("Dropdown");
const e3 = ut({
  urlList: {
    type: Pe(Array),
    default: () => Ts([])
  },
  zIndex: {
    type: Number
  },
  initialIndex: {
    type: Number,
    default: 0
  },
  infinite: {
    type: Boolean,
    default: !0
  },
  hideOnClickModal: Boolean,
  teleported: Boolean,
  closeOnPressEscape: {
    type: Boolean,
    default: !0
  },
  zoomRate: {
    type: Number,
    default: 1.2
  },
  minScale: {
    type: Number,
    default: 0.2
  },
  maxScale: {
    type: Number,
    default: 7
  }
}), t3 = {
  close: () => !0,
  switch: (t) => gt(t),
  rotate: (t) => gt(t)
}, n3 = ["src"], r3 = be({
  name: "ElImageViewer"
}), i3 = /* @__PURE__ */ be({
  ...r3,
  props: e3,
  emits: t3,
  setup(t, { expose: e, emit: n }) {
    const r = t, i = {
      CONTAIN: {
        name: "contain",
        icon: Ur(lm)
      },
      ORIGINAL: {
        name: "original",
        icon: Ur(bk)
      }
    }, { t: s } = or(), o = Fe("image-viewer"), { nextZIndex: a } = Gl(), l = K(), u = K([]), c = yv(), d = K(!0), h = K(r.initialIndex), v = Mn(i.CONTAIN), y = K({
      scale: 1,
      deg: 0,
      offsetX: 0,
      offsetY: 0,
      enableTransition: !1
    }), b = F(() => {
      const { urlList: j } = r;
      return j.length <= 1;
    }), p = F(() => h.value === 0), f = F(() => h.value === r.urlList.length - 1), m = F(() => r.urlList[h.value]), g = F(() => [
      o.e("btn"),
      o.e("prev"),
      o.is("disabled", !r.infinite && p.value)
    ]), w = F(() => [
      o.e("btn"),
      o.e("next"),
      o.is("disabled", !r.infinite && f.value)
    ]), _ = F(() => {
      const { scale: j, deg: re, offsetX: fe, offsetY: Y, enableTransition: le } = y.value;
      let ce = fe / j, me = Y / j;
      switch (re % 360) {
        case 90:
        case -270:
          [ce, me] = [me, -ce];
          break;
        case 180:
        case -180:
          [ce, me] = [-ce, -me];
          break;
        case 270:
        case -90:
          [ce, me] = [-me, ce];
          break;
      }
      const _e = {
        transform: `scale(${j}) rotate(${re}deg) translate(${ce}px, ${me}px)`,
        transition: le ? "transform .3s" : ""
      };
      return v.value.name === i.CONTAIN.name && (_e.maxWidth = _e.maxHeight = "100%"), _e;
    }), E = F(() => gt(r.zIndex) ? r.zIndex : a());
    function C() {
      k(), n("close");
    }
    function T() {
      const j = yu((fe) => {
        switch (fe.code) {
          case sn.esc:
            r.closeOnPressEscape && C();
            break;
          case sn.space:
            z();
            break;
          case sn.left:
            J();
            break;
          case sn.up:
            U("zoomIn");
            break;
          case sn.right:
            M();
            break;
          case sn.down:
            U("zoomOut");
            break;
        }
      }), re = yu((fe) => {
        const Y = fe.deltaY || fe.deltaX;
        U(Y < 0 ? "zoomIn" : "zoomOut", {
          zoomRate: r.zoomRate,
          enableTransition: !1
        });
      });
      c.run(() => {
        bn(document, "keydown", j), bn(document, "wheel", re);
      });
    }
    function k() {
      c.stop();
    }
    function N() {
      d.value = !1;
    }
    function I(j) {
      d.value = !1, j.target.alt = s("el.image.error");
    }
    function P(j) {
      if (d.value || j.button !== 0 || !l.value)
        return;
      y.value.enableTransition = !1;
      const { offsetX: re, offsetY: fe } = y.value, Y = j.pageX, le = j.pageY, ce = yu((_e) => {
        y.value = {
          ...y.value,
          offsetX: re + _e.pageX - Y,
          offsetY: fe + _e.pageY - le
        };
      }), me = bn(document, "mousemove", ce);
      bn(document, "mouseup", () => {
        me();
      }), j.preventDefault();
    }
    function D() {
      y.value = {
        scale: 1,
        deg: 0,
        offsetX: 0,
        offsetY: 0,
        enableTransition: !1
      };
    }
    function z() {
      if (d.value)
        return;
      const j = rc(i), re = Object.values(i), fe = v.value.name, le = (re.findIndex((ce) => ce.name === fe) + 1) % j.length;
      v.value = i[j[le]], D();
    }
    function G(j) {
      const re = r.urlList.length;
      h.value = (j + re) % re;
    }
    function J() {
      p.value && !r.infinite || G(h.value - 1);
    }
    function M() {
      f.value && !r.infinite || G(h.value + 1);
    }
    function U(j, re = {}) {
      if (d.value)
        return;
      const { minScale: fe, maxScale: Y } = r, { zoomRate: le, rotateDeg: ce, enableTransition: me } = {
        zoomRate: r.zoomRate,
        rotateDeg: 90,
        enableTransition: !0,
        ...re
      };
      switch (j) {
        case "zoomOut":
          y.value.scale > fe && (y.value.scale = Number.parseFloat((y.value.scale / le).toFixed(3)));
          break;
        case "zoomIn":
          y.value.scale < Y && (y.value.scale = Number.parseFloat((y.value.scale * le).toFixed(3)));
          break;
        case "clockwise":
          y.value.deg += ce, n("rotate", y.value.deg);
          break;
        case "anticlockwise":
          y.value.deg -= ce, n("rotate", y.value.deg);
          break;
      }
      y.value.enableTransition = me;
    }
    return ke(m, () => {
      rt(() => {
        const j = u.value[0];
        j != null && j.complete || (d.value = !0);
      });
    }), ke(h, (j) => {
      D(), n("switch", j);
    }), Tt(() => {
      var j, re;
      T(), (re = (j = l.value) == null ? void 0 : j.focus) == null || re.call(j);
    }), e({
      setActiveItem: G
    }), (j, re) => (V(), Ce(mv, {
      to: "body",
      disabled: !j.teleported
    }, [
      ve(gr, {
        name: "viewer-fade",
        appear: ""
      }, {
        default: de(() => [
          ae("div", {
            ref_key: "wrapper",
            ref: l,
            tabindex: -1,
            class: ee(x(o).e("wrapper")),
            style: it({ zIndex: x(E) })
          }, [
            ae("div", {
              class: ee(x(o).e("mask")),
              onClick: re[0] || (re[0] = ft((fe) => j.hideOnClickModal && C(), ["self"]))
            }, null, 2),
            ye(" CLOSE "),
            ae("span", {
              class: ee([x(o).e("btn"), x(o).e("close")]),
              onClick: C
            }, [
              ve(x(_t), null, {
                default: de(() => [
                  ve(x(ko))
                ]),
                _: 1
              })
            ], 2),
            ye(" ARROW "),
            x(b) ? ye("v-if", !0) : (V(), se(Ft, { key: 0 }, [
              ae("span", {
                class: ee(x(g)),
                onClick: J
              }, [
                ve(x(_t), null, {
                  default: de(() => [
                    ve(x(qS))
                  ]),
                  _: 1
                })
              ], 2),
              ae("span", {
                class: ee(x(w)),
                onClick: M
              }, [
                ve(x(_t), null, {
                  default: de(() => [
                    ve(x(Ad))
                  ]),
                  _: 1
                })
              ], 2)
            ], 64)),
            ye(" ACTIONS "),
            ae("div", {
              class: ee([x(o).e("btn"), x(o).e("actions")])
            }, [
              ae("div", {
                class: ee(x(o).e("actions__inner"))
              }, [
                ve(x(_t), {
                  onClick: re[1] || (re[1] = (fe) => U("zoomOut"))
                }, {
                  default: de(() => [
                    ve(x(Gk))
                  ]),
                  _: 1
                }),
                ve(x(_t), {
                  onClick: re[2] || (re[2] = (fe) => U("zoomIn"))
                }, {
                  default: de(() => [
                    ve(x(cm))
                  ]),
                  _: 1
                }),
                ae("i", {
                  class: ee(x(o).e("actions__divider"))
                }, null, 2),
                ve(x(_t), { onClick: z }, {
                  default: de(() => [
                    (V(), Ce(In(x(v).icon)))
                  ]),
                  _: 1
                }),
                ae("i", {
                  class: ee(x(o).e("actions__divider"))
                }, null, 2),
                ve(x(_t), {
                  onClick: re[3] || (re[3] = (fe) => U("anticlockwise"))
                }, {
                  default: de(() => [
                    ve(x(ak))
                  ]),
                  _: 1
                }),
                ve(x(_t), {
                  onClick: re[4] || (re[4] = (fe) => U("clockwise"))
                }, {
                  default: de(() => [
                    ve(x(hk))
                  ]),
                  _: 1
                })
              ], 2)
            ], 2),
            ye(" CANVAS "),
            ae("div", {
              class: ee(x(o).e("canvas"))
            }, [
              (V(!0), se(Ft, null, Gn(j.urlList, (fe, Y) => $t((V(), se("img", {
                ref_for: !0,
                ref: (le) => u.value[Y] = le,
                key: fe,
                src: fe,
                style: it(x(_)),
                class: ee(x(o).e("img")),
                onLoad: N,
                onError: I,
                onMousedown: P
              }, null, 46, n3)), [
                [Yn, Y === h.value]
              ])), 128))
            ], 2),
            De(j.$slots, "default")
          ], 6)
        ]),
        _: 3
      })
    ], 8, ["disabled"]));
  }
});
var s3 = /* @__PURE__ */ qe(i3, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/image-viewer/src/image-viewer.vue"]]);
const o3 = nn(s3), a3 = ut({
  hideOnClickModal: Boolean,
  src: {
    type: String,
    default: ""
  },
  fit: {
    type: String,
    values: ["", "contain", "cover", "fill", "none", "scale-down"],
    default: ""
  },
  loading: {
    type: String,
    values: ["eager", "lazy"]
  },
  lazy: Boolean,
  scrollContainer: {
    type: Pe([String, Object])
  },
  previewSrcList: {
    type: Pe(Array),
    default: () => Ts([])
  },
  previewTeleported: Boolean,
  zIndex: {
    type: Number
  },
  initialIndex: {
    type: Number,
    default: 0
  },
  infinite: {
    type: Boolean,
    default: !0
  },
  closeOnPressEscape: {
    type: Boolean,
    default: !0
  },
  zoomRate: {
    type: Number,
    default: 1.2
  },
  minScale: {
    type: Number,
    default: 0.2
  },
  maxScale: {
    type: Number,
    default: 7
  }
}), l3 = {
  load: (t) => t instanceof Event,
  error: (t) => t instanceof Event,
  switch: (t) => gt(t),
  close: () => !0,
  show: () => !0
}, u3 = ["src", "loading"], c3 = { key: 0 }, d3 = be({
  name: "ElImage",
  inheritAttrs: !1
}), f3 = /* @__PURE__ */ be({
  ...d3,
  props: a3,
  emits: l3,
  setup(t, { emit: e }) {
    const n = t;
    let r = "";
    const { t: i } = or(), s = Fe("image"), o = hv(), a = pm(), l = K(), u = K(!1), c = K(!0), d = K(!1), h = K(), v = K(), y = Et && "loading" in HTMLImageElement.prototype;
    let b, p;
    const f = F(() => [
      s.e("inner"),
      w.value && s.e("preview"),
      c.value && s.is("loading")
    ]), m = F(() => o.style), g = F(() => {
      const { fit: U } = n;
      return Et && U ? { objectFit: U } : {};
    }), w = F(() => {
      const { previewSrcList: U } = n;
      return Array.isArray(U) && U.length > 0;
    }), _ = F(() => {
      const { previewSrcList: U, initialIndex: j } = n;
      let re = j;
      return j > U.length - 1 && (re = 0), re;
    }), E = F(() => n.loading === "eager" ? !1 : !y && n.loading === "lazy" || n.lazy), C = () => {
      Et && (c.value = !0, u.value = !1, l.value = n.src);
    };
    function T(U) {
      c.value = !1, u.value = !1, e("load", U);
    }
    function k(U) {
      c.value = !1, u.value = !0, e("error", U);
    }
    function N() {
      Sb(h.value, v.value) && (C(), D());
    }
    const I = lb(N, 200, !0);
    async function P() {
      var U;
      if (!Et)
        return;
      await rt();
      const { scrollContainer: j } = n;
      zi(j) ? v.value = j : qt(j) && j !== "" ? v.value = (U = document.querySelector(j)) != null ? U : void 0 : h.value && (v.value = $S(h.value)), v.value && (b = bn(v, "scroll", I), setTimeout(() => N(), 100));
    }
    function D() {
      !Et || !v.value || !I || (b == null || b(), v.value = void 0);
    }
    function z(U) {
      if (U.ctrlKey) {
        if (U.deltaY < 0)
          return U.preventDefault(), !1;
        if (U.deltaY > 0)
          return U.preventDefault(), !1;
      }
    }
    function G() {
      w.value && (p = bn("wheel", z, {
        passive: !1
      }), r = document.body.style.overflow, document.body.style.overflow = "hidden", d.value = !0, e("show"));
    }
    function J() {
      p == null || p(), document.body.style.overflow = r, d.value = !1, e("close");
    }
    function M(U) {
      e("switch", U);
    }
    return ke(() => n.src, () => {
      E.value ? (c.value = !0, u.value = !1, D(), P()) : C();
    }), Tt(() => {
      E.value ? P() : C();
    }), (U, j) => (V(), se("div", {
      ref_key: "container",
      ref: h,
      class: ee([x(s).b(), U.$attrs.class]),
      style: it(x(m))
    }, [
      u.value ? De(U.$slots, "error", { key: 0 }, () => [
        ae("div", {
          class: ee(x(s).e("error"))
        }, st(x(i)("el.image.error")), 3)
      ]) : (V(), se(Ft, { key: 1 }, [
        l.value !== void 0 ? (V(), se("img", qn({ key: 0 }, x(a), {
          src: l.value,
          loading: U.loading,
          style: x(g),
          class: x(f),
          onClick: G,
          onLoad: T,
          onError: k
        }), null, 16, u3)) : ye("v-if", !0),
        c.value ? (V(), se("div", {
          key: 1,
          class: ee(x(s).e("wrapper"))
        }, [
          De(U.$slots, "placeholder", {}, () => [
            ae("div", {
              class: ee(x(s).e("placeholder"))
            }, null, 2)
          ])
        ], 2)) : ye("v-if", !0)
      ], 64)),
      x(w) ? (V(), se(Ft, { key: 2 }, [
        d.value ? (V(), Ce(x(o3), {
          key: 0,
          "z-index": U.zIndex,
          "initial-index": x(_),
          infinite: U.infinite,
          "zoom-rate": U.zoomRate,
          "min-scale": U.minScale,
          "max-scale": U.maxScale,
          "url-list": U.previewSrcList,
          "hide-on-click-modal": U.hideOnClickModal,
          teleported: U.previewTeleported,
          "close-on-press-escape": U.closeOnPressEscape,
          onClose: J,
          onSwitch: M
        }, {
          default: de(() => [
            U.$slots.viewer ? (V(), se("div", c3, [
              De(U.$slots, "viewer")
            ])) : ye("v-if", !0)
          ]),
          _: 3
        }, 8, ["z-index", "initial-index", "infinite", "zoom-rate", "min-scale", "max-scale", "url-list", "hide-on-click-modal", "teleported", "close-on-press-escape"])) : ye("v-if", !0)
      ], 64)) : ye("v-if", !0)
    ], 6));
  }
});
var h3 = /* @__PURE__ */ qe(f3, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/image/src/image.vue"]]);
const p3 = nn(h3), v3 = ut({
  id: {
    type: String,
    default: void 0
  },
  step: {
    type: Number,
    default: 1
  },
  stepStrictly: Boolean,
  max: {
    type: Number,
    default: Number.POSITIVE_INFINITY
  },
  min: {
    type: Number,
    default: Number.NEGATIVE_INFINITY
  },
  modelValue: Number,
  readonly: Boolean,
  disabled: Boolean,
  size: Rr,
  controls: {
    type: Boolean,
    default: !0
  },
  controlsPosition: {
    type: String,
    default: "",
    values: ["", "right"]
  },
  valueOnClear: {
    type: [String, Number, null],
    validator: (t) => t === null || gt(t) || ["min", "max"].includes(t),
    default: null
  },
  name: String,
  label: String,
  placeholder: String,
  precision: {
    type: Number,
    validator: (t) => t >= 0 && t === Number.parseInt(`${t}`, 10)
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), m3 = {
  [Yi]: (t, e) => e !== t,
  blur: (t) => t instanceof FocusEvent,
  focus: (t) => t instanceof FocusEvent,
  [Li]: (t) => gt(t) || er(t),
  [Pt]: (t) => gt(t) || er(t)
}, g3 = ["aria-label", "onKeydown"], y3 = ["aria-label", "onKeydown"], b3 = be({
  name: "ElInputNumber"
}), w3 = /* @__PURE__ */ be({
  ...b3,
  props: v3,
  emits: m3,
  setup(t, { expose: e, emit: n }) {
    const r = t, { t: i } = or(), s = Fe("input-number"), o = K(), a = Pn({
      currentValue: r.modelValue,
      userInput: null
    }), { formItem: l } = oi(), u = F(() => gt(r.modelValue) && r.modelValue <= r.min), c = F(() => gt(r.modelValue) && r.modelValue >= r.max), d = F(() => {
      const D = f(r.step);
      return Er(r.precision) ? Math.max(f(r.modelValue), D) : (D > r.precision && Vt("InputNumber", "precision should not be less than the decimal places of step"), r.precision);
    }), h = F(() => r.controls && r.controlsPosition === "right"), v = Lr(), y = Pr(), b = F(() => {
      if (a.userInput !== null)
        return a.userInput;
      let D = a.currentValue;
      if (er(D))
        return "";
      if (gt(D)) {
        if (Number.isNaN(D))
          return "";
        Er(r.precision) || (D = D.toFixed(r.precision));
      }
      return D;
    }), p = (D, z) => {
      if (Er(z) && (z = d.value), z === 0)
        return Math.round(D);
      let G = String(D);
      const J = G.indexOf(".");
      if (J === -1 || !G.replace(".", "").split("")[J + z])
        return D;
      const j = G.length;
      return G.charAt(j - 1) === "5" && (G = `${G.slice(0, Math.max(0, j - 1))}6`), Number.parseFloat(Number(G).toFixed(z));
    }, f = (D) => {
      if (er(D))
        return 0;
      const z = D.toString(), G = z.indexOf(".");
      let J = 0;
      return G !== -1 && (J = z.length - G - 1), J;
    }, m = (D, z = 1) => gt(D) ? p(D + r.step * z) : a.currentValue, g = () => {
      if (r.readonly || y.value || c.value)
        return;
      const D = Number(b.value) || 0, z = m(D);
      E(z), n(Li, a.currentValue);
    }, w = () => {
      if (r.readonly || y.value || u.value)
        return;
      const D = Number(b.value) || 0, z = m(D, -1);
      E(z), n(Li, a.currentValue);
    }, _ = (D, z) => {
      const { max: G, min: J, step: M, precision: U, stepStrictly: j, valueOnClear: re } = r;
      G < J && Gi("InputNumber", "min should not be greater than max.");
      let fe = Number(D);
      if (er(D) || Number.isNaN(fe))
        return null;
      if (D === "") {
        if (re === null)
          return null;
        fe = qt(re) ? { min: J, max: G }[re] : re;
      }
      return j && (fe = p(Math.round(fe / M) * M, U)), Er(U) || (fe = p(fe, U)), (fe > G || fe < J) && (fe = fe > G ? G : J, z && n(Pt, fe)), fe;
    }, E = (D, z = !0) => {
      var G;
      const J = a.currentValue, M = _(D);
      if (!z) {
        n(Pt, M);
        return;
      }
      J !== M && (a.userInput = null, n(Pt, M), n(Yi, M, J), r.validateEvent && ((G = l == null ? void 0 : l.validate) == null || G.call(l, "change").catch((U) => Vt(U))), a.currentValue = M);
    }, C = (D) => {
      a.userInput = D;
      const z = D === "" ? null : Number(D);
      n(Li, z), E(z, !1);
    }, T = (D) => {
      const z = D !== "" ? Number(D) : "";
      (gt(z) && !Number.isNaN(z) || D === "") && E(z), a.userInput = null;
    }, k = () => {
      var D, z;
      (z = (D = o.value) == null ? void 0 : D.focus) == null || z.call(D);
    }, N = () => {
      var D, z;
      (z = (D = o.value) == null ? void 0 : D.blur) == null || z.call(D);
    }, I = (D) => {
      n("focus", D);
    }, P = (D) => {
      var z;
      n("blur", D), r.validateEvent && ((z = l == null ? void 0 : l.validate) == null || z.call(l, "blur").catch((G) => Vt(G)));
    };
    return ke(() => r.modelValue, (D) => {
      const z = _(a.userInput), G = _(D, !0);
      !gt(z) && (!z || z !== G) && (a.currentValue = G, a.userInput = null);
    }, { immediate: !0 }), Tt(() => {
      var D;
      const { min: z, max: G, modelValue: J } = r, M = (D = o.value) == null ? void 0 : D.input;
      if (M.setAttribute("role", "spinbutton"), Number.isFinite(G) ? M.setAttribute("aria-valuemax", String(G)) : M.removeAttribute("aria-valuemax"), Number.isFinite(z) ? M.setAttribute("aria-valuemin", String(z)) : M.removeAttribute("aria-valuemin"), M.setAttribute("aria-valuenow", a.currentValue || a.currentValue === 0 ? String(a.currentValue) : ""), M.setAttribute("aria-disabled", String(y.value)), !gt(J) && J != null) {
        let U = Number(J);
        Number.isNaN(U) && (U = null), n(Pt, U);
      }
    }), Dl(() => {
      var D, z;
      const G = (D = o.value) == null ? void 0 : D.input;
      G == null || G.setAttribute("aria-valuenow", `${(z = a.currentValue) != null ? z : ""}`);
    }), e({
      focus: k,
      blur: N
    }), (D, z) => (V(), se("div", {
      class: ee([
        x(s).b(),
        x(s).m(x(v)),
        x(s).is("disabled", x(y)),
        x(s).is("without-controls", !D.controls),
        x(s).is("controls-right", x(h))
      ]),
      onDragstart: z[1] || (z[1] = ft(() => {
      }, ["prevent"]))
    }, [
      D.controls ? $t((V(), se("span", {
        key: 0,
        role: "button",
        "aria-label": x(i)("el.inputNumber.decrease"),
        class: ee([x(s).e("decrease"), x(s).is("disabled", x(u))]),
        onKeydown: vn(w, ["enter"])
      }, [
        ve(x(_t), null, {
          default: de(() => [
            x(h) ? (V(), Ce(x(Nd), { key: 0 })) : (V(), Ce(x(AC), { key: 1 }))
          ]),
          _: 1
        })
      ], 42, g3)), [
        [x(Jh), w]
      ]) : ye("v-if", !0),
      D.controls ? $t((V(), se("span", {
        key: 1,
        role: "button",
        "aria-label": x(i)("el.inputNumber.increase"),
        class: ee([x(s).e("increase"), x(s).is("disabled", x(c))]),
        onKeydown: vn(g, ["enter"])
      }, [
        ve(x(_t), null, {
          default: de(() => [
            x(h) ? (V(), Ce(x(sm), { key: 0 })) : (V(), Ce(x(um), { key: 1 }))
          ]),
          _: 1
        })
      ], 42, y3)), [
        [x(Jh), g]
      ]) : ye("v-if", !0),
      ve(x(Yl), {
        id: D.id,
        ref_key: "input",
        ref: o,
        type: "number",
        step: D.step,
        "model-value": x(b),
        placeholder: D.placeholder,
        readonly: D.readonly,
        disabled: x(y),
        size: x(v),
        max: D.max,
        min: D.min,
        name: D.name,
        label: D.label,
        "validate-event": !1,
        onWheel: z[0] || (z[0] = ft(() => {
        }, ["prevent"])),
        onKeydown: [
          vn(ft(g, ["prevent"]), ["up"]),
          vn(ft(w, ["prevent"]), ["down"])
        ],
        onBlur: P,
        onFocus: I,
        onInput: C,
        onChange: T
      }, null, 8, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "label", "onKeydown"])
    ], 34));
  }
});
var _3 = /* @__PURE__ */ qe(w3, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input-number/src/input-number.vue"]]);
const xg = nn(_3), Cg = Symbol("ElSelectGroup"), Ql = Symbol("ElSelect");
function E3(t, e) {
  const n = tt(Ql), r = tt(Cg, { disabled: !1 }), i = F(() => wn(t.value)), s = F(() => n.props.multiple ? d(n.props.modelValue, t.value) : h(t.value, n.props.modelValue)), o = F(() => {
    if (n.props.multiple) {
      const b = n.props.modelValue || [];
      return !s.value && b.length >= n.props.multipleLimit && n.props.multipleLimit > 0;
    } else
      return !1;
  }), a = F(() => t.label || (i.value ? "" : t.value)), l = F(() => t.value || t.label || ""), u = F(() => t.disabled || e.groupDisabled || o.value), c = ht(), d = (b = [], p) => {
    if (i.value) {
      const f = n.props.valueKey;
      return b && b.some((m) => yi(Cn(m, f)) === Cn(p, f));
    } else
      return b && b.includes(p);
  }, h = (b, p) => {
    if (i.value) {
      const { valueKey: f } = n.props;
      return Cn(b, f) === Cn(p, f);
    } else
      return b === p;
  }, v = () => {
    !t.disabled && !r.disabled && (n.hoverIndex = n.optionsArray.indexOf(c.proxy));
  };
  ke(() => a.value, () => {
    !t.created && !n.props.remote && n.setSelected();
  }), ke(() => t.value, (b, p) => {
    const { remote: f, valueKey: m } = n.props;
    if (Object.is(b, p) || (n.onOptionDestroy(p, c.proxy), n.onOptionCreate(c.proxy)), !t.created && !f) {
      if (m && wn(b) && wn(p) && b[m] === p[m])
        return;
      n.setSelected();
    }
  }), ke(() => r.disabled, () => {
    e.groupDisabled = r.disabled;
  }, { immediate: !0 });
  const { queryChange: y } = yi(n);
  return ke(y, (b) => {
    const { query: p } = x(b), f = new RegExp(AS(p), "i");
    e.visible = f.test(a.value) || t.created, e.visible || n.filteredOptionsCount--;
  }, { immediate: !0 }), {
    select: n,
    currentLabel: a,
    currentValue: l,
    itemSelected: s,
    isDisabled: u,
    hoverItem: v
  };
}
const S3 = be({
  name: "ElOption",
  componentName: "ElOption",
  props: {
    value: {
      required: !0,
      type: [String, Number, Boolean, Object]
    },
    label: [String, Number],
    created: Boolean,
    disabled: Boolean
  },
  setup(t) {
    const e = Fe("select"), n = Jo(), r = F(() => [
      e.be("dropdown", "item"),
      e.is("disabled", x(a)),
      {
        selected: x(o),
        hover: x(d)
      }
    ]), i = Pn({
      index: -1,
      groupDisabled: !1,
      visible: !0,
      hitState: !1,
      hover: !1
    }), { currentLabel: s, itemSelected: o, isDisabled: a, select: l, hoverItem: u } = E3(t, i), { visible: c, hover: d } = hn(i), h = ht().proxy;
    l.onOptionCreate(h), Sn(() => {
      const y = h.value, { selected: b } = l, f = (l.props.multiple ? b : [b]).some((m) => m.value === h.value);
      rt(() => {
        l.cachedOptions.get(y) === h && !f && l.cachedOptions.delete(y);
      }), l.onOptionDestroy(y, h);
    });
    function v() {
      t.disabled !== !0 && i.groupDisabled !== !0 && l.handleOptionSelect(h);
    }
    return {
      ns: e,
      id: n,
      containerKls: r,
      currentLabel: s,
      itemSelected: o,
      isDisabled: a,
      select: l,
      hoverItem: u,
      visible: c,
      hover: d,
      selectOptionClick: v,
      states: i
    };
  }
}), x3 = ["id", "aria-disabled", "aria-selected"];
function C3(t, e, n, r, i, s) {
  return $t((V(), se("li", {
    id: t.id,
    class: ee(t.containerKls),
    role: "option",
    "aria-disabled": t.isDisabled || void 0,
    "aria-selected": t.itemSelected,
    onMouseenter: e[0] || (e[0] = (...o) => t.hoverItem && t.hoverItem(...o)),
    onClick: e[1] || (e[1] = ft((...o) => t.selectOptionClick && t.selectOptionClick(...o), ["stop"]))
  }, [
    De(t.$slots, "default", {}, () => [
      ae("span", null, st(t.currentLabel), 1)
    ])
  ], 42, x3)), [
    [Yn, t.visible]
  ]);
}
var Yd = /* @__PURE__ */ qe(S3, [["render", C3], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option.vue"]]);
const k3 = be({
  name: "ElSelectDropdown",
  componentName: "ElSelectDropdown",
  setup() {
    const t = tt(Ql), e = Fe("select"), n = F(() => t.props.popperClass), r = F(() => t.props.multiple), i = F(() => t.props.fitInputWidth), s = K("");
    function o() {
      var a;
      s.value = `${(a = t.selectWrapper) == null ? void 0 : a.offsetWidth}px`;
    }
    return Tt(() => {
      o(), Cs(t.selectWrapper, o);
    }), {
      ns: e,
      minWidth: s,
      popperClass: n,
      isMultiple: r,
      isFitInputWidth: i
    };
  }
});
function T3(t, e, n, r, i, s) {
  return V(), se("div", {
    class: ee([t.ns.b("dropdown"), t.ns.is("multiple", t.isMultiple), t.popperClass]),
    style: it({ [t.isFitInputWidth ? "width" : "minWidth"]: t.minWidth })
  }, [
    De(t.$slots, "default")
  ], 6);
}
var O3 = /* @__PURE__ */ qe(k3, [["render", T3], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select-dropdown.vue"]]);
function N3(t) {
  const { t: e } = or();
  return Pn({
    options: /* @__PURE__ */ new Map(),
    cachedOptions: /* @__PURE__ */ new Map(),
    disabledOptions: /* @__PURE__ */ new Map(),
    createdLabel: null,
    createdSelected: !1,
    selected: t.multiple ? [] : {},
    inputLength: 20,
    inputWidth: 0,
    optionsCount: 0,
    filteredOptionsCount: 0,
    visible: !1,
    selectedLabel: "",
    hoverIndex: -1,
    query: "",
    previousQuery: null,
    inputHovering: !1,
    cachedPlaceHolder: "",
    currentPlaceholder: e("el.select.placeholder"),
    menuVisibleOnFocus: !1,
    isOnComposition: !1,
    prefixWidth: 11,
    mouseEnter: !1,
    focused: !1
  });
}
const A3 = (t, e, n) => {
  const { t: r } = or(), i = Fe("select");
  vm({
    from: "suffixTransition",
    replacement: "override style scheme",
    version: "2.3.0",
    scope: "props",
    ref: "https://element-plus.org/en-US/component/select.html#select-attributes"
  }, F(() => t.suffixTransition === !1));
  const s = K(null), o = K(null), a = K(null), l = K(null), u = K(null), c = K(null), d = K(null), h = K(null), v = K(), y = Mn({ query: "" }), b = Mn(""), p = K([]);
  let f = 0;
  const { form: m, formItem: g } = oi(), w = F(() => !t.filterable || t.multiple || !e.visible), _ = F(() => t.disabled || (m == null ? void 0 : m.disabled)), E = F(() => {
    const B = t.multiple ? Array.isArray(t.modelValue) && t.modelValue.length > 0 : t.modelValue !== void 0 && t.modelValue !== null && t.modelValue !== "";
    return t.clearable && !_.value && e.inputHovering && B;
  }), C = F(() => t.remote && t.filterable && !t.remoteShowSuffix ? "" : t.suffixIcon), T = F(() => i.is("reverse", C.value && e.visible && t.suffixTransition)), k = F(() => (m == null ? void 0 : m.statusIcon) && (g == null ? void 0 : g.validateState) && fm[g == null ? void 0 : g.validateState]), N = F(() => t.remote ? 300 : 0), I = F(() => t.loading ? t.loadingText || r("el.select.loading") : t.remote && e.query === "" && e.options.size === 0 ? !1 : t.filterable && e.query && e.options.size > 0 && e.filteredOptionsCount === 0 ? t.noMatchText || r("el.select.noMatch") : e.options.size === 0 ? t.noDataText || r("el.select.noData") : null), P = F(() => {
    const B = Array.from(e.options.values()), oe = [];
    return p.value.forEach((S) => {
      const Z = B.findIndex((ie) => ie.currentLabel === S);
      Z > -1 && oe.push(B[Z]);
    }), oe.length >= B.length ? oe : B;
  }), D = F(() => Array.from(e.cachedOptions.values())), z = F(() => {
    const B = P.value.filter((oe) => !oe.created).some((oe) => oe.currentLabel === e.query);
    return t.filterable && t.allowCreate && e.query !== "" && !B;
  }), G = Lr(), J = F(() => ["small"].includes(G.value) ? "small" : "default"), M = F({
    get() {
      return e.visible && I.value !== !1;
    },
    set(B) {
      e.visible = B;
    }
  });
  ke([() => _.value, () => G.value, () => m == null ? void 0 : m.size], () => {
    rt(() => {
      U();
    });
  }), ke(() => t.placeholder, (B) => {
    e.cachedPlaceHolder = e.currentPlaceholder = B, t.multiple && Array.isArray(t.modelValue) && t.modelValue.length > 0 && (e.currentPlaceholder = "");
  }), ke(() => t.modelValue, (B, oe) => {
    t.multiple && (U(), B && B.length > 0 || o.value && e.query !== "" ? e.currentPlaceholder = "" : e.currentPlaceholder = e.cachedPlaceHolder, t.filterable && !t.reserveKeyword && (e.query = "", j(e.query))), Y(), t.filterable && !t.multiple && (e.inputLength = 20), !ll(B, oe) && t.validateEvent && (g == null || g.validate("change").catch((S) => Vt(S)));
  }, {
    flush: "post",
    deep: !0
  }), ke(() => e.visible, (B) => {
    var oe, S, Z, ie, A;
    B ? ((S = (oe = l.value) == null ? void 0 : oe.updatePopper) == null || S.call(oe), t.filterable && (e.filteredOptionsCount = e.optionsCount, e.query = t.remote ? "" : e.selectedLabel, (ie = (Z = a.value) == null ? void 0 : Z.focus) == null || ie.call(Z), t.multiple ? (A = o.value) == null || A.focus() : e.selectedLabel && (e.currentPlaceholder = `${e.selectedLabel}`, e.selectedLabel = ""), j(e.query), !t.multiple && !t.remote && (y.value.query = "", Gs(y), Gs(b)))) : (t.filterable && (mn(t.filterMethod) && t.filterMethod(""), mn(t.remoteMethod) && t.remoteMethod("")), e.query = "", e.previousQuery = null, e.selectedLabel = "", e.inputLength = 20, e.menuVisibleOnFocus = !1, ce(), rt(() => {
      o.value && o.value.value === "" && e.selected.length === 0 && (e.currentPlaceholder = e.cachedPlaceHolder);
    }), t.multiple || (e.selected && (t.filterable && t.allowCreate && e.createdSelected && e.createdLabel ? e.selectedLabel = e.createdLabel : e.selectedLabel = e.selected.currentLabel, t.filterable && (e.query = e.selectedLabel)), t.filterable && (e.currentPlaceholder = e.cachedPlaceHolder))), n.emit("visible-change", B);
  }), ke(() => e.options.entries(), () => {
    var B, oe, S;
    if (!Et)
      return;
    (oe = (B = l.value) == null ? void 0 : B.updatePopper) == null || oe.call(B), t.multiple && U();
    const Z = ((S = d.value) == null ? void 0 : S.querySelectorAll("input")) || [];
    (!t.filterable && !t.defaultFirstOption && !Er(t.modelValue) || !Array.from(Z).includes(document.activeElement)) && Y(), t.defaultFirstOption && (t.filterable || t.remote) && e.filteredOptionsCount && fe();
  }, {
    flush: "post"
  }), ke(() => e.hoverIndex, (B) => {
    gt(B) && B > -1 ? v.value = P.value[B] || {} : v.value = {}, P.value.forEach((oe) => {
      oe.hover = v.value === oe;
    });
  });
  const U = () => {
    rt(() => {
      var B, oe;
      if (!s.value)
        return;
      const S = s.value.$el.querySelector("input");
      f = f || (S.clientHeight > 0 ? S.clientHeight + 2 : 0);
      const Z = c.value, ie = getComputedStyle(S).getPropertyValue(i.cssVarName("input-height")), A = Number.parseFloat(ie) || Qk(G.value || (m == null ? void 0 : m.size)), W = G.value || A === f || f <= 0 ? A : f;
      !(S.offsetParent === null) && (S.style.height = `${(e.selected.length === 0 ? W : Math.max(Z ? Z.clientHeight + (Z.clientHeight > W ? 6 : 0) : 0, W)) - 2}px`), e.visible && I.value !== !1 && ((oe = (B = l.value) == null ? void 0 : B.updatePopper) == null || oe.call(B));
    });
  }, j = async (B) => {
    if (!(e.previousQuery === B || e.isOnComposition)) {
      if (e.previousQuery === null && (mn(t.filterMethod) || mn(t.remoteMethod))) {
        e.previousQuery = B;
        return;
      }
      e.previousQuery = B, rt(() => {
        var oe, S;
        e.visible && ((S = (oe = l.value) == null ? void 0 : oe.updatePopper) == null || S.call(oe));
      }), e.hoverIndex = -1, t.multiple && t.filterable && rt(() => {
        if (!_.value) {
          const oe = o.value.value.length * 15 + 20;
          e.inputLength = t.collapseTags ? Math.min(50, oe) : oe, re();
        }
        U();
      }), t.remote && mn(t.remoteMethod) ? (e.hoverIndex = -1, t.remoteMethod(B)) : mn(t.filterMethod) ? (t.filterMethod(B), Gs(b)) : (e.filteredOptionsCount = e.optionsCount, y.value.query = B, Gs(y), Gs(b)), t.defaultFirstOption && (t.filterable || t.remote) && e.filteredOptionsCount && (await rt(), fe());
    }
  }, re = () => {
    e.currentPlaceholder !== "" && (e.currentPlaceholder = o.value.value ? "" : e.cachedPlaceHolder);
  }, fe = () => {
    const B = P.value.filter((Z) => Z.visible && !Z.disabled && !Z.states.groupDisabled), oe = B.find((Z) => Z.created), S = B[0];
    e.hoverIndex = It(P.value, oe || S);
  }, Y = () => {
    var B;
    if (t.multiple)
      e.selectedLabel = "";
    else {
      const S = le(t.modelValue);
      (B = S.props) != null && B.created ? (e.createdLabel = S.props.value, e.createdSelected = !0) : e.createdSelected = !1, e.selectedLabel = S.currentLabel, e.selected = S, t.filterable && (e.query = e.selectedLabel);
      return;
    }
    const oe = [];
    Array.isArray(t.modelValue) && t.modelValue.forEach((S) => {
      oe.push(le(S));
    }), e.selected = oe, rt(() => {
      U();
    });
  }, le = (B) => {
    let oe;
    const S = hu(B).toLowerCase() === "object", Z = hu(B).toLowerCase() === "null", ie = hu(B).toLowerCase() === "undefined";
    for (let ne = e.cachedOptions.size - 1; ne >= 0; ne--) {
      const Le = D.value[ne];
      if (S ? Cn(Le.value, t.valueKey) === Cn(B, t.valueKey) : Le.value === B) {
        oe = {
          value: B,
          currentLabel: Le.currentLabel,
          isDisabled: Le.isDisabled
        };
        break;
      }
    }
    if (oe)
      return oe;
    const A = S ? B.label : !Z && !ie ? B : "", W = {
      value: B,
      currentLabel: A
    };
    return t.multiple && (W.hitState = !1), W;
  }, ce = () => {
    setTimeout(() => {
      const B = t.valueKey;
      t.multiple ? e.selected.length > 0 ? e.hoverIndex = Math.min.apply(null, e.selected.map((oe) => P.value.findIndex((S) => Cn(S, B) === Cn(oe, B)))) : e.hoverIndex = -1 : e.hoverIndex = P.value.findIndex((oe) => Ze(oe) === Ze(e.selected));
    }, 300);
  }, me = () => {
    var B, oe;
    _e(), (oe = (B = l.value) == null ? void 0 : B.updatePopper) == null || oe.call(B), t.multiple && U();
  }, _e = () => {
    var B;
    e.inputWidth = (B = s.value) == null ? void 0 : B.$el.offsetWidth;
  }, ze = () => {
    t.filterable && e.query !== e.selectedLabel && (e.query = e.selectedLabel, j(e.query));
  }, Oe = Xr(() => {
    ze();
  }, N.value), Qe = Xr((B) => {
    j(B.target.value);
  }, N.value), Be = (B) => {
    ll(t.modelValue, B) || n.emit(Yi, B);
  }, He = (B) => gS(B, (oe) => !e.disabledOptions.has(oe)), ct = (B) => {
    if (B.code !== sn.delete) {
      if (B.target.value.length <= 0 && !lt()) {
        const oe = t.modelValue.slice(), S = He(oe);
        if (S < 0)
          return;
        oe.splice(S, 1), n.emit(Pt, oe), Be(oe);
      }
      B.target.value.length === 1 && t.modelValue.length === 0 && (e.currentPlaceholder = e.cachedPlaceHolder);
    }
  }, nt = (B, oe) => {
    const S = e.selected.indexOf(oe);
    if (S > -1 && !_.value) {
      const Z = t.modelValue.slice();
      Z.splice(S, 1), n.emit(Pt, Z), Be(Z), n.emit("remove-tag", oe.value);
    }
    B.stopPropagation(), Ue();
  }, St = (B) => {
    B.stopPropagation();
    const oe = t.multiple ? [] : "";
    if (!qt(oe))
      for (const S of e.selected)
        S.isDisabled && oe.push(S.value);
    n.emit(Pt, oe), Be(oe), e.hoverIndex = -1, e.visible = !1, n.emit("clear"), Ue();
  }, yt = (B) => {
    var oe;
    if (t.multiple) {
      const S = (t.modelValue || []).slice(), Z = It(S, B.value);
      Z > -1 ? S.splice(Z, 1) : (t.multipleLimit <= 0 || S.length < t.multipleLimit) && S.push(B.value), n.emit(Pt, S), Be(S), B.created && (e.query = "", j(""), e.inputLength = 20), t.filterable && ((oe = o.value) == null || oe.focus());
    } else
      n.emit(Pt, B.value), Be(B.value), e.visible = !1;
    ot(), !e.visible && rt(() => {
      bt(B);
    });
  }, It = (B = [], oe) => {
    if (!wn(oe))
      return B.indexOf(oe);
    const S = t.valueKey;
    let Z = -1;
    return B.some((ie, A) => yi(Cn(ie, S)) === Cn(oe, S) ? (Z = A, !0) : !1), Z;
  }, ot = () => {
    const B = o.value || s.value;
    B && (B == null || B.focus());
  }, bt = (B) => {
    var oe, S, Z, ie, A;
    const W = Array.isArray(B) ? B[0] : B;
    let ne = null;
    if (W != null && W.value) {
      const Le = P.value.filter((Ne) => Ne.value === W.value);
      Le.length > 0 && (ne = Le[0].$el);
    }
    if (l.value && ne) {
      const Le = (ie = (Z = (S = (oe = l.value) == null ? void 0 : oe.popperRef) == null ? void 0 : S.contentRef) == null ? void 0 : Z.querySelector) == null ? void 0 : ie.call(Z, `.${i.be("dropdown", "wrap")}`);
      Le && DS(Le, ne);
    }
    (A = h.value) == null || A.handleScroll();
  }, Kt = (B) => {
    e.optionsCount++, e.filteredOptionsCount++, e.options.set(B.value, B), e.cachedOptions.set(B.value, B), B.disabled && e.disabledOptions.set(B.value, B);
  }, wt = (B, oe) => {
    e.options.get(B) === oe && (e.optionsCount--, e.filteredOptionsCount--, e.options.delete(B));
  }, xt = (B) => {
    B.code !== sn.backspace && lt(!1), e.inputLength = o.value.value.length * 15 + 20, U();
  }, lt = (B) => {
    if (!Array.isArray(e.selected))
      return;
    const oe = He(e.selected.map((Z) => Z.value)), S = e.selected[oe];
    if (S)
      return B === !0 || B === !1 ? (S.hitState = B, B) : (S.hitState = !S.hitState, S.hitState);
  }, Ge = (B) => {
    const oe = B.target.value;
    if (B.type === "compositionend")
      e.isOnComposition = !1, rt(() => j(oe));
    else {
      const S = oe[oe.length - 1] || "";
      e.isOnComposition = !hm(S);
    }
  }, Rt = () => {
    rt(() => bt(e.selected));
  }, we = (B) => {
    e.focused || ((t.automaticDropdown || t.filterable) && (t.filterable && !e.visible && (e.menuVisibleOnFocus = !0), e.visible = !0), e.focused = !0, n.emit("focus", B));
  }, Ue = () => {
    var B, oe;
    e.visible ? (B = o.value || s.value) == null || B.focus() : (oe = s.value) == null || oe.focus();
  }, at = () => {
    var B, oe, S;
    e.visible = !1, (B = s.value) == null || B.blur(), (S = (oe = a.value) == null ? void 0 : oe.blur) == null || S.call(oe);
  }, Lt = (B) => {
    var oe, S, Z;
    (oe = l.value) != null && oe.isFocusInsideContent(B) || (S = u.value) != null && S.isFocusInsideContent(B) || (Z = d.value) != null && Z.contains(B.relatedTarget) || (e.visible && Ae(), e.focused = !1, n.emit("blur", B));
  }, Zt = (B) => {
    St(B);
  }, Ae = () => {
    e.visible = !1;
  }, Ve = (B) => {
    e.visible && (B.preventDefault(), B.stopPropagation(), e.visible = !1);
  }, Ye = (B) => {
    B && !e.mouseEnter || _.value || (e.menuVisibleOnFocus ? e.menuVisibleOnFocus = !1 : (!l.value || !l.value.isFocusInsideContent()) && (e.visible = !e.visible), Ue());
  }, je = () => {
    e.visible ? P.value[e.hoverIndex] && yt(P.value[e.hoverIndex]) : Ye();
  }, Ze = (B) => wn(B.value) ? Cn(B.value, t.valueKey) : B.value, Ct = F(() => P.value.filter((B) => B.visible).every((B) => B.disabled)), L = F(() => t.multiple ? e.selected.slice(0, t.maxCollapseTags) : []), he = F(() => t.multiple ? e.selected.slice(t.maxCollapseTags) : []), ge = (B) => {
    if (!e.visible) {
      e.visible = !0;
      return;
    }
    if (!(e.options.size === 0 || e.filteredOptionsCount === 0) && !e.isOnComposition && !Ct.value) {
      B === "next" ? (e.hoverIndex++, e.hoverIndex === e.options.size && (e.hoverIndex = 0)) : B === "prev" && (e.hoverIndex--, e.hoverIndex < 0 && (e.hoverIndex = e.options.size - 1));
      const oe = P.value[e.hoverIndex];
      (oe.disabled === !0 || oe.states.groupDisabled === !0 || !oe.visible) && ge(B), rt(() => bt(v.value));
    }
  }, Ie = () => {
    e.mouseEnter = !0;
  }, q = () => {
    e.mouseEnter = !1;
  }, ue = (B, oe) => {
    var S, Z;
    nt(B, oe), (Z = (S = u.value) == null ? void 0 : S.updatePopper) == null || Z.call(S);
  }, O = F(() => ({
    maxWidth: `${x(e.inputWidth) - 32 - (k.value ? 22 : 0)}px`,
    width: "100%"
  }));
  return {
    optionList: p,
    optionsArray: P,
    hoverOption: v,
    selectSize: G,
    handleResize: me,
    debouncedOnInputChange: Oe,
    debouncedQueryChange: Qe,
    deletePrevTag: ct,
    deleteTag: nt,
    deleteSelected: St,
    handleOptionSelect: yt,
    scrollToOption: bt,
    readonly: w,
    resetInputHeight: U,
    showClose: E,
    iconComponent: C,
    iconReverse: T,
    showNewOption: z,
    collapseTagSize: J,
    setSelected: Y,
    managePlaceholder: re,
    selectDisabled: _,
    emptyText: I,
    toggleLastOptionHitState: lt,
    resetInputState: xt,
    handleComposition: Ge,
    onOptionCreate: Kt,
    onOptionDestroy: wt,
    handleMenuEnter: Rt,
    handleFocus: we,
    focus: Ue,
    blur: at,
    handleBlur: Lt,
    handleClearClick: Zt,
    handleClose: Ae,
    handleKeydownEscape: Ve,
    toggleMenu: Ye,
    selectOption: je,
    getValueKey: Ze,
    navigateOptions: ge,
    handleDeleteTooltipTag: ue,
    dropMenuVisible: M,
    queryChange: y,
    groupQueryChange: b,
    showTagList: L,
    collapseTagList: he,
    selectTagsStyle: O,
    reference: s,
    input: o,
    iOSInput: a,
    tooltipRef: l,
    tagTooltipRef: u,
    tags: c,
    selectWrapper: d,
    scrollbar: h,
    handleMouseEnter: Ie,
    handleMouseLeave: q
  };
};
var I3 = be({
  name: "ElOptions",
  emits: ["update-options"],
  setup(t, { slots: e, emit: n }) {
    let r = [];
    function i(s, o) {
      if (s.length !== o.length)
        return !1;
      for (const [a] of s.entries())
        if (s[a] != o[a])
          return !1;
      return !0;
    }
    return () => {
      var s, o;
      const a = (s = e.default) == null ? void 0 : s.call(e), l = [];
      function u(c) {
        Array.isArray(c) && c.forEach((d) => {
          var h, v, y, b;
          const p = (h = (d == null ? void 0 : d.type) || {}) == null ? void 0 : h.name;
          p === "ElOptionGroup" ? u(!qt(d.children) && !Array.isArray(d.children) && mn((v = d.children) == null ? void 0 : v.default) ? (y = d.children) == null ? void 0 : y.default() : d.children) : p === "ElOption" ? l.push((b = d.props) == null ? void 0 : b.label) : Array.isArray(d.children) && u(d.children);
        });
      }
      return a.length && u((o = a[0]) == null ? void 0 : o.children), i(l, r) || (r = l, n("update-options", l)), a;
    };
  }
});
const ip = "ElSelect", R3 = be({
  name: ip,
  componentName: ip,
  components: {
    ElInput: Yl,
    ElSelectMenu: O3,
    ElOption: Yd,
    ElOptions: I3,
    ElTag: xI,
    ElScrollbar: Wd,
    ElTooltip: Zl,
    ElIcon: _t
  },
  directives: { ClickOutside: Qm },
  props: {
    name: String,
    id: String,
    modelValue: {
      type: [Array, String, Number, Boolean, Object],
      default: void 0
    },
    autocomplete: {
      type: String,
      default: "off"
    },
    automaticDropdown: Boolean,
    size: {
      type: String,
      validator: Jk
    },
    effect: {
      type: String,
      default: "light"
    },
    disabled: Boolean,
    clearable: Boolean,
    filterable: Boolean,
    allowCreate: Boolean,
    loading: Boolean,
    popperClass: {
      type: String,
      default: ""
    },
    popperOptions: {
      type: Object,
      default: () => ({})
    },
    remote: Boolean,
    loadingText: String,
    noMatchText: String,
    noDataText: String,
    remoteMethod: Function,
    filterMethod: Function,
    multiple: Boolean,
    multipleLimit: {
      type: Number,
      default: 0
    },
    placeholder: {
      type: String
    },
    defaultFirstOption: Boolean,
    reserveKeyword: {
      type: Boolean,
      default: !0
    },
    valueKey: {
      type: String,
      default: "value"
    },
    collapseTags: Boolean,
    collapseTagsTooltip: Boolean,
    maxCollapseTags: {
      type: Number,
      default: 1
    },
    teleported: Kn.teleported,
    persistent: {
      type: Boolean,
      default: !0
    },
    clearIcon: {
      type: bi,
      default: Wl
    },
    fitInputWidth: Boolean,
    suffixIcon: {
      type: bi,
      default: Nd
    },
    tagType: { ...gg.type, default: "info" },
    validateEvent: {
      type: Boolean,
      default: !0
    },
    remoteShowSuffix: Boolean,
    suffixTransition: {
      type: Boolean,
      default: !0
    },
    placement: {
      type: String,
      values: Fs,
      default: "bottom-start"
    },
    ariaLabel: {
      type: String,
      default: void 0
    }
  },
  emits: [
    Pt,
    Yi,
    "remove-tag",
    "clear",
    "visible-change",
    "focus",
    "blur"
  ],
  setup(t, e) {
    const n = Fe("select"), r = Fe("input"), { t: i } = or(), s = Jo(), o = N3(t), {
      optionList: a,
      optionsArray: l,
      hoverOption: u,
      selectSize: c,
      readonly: d,
      handleResize: h,
      collapseTagSize: v,
      debouncedOnInputChange: y,
      debouncedQueryChange: b,
      deletePrevTag: p,
      deleteTag: f,
      deleteSelected: m,
      handleOptionSelect: g,
      scrollToOption: w,
      setSelected: _,
      resetInputHeight: E,
      managePlaceholder: C,
      showClose: T,
      selectDisabled: k,
      iconComponent: N,
      iconReverse: I,
      showNewOption: P,
      emptyText: D,
      toggleLastOptionHitState: z,
      resetInputState: G,
      handleComposition: J,
      onOptionCreate: M,
      onOptionDestroy: U,
      handleMenuEnter: j,
      handleFocus: re,
      focus: fe,
      blur: Y,
      handleBlur: le,
      handleClearClick: ce,
      handleClose: me,
      handleKeydownEscape: _e,
      toggleMenu: ze,
      selectOption: Oe,
      getValueKey: Qe,
      navigateOptions: Be,
      handleDeleteTooltipTag: He,
      dropMenuVisible: ct,
      reference: nt,
      input: St,
      iOSInput: yt,
      tooltipRef: It,
      tagTooltipRef: ot,
      tags: bt,
      selectWrapper: Kt,
      scrollbar: wt,
      queryChange: xt,
      groupQueryChange: lt,
      handleMouseEnter: Ge,
      handleMouseLeave: Rt,
      showTagList: we,
      collapseTagList: Ue,
      selectTagsStyle: at
    } = A3(t, o, e), {
      inputWidth: Lt,
      selected: Zt,
      inputLength: Ae,
      filteredOptionsCount: Ve,
      visible: Ye,
      selectedLabel: je,
      hoverIndex: Ze,
      query: Ct,
      inputHovering: L,
      currentPlaceholder: he,
      menuVisibleOnFocus: ge,
      isOnComposition: Ie,
      options: q,
      cachedOptions: ue,
      optionsCount: O,
      prefixWidth: B
    } = hn(o), oe = F(() => {
      const Xe = [n.b()], ln = x(c);
      return ln && Xe.push(n.m(ln)), t.disabled && Xe.push(n.m("disabled")), Xe;
    }), S = F(() => [
      n.e("tags"),
      n.is("disabled", x(k))
    ]), Z = F(() => [
      n.b("tags-wrapper"),
      { "has-prefix": x(B) && x(Zt).length }
    ]), ie = F(() => [
      n.e("input"),
      n.is(x(c)),
      n.is("disabled", x(k))
    ]), A = F(() => [
      n.e("input"),
      n.is(x(c)),
      n.em("input", "iOS")
    ]), W = F(() => [
      n.is("empty", !t.allowCreate && !!x(Ct) && x(Ve) === 0)
    ]), ne = F(() => ({ maxWidth: `${x(Lt) > 123 ? x(Lt) - 123 : x(Lt) - 75}px` })), Le = F(() => ({
      marginLeft: `${x(B)}px`,
      flexGrow: 1,
      width: `${x(Ae) / (x(Lt) - 32)}%`,
      maxWidth: `${x(Lt) - 42}px`
    }));
    Gt(Ql, Pn({
      props: t,
      options: q,
      optionsArray: l,
      cachedOptions: ue,
      optionsCount: O,
      filteredOptionsCount: Ve,
      hoverIndex: Ze,
      handleOptionSelect: g,
      onOptionCreate: M,
      onOptionDestroy: U,
      selectWrapper: Kt,
      selected: Zt,
      setSelected: _,
      queryChange: xt,
      groupQueryChange: lt
    })), Tt(() => {
      o.cachedPlaceHolder = he.value = t.placeholder || (() => i("el.select.placeholder")), t.multiple && Array.isArray(t.modelValue) && t.modelValue.length > 0 && (he.value = ""), Cs(Kt, h), t.remote && t.multiple && E(), rt(() => {
        const Xe = nt.value && nt.value.$el;
        if (Xe && (Lt.value = Xe.getBoundingClientRect().width, e.slots.prefix)) {
          const ln = Xe.querySelector(`.${r.e("prefix")}`);
          B.value = Math.max(ln.getBoundingClientRect().width + 11, 30);
        }
      }), _();
    }), t.multiple && !Array.isArray(t.modelValue) && e.emit(Pt, []), !t.multiple && Array.isArray(t.modelValue) && e.emit(Pt, "");
    const Ne = F(() => {
      var Xe, ln;
      return (ln = (Xe = It.value) == null ? void 0 : Xe.popperRef) == null ? void 0 : ln.contentRef;
    });
    return {
      isIOS: Ev,
      onOptionsRendered: (Xe) => {
        a.value = Xe;
      },
      prefixWidth: B,
      selectSize: c,
      readonly: d,
      handleResize: h,
      collapseTagSize: v,
      debouncedOnInputChange: y,
      debouncedQueryChange: b,
      deletePrevTag: p,
      deleteTag: f,
      handleDeleteTooltipTag: He,
      deleteSelected: m,
      handleOptionSelect: g,
      scrollToOption: w,
      inputWidth: Lt,
      selected: Zt,
      inputLength: Ae,
      filteredOptionsCount: Ve,
      visible: Ye,
      selectedLabel: je,
      hoverIndex: Ze,
      query: Ct,
      inputHovering: L,
      currentPlaceholder: he,
      menuVisibleOnFocus: ge,
      isOnComposition: Ie,
      options: q,
      resetInputHeight: E,
      managePlaceholder: C,
      showClose: T,
      selectDisabled: k,
      iconComponent: N,
      iconReverse: I,
      showNewOption: P,
      emptyText: D,
      toggleLastOptionHitState: z,
      resetInputState: G,
      handleComposition: J,
      handleMenuEnter: j,
      handleFocus: re,
      focus: fe,
      blur: Y,
      handleBlur: le,
      handleClearClick: ce,
      handleClose: me,
      handleKeydownEscape: _e,
      toggleMenu: ze,
      selectOption: Oe,
      getValueKey: Qe,
      navigateOptions: Be,
      dropMenuVisible: ct,
      reference: nt,
      input: St,
      iOSInput: yt,
      tooltipRef: It,
      popperPaneRef: Ne,
      tags: bt,
      selectWrapper: Kt,
      scrollbar: wt,
      wrapperKls: oe,
      tagsKls: S,
      tagWrapperKls: Z,
      inputKls: ie,
      iOSInputKls: A,
      scrollbarKls: W,
      selectTagsStyle: at,
      nsSelect: n,
      tagTextStyle: ne,
      inputStyle: Le,
      handleMouseEnter: Ge,
      handleMouseLeave: Rt,
      showTagList: we,
      collapseTagList: Ue,
      tagTooltipRef: ot,
      contentId: s,
      hoverOption: u
    };
  }
}), L3 = ["disabled", "autocomplete", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label"], P3 = ["disabled"], $3 = { style: { height: "100%", display: "flex", "justify-content": "center", "align-items": "center" } };
function D3(t, e, n, r, i, s) {
  const o = Dt("el-tag"), a = Dt("el-tooltip"), l = Dt("el-icon"), u = Dt("el-input"), c = Dt("el-option"), d = Dt("el-options"), h = Dt("el-scrollbar"), v = Dt("el-select-menu"), y = ud("click-outside");
  return $t((V(), se("div", {
    ref: "selectWrapper",
    class: ee(t.wrapperKls),
    onMouseenter: e[22] || (e[22] = (...b) => t.handleMouseEnter && t.handleMouseEnter(...b)),
    onMouseleave: e[23] || (e[23] = (...b) => t.handleMouseLeave && t.handleMouseLeave(...b)),
    onClick: e[24] || (e[24] = ft((...b) => t.toggleMenu && t.toggleMenu(...b), ["stop"]))
  }, [
    ve(a, {
      ref: "tooltipRef",
      visible: t.dropMenuVisible,
      placement: t.placement,
      teleported: t.teleported,
      "popper-class": [t.nsSelect.e("popper"), t.popperClass],
      "popper-options": t.popperOptions,
      "fallback-placements": ["bottom-start", "top-start", "right", "left"],
      effect: t.effect,
      pure: "",
      trigger: "click",
      transition: `${t.nsSelect.namespace.value}-zoom-in-top`,
      "stop-popper-mouse-event": !1,
      "gpu-acceleration": !1,
      persistent: t.persistent,
      onShow: t.handleMenuEnter
    }, {
      default: de(() => {
        var b, p;
        return [
          ae("div", {
            class: "select-trigger",
            onMouseenter: e[20] || (e[20] = (f) => t.inputHovering = !0),
            onMouseleave: e[21] || (e[21] = (f) => t.inputHovering = !1)
          }, [
            t.multiple ? (V(), se("div", {
              key: 0,
              ref: "tags",
              tabindex: "-1",
              class: ee(t.tagsKls),
              style: it(t.selectTagsStyle),
              onClick: e[15] || (e[15] = (...f) => t.focus && t.focus(...f))
            }, [
              t.collapseTags && t.selected.length ? (V(), Ce(gr, {
                key: 0,
                onAfterLeave: t.resetInputHeight
              }, {
                default: de(() => [
                  ae("span", {
                    class: ee(t.tagWrapperKls)
                  }, [
                    (V(!0), se(Ft, null, Gn(t.showTagList, (f) => (V(), Ce(o, {
                      key: t.getValueKey(f),
                      closable: !t.selectDisabled && !f.isDisabled,
                      size: t.collapseTagSize,
                      hit: f.hitState,
                      type: t.tagType,
                      "disable-transitions": "",
                      onClose: (m) => t.deleteTag(m, f)
                    }, {
                      default: de(() => [
                        ae("span", {
                          class: ee(t.nsSelect.e("tags-text")),
                          style: it(t.tagTextStyle)
                        }, st(f.currentLabel), 7)
                      ]),
                      _: 2
                    }, 1032, ["closable", "size", "hit", "type", "onClose"]))), 128)),
                    t.selected.length > t.maxCollapseTags ? (V(), Ce(o, {
                      key: 0,
                      closable: !1,
                      size: t.collapseTagSize,
                      type: t.tagType,
                      "disable-transitions": ""
                    }, {
                      default: de(() => [
                        t.collapseTagsTooltip ? (V(), Ce(a, {
                          key: 0,
                          ref: "tagTooltipRef",
                          disabled: t.dropMenuVisible,
                          "fallback-placements": ["bottom", "top", "right", "left"],
                          effect: t.effect,
                          placement: "bottom",
                          teleported: t.teleported
                        }, {
                          default: de(() => [
                            ae("span", {
                              class: ee(t.nsSelect.e("tags-text"))
                            }, "+ " + st(t.selected.length - t.maxCollapseTags), 3)
                          ]),
                          content: de(() => [
                            ae("div", {
                              class: ee(t.nsSelect.e("collapse-tags"))
                            }, [
                              (V(!0), se(Ft, null, Gn(t.collapseTagList, (f) => (V(), se("div", {
                                key: t.getValueKey(f),
                                class: ee(t.nsSelect.e("collapse-tag"))
                              }, [
                                ve(o, {
                                  class: "in-tooltip",
                                  closable: !t.selectDisabled && !f.isDisabled,
                                  size: t.collapseTagSize,
                                  hit: f.hitState,
                                  type: t.tagType,
                                  "disable-transitions": "",
                                  style: { margin: "2px" },
                                  onClose: (m) => t.handleDeleteTooltipTag(m, f)
                                }, {
                                  default: de(() => [
                                    ae("span", {
                                      class: ee(t.nsSelect.e("tags-text")),
                                      style: it({
                                        maxWidth: t.inputWidth - 75 + "px"
                                      })
                                    }, st(f.currentLabel), 7)
                                  ]),
                                  _: 2
                                }, 1032, ["closable", "size", "hit", "type", "onClose"])
                              ], 2))), 128))
                            ], 2)
                          ]),
                          _: 1
                        }, 8, ["disabled", "effect", "teleported"])) : (V(), se("span", {
                          key: 1,
                          class: ee(t.nsSelect.e("tags-text"))
                        }, "+ " + st(t.selected.length - t.maxCollapseTags), 3))
                      ]),
                      _: 1
                    }, 8, ["size", "type"])) : ye("v-if", !0)
                  ], 2)
                ]),
                _: 1
              }, 8, ["onAfterLeave"])) : ye("v-if", !0),
              t.collapseTags ? ye("v-if", !0) : (V(), Ce(gr, {
                key: 1,
                onAfterLeave: t.resetInputHeight
              }, {
                default: de(() => [
                  ae("span", {
                    class: ee(t.tagWrapperKls),
                    style: it(t.prefixWidth && t.selected.length ? { marginLeft: `${t.prefixWidth}px` } : "")
                  }, [
                    (V(!0), se(Ft, null, Gn(t.selected, (f) => (V(), Ce(o, {
                      key: t.getValueKey(f),
                      closable: !t.selectDisabled && !f.isDisabled,
                      size: t.collapseTagSize,
                      hit: f.hitState,
                      type: t.tagType,
                      "disable-transitions": "",
                      onClose: (m) => t.deleteTag(m, f)
                    }, {
                      default: de(() => [
                        ae("span", {
                          class: ee(t.nsSelect.e("tags-text")),
                          style: it({ maxWidth: t.inputWidth - 75 + "px" })
                        }, st(f.currentLabel), 7)
                      ]),
                      _: 2
                    }, 1032, ["closable", "size", "hit", "type", "onClose"]))), 128))
                  ], 6)
                ]),
                _: 1
              }, 8, ["onAfterLeave"])),
              t.filterable && !t.selectDisabled ? $t((V(), se("input", {
                key: 2,
                ref: "input",
                "onUpdate:modelValue": e[0] || (e[0] = (f) => t.query = f),
                type: "text",
                class: ee(t.inputKls),
                disabled: t.selectDisabled,
                autocomplete: t.autocomplete,
                style: it(t.inputStyle),
                role: "combobox",
                "aria-activedescendant": ((b = t.hoverOption) == null ? void 0 : b.id) || "",
                "aria-controls": t.contentId,
                "aria-expanded": t.dropMenuVisible,
                "aria-label": t.ariaLabel,
                "aria-autocomplete": "none",
                "aria-haspopup": "listbox",
                onFocus: e[1] || (e[1] = (...f) => t.handleFocus && t.handleFocus(...f)),
                onBlur: e[2] || (e[2] = (...f) => t.handleBlur && t.handleBlur(...f)),
                onKeyup: e[3] || (e[3] = (...f) => t.managePlaceholder && t.managePlaceholder(...f)),
                onKeydown: [
                  e[4] || (e[4] = (...f) => t.resetInputState && t.resetInputState(...f)),
                  e[5] || (e[5] = vn(ft((f) => t.navigateOptions("next"), ["prevent"]), ["down"])),
                  e[6] || (e[6] = vn(ft((f) => t.navigateOptions("prev"), ["prevent"]), ["up"])),
                  e[7] || (e[7] = vn((...f) => t.handleKeydownEscape && t.handleKeydownEscape(...f), ["esc"])),
                  e[8] || (e[8] = vn(ft((...f) => t.selectOption && t.selectOption(...f), ["stop", "prevent"]), ["enter"])),
                  e[9] || (e[9] = vn((...f) => t.deletePrevTag && t.deletePrevTag(...f), ["delete"])),
                  e[10] || (e[10] = vn((f) => t.visible = !1, ["tab"]))
                ],
                onCompositionstart: e[11] || (e[11] = (...f) => t.handleComposition && t.handleComposition(...f)),
                onCompositionupdate: e[12] || (e[12] = (...f) => t.handleComposition && t.handleComposition(...f)),
                onCompositionend: e[13] || (e[13] = (...f) => t.handleComposition && t.handleComposition(...f)),
                onInput: e[14] || (e[14] = (...f) => t.debouncedQueryChange && t.debouncedQueryChange(...f))
              }, null, 46, L3)), [
                [Qy, t.query]
              ]) : ye("v-if", !0)
            ], 6)) : ye("v-if", !0),
            t.isIOS && !t.multiple && t.filterable && t.readonly ? (V(), se("input", {
              key: 1,
              ref: "iOSInput",
              class: ee(t.iOSInputKls),
              disabled: t.selectDisabled,
              type: "text"
            }, null, 10, P3)) : ye("v-if", !0),
            ve(u, {
              id: t.id,
              ref: "reference",
              modelValue: t.selectedLabel,
              "onUpdate:modelValue": e[16] || (e[16] = (f) => t.selectedLabel = f),
              type: "text",
              placeholder: typeof t.currentPlaceholder == "function" ? t.currentPlaceholder() : t.currentPlaceholder,
              name: t.name,
              autocomplete: t.autocomplete,
              size: t.selectSize,
              disabled: t.selectDisabled,
              readonly: t.readonly,
              "validate-event": !1,
              class: ee([t.nsSelect.is("focus", t.visible)]),
              tabindex: t.multiple && t.filterable ? -1 : void 0,
              role: "combobox",
              "aria-activedescendant": ((p = t.hoverOption) == null ? void 0 : p.id) || "",
              "aria-controls": t.contentId,
              "aria-expanded": t.dropMenuVisible,
              label: t.ariaLabel,
              "aria-autocomplete": "none",
              "aria-haspopup": "listbox",
              onFocus: t.handleFocus,
              onBlur: t.handleBlur,
              onInput: t.debouncedOnInputChange,
              onPaste: t.debouncedOnInputChange,
              onCompositionstart: t.handleComposition,
              onCompositionupdate: t.handleComposition,
              onCompositionend: t.handleComposition,
              onKeydown: [
                e[17] || (e[17] = vn(ft((f) => t.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
                e[18] || (e[18] = vn(ft((f) => t.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
                vn(ft(t.selectOption, ["stop", "prevent"]), ["enter"]),
                vn(t.handleKeydownEscape, ["esc"]),
                e[19] || (e[19] = vn((f) => t.visible = !1, ["tab"]))
              ]
            }, Gu({
              suffix: de(() => [
                t.iconComponent && !t.showClose ? (V(), Ce(l, {
                  key: 0,
                  class: ee([t.nsSelect.e("caret"), t.nsSelect.e("icon"), t.iconReverse])
                }, {
                  default: de(() => [
                    (V(), Ce(In(t.iconComponent)))
                  ]),
                  _: 1
                }, 8, ["class"])) : ye("v-if", !0),
                t.showClose && t.clearIcon ? (V(), Ce(l, {
                  key: 1,
                  class: ee([t.nsSelect.e("caret"), t.nsSelect.e("icon")]),
                  onClick: t.handleClearClick
                }, {
                  default: de(() => [
                    (V(), Ce(In(t.clearIcon)))
                  ]),
                  _: 1
                }, 8, ["class", "onClick"])) : ye("v-if", !0)
              ]),
              _: 2
            }, [
              t.$slots.prefix ? {
                name: "prefix",
                fn: de(() => [
                  ae("div", $3, [
                    De(t.$slots, "prefix")
                  ])
                ])
              } : void 0
            ]), 1032, ["id", "modelValue", "placeholder", "name", "autocomplete", "size", "disabled", "readonly", "class", "tabindex", "aria-activedescendant", "aria-controls", "aria-expanded", "label", "onFocus", "onBlur", "onInput", "onPaste", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onKeydown"])
          ], 32)
        ];
      }),
      content: de(() => [
        ve(v, null, {
          default: de(() => [
            $t(ve(h, {
              id: t.contentId,
              ref: "scrollbar",
              tag: "ul",
              "wrap-class": t.nsSelect.be("dropdown", "wrap"),
              "view-class": t.nsSelect.be("dropdown", "list"),
              class: ee(t.scrollbarKls),
              role: "listbox",
              "aria-label": t.ariaLabel,
              "aria-orientation": "vertical"
            }, {
              default: de(() => [
                t.showNewOption ? (V(), Ce(c, {
                  key: 0,
                  value: t.query,
                  created: !0
                }, null, 8, ["value"])) : ye("v-if", !0),
                ve(d, { onUpdateOptions: t.onOptionsRendered }, {
                  default: de(() => [
                    De(t.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["onUpdateOptions"])
              ]),
              _: 3
            }, 8, ["id", "wrap-class", "view-class", "class", "aria-label"]), [
              [Yn, t.options.size > 0 && !t.loading]
            ]),
            t.emptyText && (!t.allowCreate || t.loading || t.allowCreate && t.options.size === 0) ? (V(), se(Ft, { key: 0 }, [
              t.$slots.empty ? De(t.$slots, "empty", { key: 0 }) : (V(), se("p", {
                key: 1,
                class: ee(t.nsSelect.be("dropdown", "empty"))
              }, st(t.emptyText), 3))
            ], 64)) : ye("v-if", !0)
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "effect", "transition", "persistent", "onShow"])
  ], 34)), [
    [y, t.handleClose, t.popperPaneRef]
  ]);
}
var B3 = /* @__PURE__ */ qe(R3, [["render", D3], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select.vue"]]);
const M3 = be({
  name: "ElOptionGroup",
  componentName: "ElOptionGroup",
  props: {
    label: String,
    disabled: Boolean
  },
  setup(t) {
    const e = Fe("select"), n = K(!0), r = ht(), i = K([]);
    Gt(Cg, Pn({
      ...hn(t)
    }));
    const s = tt(Ql);
    Tt(() => {
      i.value = o(r.subTree);
    });
    const o = (l) => {
      const u = [];
      return Array.isArray(l.children) && l.children.forEach((c) => {
        var d;
        c.type && c.type.name === "ElOption" && c.component && c.component.proxy ? u.push(c.component.proxy) : (d = c.children) != null && d.length && u.push(...o(c));
      }), u;
    }, { groupQueryChange: a } = yi(s);
    return ke(a, () => {
      n.value = i.value.some((l) => l.visible === !0);
    }, { flush: "post" }), {
      visible: n,
      ns: e
    };
  }
});
function z3(t, e, n, r, i, s) {
  return $t((V(), se("ul", {
    class: ee(t.ns.be("group", "wrap"))
  }, [
    ae("li", {
      class: ee(t.ns.be("group", "title"))
    }, st(t.label), 3),
    ae("li", null, [
      ae("ul", {
        class: ee(t.ns.b("group"))
      }, [
        De(t.$slots, "default")
      ], 2)
    ])
  ], 2)), [
    [Yn, t.visible]
  ]);
}
var kg = /* @__PURE__ */ qe(M3, [["render", z3], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option-group.vue"]]);
const F3 = nn(B3, {
  Option: Yd,
  OptionGroup: kg
}), j3 = sr(Yd);
sr(kg);
const U3 = ut({
  trigger: Ao.trigger,
  placement: Cu.placement,
  disabled: Ao.disabled,
  visible: Kn.visible,
  transition: Kn.transition,
  popperOptions: Cu.popperOptions,
  tabindex: Cu.tabindex,
  content: Kn.content,
  popperStyle: Kn.popperStyle,
  popperClass: Kn.popperClass,
  enterable: {
    ...Kn.enterable,
    default: !0
  },
  effect: {
    ...Kn.effect,
    default: "light"
  },
  teleported: Kn.teleported,
  title: String,
  width: {
    type: [String, Number],
    default: 150
  },
  offset: {
    type: Number,
    default: void 0
  },
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  autoClose: {
    type: Number,
    default: 0
  },
  showArrow: {
    type: Boolean,
    default: !0
  },
  persistent: {
    type: Boolean,
    default: !0
  },
  "onUpdate:visible": {
    type: Function
  }
}), V3 = {
  "update:visible": (t) => Zr(t),
  "before-enter": () => !0,
  "before-leave": () => !0,
  "after-enter": () => !0,
  "after-leave": () => !0
}, W3 = "onUpdate:visible", H3 = be({
  name: "ElPopover"
}), K3 = /* @__PURE__ */ be({
  ...H3,
  props: U3,
  emits: V3,
  setup(t, { expose: e, emit: n }) {
    const r = t, i = F(() => r[W3]), s = Fe("popover"), o = K(), a = F(() => {
      var p;
      return (p = x(o)) == null ? void 0 : p.popperRef;
    }), l = F(() => [
      {
        width: ul(r.width)
      },
      r.popperStyle
    ]), u = F(() => [s.b(), r.popperClass, { [s.m("plain")]: !!r.content }]), c = F(() => r.transition === `${s.namespace.value}-fade-in-linear`), d = () => {
      var p;
      (p = o.value) == null || p.hide();
    }, h = () => {
      n("before-enter");
    }, v = () => {
      n("before-leave");
    }, y = () => {
      n("after-enter");
    }, b = () => {
      n("update:visible", !1), n("after-leave");
    };
    return e({
      popperRef: a,
      hide: d
    }), (p, f) => (V(), Ce(x(Zl), qn({
      ref_key: "tooltipRef",
      ref: o
    }, p.$attrs, {
      trigger: p.trigger,
      placement: p.placement,
      disabled: p.disabled,
      visible: p.visible,
      transition: p.transition,
      "popper-options": p.popperOptions,
      tabindex: p.tabindex,
      content: p.content,
      offset: p.offset,
      "show-after": p.showAfter,
      "hide-after": p.hideAfter,
      "auto-close": p.autoClose,
      "show-arrow": p.showArrow,
      "aria-label": p.title,
      effect: p.effect,
      enterable: p.enterable,
      "popper-class": x(u),
      "popper-style": x(l),
      teleported: p.teleported,
      persistent: p.persistent,
      "gpu-acceleration": x(c),
      "onUpdate:visible": x(i),
      onBeforeShow: h,
      onBeforeHide: v,
      onShow: y,
      onHide: b
    }), {
      content: de(() => [
        p.title ? (V(), se("div", {
          key: 0,
          class: ee(x(s).e("title")),
          role: "title"
        }, st(p.title), 3)) : ye("v-if", !0),
        De(p.$slots, "default", {}, () => [
          cn(st(p.content), 1)
        ])
      ]),
      default: de(() => [
        p.$slots.reference ? De(p.$slots, "reference", { key: 0 }) : ye("v-if", !0)
      ]),
      _: 3
    }, 16, ["trigger", "placement", "disabled", "visible", "transition", "popper-options", "tabindex", "content", "offset", "show-after", "hide-after", "auto-close", "show-arrow", "aria-label", "effect", "enterable", "popper-class", "popper-style", "teleported", "persistent", "gpu-acceleration", "onUpdate:visible"]));
  }
});
var q3 = /* @__PURE__ */ qe(K3, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popover/src/popover.vue"]]);
const sp = (t, e) => {
  const n = e.arg || e.value, r = n == null ? void 0 : n.popperRef;
  r && (r.triggerRef = t);
};
var G3 = {
  mounted(t, e) {
    sp(t, e);
  },
  updated(t, e) {
    sp(t, e);
  }
};
const Y3 = "popover", Tg = Xk(G3, Y3), ta = nn(q3, {
  directive: Tg
}), X3 = ut({
  type: {
    type: String,
    default: "line",
    values: ["line", "circle", "dashboard"]
  },
  percentage: {
    type: Number,
    default: 0,
    validator: (t) => t >= 0 && t <= 100
  },
  status: {
    type: String,
    default: "",
    values: ["", "success", "exception", "warning"]
  },
  indeterminate: {
    type: Boolean,
    default: !1
  },
  duration: {
    type: Number,
    default: 3
  },
  strokeWidth: {
    type: Number,
    default: 6
  },
  strokeLinecap: {
    type: Pe(String),
    default: "round"
  },
  textInside: {
    type: Boolean,
    default: !1
  },
  width: {
    type: Number,
    default: 126
  },
  showText: {
    type: Boolean,
    default: !0
  },
  color: {
    type: Pe([
      String,
      Array,
      Function
    ]),
    default: ""
  },
  striped: Boolean,
  stripedFlow: Boolean,
  format: {
    type: Pe(Function),
    default: (t) => `${t}%`
  }
}), Z3 = ["aria-valuenow"], Q3 = { viewBox: "0 0 100 100" }, J3 = ["d", "stroke", "stroke-linecap", "stroke-width"], eR = ["d", "stroke", "opacity", "stroke-linecap", "stroke-width"], tR = { key: 0 }, nR = be({
  name: "ElProgress"
}), rR = /* @__PURE__ */ be({
  ...nR,
  props: X3,
  setup(t) {
    const e = t, n = {
      success: "#13ce66",
      exception: "#ff4949",
      warning: "#e6a23c",
      default: "#20a0ff"
    }, r = Fe("progress"), i = F(() => ({
      width: `${e.percentage}%`,
      animationDuration: `${e.duration}s`,
      backgroundColor: m(e.percentage)
    })), s = F(() => (e.strokeWidth / e.width * 100).toFixed(1)), o = F(() => ["circle", "dashboard"].includes(e.type) ? Number.parseInt(`${50 - Number.parseFloat(s.value) / 2}`, 10) : 0), a = F(() => {
      const g = o.value, w = e.type === "dashboard";
      return `
          M 50 50
          m 0 ${w ? "" : "-"}${g}
          a ${g} ${g} 0 1 1 0 ${w ? "-" : ""}${g * 2}
          a ${g} ${g} 0 1 1 0 ${w ? "" : "-"}${g * 2}
          `;
    }), l = F(() => 2 * Math.PI * o.value), u = F(() => e.type === "dashboard" ? 0.75 : 1), c = F(() => `${-1 * l.value * (1 - u.value) / 2}px`), d = F(() => ({
      strokeDasharray: `${l.value * u.value}px, ${l.value}px`,
      strokeDashoffset: c.value
    })), h = F(() => ({
      strokeDasharray: `${l.value * u.value * (e.percentage / 100)}px, ${l.value}px`,
      strokeDashoffset: c.value,
      transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s"
    })), v = F(() => {
      let g;
      return e.color ? g = m(e.percentage) : g = n[e.status] || n.default, g;
    }), y = F(() => e.status === "warning" ? Bk : e.type === "line" ? e.status === "success" ? Id : Wl : e.status === "success" ? om : ko), b = F(() => e.type === "line" ? 12 + e.strokeWidth * 0.4 : e.width * 0.111111 + 2), p = F(() => e.format(e.percentage));
    function f(g) {
      const w = 100 / g.length;
      return g.map((E, C) => qt(E) ? {
        color: E,
        percentage: (C + 1) * w
      } : E).sort((E, C) => E.percentage - C.percentage);
    }
    const m = (g) => {
      var w;
      const { color: _ } = e;
      if (mn(_))
        return _(g);
      if (qt(_))
        return _;
      {
        const E = f(_);
        for (const C of E)
          if (C.percentage > g)
            return C.color;
        return (w = E[E.length - 1]) == null ? void 0 : w.color;
      }
    };
    return (g, w) => (V(), se("div", {
      class: ee([
        x(r).b(),
        x(r).m(g.type),
        x(r).is(g.status),
        {
          [x(r).m("without-text")]: !g.showText,
          [x(r).m("text-inside")]: g.textInside
        }
      ]),
      role: "progressbar",
      "aria-valuenow": g.percentage,
      "aria-valuemin": "0",
      "aria-valuemax": "100"
    }, [
      g.type === "line" ? (V(), se("div", {
        key: 0,
        class: ee(x(r).b("bar"))
      }, [
        ae("div", {
          class: ee(x(r).be("bar", "outer")),
          style: it({ height: `${g.strokeWidth}px` })
        }, [
          ae("div", {
            class: ee([
              x(r).be("bar", "inner"),
              { [x(r).bem("bar", "inner", "indeterminate")]: g.indeterminate },
              { [x(r).bem("bar", "inner", "striped")]: g.striped },
              { [x(r).bem("bar", "inner", "striped-flow")]: g.stripedFlow }
            ]),
            style: it(x(i))
          }, [
            (g.showText || g.$slots.default) && g.textInside ? (V(), se("div", {
              key: 0,
              class: ee(x(r).be("bar", "innerText"))
            }, [
              De(g.$slots, "default", { percentage: g.percentage }, () => [
                ae("span", null, st(x(p)), 1)
              ])
            ], 2)) : ye("v-if", !0)
          ], 6)
        ], 6)
      ], 2)) : (V(), se("div", {
        key: 1,
        class: ee(x(r).b("circle")),
        style: it({ height: `${g.width}px`, width: `${g.width}px` })
      }, [
        (V(), se("svg", Q3, [
          ae("path", {
            class: ee(x(r).be("circle", "track")),
            d: x(a),
            stroke: `var(${x(r).cssVarName("fill-color-light")}, #e5e9f2)`,
            "stroke-linecap": g.strokeLinecap,
            "stroke-width": x(s),
            fill: "none",
            style: it(x(d))
          }, null, 14, J3),
          ae("path", {
            class: ee(x(r).be("circle", "path")),
            d: x(a),
            stroke: x(v),
            fill: "none",
            opacity: g.percentage ? 1 : 0,
            "stroke-linecap": g.strokeLinecap,
            "stroke-width": x(s),
            style: it(x(h))
          }, null, 14, eR)
        ]))
      ], 6)),
      (g.showText || g.$slots.default) && !g.textInside ? (V(), se("div", {
        key: 2,
        class: ee(x(r).e("text")),
        style: it({ fontSize: `${x(b)}px` })
      }, [
        De(g.$slots, "default", { percentage: g.percentage }, () => [
          g.status ? (V(), Ce(x(_t), { key: 1 }, {
            default: de(() => [
              (V(), Ce(In(x(y))))
            ]),
            _: 1
          })) : (V(), se("span", tR, st(x(p)), 1))
        ])
      ], 6)) : ye("v-if", !0)
    ], 10, Z3));
  }
});
var iR = /* @__PURE__ */ qe(rR, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/progress/src/progress.vue"]]);
const Og = nn(iR), Ng = Symbol("sliderContextKey"), sR = ut({
  modelValue: {
    type: Pe([Number, Array]),
    default: 0
  },
  id: {
    type: String,
    default: void 0
  },
  min: {
    type: Number,
    default: 0
  },
  max: {
    type: Number,
    default: 100
  },
  step: {
    type: Number,
    default: 1
  },
  showInput: Boolean,
  showInputControls: {
    type: Boolean,
    default: !0
  },
  size: Rr,
  inputSize: Rr,
  showStops: Boolean,
  showTooltip: {
    type: Boolean,
    default: !0
  },
  formatTooltip: {
    type: Pe(Function),
    default: void 0
  },
  disabled: Boolean,
  range: Boolean,
  vertical: Boolean,
  height: String,
  debounce: {
    type: Number,
    default: 300
  },
  label: {
    type: String,
    default: void 0
  },
  rangeStartLabel: {
    type: String,
    default: void 0
  },
  rangeEndLabel: {
    type: String,
    default: void 0
  },
  formatValueText: {
    type: Pe(Function),
    default: void 0
  },
  tooltipClass: {
    type: String,
    default: void 0
  },
  placement: {
    type: String,
    values: Fs,
    default: "top"
  },
  marks: {
    type: Pe(Object)
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), ku = (t) => gt(t) || Nr(t) && t.every(gt), oR = {
  [Pt]: ku,
  [Li]: ku,
  [Yi]: ku
}, aR = (t, e, n) => {
  const r = K();
  return Tt(async () => {
    t.range ? (Array.isArray(t.modelValue) ? (e.firstValue = Math.max(t.min, t.modelValue[0]), e.secondValue = Math.min(t.max, t.modelValue[1])) : (e.firstValue = t.min, e.secondValue = t.max), e.oldValue = [e.firstValue, e.secondValue]) : (typeof t.modelValue != "number" || Number.isNaN(t.modelValue) ? e.firstValue = t.min : e.firstValue = Math.min(t.max, Math.max(t.min, t.modelValue)), e.oldValue = e.firstValue), bn(window, "resize", n), await rt(), n();
  }), {
    sliderWrapper: r
  };
}, lR = (t) => F(() => t.marks ? Object.keys(t.marks).map(Number.parseFloat).sort((n, r) => n - r).filter((n) => n <= t.max && n >= t.min).map((n) => ({
  point: n,
  position: (n - t.min) * 100 / (t.max - t.min),
  mark: t.marks[n]
})) : []), uR = (t, e, n) => {
  const { form: r, formItem: i } = oi(), s = Mn(), o = K(), a = K(), l = {
    firstButton: o,
    secondButton: a
  }, u = F(() => t.disabled || (r == null ? void 0 : r.disabled) || !1), c = F(() => Math.min(e.firstValue, e.secondValue)), d = F(() => Math.max(e.firstValue, e.secondValue)), h = F(() => t.range ? `${100 * (d.value - c.value) / (t.max - t.min)}%` : `${100 * (e.firstValue - t.min) / (t.max - t.min)}%`), v = F(() => t.range ? `${100 * (c.value - t.min) / (t.max - t.min)}%` : "0%"), y = F(() => t.vertical ? { height: t.height } : {}), b = F(() => t.vertical ? {
    height: h.value,
    bottom: v.value
  } : {
    width: h.value,
    left: v.value
  }), p = () => {
    s.value && (e.sliderSize = s.value[`client${t.vertical ? "Height" : "Width"}`]);
  }, f = (I) => {
    const P = t.min + I * (t.max - t.min) / 100;
    if (!t.range)
      return o;
    let D;
    return Math.abs(c.value - P) < Math.abs(d.value - P) ? D = e.firstValue < e.secondValue ? "firstButton" : "secondButton" : D = e.firstValue > e.secondValue ? "firstButton" : "secondButton", l[D];
  }, m = (I) => {
    const P = f(I);
    return P.value.setPosition(I), P;
  }, g = (I) => {
    e.firstValue = I, _(t.range ? [c.value, d.value] : I);
  }, w = (I) => {
    e.secondValue = I, t.range && _([c.value, d.value]);
  }, _ = (I) => {
    n(Pt, I), n(Li, I);
  }, E = async () => {
    await rt(), n(Yi, t.range ? [c.value, d.value] : t.modelValue);
  }, C = (I) => {
    var P, D, z, G, J, M;
    if (u.value || e.dragging)
      return;
    p();
    let U = 0;
    if (t.vertical) {
      const j = (z = (D = (P = I.touches) == null ? void 0 : P.item(0)) == null ? void 0 : D.clientY) != null ? z : I.clientY;
      U = (s.value.getBoundingClientRect().bottom - j) / e.sliderSize * 100;
    } else {
      const j = (M = (J = (G = I.touches) == null ? void 0 : G.item(0)) == null ? void 0 : J.clientX) != null ? M : I.clientX, re = s.value.getBoundingClientRect().left;
      U = (j - re) / e.sliderSize * 100;
    }
    if (!(U < 0 || U > 100))
      return m(U);
  };
  return {
    elFormItem: i,
    slider: s,
    firstButton: o,
    secondButton: a,
    sliderDisabled: u,
    minValue: c,
    maxValue: d,
    runwayStyle: y,
    barStyle: b,
    resetSize: p,
    setPosition: m,
    emitChange: E,
    onSliderWrapperPrevent: (I) => {
      var P, D;
      ((P = l.firstButton.value) != null && P.dragging || (D = l.secondButton.value) != null && D.dragging) && I.preventDefault();
    },
    onSliderClick: (I) => {
      C(I) && E();
    },
    onSliderDown: async (I) => {
      const P = C(I);
      P && (await rt(), P.value.onButtonDown(I));
    },
    setFirstValue: g,
    setSecondValue: w
  };
}, { left: cR, down: dR, right: fR, up: hR, home: pR, end: vR, pageUp: mR, pageDown: gR } = sn, yR = (t, e, n) => {
  const r = K(), i = K(!1), s = F(() => e.value instanceof Function), o = F(() => s.value && e.value(t.modelValue) || t.modelValue), a = Xr(() => {
    n.value && (i.value = !0);
  }, 50), l = Xr(() => {
    n.value && (i.value = !1);
  }, 50);
  return {
    tooltip: r,
    tooltipVisible: i,
    formatValue: o,
    displayTooltip: a,
    hideTooltip: l
  };
}, bR = (t, e, n) => {
  const {
    disabled: r,
    min: i,
    max: s,
    step: o,
    showTooltip: a,
    precision: l,
    sliderSize: u,
    formatTooltip: c,
    emitChange: d,
    resetSize: h,
    updateDragging: v
  } = tt(Ng), { tooltip: y, tooltipVisible: b, formatValue: p, displayTooltip: f, hideTooltip: m } = yR(t, c, a), g = K(), w = F(() => `${(t.modelValue - i.value) / (s.value - i.value) * 100}%`), _ = F(() => t.vertical ? { bottom: w.value } : { left: w.value }), E = () => {
    e.hovering = !0, f();
  }, C = () => {
    e.hovering = !1, e.dragging || m();
  }, T = (Y) => {
    r.value || (Y.preventDefault(), U(Y), window.addEventListener("mousemove", j), window.addEventListener("touchmove", j), window.addEventListener("mouseup", re), window.addEventListener("touchend", re), window.addEventListener("contextmenu", re), g.value.focus());
  }, k = (Y) => {
    r.value || (e.newPosition = Number.parseFloat(w.value) + Y / (s.value - i.value) * 100, fe(e.newPosition), d());
  }, N = () => {
    k(-o.value);
  }, I = () => {
    k(o.value);
  }, P = () => {
    k(-o.value * 4);
  }, D = () => {
    k(o.value * 4);
  }, z = () => {
    r.value || (fe(0), d());
  }, G = () => {
    r.value || (fe(100), d());
  }, J = (Y) => {
    let le = !0;
    [cR, dR].includes(Y.key) ? N() : [fR, hR].includes(Y.key) ? I() : Y.key === pR ? z() : Y.key === vR ? G() : Y.key === gR ? P() : Y.key === mR ? D() : le = !1, le && Y.preventDefault();
  }, M = (Y) => {
    let le, ce;
    return Y.type.startsWith("touch") ? (ce = Y.touches[0].clientY, le = Y.touches[0].clientX) : (ce = Y.clientY, le = Y.clientX), {
      clientX: le,
      clientY: ce
    };
  }, U = (Y) => {
    e.dragging = !0, e.isClick = !0;
    const { clientX: le, clientY: ce } = M(Y);
    t.vertical ? e.startY = ce : e.startX = le, e.startPosition = Number.parseFloat(w.value), e.newPosition = e.startPosition;
  }, j = (Y) => {
    if (e.dragging) {
      e.isClick = !1, f(), h();
      let le;
      const { clientX: ce, clientY: me } = M(Y);
      t.vertical ? (e.currentY = me, le = (e.startY - e.currentY) / u.value * 100) : (e.currentX = ce, le = (e.currentX - e.startX) / u.value * 100), e.newPosition = e.startPosition + le, fe(e.newPosition);
    }
  }, re = () => {
    e.dragging && (setTimeout(() => {
      e.dragging = !1, e.hovering || m(), e.isClick || fe(e.newPosition), d();
    }, 0), window.removeEventListener("mousemove", j), window.removeEventListener("touchmove", j), window.removeEventListener("mouseup", re), window.removeEventListener("touchend", re), window.removeEventListener("contextmenu", re));
  }, fe = async (Y) => {
    if (Y === null || Number.isNaN(+Y))
      return;
    Y < 0 ? Y = 0 : Y > 100 && (Y = 100);
    const le = 100 / ((s.value - i.value) / o.value);
    let me = Math.round(Y / le) * le * (s.value - i.value) * 0.01 + i.value;
    me = Number.parseFloat(me.toFixed(l.value)), me !== t.modelValue && n(Pt, me), !e.dragging && t.modelValue !== e.oldValue && (e.oldValue = t.modelValue), await rt(), e.dragging && f(), y.value.updatePopper();
  };
  return ke(() => e.dragging, (Y) => {
    v(Y);
  }), {
    disabled: r,
    button: g,
    tooltip: y,
    tooltipVisible: b,
    showTooltip: a,
    wrapperStyle: _,
    formatValue: p,
    handleMouseEnter: E,
    handleMouseLeave: C,
    onButtonDown: T,
    onKeyDown: J,
    setPosition: fe
  };
}, wR = (t, e, n, r) => ({
  stops: F(() => {
    if (!t.showStops || t.min > t.max)
      return [];
    if (t.step === 0)
      return Vt("ElSlider", "step should not be 0."), [];
    const o = (t.max - t.min) / t.step, a = 100 * t.step / (t.max - t.min), l = Array.from({ length: o - 1 }).map((u, c) => (c + 1) * a);
    return t.range ? l.filter((u) => u < 100 * (n.value - t.min) / (t.max - t.min) || u > 100 * (r.value - t.min) / (t.max - t.min)) : l.filter((u) => u > 100 * (e.firstValue - t.min) / (t.max - t.min));
  }),
  getStopStyle: (o) => t.vertical ? { bottom: `${o}%` } : { left: `${o}%` }
}), _R = (t, e, n, r, i, s) => {
  const o = (u) => {
    i(Pt, u), i(Li, u);
  }, a = () => t.range ? ![n.value, r.value].every((u, c) => u === e.oldValue[c]) : t.modelValue !== e.oldValue, l = () => {
    var u, c;
    t.min > t.max && Gi("Slider", "min should not be greater than max.");
    const d = t.modelValue;
    t.range && Array.isArray(d) ? d[1] < t.min ? o([t.min, t.min]) : d[0] > t.max ? o([t.max, t.max]) : d[0] < t.min ? o([t.min, d[1]]) : d[1] > t.max ? o([d[0], t.max]) : (e.firstValue = d[0], e.secondValue = d[1], a() && (t.validateEvent && ((u = s == null ? void 0 : s.validate) == null || u.call(s, "change").catch((h) => Vt(h))), e.oldValue = d.slice())) : !t.range && typeof d == "number" && !Number.isNaN(d) && (d < t.min ? o(t.min) : d > t.max ? o(t.max) : (e.firstValue = d, a() && (t.validateEvent && ((c = s == null ? void 0 : s.validate) == null || c.call(s, "change").catch((h) => Vt(h))), e.oldValue = d)));
  };
  l(), ke(() => e.dragging, (u) => {
    u || l();
  }), ke(() => t.modelValue, (u, c) => {
    e.dragging || Array.isArray(u) && Array.isArray(c) && u.every((d, h) => d === c[h]) && e.firstValue === u[0] && e.secondValue === u[1] || l();
  }, {
    deep: !0
  }), ke(() => [t.min, t.max], () => {
    l();
  });
}, ER = ut({
  modelValue: {
    type: Number,
    default: 0
  },
  vertical: Boolean,
  tooltipClass: String,
  placement: {
    type: String,
    values: Fs,
    default: "top"
  }
}), SR = {
  [Pt]: (t) => gt(t)
}, xR = ["tabindex"], CR = be({
  name: "ElSliderButton"
}), kR = /* @__PURE__ */ be({
  ...CR,
  props: ER,
  emits: SR,
  setup(t, { expose: e, emit: n }) {
    const r = t, i = Fe("slider"), s = Pn({
      hovering: !1,
      dragging: !1,
      isClick: !1,
      startX: 0,
      currentX: 0,
      startY: 0,
      currentY: 0,
      startPosition: 0,
      newPosition: 0,
      oldValue: r.modelValue
    }), {
      disabled: o,
      button: a,
      tooltip: l,
      showTooltip: u,
      tooltipVisible: c,
      wrapperStyle: d,
      formatValue: h,
      handleMouseEnter: v,
      handleMouseLeave: y,
      onButtonDown: b,
      onKeyDown: p,
      setPosition: f
    } = bR(r, s, n), { hovering: m, dragging: g } = hn(s);
    return e({
      onButtonDown: b,
      onKeyDown: p,
      setPosition: f,
      hovering: m,
      dragging: g
    }), (w, _) => (V(), se("div", {
      ref_key: "button",
      ref: a,
      class: ee([x(i).e("button-wrapper"), { hover: x(m), dragging: x(g) }]),
      style: it(x(d)),
      tabindex: x(o) ? -1 : 0,
      onMouseenter: _[0] || (_[0] = (...E) => x(v) && x(v)(...E)),
      onMouseleave: _[1] || (_[1] = (...E) => x(y) && x(y)(...E)),
      onMousedown: _[2] || (_[2] = (...E) => x(b) && x(b)(...E)),
      onTouchstart: _[3] || (_[3] = (...E) => x(b) && x(b)(...E)),
      onFocus: _[4] || (_[4] = (...E) => x(v) && x(v)(...E)),
      onBlur: _[5] || (_[5] = (...E) => x(y) && x(y)(...E)),
      onKeydown: _[6] || (_[6] = (...E) => x(p) && x(p)(...E))
    }, [
      ve(x(Zl), {
        ref_key: "tooltip",
        ref: l,
        visible: x(c),
        placement: w.placement,
        "fallback-placements": ["top", "bottom", "right", "left"],
        "stop-popper-mouse-event": !1,
        "popper-class": w.tooltipClass,
        disabled: !x(u),
        persistent: ""
      }, {
        content: de(() => [
          ae("span", null, st(x(h)), 1)
        ]),
        default: de(() => [
          ae("div", {
            class: ee([x(i).e("button"), { hover: x(m), dragging: x(g) }])
          }, null, 2)
        ]),
        _: 1
      }, 8, ["visible", "placement", "popper-class", "disabled"])
    ], 46, xR));
  }
});
var op = /* @__PURE__ */ qe(kR, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/button.vue"]]);
const TR = ut({
  mark: {
    type: Pe([String, Object]),
    default: void 0
  }
});
var OR = be({
  name: "ElSliderMarker",
  props: TR,
  setup(t) {
    const e = Fe("slider"), n = F(() => qt(t.mark) ? t.mark : t.mark.label), r = F(() => qt(t.mark) ? void 0 : t.mark.style);
    return () => et("div", {
      class: e.e("marks-text"),
      style: r.value
    }, n.value);
  }
});
const NR = ["id", "role", "aria-label", "aria-labelledby"], AR = { key: 1 }, IR = be({
  name: "ElSlider"
}), RR = /* @__PURE__ */ be({
  ...IR,
  props: sR,
  emits: oR,
  setup(t, { expose: e, emit: n }) {
    const r = t, i = Fe("slider"), { t: s } = or(), o = Pn({
      firstValue: 0,
      secondValue: 0,
      oldValue: 0,
      dragging: !1,
      sliderSize: 1
    }), {
      elFormItem: a,
      slider: l,
      firstButton: u,
      secondButton: c,
      sliderDisabled: d,
      minValue: h,
      maxValue: v,
      runwayStyle: y,
      barStyle: b,
      resetSize: p,
      emitChange: f,
      onSliderWrapperPrevent: m,
      onSliderClick: g,
      onSliderDown: w,
      setFirstValue: _,
      setSecondValue: E
    } = uR(r, o, n), { stops: C, getStopStyle: T } = wR(r, o, h, v), { inputId: k, isLabeledByFormItem: N } = ea(r, {
      formItemContext: a
    }), I = Lr(), P = F(() => r.inputSize || I.value), D = F(() => r.label || s("el.slider.defaultLabel", {
      min: r.min,
      max: r.max
    })), z = F(() => r.range ? r.rangeStartLabel || s("el.slider.defaultRangeStartLabel") : D.value), G = F(() => r.formatValueText ? r.formatValueText(Y.value) : `${Y.value}`), J = F(() => r.rangeEndLabel || s("el.slider.defaultRangeEndLabel")), M = F(() => r.formatValueText ? r.formatValueText(le.value) : `${le.value}`), U = F(() => [
      i.b(),
      i.m(I.value),
      i.is("vertical", r.vertical),
      { [i.m("with-input")]: r.showInput }
    ]), j = lR(r);
    _R(r, o, h, v, n, a);
    const re = F(() => {
      const _e = [r.min, r.max, r.step].map((ze) => {
        const Oe = `${ze}`.split(".")[1];
        return Oe ? Oe.length : 0;
      });
      return Math.max.apply(null, _e);
    }), { sliderWrapper: fe } = aR(r, o, p), { firstValue: Y, secondValue: le, sliderSize: ce } = hn(o), me = (_e) => {
      o.dragging = _e;
    };
    return Gt(Ng, {
      ...hn(r),
      sliderSize: ce,
      disabled: d,
      precision: re,
      emitChange: f,
      resetSize: p,
      updateDragging: me
    }), e({
      onSliderClick: g
    }), (_e, ze) => {
      var Oe, Qe;
      return V(), se("div", {
        id: _e.range ? x(k) : void 0,
        ref_key: "sliderWrapper",
        ref: fe,
        class: ee(x(U)),
        role: _e.range ? "group" : void 0,
        "aria-label": _e.range && !x(N) ? x(D) : void 0,
        "aria-labelledby": _e.range && x(N) ? (Oe = x(a)) == null ? void 0 : Oe.labelId : void 0,
        onTouchstart: ze[2] || (ze[2] = (...Be) => x(m) && x(m)(...Be)),
        onTouchmove: ze[3] || (ze[3] = (...Be) => x(m) && x(m)(...Be))
      }, [
        ae("div", {
          ref_key: "slider",
          ref: l,
          class: ee([
            x(i).e("runway"),
            { "show-input": _e.showInput && !_e.range },
            x(i).is("disabled", x(d))
          ]),
          style: it(x(y)),
          onMousedown: ze[0] || (ze[0] = (...Be) => x(w) && x(w)(...Be)),
          onTouchstart: ze[1] || (ze[1] = (...Be) => x(w) && x(w)(...Be))
        }, [
          ae("div", {
            class: ee(x(i).e("bar")),
            style: it(x(b))
          }, null, 6),
          ve(op, {
            id: _e.range ? void 0 : x(k),
            ref_key: "firstButton",
            ref: u,
            "model-value": x(Y),
            vertical: _e.vertical,
            "tooltip-class": _e.tooltipClass,
            placement: _e.placement,
            role: "slider",
            "aria-label": _e.range || !x(N) ? x(z) : void 0,
            "aria-labelledby": !_e.range && x(N) ? (Qe = x(a)) == null ? void 0 : Qe.labelId : void 0,
            "aria-valuemin": _e.min,
            "aria-valuemax": _e.range ? x(le) : _e.max,
            "aria-valuenow": x(Y),
            "aria-valuetext": x(G),
            "aria-orientation": _e.vertical ? "vertical" : "horizontal",
            "aria-disabled": x(d),
            "onUpdate:modelValue": x(_)
          }, null, 8, ["id", "model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-labelledby", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"]),
          _e.range ? (V(), Ce(op, {
            key: 0,
            ref_key: "secondButton",
            ref: c,
            "model-value": x(le),
            vertical: _e.vertical,
            "tooltip-class": _e.tooltipClass,
            placement: _e.placement,
            role: "slider",
            "aria-label": x(J),
            "aria-valuemin": x(Y),
            "aria-valuemax": _e.max,
            "aria-valuenow": x(le),
            "aria-valuetext": x(M),
            "aria-orientation": _e.vertical ? "vertical" : "horizontal",
            "aria-disabled": x(d),
            "onUpdate:modelValue": x(E)
          }, null, 8, ["model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"])) : ye("v-if", !0),
          _e.showStops ? (V(), se("div", AR, [
            (V(!0), se(Ft, null, Gn(x(C), (Be, He) => (V(), se("div", {
              key: He,
              class: ee(x(i).e("stop")),
              style: it(x(T)(Be))
            }, null, 6))), 128))
          ])) : ye("v-if", !0),
          x(j).length > 0 ? (V(), se(Ft, { key: 2 }, [
            ae("div", null, [
              (V(!0), se(Ft, null, Gn(x(j), (Be, He) => (V(), se("div", {
                key: He,
                style: it(x(T)(Be.position)),
                class: ee([x(i).e("stop"), x(i).e("marks-stop")])
              }, null, 6))), 128))
            ]),
            ae("div", {
              class: ee(x(i).e("marks"))
            }, [
              (V(!0), se(Ft, null, Gn(x(j), (Be, He) => (V(), Ce(x(OR), {
                key: He,
                mark: Be.mark,
                style: it(x(T)(Be.position))
              }, null, 8, ["mark", "style"]))), 128))
            ], 2)
          ], 64)) : ye("v-if", !0)
        ], 38),
        _e.showInput && !_e.range ? (V(), Ce(x(xg), {
          key: 0,
          ref: "input",
          "model-value": x(Y),
          class: ee(x(i).e("input")),
          step: _e.step,
          disabled: x(d),
          controls: _e.showInputControls,
          min: _e.min,
          max: _e.max,
          debounce: _e.debounce,
          size: x(P),
          "onUpdate:modelValue": x(_),
          onChange: x(f)
        }, null, 8, ["model-value", "class", "step", "disabled", "controls", "min", "max", "debounce", "size", "onUpdate:modelValue", "onChange"])) : ye("v-if", !0)
      ], 42, NR);
    };
  }
});
var LR = /* @__PURE__ */ qe(RR, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/slider.vue"]]);
const PR = nn(LR);
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
var $R = /["'&<>]/, DR = BR;
function BR(t) {
  var e = "" + t, n = $R.exec(e);
  if (!n)
    return e;
  var r, i = "", s = 0, o = 0;
  for (s = n.index; s < e.length; s++) {
    switch (e.charCodeAt(s)) {
      case 34:
        r = "&quot;";
        break;
      case 38:
        r = "&amp;";
        break;
      case 39:
        r = "&#39;";
        break;
      case 60:
        r = "&lt;";
        break;
      case 62:
        r = "&gt;";
        break;
      default:
        continue;
    }
    o !== s && (i += e.substring(o, s)), o = s + 1, i += r;
  }
  return o !== s ? i + e.substring(o, s) : i;
}
const Tu = function(t) {
  var e;
  return (e = t.target) == null ? void 0 : e.closest("td");
}, MR = function(t, e, n, r, i) {
  if (!e && !r && (!i || Array.isArray(i) && !i.length))
    return t;
  typeof n == "string" ? n = n === "descending" ? -1 : 1 : n = n && n < 0 ? -1 : 1;
  const s = r ? null : function(a, l) {
    return i ? (Array.isArray(i) || (i = [i]), i.map((u) => typeof u == "string" ? Cn(a, u) : u(a, l, t))) : (e !== "$key" && wn(a) && "$value" in a && (a = a.$value), [wn(a) ? Cn(a, e) : a]);
  }, o = function(a, l) {
    if (r)
      return r(a.value, l.value);
    for (let u = 0, c = a.key.length; u < c; u++) {
      if (a.key[u] < l.key[u])
        return -1;
      if (a.key[u] > l.key[u])
        return 1;
    }
    return 0;
  };
  return t.map((a, l) => ({
    value: a,
    index: l,
    key: s ? s(a, l) : null
  })).sort((a, l) => {
    let u = o(a, l);
    return u || (u = a.index - l.index), u * +n;
  }).map((a) => a.value);
}, Ag = function(t, e) {
  let n = null;
  return t.columns.forEach((r) => {
    r.id === e && (n = r);
  }), n;
}, zR = function(t, e) {
  let n = null;
  for (let r = 0; r < t.columns.length; r++) {
    const i = t.columns[r];
    if (i.columnKey === e) {
      n = i;
      break;
    }
  }
  return n || Gi("ElTable", `No column matching with column-key: ${e}`), n;
}, ap = function(t, e, n) {
  const r = (e.className || "").match(new RegExp(`${n}-table_[^\\s]+`, "gm"));
  return r ? Ag(t, r[0]) : null;
}, yn = (t, e) => {
  if (!t)
    throw new Error("Row is required when get row identity");
  if (typeof e == "string") {
    if (!e.includes("."))
      return `${t[e]}`;
    const n = e.split(".");
    let r = t;
    for (const i of n)
      r = r[i];
    return `${r}`;
  } else if (typeof e == "function")
    return e.call(null, t);
}, Ii = function(t, e) {
  const n = {};
  return (t || []).forEach((r, i) => {
    n[yn(r, e)] = { row: r, index: i };
  }), n;
};
function FR(t, e) {
  const n = {};
  let r;
  for (r in t)
    n[r] = t[r];
  for (r in e)
    if (Or(e, r)) {
      const i = e[r];
      typeof i < "u" && (n[r] = i);
    }
  return n;
}
function Xd(t) {
  return t === "" || t !== void 0 && (t = Number.parseInt(t, 10), Number.isNaN(t) && (t = "")), t;
}
function Ig(t) {
  return t === "" || t !== void 0 && (t = Xd(t), Number.isNaN(t) && (t = 80)), t;
}
function jR(t) {
  return typeof t == "number" ? t : typeof t == "string" ? /^\d+(?:px)?$/.test(t) ? Number.parseInt(t, 10) : t : null;
}
function UR(...t) {
  return t.length === 0 ? (e) => e : t.length === 1 ? t[0] : t.reduce((e, n) => (...r) => e(n(...r)));
}
function co(t, e, n) {
  let r = !1;
  const i = t.indexOf(e), s = i !== -1, o = (a) => {
    a === "add" ? t.push(e) : t.splice(i, 1), r = !0, Nr(e.children) && e.children.forEach((l) => {
      co(t, l, n ?? !s);
    });
  };
  return Zr(n) ? n && !s ? o("add") : !n && s && o("remove") : o(s ? "remove" : "add"), r;
}
function VR(t, e, n = "children", r = "hasChildren") {
  const i = (o) => !(Array.isArray(o) && o.length);
  function s(o, a, l) {
    e(o, a, l), a.forEach((u) => {
      if (u[r]) {
        e(u, null, l + 1);
        return;
      }
      const c = u[n];
      i(c) || s(u, c, l + 1);
    });
  }
  t.forEach((o) => {
    if (o[r]) {
      e(o, null, 0);
      return;
    }
    const a = o[n];
    i(a) || s(o, a, 0);
  });
}
let Fr;
function WR(t, e, n, r, i) {
  i = tm({
    enterable: !0,
    showArrow: !0
  }, i);
  const s = t == null ? void 0 : t.dataset.prefix, o = t == null ? void 0 : t.querySelector(`.${s}-scrollbar__wrap`);
  function a() {
    const p = i.effect === "light", f = document.createElement("div");
    return f.className = [
      `${s}-popper`,
      p ? "is-light" : "is-dark",
      i.popperClass || ""
    ].join(" "), n = DR(n), f.innerHTML = n, f.style.zIndex = String(r()), t == null || t.appendChild(f), f;
  }
  function l() {
    const p = document.createElement("div");
    return p.className = `${s}-popper__arrow`, p;
  }
  function u() {
    c && c.update();
  }
  Fr == null || Fr(), Fr = () => {
    try {
      c && c.destroy(), v && (t == null || t.removeChild(v)), e.removeEventListener("mouseenter", d), e.removeEventListener("mouseleave", h), o == null || o.removeEventListener("scroll", Fr), Fr = void 0;
    } catch {
    }
  };
  let c = null, d = u, h = Fr;
  i.enterable && ({ onOpen: d, onClose: h } = Pm({
    showAfter: i.showAfter,
    hideAfter: i.hideAfter,
    open: u,
    close: Fr
  }));
  const v = a();
  v.onmouseenter = d, v.onmouseleave = h;
  const y = [];
  if (i.offset && y.push({
    name: "offset",
    options: {
      offset: [0, i.offset]
    }
  }), i.showArrow) {
    const p = v.appendChild(l());
    y.push({
      name: "arrow",
      options: {
        element: p,
        padding: 10
      }
    });
  }
  const b = i.popperOptions || {};
  return c = Im(e, v, {
    placement: i.placement || "top",
    strategy: "fixed",
    ...b,
    modifiers: b.modifiers ? y.concat(b.modifiers) : y
  }), e.addEventListener("mouseenter", d), e.addEventListener("mouseleave", h), o == null || o.addEventListener("scroll", Fr), c;
}
function Rg(t) {
  return t.children ? wS(t.children, Rg) : [t];
}
function lp(t, e) {
  return t + e.colSpan;
}
const Lg = (t, e, n, r) => {
  let i = 0, s = t;
  const o = n.states.columns.value;
  if (r) {
    const l = Rg(r[t]);
    i = o.slice(0, o.indexOf(l[0])).reduce(lp, 0), s = i + l.reduce(lp, 0) - 1;
  } else
    i = t;
  let a;
  switch (e) {
    case "left":
      s < n.states.fixedLeafColumnsLength.value && (a = "left");
      break;
    case "right":
      i >= o.length - n.states.rightFixedLeafColumnsLength.value && (a = "right");
      break;
    default:
      s < n.states.fixedLeafColumnsLength.value ? a = "left" : i >= o.length - n.states.rightFixedLeafColumnsLength.value && (a = "right");
  }
  return a ? {
    direction: a,
    start: i,
    after: s
  } : {};
}, Zd = (t, e, n, r, i, s = 0) => {
  const o = [], { direction: a, start: l, after: u } = Lg(e, n, r, i);
  if (a) {
    const c = a === "left";
    o.push(`${t}-fixed-column--${a}`), c && u + s === r.states.fixedLeafColumnsLength.value - 1 ? o.push("is-last-column") : !c && l - s === r.states.columns.value.length - r.states.rightFixedLeafColumnsLength.value && o.push("is-first-column");
  }
  return o;
};
function up(t, e) {
  return t + (e.realWidth === null || Number.isNaN(e.realWidth) ? Number(e.width) : e.realWidth);
}
const Qd = (t, e, n, r) => {
  const {
    direction: i,
    start: s = 0,
    after: o = 0
  } = Lg(t, e, n, r);
  if (!i)
    return;
  const a = {}, l = i === "left", u = n.states.columns.value;
  return l ? a.left = u.slice(0, s).reduce(up, 0) : a.right = u.slice(o + 1).reverse().reduce(up, 0), a;
}, Ls = (t, e) => {
  t && (Number.isNaN(t[e]) || (t[e] = `${t[e]}px`));
};
function HR(t) {
  const e = ht(), n = K(!1), r = K([]);
  return {
    updateExpandRows: () => {
      const l = t.data.value || [], u = t.rowKey.value;
      if (n.value)
        r.value = l.slice();
      else if (u) {
        const c = Ii(r.value, u);
        r.value = l.reduce((d, h) => {
          const v = yn(h, u);
          return c[v] && d.push(h), d;
        }, []);
      } else
        r.value = [];
    },
    toggleRowExpansion: (l, u) => {
      co(r.value, l, u) && e.emit("expand-change", l, r.value.slice());
    },
    setExpandRowKeys: (l) => {
      e.store.assertRowKey();
      const u = t.data.value || [], c = t.rowKey.value, d = Ii(u, c);
      r.value = l.reduce((h, v) => {
        const y = d[v];
        return y && h.push(y.row), h;
      }, []);
    },
    isRowExpanded: (l) => {
      const u = t.rowKey.value;
      return u ? !!Ii(r.value, u)[yn(l, u)] : r.value.includes(l);
    },
    states: {
      expandRows: r,
      defaultExpandAll: n
    }
  };
}
function KR(t) {
  const e = ht(), n = K(null), r = K(null), i = (u) => {
    e.store.assertRowKey(), n.value = u, o(u);
  }, s = () => {
    n.value = null;
  }, o = (u) => {
    const { data: c, rowKey: d } = t;
    let h = null;
    d.value && (h = (x(c) || []).find((v) => yn(v, d.value) === u)), r.value = h, e.emit("current-change", r.value, null);
  };
  return {
    setCurrentRowKey: i,
    restoreCurrentRowKey: s,
    setCurrentRowByKey: o,
    updateCurrentRow: (u) => {
      const c = r.value;
      if (u && u !== c) {
        r.value = u, e.emit("current-change", r.value, c);
        return;
      }
      !u && c && (r.value = null, e.emit("current-change", null, c));
    },
    updateCurrentRowData: () => {
      const u = t.rowKey.value, c = t.data.value || [], d = r.value;
      if (!c.includes(d) && d) {
        if (u) {
          const h = yn(d, u);
          o(h);
        } else
          r.value = null;
        r.value === null && e.emit("current-change", null, d);
      } else
        n.value && (o(n.value), s());
    },
    states: {
      _currentRowKey: n,
      currentRow: r
    }
  };
}
function qR(t) {
  const e = K([]), n = K({}), r = K(16), i = K(!1), s = K({}), o = K("hasChildren"), a = K("children"), l = ht(), u = F(() => {
    if (!t.rowKey.value)
      return {};
    const f = t.data.value || [];
    return d(f);
  }), c = F(() => {
    const f = t.rowKey.value, m = Object.keys(s.value), g = {};
    return m.length && m.forEach((w) => {
      if (s.value[w].length) {
        const _ = { children: [] };
        s.value[w].forEach((E) => {
          const C = yn(E, f);
          _.children.push(C), E[o.value] && !g[C] && (g[C] = { children: [] });
        }), g[w] = _;
      }
    }), g;
  }), d = (f) => {
    const m = t.rowKey.value, g = {};
    return VR(f, (w, _, E) => {
      const C = yn(w, m);
      Array.isArray(_) ? g[C] = {
        children: _.map((T) => yn(T, m)),
        level: E
      } : i.value && (g[C] = {
        children: [],
        lazy: !0,
        level: E
      });
    }, a.value, o.value), g;
  }, h = (f = !1, m = ((g) => (g = l.store) == null ? void 0 : g.states.defaultExpandAll.value)()) => {
    var g;
    const w = u.value, _ = c.value, E = Object.keys(w), C = {};
    if (E.length) {
      const T = x(n), k = [], N = (P, D) => {
        if (f)
          return e.value ? m || e.value.includes(D) : !!(m || P != null && P.expanded);
        {
          const z = m || e.value && e.value.includes(D);
          return !!(P != null && P.expanded || z);
        }
      };
      E.forEach((P) => {
        const D = T[P], z = { ...w[P] };
        if (z.expanded = N(D, P), z.lazy) {
          const { loaded: G = !1, loading: J = !1 } = D || {};
          z.loaded = !!G, z.loading = !!J, k.push(P);
        }
        C[P] = z;
      });
      const I = Object.keys(_);
      i.value && I.length && k.length && I.forEach((P) => {
        const D = T[P], z = _[P].children;
        if (k.includes(P)) {
          if (C[P].children.length !== 0)
            throw new Error("[ElTable]children must be an empty array.");
          C[P].children = z;
        } else {
          const { loaded: G = !1, loading: J = !1 } = D || {};
          C[P] = {
            lazy: !0,
            loaded: !!G,
            loading: !!J,
            expanded: N(D, P),
            children: z,
            level: ""
          };
        }
      });
    }
    n.value = C, (g = l.store) == null || g.updateTableScrollY();
  };
  ke(() => e.value, () => {
    h(!0);
  }), ke(() => u.value, () => {
    h();
  }), ke(() => c.value, () => {
    h();
  });
  const v = (f) => {
    e.value = f, h();
  }, y = (f, m) => {
    l.store.assertRowKey();
    const g = t.rowKey.value, w = yn(f, g), _ = w && n.value[w];
    if (w && _ && "expanded" in _) {
      const E = _.expanded;
      m = typeof m > "u" ? !_.expanded : m, n.value[w].expanded = m, E !== m && l.emit("expand-change", f, m), l.store.updateTableScrollY();
    }
  }, b = (f) => {
    l.store.assertRowKey();
    const m = t.rowKey.value, g = yn(f, m), w = n.value[g];
    i.value && w && "loaded" in w && !w.loaded ? p(f, g, w) : y(f, void 0);
  }, p = (f, m, g) => {
    const { load: w } = l.props;
    w && !n.value[m].loaded && (n.value[m].loading = !0, w(f, g, (_) => {
      if (!Array.isArray(_))
        throw new TypeError("[ElTable] data must be an array");
      n.value[m].loading = !1, n.value[m].loaded = !0, n.value[m].expanded = !0, _.length && (s.value[m] = _), l.emit("expand-change", f, !0);
    }));
  };
  return {
    loadData: p,
    loadOrToggle: b,
    toggleTreeExpansion: y,
    updateTreeExpandKeys: v,
    updateTreeData: h,
    normalize: d,
    states: {
      expandRowKeys: e,
      treeData: n,
      indent: r,
      lazy: i,
      lazyTreeNodeMap: s,
      lazyColumnIdentifier: o,
      childrenColumnName: a
    }
  };
}
const GR = (t, e) => {
  const n = e.sortingColumn;
  return !n || typeof n.sortable == "string" ? t : MR(t, e.sortProp, e.sortOrder, n.sortMethod, n.sortBy);
}, ja = (t) => {
  const e = [];
  return t.forEach((n) => {
    n.children && n.children.length > 0 ? e.push.apply(e, ja(n.children)) : e.push(n);
  }), e;
};
function YR() {
  var t;
  const e = ht(), { size: n } = hn((t = e.proxy) == null ? void 0 : t.$props), r = K(null), i = K([]), s = K([]), o = K(!1), a = K([]), l = K([]), u = K([]), c = K([]), d = K([]), h = K([]), v = K([]), y = K([]), b = [], p = K(0), f = K(0), m = K(0), g = K(!1), w = K([]), _ = K(!1), E = K(!1), C = K(null), T = K({}), k = K(null), N = K(null), I = K(null), P = K(null), D = K(null);
  ke(i, () => e.state && M(!1), {
    deep: !0
  });
  const z = () => {
    if (!r.value)
      throw new Error("[ElTable] prop row-key is required");
  }, G = (Ae) => {
    var Ve;
    (Ve = Ae.children) == null || Ve.forEach((Ye) => {
      Ye.fixed = Ae.fixed, G(Ye);
    });
  }, J = () => {
    a.value.forEach((Ze) => {
      G(Ze);
    }), c.value = a.value.filter((Ze) => Ze.fixed === !0 || Ze.fixed === "left"), d.value = a.value.filter((Ze) => Ze.fixed === "right"), c.value.length > 0 && a.value[0] && a.value[0].type === "selection" && !a.value[0].fixed && (a.value[0].fixed = !0, c.value.unshift(a.value[0]));
    const Ae = a.value.filter((Ze) => !Ze.fixed);
    l.value = [].concat(c.value).concat(Ae).concat(d.value);
    const Ve = ja(Ae), Ye = ja(c.value), je = ja(d.value);
    p.value = Ve.length, f.value = Ye.length, m.value = je.length, u.value = [].concat(Ye).concat(Ve).concat(je), o.value = c.value.length > 0 || d.value.length > 0;
  }, M = (Ae, Ve = !1) => {
    Ae && J(), Ve ? e.state.doLayout() : e.state.debouncedUpdateLayout();
  }, U = (Ae) => w.value.includes(Ae), j = () => {
    g.value = !1, w.value.length && (w.value = [], e.emit("selection-change", []));
  }, re = () => {
    let Ae;
    if (r.value) {
      Ae = [];
      const Ve = Ii(w.value, r.value), Ye = Ii(i.value, r.value);
      for (const je in Ve)
        Or(Ve, je) && !Ye[je] && Ae.push(Ve[je].row);
    } else
      Ae = w.value.filter((Ve) => !i.value.includes(Ve));
    if (Ae.length) {
      const Ve = w.value.filter((Ye) => !Ae.includes(Ye));
      w.value = Ve, e.emit("selection-change", Ve.slice());
    }
  }, fe = () => (w.value || []).slice(), Y = (Ae, Ve = void 0, Ye = !0) => {
    if (co(w.value, Ae, Ve)) {
      const Ze = (w.value || []).slice();
      Ye && e.emit("select", Ze, Ae), e.emit("selection-change", Ze);
    }
  }, le = () => {
    var Ae, Ve;
    const Ye = E.value ? !g.value : !(g.value || w.value.length);
    g.value = Ye;
    let je = !1, Ze = 0;
    const Ct = (Ve = (Ae = e == null ? void 0 : e.store) == null ? void 0 : Ae.states) == null ? void 0 : Ve.rowKey.value;
    i.value.forEach((L, he) => {
      const ge = he + Ze;
      C.value ? C.value.call(null, L, ge) && co(w.value, L, Ye) && (je = !0) : co(w.value, L, Ye) && (je = !0), Ze += _e(yn(L, Ct));
    }), je && e.emit("selection-change", w.value ? w.value.slice() : []), e.emit("select-all", w.value);
  }, ce = () => {
    const Ae = Ii(w.value, r.value);
    i.value.forEach((Ve) => {
      const Ye = yn(Ve, r.value), je = Ae[Ye];
      je && (w.value[je.index] = Ve);
    });
  }, me = () => {
    var Ae, Ve, Ye;
    if (((Ae = i.value) == null ? void 0 : Ae.length) === 0) {
      g.value = !1;
      return;
    }
    let je;
    r.value && (je = Ii(w.value, r.value));
    const Ze = function(ge) {
      return je ? !!je[yn(ge, r.value)] : w.value.includes(ge);
    };
    let Ct = !0, L = 0, he = 0;
    for (let ge = 0, Ie = (i.value || []).length; ge < Ie; ge++) {
      const q = (Ye = (Ve = e == null ? void 0 : e.store) == null ? void 0 : Ve.states) == null ? void 0 : Ye.rowKey.value, ue = ge + he, O = i.value[ge], B = C.value && C.value.call(null, O, ue);
      if (Ze(O))
        L++;
      else if (!C.value || B) {
        Ct = !1;
        break;
      }
      he += _e(yn(O, q));
    }
    L === 0 && (Ct = !1), g.value = Ct;
  }, _e = (Ae) => {
    var Ve;
    if (!e || !e.store)
      return 0;
    const { treeData: Ye } = e.store.states;
    let je = 0;
    const Ze = (Ve = Ye.value[Ae]) == null ? void 0 : Ve.children;
    return Ze && (je += Ze.length, Ze.forEach((Ct) => {
      je += _e(Ct);
    })), je;
  }, ze = (Ae, Ve) => {
    Array.isArray(Ae) || (Ae = [Ae]);
    const Ye = {};
    return Ae.forEach((je) => {
      T.value[je.id] = Ve, Ye[je.columnKey || je.id] = Ve;
    }), Ye;
  }, Oe = (Ae, Ve, Ye) => {
    N.value && N.value !== Ae && (N.value.order = null), N.value = Ae, I.value = Ve, P.value = Ye;
  }, Qe = () => {
    let Ae = x(s);
    Object.keys(T.value).forEach((Ve) => {
      const Ye = T.value[Ve];
      if (!Ye || Ye.length === 0)
        return;
      const je = Ag({
        columns: u.value
      }, Ve);
      je && je.filterMethod && (Ae = Ae.filter((Ze) => Ye.some((Ct) => je.filterMethod.call(null, Ct, Ze, je))));
    }), k.value = Ae;
  }, Be = () => {
    i.value = GR(k.value, {
      sortingColumn: N.value,
      sortProp: I.value,
      sortOrder: P.value
    });
  }, He = (Ae = void 0) => {
    Ae && Ae.filter || Qe(), Be();
  }, ct = (Ae) => {
    const { tableHeaderRef: Ve } = e.refs;
    if (!Ve)
      return;
    const Ye = Object.assign({}, Ve.filterPanels), je = Object.keys(Ye);
    if (je.length)
      if (typeof Ae == "string" && (Ae = [Ae]), Array.isArray(Ae)) {
        const Ze = Ae.map((Ct) => zR({
          columns: u.value
        }, Ct));
        je.forEach((Ct) => {
          const L = Ze.find((he) => he.id === Ct);
          L && (L.filteredValue = []);
        }), e.store.commit("filterChange", {
          column: Ze,
          values: [],
          silent: !0,
          multi: !0
        });
      } else
        je.forEach((Ze) => {
          const Ct = u.value.find((L) => L.id === Ze);
          Ct && (Ct.filteredValue = []);
        }), T.value = {}, e.store.commit("filterChange", {
          column: {},
          values: [],
          silent: !0
        });
  }, nt = () => {
    N.value && (Oe(null, null, null), e.store.commit("changeSortCondition", {
      silent: !0
    }));
  }, {
    setExpandRowKeys: St,
    toggleRowExpansion: yt,
    updateExpandRows: It,
    states: ot,
    isRowExpanded: bt
  } = HR({
    data: i,
    rowKey: r
  }), {
    updateTreeExpandKeys: Kt,
    toggleTreeExpansion: wt,
    updateTreeData: xt,
    loadOrToggle: lt,
    states: Ge
  } = qR({
    data: i,
    rowKey: r
  }), {
    updateCurrentRowData: Rt,
    updateCurrentRow: we,
    setCurrentRowKey: Ue,
    states: at
  } = KR({
    data: i,
    rowKey: r
  });
  return {
    assertRowKey: z,
    updateColumns: J,
    scheduleLayout: M,
    isSelected: U,
    clearSelection: j,
    cleanSelection: re,
    getSelectionRows: fe,
    toggleRowSelection: Y,
    _toggleAllSelection: le,
    toggleAllSelection: null,
    updateSelectionByRowKey: ce,
    updateAllSelected: me,
    updateFilters: ze,
    updateCurrentRow: we,
    updateSort: Oe,
    execFilter: Qe,
    execSort: Be,
    execQuery: He,
    clearFilter: ct,
    clearSort: nt,
    toggleRowExpansion: yt,
    setExpandRowKeysAdapter: (Ae) => {
      St(Ae), Kt(Ae);
    },
    setCurrentRowKey: Ue,
    toggleRowExpansionAdapter: (Ae, Ve) => {
      u.value.some(({ type: je }) => je === "expand") ? yt(Ae, Ve) : wt(Ae, Ve);
    },
    isRowExpanded: bt,
    updateExpandRows: It,
    updateCurrentRowData: Rt,
    loadOrToggle: lt,
    updateTreeData: xt,
    states: {
      tableSize: n,
      rowKey: r,
      data: i,
      _data: s,
      isComplex: o,
      _columns: a,
      originColumns: l,
      columns: u,
      fixedColumns: c,
      rightFixedColumns: d,
      leafColumns: h,
      fixedLeafColumns: v,
      rightFixedLeafColumns: y,
      updateOrderFns: b,
      leafColumnsLength: p,
      fixedLeafColumnsLength: f,
      rightFixedLeafColumnsLength: m,
      isAllSelected: g,
      selection: w,
      reserveSelection: _,
      selectOnIndeterminate: E,
      selectable: C,
      filters: T,
      filteredData: k,
      sortingColumn: N,
      sortProp: I,
      sortOrder: P,
      hoverRow: D,
      ...ot,
      ...Ge,
      ...at
    }
  };
}
function gc(t, e) {
  return t.map((n) => {
    var r;
    return n.id === e.id ? e : ((r = n.children) != null && r.length && (n.children = gc(n.children, e)), n);
  });
}
function yc(t) {
  t.forEach((e) => {
    var n, r;
    e.no = (n = e.getColumnIndex) == null ? void 0 : n.call(e), (r = e.children) != null && r.length && yc(e.children);
  }), t.sort((e, n) => e.no - n.no);
}
function XR() {
  const t = ht(), e = YR();
  return {
    ns: Fe("table"),
    ...e,
    mutations: {
      setData(o, a) {
        const l = x(o._data) !== a;
        o.data.value = a, o._data.value = a, t.store.execQuery(), t.store.updateCurrentRowData(), t.store.updateExpandRows(), t.store.updateTreeData(t.store.states.defaultExpandAll.value), x(o.reserveSelection) ? (t.store.assertRowKey(), t.store.updateSelectionByRowKey()) : l ? t.store.clearSelection() : t.store.cleanSelection(), t.store.updateAllSelected(), t.$ready && t.store.scheduleLayout();
      },
      insertColumn(o, a, l, u) {
        const c = x(o._columns);
        let d = [];
        l ? (l && !l.children && (l.children = []), l.children.push(a), d = gc(c, l)) : (c.push(a), d = c), yc(d), o._columns.value = d, o.updateOrderFns.push(u), a.type === "selection" && (o.selectable.value = a.selectable, o.reserveSelection.value = a.reserveSelection), t.$ready && (t.store.updateColumns(), t.store.scheduleLayout());
      },
      updateColumnOrder(o, a) {
        var l;
        ((l = a.getColumnIndex) == null ? void 0 : l.call(a)) !== a.no && (yc(o._columns.value), t.$ready && t.store.updateColumns());
      },
      removeColumn(o, a, l, u) {
        const c = x(o._columns) || [];
        if (l)
          l.children.splice(l.children.findIndex((h) => h.id === a.id), 1), rt(() => {
            var h;
            ((h = l.children) == null ? void 0 : h.length) === 0 && delete l.children;
          }), o._columns.value = gc(c, l);
        else {
          const h = c.indexOf(a);
          h > -1 && (c.splice(h, 1), o._columns.value = c);
        }
        const d = o.updateOrderFns.indexOf(u);
        d > -1 && o.updateOrderFns.splice(d, 1), t.$ready && (t.store.updateColumns(), t.store.scheduleLayout());
      },
      sort(o, a) {
        const { prop: l, order: u, init: c } = a;
        if (l) {
          const d = x(o.columns).find((h) => h.property === l);
          d && (d.order = u, t.store.updateSort(d, l, u), t.store.commit("changeSortCondition", { init: c }));
        }
      },
      changeSortCondition(o, a) {
        const { sortingColumn: l, sortProp: u, sortOrder: c } = o, d = x(l), h = x(u), v = x(c);
        v === null && (o.sortingColumn.value = null, o.sortProp.value = null);
        const y = { filter: !0 };
        t.store.execQuery(y), (!a || !(a.silent || a.init)) && t.emit("sort-change", {
          column: d,
          prop: h,
          order: v
        }), t.store.updateTableScrollY();
      },
      filterChange(o, a) {
        const { column: l, values: u, silent: c } = a, d = t.store.updateFilters(l, u);
        t.store.execQuery(), c || t.emit("filter-change", d), t.store.updateTableScrollY();
      },
      toggleAllSelection() {
        t.store.toggleAllSelection();
      },
      rowSelectedChanged(o, a) {
        t.store.toggleRowSelection(a), t.store.updateAllSelected();
      },
      setHoverRow(o, a) {
        o.hoverRow.value = a;
      },
      setCurrentRow(o, a) {
        t.store.updateCurrentRow(a);
      }
    },
    commit: function(o, ...a) {
      const l = t.store.mutations;
      if (l[o])
        l[o].apply(t, [t.store.states].concat(a));
      else
        throw new Error(`Action not found: ${o}`);
    },
    updateTableScrollY: function() {
      rt(() => t.layout.updateScrollY.apply(t.layout));
    }
  };
}
const fo = {
  rowKey: "rowKey",
  defaultExpandAll: "defaultExpandAll",
  selectOnIndeterminate: "selectOnIndeterminate",
  indent: "indent",
  lazy: "lazy",
  data: "data",
  ["treeProps.hasChildren"]: {
    key: "lazyColumnIdentifier",
    default: "hasChildren"
  },
  ["treeProps.children"]: {
    key: "childrenColumnName",
    default: "children"
  }
};
function ZR(t, e) {
  if (!t)
    throw new Error("Table is required.");
  const n = XR();
  return n.toggleAllSelection = Xr(n._toggleAllSelection, 10), Object.keys(fo).forEach((r) => {
    Pg($g(e, r), r, n);
  }), QR(n, e), n;
}
function QR(t, e) {
  Object.keys(fo).forEach((n) => {
    ke(() => $g(e, n), (r) => {
      Pg(r, n, t);
    });
  });
}
function Pg(t, e, n) {
  let r = t, i = fo[e];
  typeof fo[e] == "object" && (i = i.key, r = r || fo[e].default), n.states[i].value = r;
}
function $g(t, e) {
  if (e.includes(".")) {
    const n = e.split(".");
    let r = t;
    return n.forEach((i) => {
      r = r[i];
    }), r;
  } else
    return t[e];
}
class JR {
  constructor(e) {
    this.observers = [], this.table = null, this.store = null, this.columns = [], this.fit = !0, this.showHeader = !0, this.height = K(null), this.scrollX = K(!1), this.scrollY = K(!1), this.bodyWidth = K(null), this.fixedWidth = K(null), this.rightFixedWidth = K(null), this.gutterWidth = 0;
    for (const n in e)
      Or(e, n) && (on(this[n]) ? this[n].value = e[n] : this[n] = e[n]);
    if (!this.table)
      throw new Error("Table is required for Table Layout");
    if (!this.store)
      throw new Error("Store is required for Table Layout");
  }
  updateScrollY() {
    if (this.height.value === null)
      return !1;
    const n = this.table.refs.scrollBarRef;
    if (this.table.vnode.el && (n != null && n.wrapRef)) {
      let r = !0;
      const i = this.scrollY.value;
      return r = n.wrapRef.scrollHeight > n.wrapRef.clientHeight, this.scrollY.value = r, i !== r;
    }
    return !1;
  }
  setHeight(e, n = "height") {
    if (!Et)
      return;
    const r = this.table.vnode.el;
    if (e = jR(e), this.height.value = Number(e), !r && (e || e === 0))
      return rt(() => this.setHeight(e, n));
    typeof e == "number" ? (r.style[n] = `${e}px`, this.updateElsHeight()) : typeof e == "string" && (r.style[n] = e, this.updateElsHeight());
  }
  setMaxHeight(e) {
    this.setHeight(e, "max-height");
  }
  getFlattenColumns() {
    const e = [];
    return this.table.store.states.columns.value.forEach((r) => {
      r.isColumnGroup ? e.push.apply(e, r.columns) : e.push(r);
    }), e;
  }
  updateElsHeight() {
    this.updateScrollY(), this.notifyObservers("scrollable");
  }
  headerDisplayNone(e) {
    if (!e)
      return !0;
    let n = e;
    for (; n.tagName !== "DIV"; ) {
      if (getComputedStyle(n).display === "none")
        return !0;
      n = n.parentElement;
    }
    return !1;
  }
  updateColumnsWidth() {
    if (!Et)
      return;
    const e = this.fit, n = this.table.vnode.el.clientWidth;
    let r = 0;
    const i = this.getFlattenColumns(), s = i.filter((l) => typeof l.width != "number");
    if (i.forEach((l) => {
      typeof l.width == "number" && l.realWidth && (l.realWidth = null);
    }), s.length > 0 && e) {
      if (i.forEach((l) => {
        r += Number(l.width || l.minWidth || 80);
      }), r <= n) {
        this.scrollX.value = !1;
        const l = n - r;
        if (s.length === 1)
          s[0].realWidth = Number(s[0].minWidth || 80) + l;
        else {
          const u = s.reduce((h, v) => h + Number(v.minWidth || 80), 0), c = l / u;
          let d = 0;
          s.forEach((h, v) => {
            if (v === 0)
              return;
            const y = Math.floor(Number(h.minWidth || 80) * c);
            d += y, h.realWidth = Number(h.minWidth || 80) + y;
          }), s[0].realWidth = Number(s[0].minWidth || 80) + l - d;
        }
      } else
        this.scrollX.value = !0, s.forEach((l) => {
          l.realWidth = Number(l.minWidth);
        });
      this.bodyWidth.value = Math.max(r, n), this.table.state.resizeState.value.width = this.bodyWidth.value;
    } else
      i.forEach((l) => {
        !l.width && !l.minWidth ? l.realWidth = 80 : l.realWidth = Number(l.width || l.minWidth), r += l.realWidth;
      }), this.scrollX.value = r > n, this.bodyWidth.value = r;
    const o = this.store.states.fixedColumns.value;
    if (o.length > 0) {
      let l = 0;
      o.forEach((u) => {
        l += Number(u.realWidth || u.width);
      }), this.fixedWidth.value = l;
    }
    const a = this.store.states.rightFixedColumns.value;
    if (a.length > 0) {
      let l = 0;
      a.forEach((u) => {
        l += Number(u.realWidth || u.width);
      }), this.rightFixedWidth.value = l;
    }
    this.notifyObservers("columns");
  }
  addObserver(e) {
    this.observers.push(e);
  }
  removeObserver(e) {
    const n = this.observers.indexOf(e);
    n !== -1 && this.observers.splice(n, 1);
  }
  notifyObservers(e) {
    this.observers.forEach((r) => {
      var i, s;
      switch (e) {
        case "columns":
          (i = r.state) == null || i.onColumnsChange(this);
          break;
        case "scrollable":
          (s = r.state) == null || s.onScrollableChange(this);
          break;
        default:
          throw new Error(`Table Layout don't have event ${e}.`);
      }
    });
  }
}
const { CheckboxGroup: e4 } = Fi, t4 = be({
  name: "ElTableFilterPanel",
  components: {
    ElCheckbox: Fi,
    ElCheckboxGroup: e4,
    ElScrollbar: Wd,
    ElTooltip: Zl,
    ElIcon: _t,
    ArrowDown: Nd,
    ArrowUp: sm
  },
  directives: { ClickOutside: Qm },
  props: {
    placement: {
      type: String,
      default: "bottom-start"
    },
    store: {
      type: Object
    },
    column: {
      type: Object
    },
    upDataColumn: {
      type: Function
    }
  },
  setup(t) {
    const e = ht(), { t: n } = or(), r = Fe("table-filter"), i = e == null ? void 0 : e.parent;
    i.filterPanels.value[t.column.id] || (i.filterPanels.value[t.column.id] = e);
    const s = K(!1), o = K(null), a = F(() => t.column && t.column.filters), l = F({
      get: () => {
        var w;
        return (((w = t.column) == null ? void 0 : w.filteredValue) || [])[0];
      },
      set: (w) => {
        u.value && (typeof w < "u" && w !== null ? u.value.splice(0, 1, w) : u.value.splice(0, 1));
      }
    }), u = F({
      get() {
        return t.column ? t.column.filteredValue || [] : [];
      },
      set(w) {
        t.column && t.upDataColumn("filteredValue", w);
      }
    }), c = F(() => t.column ? t.column.filterMultiple : !0), d = (w) => w.value === l.value, h = () => {
      s.value = !1;
    }, v = (w) => {
      w.stopPropagation(), s.value = !s.value;
    }, y = () => {
      s.value = !1;
    }, b = () => {
      m(u.value), h();
    }, p = () => {
      u.value = [], m(u.value), h();
    }, f = (w) => {
      l.value = w, m(typeof w < "u" && w !== null ? u.value : []), h();
    }, m = (w) => {
      t.store.commit("filterChange", {
        column: t.column,
        values: w
      }), t.store.updateAllSelected();
    };
    ke(s, (w) => {
      t.column && t.upDataColumn("filterOpened", w);
    }, {
      immediate: !0
    });
    const g = F(() => {
      var w, _;
      return (_ = (w = o.value) == null ? void 0 : w.popperRef) == null ? void 0 : _.contentRef;
    });
    return {
      tooltipVisible: s,
      multiple: c,
      filteredValue: u,
      filterValue: l,
      filters: a,
      handleConfirm: b,
      handleReset: p,
      handleSelect: f,
      isActive: d,
      t: n,
      ns: r,
      showFilterPanel: v,
      hideFilterPanel: y,
      popperPaneRef: g,
      tooltip: o
    };
  }
}), n4 = { key: 0 }, r4 = ["disabled"], i4 = ["label", "onClick"];
function s4(t, e, n, r, i, s) {
  const o = Dt("el-checkbox"), a = Dt("el-checkbox-group"), l = Dt("el-scrollbar"), u = Dt("arrow-up"), c = Dt("arrow-down"), d = Dt("el-icon"), h = Dt("el-tooltip"), v = ud("click-outside");
  return V(), Ce(h, {
    ref: "tooltip",
    visible: t.tooltipVisible,
    offset: 0,
    placement: t.placement,
    "show-arrow": !1,
    "stop-popper-mouse-event": !1,
    teleported: "",
    effect: "light",
    pure: "",
    "popper-class": t.ns.b(),
    persistent: ""
  }, {
    content: de(() => [
      t.multiple ? (V(), se("div", n4, [
        ae("div", {
          class: ee(t.ns.e("content"))
        }, [
          ve(l, {
            "wrap-class": t.ns.e("wrap")
          }, {
            default: de(() => [
              ve(a, {
                modelValue: t.filteredValue,
                "onUpdate:modelValue": e[0] || (e[0] = (y) => t.filteredValue = y),
                class: ee(t.ns.e("checkbox-group"))
              }, {
                default: de(() => [
                  (V(!0), se(Ft, null, Gn(t.filters, (y) => (V(), Ce(o, {
                    key: y.value,
                    label: y.value
                  }, {
                    default: de(() => [
                      cn(st(y.text), 1)
                    ]),
                    _: 2
                  }, 1032, ["label"]))), 128))
                ]),
                _: 1
              }, 8, ["modelValue", "class"])
            ]),
            _: 1
          }, 8, ["wrap-class"])
        ], 2),
        ae("div", {
          class: ee(t.ns.e("bottom"))
        }, [
          ae("button", {
            class: ee({ [t.ns.is("disabled")]: t.filteredValue.length === 0 }),
            disabled: t.filteredValue.length === 0,
            type: "button",
            onClick: e[1] || (e[1] = (...y) => t.handleConfirm && t.handleConfirm(...y))
          }, st(t.t("el.table.confirmFilter")), 11, r4),
          ae("button", {
            type: "button",
            onClick: e[2] || (e[2] = (...y) => t.handleReset && t.handleReset(...y))
          }, st(t.t("el.table.resetFilter")), 1)
        ], 2)
      ])) : (V(), se("ul", {
        key: 1,
        class: ee(t.ns.e("list"))
      }, [
        ae("li", {
          class: ee([
            t.ns.e("list-item"),
            {
              [t.ns.is("active")]: t.filterValue === void 0 || t.filterValue === null
            }
          ]),
          onClick: e[3] || (e[3] = (y) => t.handleSelect(null))
        }, st(t.t("el.table.clearFilter")), 3),
        (V(!0), se(Ft, null, Gn(t.filters, (y) => (V(), se("li", {
          key: y.value,
          class: ee([t.ns.e("list-item"), t.ns.is("active", t.isActive(y))]),
          label: y.value,
          onClick: (b) => t.handleSelect(y.value)
        }, st(y.text), 11, i4))), 128))
      ], 2))
    ]),
    default: de(() => [
      $t((V(), se("span", {
        class: ee([
          `${t.ns.namespace.value}-table__column-filter-trigger`,
          `${t.ns.namespace.value}-none-outline`
        ]),
        onClick: e[4] || (e[4] = (...y) => t.showFilterPanel && t.showFilterPanel(...y))
      }, [
        ve(d, null, {
          default: de(() => [
            t.column.filterOpened ? (V(), Ce(u, { key: 0 })) : (V(), Ce(c, { key: 1 }))
          ]),
          _: 1
        })
      ], 2)), [
        [v, t.hideFilterPanel, t.popperPaneRef]
      ])
    ]),
    _: 1
  }, 8, ["visible", "placement", "popper-class"]);
}
var o4 = /* @__PURE__ */ qe(t4, [["render", s4], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/table/src/filter-panel.vue"]]);
function Dg(t) {
  const e = ht();
  ld(() => {
    n.value.addObserver(e);
  }), Tt(() => {
    r(n.value), i(n.value);
  }), Dl(() => {
    r(n.value), i(n.value);
  }), Wo(() => {
    n.value.removeObserver(e);
  });
  const n = F(() => {
    const s = t.layout;
    if (!s)
      throw new Error("Can not find table layout.");
    return s;
  }), r = (s) => {
    var o;
    const a = ((o = t.vnode.el) == null ? void 0 : o.querySelectorAll("colgroup > col")) || [];
    if (!a.length)
      return;
    const l = s.getFlattenColumns(), u = {};
    l.forEach((c) => {
      u[c.id] = c;
    });
    for (let c = 0, d = a.length; c < d; c++) {
      const h = a[c], v = h.getAttribute("name"), y = u[v];
      y && h.setAttribute("width", y.realWidth || y.width);
    }
  }, i = (s) => {
    var o, a;
    const l = ((o = t.vnode.el) == null ? void 0 : o.querySelectorAll("colgroup > col[name=gutter]")) || [];
    for (let c = 0, d = l.length; c < d; c++)
      l[c].setAttribute("width", s.scrollY.value ? s.gutterWidth : "0");
    const u = ((a = t.vnode.el) == null ? void 0 : a.querySelectorAll("th.gutter")) || [];
    for (let c = 0, d = u.length; c < d; c++) {
      const h = u[c];
      h.style.width = s.scrollY.value ? `${s.gutterWidth}px` : "0", h.style.display = s.scrollY.value ? "" : "none";
    }
  };
  return {
    tableLayout: n.value,
    onColumnsChange: r,
    onScrollableChange: i
  };
}
const $r = Symbol("ElTable");
function a4(t, e) {
  const n = ht(), r = tt($r), i = (b) => {
    b.stopPropagation();
  }, s = (b, p) => {
    !p.filters && p.sortable ? y(b, p, !1) : p.filterable && !p.sortable && i(b), r == null || r.emit("header-click", p, b);
  }, o = (b, p) => {
    r == null || r.emit("header-contextmenu", p, b);
  }, a = K(null), l = K(!1), u = K({}), c = (b, p) => {
    if (Et && !(p.children && p.children.length > 0) && a.value && t.border) {
      l.value = !0;
      const f = r;
      e("set-drag-visible", !0);
      const g = (f == null ? void 0 : f.vnode.el).getBoundingClientRect().left, w = n.vnode.el.querySelector(`th.${p.id}`), _ = w.getBoundingClientRect(), E = _.left - g + 30;
      Co(w, "noclick"), u.value = {
        startMouseLeft: b.clientX,
        startLeft: _.right - g,
        startColumnLeft: _.left - g,
        tableLeft: g
      };
      const C = f == null ? void 0 : f.refs.resizeProxy;
      C.style.left = `${u.value.startLeft}px`, document.onselectstart = function() {
        return !1;
      }, document.ondragstart = function() {
        return !1;
      };
      const T = (N) => {
        const I = N.clientX - u.value.startMouseLeft, P = u.value.startLeft + I;
        C.style.left = `${Math.max(E, P)}px`;
      }, k = () => {
        if (l.value) {
          const { startColumnLeft: N, startLeft: I } = u.value, D = Number.parseInt(C.style.left, 10) - N;
          p.width = p.realWidth = D, f == null || f.emit("header-dragend", p.width, I - N, p, b), requestAnimationFrame(() => {
            t.store.scheduleLayout(!1, !0);
          }), document.body.style.cursor = "", l.value = !1, a.value = null, u.value = {}, e("set-drag-visible", !1);
        }
        document.removeEventListener("mousemove", T), document.removeEventListener("mouseup", k), document.onselectstart = null, document.ondragstart = null, setTimeout(() => {
          Sr(w, "noclick");
        }, 0);
      };
      document.addEventListener("mousemove", T), document.addEventListener("mouseup", k);
    }
  }, d = (b, p) => {
    if (p.children && p.children.length > 0)
      return;
    const f = b.target;
    if (!zi(f))
      return;
    const m = f == null ? void 0 : f.closest("th");
    if (!(!p || !p.resizable) && !l.value && t.border) {
      const g = m.getBoundingClientRect(), w = document.body.style;
      g.width > 12 && g.right - b.pageX < 8 ? (w.cursor = "col-resize", Pa(m, "is-sortable") && (m.style.cursor = "col-resize"), a.value = p) : l.value || (w.cursor = "", Pa(m, "is-sortable") && (m.style.cursor = "pointer"), a.value = null);
    }
  }, h = () => {
    Et && (document.body.style.cursor = "");
  }, v = ({ order: b, sortOrders: p }) => {
    if (b === "")
      return p[0];
    const f = p.indexOf(b || null);
    return p[f > p.length - 2 ? 0 : f + 1];
  }, y = (b, p, f) => {
    var m;
    b.stopPropagation();
    const g = p.order === f ? null : f || v(p), w = (m = b.target) == null ? void 0 : m.closest("th");
    if (w && Pa(w, "noclick")) {
      Sr(w, "noclick");
      return;
    }
    if (!p.sortable)
      return;
    const _ = t.store.states;
    let E = _.sortProp.value, C;
    const T = _.sortingColumn.value;
    (T !== p || T === p && T.order === null) && (T && (T.order = null), _.sortingColumn.value = p, E = p.property), g ? C = p.order = g : C = p.order = null, _.sortProp.value = E, _.sortOrder.value = C, r == null || r.store.commit("changeSortCondition");
  };
  return {
    handleHeaderClick: s,
    handleHeaderContextMenu: o,
    handleMouseDown: c,
    handleMouseMove: d,
    handleMouseOut: h,
    handleSortClick: y,
    handleFilterClick: i
  };
}
function l4(t) {
  const e = tt($r), n = Fe("table");
  return {
    getHeaderRowStyle: (a) => {
      const l = e == null ? void 0 : e.props.headerRowStyle;
      return typeof l == "function" ? l.call(null, { rowIndex: a }) : l;
    },
    getHeaderRowClass: (a) => {
      const l = [], u = e == null ? void 0 : e.props.headerRowClassName;
      return typeof u == "string" ? l.push(u) : typeof u == "function" && l.push(u.call(null, { rowIndex: a })), l.join(" ");
    },
    getHeaderCellStyle: (a, l, u, c) => {
      var d;
      let h = (d = e == null ? void 0 : e.props.headerCellStyle) != null ? d : {};
      typeof h == "function" && (h = h.call(null, {
        rowIndex: a,
        columnIndex: l,
        row: u,
        column: c
      }));
      const v = Qd(l, c.fixed, t.store, u);
      return Ls(v, "left"), Ls(v, "right"), Object.assign({}, h, v);
    },
    getHeaderCellClass: (a, l, u, c) => {
      const d = Zd(n.b(), l, c.fixed, t.store, u), h = [
        c.id,
        c.order,
        c.headerAlign,
        c.className,
        c.labelClassName,
        ...d
      ];
      c.children || h.push("is-leaf"), c.sortable && h.push("is-sortable");
      const v = e == null ? void 0 : e.props.headerCellClassName;
      return typeof v == "string" ? h.push(v) : typeof v == "function" && h.push(v.call(null, {
        rowIndex: a,
        columnIndex: l,
        row: u,
        column: c
      })), h.push(n.e("cell")), h.filter((y) => !!y).join(" ");
    }
  };
}
const Bg = (t) => {
  const e = [];
  return t.forEach((n) => {
    n.children ? (e.push(n), e.push.apply(e, Bg(n.children))) : e.push(n);
  }), e;
}, u4 = (t) => {
  let e = 1;
  const n = (s, o) => {
    if (o && (s.level = o.level + 1, e < s.level && (e = s.level)), s.children) {
      let a = 0;
      s.children.forEach((l) => {
        n(l, s), a += l.colSpan;
      }), s.colSpan = a;
    } else
      s.colSpan = 1;
  };
  t.forEach((s) => {
    s.level = 1, n(s, void 0);
  });
  const r = [];
  for (let s = 0; s < e; s++)
    r.push([]);
  return Bg(t).forEach((s) => {
    s.children ? (s.rowSpan = 1, s.children.forEach((o) => o.isSubColumn = !0)) : s.rowSpan = e - s.level + 1, r[s.level - 1].push(s);
  }), r;
};
function c4(t) {
  const e = tt($r), n = F(() => u4(t.store.states.originColumns.value));
  return {
    isGroup: F(() => {
      const s = n.value.length > 1;
      return s && e && (e.state.isGroup.value = !0), s;
    }),
    toggleAllSelection: (s) => {
      s.stopPropagation(), e == null || e.store.commit("toggleAllSelection");
    },
    columnRows: n
  };
}
var d4 = be({
  name: "ElTableHeader",
  components: {
    ElCheckbox: Fi
  },
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: !0,
      type: Object
    },
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => ({
        prop: "",
        order: ""
      })
    }
  },
  setup(t, { emit: e }) {
    const n = ht(), r = tt($r), i = Fe("table"), s = K({}), { onColumnsChange: o, onScrollableChange: a } = Dg(r);
    Tt(async () => {
      await rt(), await rt();
      const { prop: E, order: C } = t.defaultSort;
      r == null || r.store.commit("sort", { prop: E, order: C, init: !0 });
    });
    const {
      handleHeaderClick: l,
      handleHeaderContextMenu: u,
      handleMouseDown: c,
      handleMouseMove: d,
      handleMouseOut: h,
      handleSortClick: v,
      handleFilterClick: y
    } = a4(t, e), {
      getHeaderRowStyle: b,
      getHeaderRowClass: p,
      getHeaderCellStyle: f,
      getHeaderCellClass: m
    } = l4(t), { isGroup: g, toggleAllSelection: w, columnRows: _ } = c4(t);
    return n.state = {
      onColumnsChange: o,
      onScrollableChange: a
    }, n.filterPanels = s, {
      ns: i,
      filterPanels: s,
      onColumnsChange: o,
      onScrollableChange: a,
      columnRows: _,
      getHeaderRowClass: p,
      getHeaderRowStyle: b,
      getHeaderCellClass: m,
      getHeaderCellStyle: f,
      handleHeaderClick: l,
      handleHeaderContextMenu: u,
      handleMouseDown: c,
      handleMouseMove: d,
      handleMouseOut: h,
      handleSortClick: v,
      handleFilterClick: y,
      isGroup: g,
      toggleAllSelection: w
    };
  },
  render() {
    const {
      ns: t,
      isGroup: e,
      columnRows: n,
      getHeaderCellStyle: r,
      getHeaderCellClass: i,
      getHeaderRowClass: s,
      getHeaderRowStyle: o,
      handleHeaderClick: a,
      handleHeaderContextMenu: l,
      handleMouseDown: u,
      handleMouseMove: c,
      handleSortClick: d,
      handleMouseOut: h,
      store: v,
      $parent: y
    } = this;
    let b = 1;
    return et("thead", {
      class: { [t.is("group")]: e }
    }, n.map((p, f) => et("tr", {
      class: s(f),
      key: f,
      style: o(f)
    }, p.map((m, g) => (m.rowSpan > b && (b = m.rowSpan), et("th", {
      class: i(f, g, p, m),
      colspan: m.colSpan,
      key: `${m.id}-thead`,
      rowspan: m.rowSpan,
      style: r(f, g, p, m),
      onClick: (w) => a(w, m),
      onContextmenu: (w) => l(w, m),
      onMousedown: (w) => u(w, m),
      onMousemove: (w) => c(w, m),
      onMouseout: h
    }, [
      et("div", {
        class: [
          "cell",
          m.filteredValue && m.filteredValue.length > 0 ? "highlight" : ""
        ]
      }, [
        m.renderHeader ? m.renderHeader({
          column: m,
          $index: g,
          store: v,
          _self: y
        }) : m.label,
        m.sortable && et("span", {
          onClick: (w) => d(w, m),
          class: "caret-wrapper"
        }, [
          et("i", {
            onClick: (w) => d(w, m, "ascending"),
            class: "sort-caret ascending"
          }),
          et("i", {
            onClick: (w) => d(w, m, "descending"),
            class: "sort-caret descending"
          })
        ]),
        m.filterable && et(o4, {
          store: v,
          placement: m.filterPlacement || "bottom-start",
          column: m,
          upDataColumn: (w, _) => {
            m[w] = _;
          }
        })
      ])
    ]))))));
  }
});
function f4(t) {
  const e = tt($r), n = K(""), r = K(et("div")), { nextZIndex: i } = Gl(), s = (y, b, p) => {
    var f;
    const m = e, g = Tu(y);
    let w;
    const _ = (f = m == null ? void 0 : m.vnode.el) == null ? void 0 : f.dataset.prefix;
    g && (w = ap({
      columns: t.store.states.columns.value
    }, g, _), w && (m == null || m.emit(`cell-${p}`, b, w, g, y))), m == null || m.emit(`row-${p}`, b, w, y);
  }, o = (y, b) => {
    s(y, b, "dblclick");
  }, a = (y, b) => {
    t.store.commit("setCurrentRow", b), s(y, b, "click");
  }, l = (y, b) => {
    s(y, b, "contextmenu");
  }, u = Xr((y) => {
    t.store.commit("setHoverRow", y);
  }, 30), c = Xr(() => {
    t.store.commit("setHoverRow", null);
  }, 30), d = (y) => {
    const b = window.getComputedStyle(y, null), p = Number.parseInt(b.paddingLeft, 10) || 0, f = Number.parseInt(b.paddingRight, 10) || 0, m = Number.parseInt(b.paddingTop, 10) || 0, g = Number.parseInt(b.paddingBottom, 10) || 0;
    return {
      left: p,
      right: f,
      top: m,
      bottom: g
    };
  };
  return {
    handleDoubleClick: o,
    handleClick: a,
    handleContextMenu: l,
    handleMouseEnter: u,
    handleMouseLeave: c,
    handleCellMouseEnter: (y, b, p) => {
      var f;
      const m = e, g = Tu(y), w = (f = m == null ? void 0 : m.vnode.el) == null ? void 0 : f.dataset.prefix;
      if (g) {
        const M = ap({
          columns: t.store.states.columns.value
        }, g, w), U = m.hoverState = { cell: g, column: M, row: b };
        m == null || m.emit("cell-mouse-enter", U.row, U.column, U.cell, y);
      }
      if (!p)
        return;
      const _ = y.target.querySelector(".cell");
      if (!(Pa(_, `${w}-tooltip`) && _.childNodes.length))
        return;
      const E = document.createRange();
      E.setStart(_, 0), E.setEnd(_, _.childNodes.length);
      let C = E.getBoundingClientRect().width, T = E.getBoundingClientRect().height;
      C - Math.floor(C) < 1e-3 && (C = Math.floor(C)), T - Math.floor(T) < 1e-3 && (T = Math.floor(T));
      const { top: I, left: P, right: D, bottom: z } = d(_), G = P + D, J = I + z;
      (C + G > _.offsetWidth || T + J > _.offsetHeight || _.scrollWidth > _.offsetWidth) && WR(e == null ? void 0 : e.refs.tableWrapper, g, g.innerText || g.textContent, i, p);
    },
    handleCellMouseLeave: (y) => {
      if (!Tu(y))
        return;
      const p = e == null ? void 0 : e.hoverState;
      e == null || e.emit("cell-mouse-leave", p == null ? void 0 : p.row, p == null ? void 0 : p.column, p == null ? void 0 : p.cell, y);
    },
    tooltipContent: n,
    tooltipTrigger: r
  };
}
function h4(t) {
  const e = tt($r), n = Fe("table");
  return {
    getRowStyle: (u, c) => {
      const d = e == null ? void 0 : e.props.rowStyle;
      return typeof d == "function" ? d.call(null, {
        row: u,
        rowIndex: c
      }) : d || null;
    },
    getRowClass: (u, c) => {
      const d = [n.e("row")];
      e != null && e.props.highlightCurrentRow && u === t.store.states.currentRow.value && d.push("current-row"), t.stripe && c % 2 === 1 && d.push(n.em("row", "striped"));
      const h = e == null ? void 0 : e.props.rowClassName;
      return typeof h == "string" ? d.push(h) : typeof h == "function" && d.push(h.call(null, {
        row: u,
        rowIndex: c
      })), d;
    },
    getCellStyle: (u, c, d, h) => {
      const v = e == null ? void 0 : e.props.cellStyle;
      let y = v ?? {};
      typeof v == "function" && (y = v.call(null, {
        rowIndex: u,
        columnIndex: c,
        row: d,
        column: h
      }));
      const b = Qd(c, t == null ? void 0 : t.fixed, t.store);
      return Ls(b, "left"), Ls(b, "right"), Object.assign({}, y, b);
    },
    getCellClass: (u, c, d, h, v) => {
      const y = Zd(n.b(), c, t == null ? void 0 : t.fixed, t.store, void 0, v), b = [h.id, h.align, h.className, ...y], p = e == null ? void 0 : e.props.cellClassName;
      return typeof p == "string" ? b.push(p) : typeof p == "function" && b.push(p.call(null, {
        rowIndex: u,
        columnIndex: c,
        row: d,
        column: h
      })), b.push(n.e("cell")), b.filter((f) => !!f).join(" ");
    },
    getSpan: (u, c, d, h) => {
      let v = 1, y = 1;
      const b = e == null ? void 0 : e.props.spanMethod;
      if (typeof b == "function") {
        const p = b({
          row: u,
          column: c,
          rowIndex: d,
          columnIndex: h
        });
        Array.isArray(p) ? (v = p[0], y = p[1]) : typeof p == "object" && (v = p.rowspan, y = p.colspan);
      }
      return { rowspan: v, colspan: y };
    },
    getColspanRealWidth: (u, c, d) => {
      if (c < 1)
        return u[d].realWidth;
      const h = u.map(({ realWidth: v, width: y }) => v || y).slice(d, d + c);
      return Number(h.reduce((v, y) => Number(v) + Number(y), -1));
    }
  };
}
function p4(t) {
  const e = tt($r), n = Fe("table"), {
    handleDoubleClick: r,
    handleClick: i,
    handleContextMenu: s,
    handleMouseEnter: o,
    handleMouseLeave: a,
    handleCellMouseEnter: l,
    handleCellMouseLeave: u,
    tooltipContent: c,
    tooltipTrigger: d
  } = f4(t), {
    getRowStyle: h,
    getRowClass: v,
    getCellStyle: y,
    getCellClass: b,
    getSpan: p,
    getColspanRealWidth: f
  } = h4(t), m = F(() => t.store.states.columns.value.findIndex(({ type: C }) => C === "default")), g = (C, T) => {
    const k = e.props.rowKey;
    return k ? yn(C, k) : T;
  }, w = (C, T, k, N = !1) => {
    const { tooltipEffect: I, tooltipOptions: P, store: D } = t, { indent: z, columns: G } = D.states, J = v(C, T);
    let M = !0;
    return k && (J.push(n.em("row", `level-${k.level}`)), M = k.display), et("tr", {
      style: [M ? null : {
        display: "none"
      }, h(C, T)],
      class: J,
      key: g(C, T),
      onDblclick: (j) => r(j, C),
      onClick: (j) => i(j, C),
      onContextmenu: (j) => s(j, C),
      onMouseenter: () => o(T),
      onMouseleave: a
    }, G.value.map((j, re) => {
      const { rowspan: fe, colspan: Y } = p(C, j, T, re);
      if (!fe || !Y)
        return null;
      const le = Object.assign({}, j);
      le.realWidth = f(G.value, Y, re);
      const ce = {
        store: t.store,
        _self: t.context || e,
        column: le,
        row: C,
        $index: T,
        cellIndex: re,
        expanded: N
      };
      re === m.value && k && (ce.treeNode = {
        indent: k.level * z.value,
        level: k.level
      }, typeof k.expanded == "boolean" && (ce.treeNode.expanded = k.expanded, "loading" in k && (ce.treeNode.loading = k.loading), "noLazyChildren" in k && (ce.treeNode.noLazyChildren = k.noLazyChildren)));
      const me = `${T},${re}`, _e = le.columnKey || le.rawColumnKey || "", ze = _(re, j, ce), Oe = j.showOverflowTooltip && tm({
        effect: I
      }, P, j.showOverflowTooltip);
      return et("td", {
        style: y(T, re, C, j),
        class: b(T, re, C, j, Y - 1),
        key: `${_e}${me}`,
        rowspan: fe,
        colspan: Y,
        onMouseenter: (Qe) => l(Qe, C, Oe),
        onMouseleave: u
      }, [ze]);
    }));
  }, _ = (C, T, k) => T.renderCell(k);
  return {
    wrappedRowRender: (C, T) => {
      const k = t.store, { isRowExpanded: N, assertRowKey: I } = k, { treeData: P, lazyTreeNodeMap: D, childrenColumnName: z, rowKey: G } = k.states, J = k.states.columns.value;
      if (J.some(({ type: U }) => U === "expand")) {
        const U = N(C), j = w(C, T, void 0, U), re = e.renderExpanded;
        return U ? re ? [
          [
            j,
            et("tr", {
              key: `expanded-row__${j.key}`
            }, [
              et("td", {
                colspan: J.length,
                class: `${n.e("cell")} ${n.e("expanded-cell")}`
              }, [re({ row: C, $index: T, store: k, expanded: U })])
            ])
          ]
        ] : (console.error("[Element Error]renderExpanded is required."), j) : [[j]];
      } else if (Object.keys(P.value).length) {
        I();
        const U = yn(C, G.value);
        let j = P.value[U], re = null;
        j && (re = {
          expanded: j.expanded,
          level: j.level,
          display: !0
        }, typeof j.lazy == "boolean" && (typeof j.loaded == "boolean" && j.loaded && (re.noLazyChildren = !(j.children && j.children.length)), re.loading = j.loading));
        const fe = [w(C, T, re)];
        if (j) {
          let Y = 0;
          const le = (me, _e) => {
            me && me.length && _e && me.forEach((ze) => {
              const Oe = {
                display: _e.display && _e.expanded,
                level: _e.level + 1,
                expanded: !1,
                noLazyChildren: !1,
                loading: !1
              }, Qe = yn(ze, G.value);
              if (Qe == null)
                throw new Error("For nested data item, row-key is required.");
              if (j = { ...P.value[Qe] }, j && (Oe.expanded = j.expanded, j.level = j.level || Oe.level, j.display = !!(j.expanded && Oe.display), typeof j.lazy == "boolean" && (typeof j.loaded == "boolean" && j.loaded && (Oe.noLazyChildren = !(j.children && j.children.length)), Oe.loading = j.loading)), Y++, fe.push(w(ze, T + Y, Oe)), j) {
                const Be = D.value[Qe] || ze[z.value];
                le(Be, j);
              }
            });
          };
          j.display = !0;
          const ce = D.value[U] || C[z.value];
          le(ce, j);
        }
        return fe;
      } else
        return w(C, T, void 0);
    },
    tooltipContent: c,
    tooltipTrigger: d
  };
}
const v4 = {
  store: {
    required: !0,
    type: Object
  },
  stripe: Boolean,
  tooltipEffect: String,
  tooltipOptions: {
    type: Object
  },
  context: {
    default: () => ({}),
    type: Object
  },
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  fixed: {
    type: String,
    default: ""
  },
  highlight: Boolean
};
var m4 = be({
  name: "ElTableBody",
  props: v4,
  setup(t) {
    const e = ht(), n = tt($r), r = Fe("table"), { wrappedRowRender: i, tooltipContent: s, tooltipTrigger: o } = p4(t), { onColumnsChange: a, onScrollableChange: l } = Dg(n);
    return ke(t.store.states.hoverRow, (u, c) => {
      !t.store.states.isComplex.value || !Et || eT(() => {
        const d = e == null ? void 0 : e.vnode.el, h = Array.from((d == null ? void 0 : d.children) || []).filter((b) => b == null ? void 0 : b.classList.contains(`${r.e("row")}`)), v = h[c], y = h[u];
        v && Sr(v, "hover-row"), y && Co(y, "hover-row");
      });
    }), Wo(() => {
      var u;
      (u = Fr) == null || u();
    }), {
      ns: r,
      onColumnsChange: a,
      onScrollableChange: l,
      wrappedRowRender: i,
      tooltipContent: s,
      tooltipTrigger: o
    };
  },
  render() {
    const { wrappedRowRender: t, store: e } = this, n = e.states.data.value || [];
    return et("tbody", { tabIndex: -1 }, [
      n.reduce((r, i) => r.concat(t(i, r.length)), [])
    ]);
  }
});
function g4() {
  const t = tt($r), e = t == null ? void 0 : t.store, n = F(() => e.states.fixedLeafColumnsLength.value), r = F(() => e.states.rightFixedColumns.value.length), i = F(() => e.states.columns.value.length), s = F(() => e.states.fixedColumns.value.length), o = F(() => e.states.rightFixedColumns.value.length);
  return {
    leftFixedLeafCount: n,
    rightFixedLeafCount: r,
    columnsCount: i,
    leftFixedCount: s,
    rightFixedCount: o,
    columns: e.states.columns
  };
}
function y4(t) {
  const { columns: e } = g4(), n = Fe("table");
  return {
    getCellClasses: (s, o) => {
      const a = s[o], l = [
        n.e("cell"),
        a.id,
        a.align,
        a.labelClassName,
        ...Zd(n.b(), o, a.fixed, t.store)
      ];
      return a.className && l.push(a.className), a.children || l.push(n.is("leaf")), l;
    },
    getCellStyles: (s, o) => {
      const a = Qd(o, s.fixed, t.store);
      return Ls(a, "left"), Ls(a, "right"), a;
    },
    columns: e
  };
}
var b4 = be({
  name: "ElTableFooter",
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: !0,
      type: Object
    },
    summaryMethod: Function,
    sumText: String,
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => ({
        prop: "",
        order: ""
      })
    }
  },
  setup(t) {
    const { getCellClasses: e, getCellStyles: n, columns: r } = y4(t);
    return {
      ns: Fe("table"),
      getCellClasses: e,
      getCellStyles: n,
      columns: r
    };
  },
  render() {
    const { columns: t, getCellStyles: e, getCellClasses: n, summaryMethod: r, sumText: i } = this, s = this.store.states.data.value;
    let o = [];
    return r ? o = r({
      columns: t,
      data: s
    }) : t.forEach((a, l) => {
      if (l === 0) {
        o[l] = i;
        return;
      }
      const u = s.map((v) => Number(v[a.property])), c = [];
      let d = !0;
      u.forEach((v) => {
        if (!Number.isNaN(+v)) {
          d = !1;
          const y = `${v}`.split(".")[1];
          c.push(y ? y.length : 0);
        }
      });
      const h = Math.max.apply(null, c);
      d ? o[l] = "" : o[l] = u.reduce((v, y) => {
        const b = Number(y);
        return Number.isNaN(+b) ? v : Number.parseFloat((v + y).toFixed(Math.min(h, 20)));
      }, 0);
    }), et(et("tfoot", [
      et("tr", {}, [
        ...t.map((a, l) => et("td", {
          key: l,
          colspan: a.colSpan,
          rowspan: a.rowSpan,
          class: n(t, l),
          style: e(a, l)
        }, [
          et("div", {
            class: ["cell", a.labelClassName]
          }, [o[l]])
        ]))
      ])
    ]));
  }
});
function w4(t) {
  return {
    setCurrentRow: (c) => {
      t.commit("setCurrentRow", c);
    },
    getSelectionRows: () => t.getSelectionRows(),
    toggleRowSelection: (c, d) => {
      t.toggleRowSelection(c, d, !1), t.updateAllSelected();
    },
    clearSelection: () => {
      t.clearSelection();
    },
    clearFilter: (c) => {
      t.clearFilter(c);
    },
    toggleAllSelection: () => {
      t.commit("toggleAllSelection");
    },
    toggleRowExpansion: (c, d) => {
      t.toggleRowExpansionAdapter(c, d);
    },
    clearSort: () => {
      t.clearSort();
    },
    sort: (c, d) => {
      t.commit("sort", { prop: c, order: d });
    }
  };
}
function _4(t, e, n, r) {
  const i = K(!1), s = K(null), o = K(!1), a = (j) => {
    o.value = j;
  }, l = K({
    width: null,
    height: null,
    headerHeight: null
  }), u = K(!1), c = {
    display: "inline-block",
    verticalAlign: "middle"
  }, d = K(), h = K(0), v = K(0), y = K(0), b = K(0), p = K(0);
  oo(() => {
    e.setHeight(t.height);
  }), oo(() => {
    e.setMaxHeight(t.maxHeight);
  }), ke(() => [t.currentRowKey, n.states.rowKey], ([j, re]) => {
    !x(re) || !x(j) || n.setCurrentRowKey(`${j}`);
  }, {
    immediate: !0
  }), ke(() => t.data, (j) => {
    r.store.commit("setData", j);
  }, {
    immediate: !0,
    deep: !0
  }), oo(() => {
    t.expandRowKeys && n.setExpandRowKeysAdapter(t.expandRowKeys);
  });
  const f = () => {
    r.store.commit("setHoverRow", null), r.hoverState && (r.hoverState = null);
  }, m = (j, re) => {
    const { pixelX: fe, pixelY: Y } = re;
    Math.abs(fe) >= Math.abs(Y) && (r.refs.bodyWrapper.scrollLeft += re.pixelX / 5);
  }, g = F(() => t.height || t.maxHeight || n.states.fixedColumns.value.length > 0 || n.states.rightFixedColumns.value.length > 0), w = F(() => ({
    width: e.bodyWidth.value ? `${e.bodyWidth.value}px` : ""
  })), _ = () => {
    g.value && e.updateElsHeight(), e.updateColumnsWidth(), requestAnimationFrame(k);
  };
  Tt(async () => {
    await rt(), n.updateColumns(), N(), requestAnimationFrame(_);
    const j = r.vnode.el, re = r.refs.headerWrapper;
    t.flexible && j && j.parentElement && (j.parentElement.style.minWidth = "0"), l.value = {
      width: d.value = j.offsetWidth,
      height: j.offsetHeight,
      headerHeight: t.showHeader && re ? re.offsetHeight : null
    }, n.states.columns.value.forEach((fe) => {
      fe.filteredValue && fe.filteredValue.length && r.store.commit("filterChange", {
        column: fe,
        values: fe.filteredValue,
        silent: !0
      });
    }), r.$ready = !0;
  });
  const E = (j, re) => {
    if (!j)
      return;
    const fe = Array.from(j.classList).filter((Y) => !Y.startsWith("is-scrolling-"));
    fe.push(e.scrollX.value ? re : "is-scrolling-none"), j.className = fe.join(" ");
  }, C = (j) => {
    const { tableWrapper: re } = r.refs;
    E(re, j);
  }, T = (j) => {
    const { tableWrapper: re } = r.refs;
    return !!(re && re.classList.contains(j));
  }, k = function() {
    if (!r.refs.scrollBarRef)
      return;
    if (!e.scrollX.value) {
      const _e = "is-scrolling-none";
      T(_e) || C(_e);
      return;
    }
    const j = r.refs.scrollBarRef.wrapRef;
    if (!j)
      return;
    const { scrollLeft: re, offsetWidth: fe, scrollWidth: Y } = j, { headerWrapper: le, footerWrapper: ce } = r.refs;
    le && (le.scrollLeft = re), ce && (ce.scrollLeft = re);
    const me = Y - fe - 1;
    re >= me ? C("is-scrolling-right") : C(re === 0 ? "is-scrolling-left" : "is-scrolling-middle");
  }, N = () => {
    r.refs.scrollBarRef && (r.refs.scrollBarRef.wrapRef && bn(r.refs.scrollBarRef.wrapRef, "scroll", k, {
      passive: !0
    }), t.fit ? Cs(r.vnode.el, I) : bn(window, "resize", I), Cs(r.refs.bodyWrapper, () => {
      var j, re;
      I(), (re = (j = r.refs) == null ? void 0 : j.scrollBarRef) == null || re.update();
    }));
  }, I = () => {
    var j, re, fe, Y;
    const le = r.vnode.el;
    if (!r.$ready || !le)
      return;
    let ce = !1;
    const {
      width: me,
      height: _e,
      headerHeight: ze
    } = l.value, Oe = d.value = le.offsetWidth;
    me !== Oe && (ce = !0);
    const Qe = le.offsetHeight;
    (t.height || g.value) && _e !== Qe && (ce = !0);
    const Be = t.tableLayout === "fixed" ? r.refs.headerWrapper : (j = r.refs.tableHeaderRef) == null ? void 0 : j.$el;
    t.showHeader && (Be == null ? void 0 : Be.offsetHeight) !== ze && (ce = !0), h.value = ((re = r.refs.tableWrapper) == null ? void 0 : re.scrollHeight) || 0, y.value = (Be == null ? void 0 : Be.scrollHeight) || 0, b.value = ((fe = r.refs.footerWrapper) == null ? void 0 : fe.offsetHeight) || 0, p.value = ((Y = r.refs.appendWrapper) == null ? void 0 : Y.offsetHeight) || 0, v.value = h.value - y.value - b.value - p.value, ce && (l.value = {
      width: Oe,
      height: Qe,
      headerHeight: t.showHeader && (Be == null ? void 0 : Be.offsetHeight) || 0
    }, _());
  }, P = Lr(), D = F(() => {
    const { bodyWidth: j, scrollY: re, gutterWidth: fe } = e;
    return j.value ? `${j.value - (re.value ? fe : 0)}px` : "";
  }), z = F(() => t.maxHeight ? "fixed" : t.tableLayout), G = F(() => {
    if (t.data && t.data.length)
      return null;
    let j = "100%";
    t.height && v.value && (j = `${v.value}px`);
    const re = d.value;
    return {
      width: re ? `${re}px` : "",
      height: j
    };
  }), J = F(() => t.height ? {
    height: Number.isNaN(Number(t.height)) ? t.height : `${t.height}px`
  } : t.maxHeight ? {
    maxHeight: Number.isNaN(Number(t.maxHeight)) ? t.maxHeight : `${t.maxHeight}px`
  } : {}), M = F(() => t.height ? {
    height: "100%"
  } : t.maxHeight ? Number.isNaN(Number(t.maxHeight)) ? {
    maxHeight: `calc(${t.maxHeight} - ${y.value + b.value}px)`
  } : {
    maxHeight: `${t.maxHeight - y.value - b.value}px`
  } : {});
  return {
    isHidden: i,
    renderExpanded: s,
    setDragVisible: a,
    isGroup: u,
    handleMouseLeave: f,
    handleHeaderFooterMousewheel: m,
    tableSize: P,
    emptyBlockStyle: G,
    handleFixedMousewheel: (j, re) => {
      const fe = r.refs.bodyWrapper;
      if (Math.abs(re.spinY) > 0) {
        const Y = fe.scrollTop;
        re.pixelY < 0 && Y !== 0 && j.preventDefault(), re.pixelY > 0 && fe.scrollHeight - fe.clientHeight > Y && j.preventDefault(), fe.scrollTop += Math.ceil(re.pixelY / 5);
      } else
        fe.scrollLeft += Math.ceil(re.pixelX / 5);
    },
    resizeProxyVisible: o,
    bodyWidth: D,
    resizeState: l,
    doLayout: _,
    tableBodyStyles: w,
    tableLayout: z,
    scrollbarViewStyle: c,
    tableInnerStyle: J,
    scrollbarStyle: M
  };
}
function E4(t) {
  const e = K(), n = () => {
    const i = t.vnode.el.querySelector(".hidden-columns"), s = { childList: !0, subtree: !0 }, o = t.store.states.updateOrderFns;
    e.value = new MutationObserver(() => {
      o.forEach((a) => a());
    }), e.value.observe(i, s);
  };
  Tt(() => {
    n();
  }), Wo(() => {
    var r;
    (r = e.value) == null || r.disconnect();
  });
}
var S4 = {
  data: {
    type: Array,
    default: () => []
  },
  size: Rr,
  width: [String, Number],
  height: [String, Number],
  maxHeight: [String, Number],
  fit: {
    type: Boolean,
    default: !0
  },
  stripe: Boolean,
  border: Boolean,
  rowKey: [String, Function],
  showHeader: {
    type: Boolean,
    default: !0
  },
  showSummary: Boolean,
  sumText: String,
  summaryMethod: Function,
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  cellClassName: [String, Function],
  cellStyle: [Object, Function],
  headerRowClassName: [String, Function],
  headerRowStyle: [Object, Function],
  headerCellClassName: [String, Function],
  headerCellStyle: [Object, Function],
  highlightCurrentRow: Boolean,
  currentRowKey: [String, Number],
  emptyText: String,
  expandRowKeys: Array,
  defaultExpandAll: Boolean,
  defaultSort: Object,
  tooltipEffect: String,
  tooltipOptions: Object,
  spanMethod: Function,
  selectOnIndeterminate: {
    type: Boolean,
    default: !0
  },
  indent: {
    type: Number,
    default: 16
  },
  treeProps: {
    type: Object,
    default: () => ({
      hasChildren: "hasChildren",
      children: "children"
    })
  },
  lazy: Boolean,
  load: Function,
  style: {
    type: Object,
    default: () => ({})
  },
  className: {
    type: String,
    default: ""
  },
  tableLayout: {
    type: String,
    default: "fixed"
  },
  scrollbarAlwaysOn: {
    type: Boolean,
    default: !1
  },
  flexible: Boolean,
  showOverflowTooltip: [Boolean, Object]
};
function Mg(t) {
  const e = t.tableLayout === "auto";
  let n = t.columns || [];
  e && n.every((i) => i.width === void 0) && (n = []);
  const r = (i) => {
    const s = {
      key: `${t.tableLayout}_${i.id}`,
      style: {},
      name: void 0
    };
    return e ? s.style = {
      width: `${i.width}px`
    } : s.name = i.id, s;
  };
  return et("colgroup", {}, n.map((i) => et("col", r(i))));
}
Mg.props = ["columns", "tableLayout"];
const x4 = () => {
  const t = K(), e = (s, o) => {
    const a = t.value;
    a && a.scrollTo(s, o);
  }, n = (s, o) => {
    const a = t.value;
    a && gt(o) && ["Top", "Left"].includes(s) && a[`setScroll${s}`](o);
  };
  return {
    scrollBarRef: t,
    scrollTo: e,
    setScrollTop: (s) => n("Top", s),
    setScrollLeft: (s) => n("Left", s)
  };
};
let C4 = 1;
const k4 = be({
  name: "ElTable",
  directives: {
    Mousewheel: PA
  },
  components: {
    TableHeader: d4,
    TableBody: m4,
    TableFooter: b4,
    ElScrollbar: Wd,
    hColgroup: Mg
  },
  props: S4,
  emits: [
    "select",
    "select-all",
    "selection-change",
    "cell-mouse-enter",
    "cell-mouse-leave",
    "cell-contextmenu",
    "cell-click",
    "cell-dblclick",
    "row-click",
    "row-contextmenu",
    "row-dblclick",
    "header-click",
    "header-contextmenu",
    "sort-change",
    "filter-change",
    "current-change",
    "header-dragend",
    "expand-change"
  ],
  setup(t) {
    const { t: e } = or(), n = Fe("table"), r = ht();
    Gt($r, r);
    const i = ZR(r, t);
    r.store = i;
    const s = new JR({
      store: r.store,
      table: r,
      fit: t.fit,
      showHeader: t.showHeader
    });
    r.layout = s;
    const o = F(() => (i.states.data.value || []).length === 0), {
      setCurrentRow: a,
      getSelectionRows: l,
      toggleRowSelection: u,
      clearSelection: c,
      clearFilter: d,
      toggleAllSelection: h,
      toggleRowExpansion: v,
      clearSort: y,
      sort: b
    } = w4(i), {
      isHidden: p,
      renderExpanded: f,
      setDragVisible: m,
      isGroup: g,
      handleMouseLeave: w,
      handleHeaderFooterMousewheel: _,
      tableSize: E,
      emptyBlockStyle: C,
      handleFixedMousewheel: T,
      resizeProxyVisible: k,
      bodyWidth: N,
      resizeState: I,
      doLayout: P,
      tableBodyStyles: D,
      tableLayout: z,
      scrollbarViewStyle: G,
      tableInnerStyle: J,
      scrollbarStyle: M
    } = _4(t, s, i, r), { scrollBarRef: U, scrollTo: j, setScrollLeft: re, setScrollTop: fe } = x4(), Y = Xr(P, 50), le = `${n.namespace.value}-table_${C4++}`;
    r.tableId = le, r.state = {
      isGroup: g,
      resizeState: I,
      doLayout: P,
      debouncedUpdateLayout: Y
    };
    const ce = F(() => t.sumText || e("el.table.sumText")), me = F(() => t.emptyText || e("el.table.emptyText"));
    return E4(r), {
      ns: n,
      layout: s,
      store: i,
      handleHeaderFooterMousewheel: _,
      handleMouseLeave: w,
      tableId: le,
      tableSize: E,
      isHidden: p,
      isEmpty: o,
      renderExpanded: f,
      resizeProxyVisible: k,
      resizeState: I,
      isGroup: g,
      bodyWidth: N,
      tableBodyStyles: D,
      emptyBlockStyle: C,
      debouncedUpdateLayout: Y,
      handleFixedMousewheel: T,
      setCurrentRow: a,
      getSelectionRows: l,
      toggleRowSelection: u,
      clearSelection: c,
      clearFilter: d,
      toggleAllSelection: h,
      toggleRowExpansion: v,
      clearSort: y,
      doLayout: P,
      sort: b,
      t: e,
      setDragVisible: m,
      context: r,
      computedSumText: ce,
      computedEmptyText: me,
      tableLayout: z,
      scrollbarViewStyle: G,
      tableInnerStyle: J,
      scrollbarStyle: M,
      scrollBarRef: U,
      scrollTo: j,
      setScrollLeft: re,
      setScrollTop: fe
    };
  }
}), T4 = ["data-prefix"], O4 = {
  ref: "hiddenColumns",
  class: "hidden-columns"
};
function N4(t, e, n, r, i, s) {
  const o = Dt("hColgroup"), a = Dt("table-header"), l = Dt("table-body"), u = Dt("table-footer"), c = Dt("el-scrollbar"), d = ud("mousewheel");
  return V(), se("div", {
    ref: "tableWrapper",
    class: ee([
      {
        [t.ns.m("fit")]: t.fit,
        [t.ns.m("striped")]: t.stripe,
        [t.ns.m("border")]: t.border || t.isGroup,
        [t.ns.m("hidden")]: t.isHidden,
        [t.ns.m("group")]: t.isGroup,
        [t.ns.m("fluid-height")]: t.maxHeight,
        [t.ns.m("scrollable-x")]: t.layout.scrollX.value,
        [t.ns.m("scrollable-y")]: t.layout.scrollY.value,
        [t.ns.m("enable-row-hover")]: !t.store.states.isComplex.value,
        [t.ns.m("enable-row-transition")]: (t.store.states.data.value || []).length !== 0 && (t.store.states.data.value || []).length < 100,
        "has-footer": t.showSummary
      },
      t.ns.m(t.tableSize),
      t.className,
      t.ns.b(),
      t.ns.m(`layout-${t.tableLayout}`)
    ]),
    style: it(t.style),
    "data-prefix": t.ns.namespace.value,
    onMouseleave: e[0] || (e[0] = (...h) => t.handleMouseLeave && t.handleMouseLeave(...h))
  }, [
    ae("div", {
      class: ee(t.ns.e("inner-wrapper")),
      style: it(t.tableInnerStyle)
    }, [
      ae("div", O4, [
        De(t.$slots, "default")
      ], 512),
      t.showHeader && t.tableLayout === "fixed" ? $t((V(), se("div", {
        key: 0,
        ref: "headerWrapper",
        class: ee(t.ns.e("header-wrapper"))
      }, [
        ae("table", {
          ref: "tableHeader",
          class: ee(t.ns.e("header")),
          style: it(t.tableBodyStyles),
          border: "0",
          cellpadding: "0",
          cellspacing: "0"
        }, [
          ve(o, {
            columns: t.store.states.columns.value,
            "table-layout": t.tableLayout
          }, null, 8, ["columns", "table-layout"]),
          ve(a, {
            ref: "tableHeaderRef",
            border: t.border,
            "default-sort": t.defaultSort,
            store: t.store,
            onSetDragVisible: t.setDragVisible
          }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"])
        ], 6)
      ], 2)), [
        [d, t.handleHeaderFooterMousewheel]
      ]) : ye("v-if", !0),
      ae("div", {
        ref: "bodyWrapper",
        class: ee(t.ns.e("body-wrapper"))
      }, [
        ve(c, {
          ref: "scrollBarRef",
          "view-style": t.scrollbarViewStyle,
          "wrap-style": t.scrollbarStyle,
          always: t.scrollbarAlwaysOn
        }, {
          default: de(() => [
            ae("table", {
              ref: "tableBody",
              class: ee(t.ns.e("body")),
              cellspacing: "0",
              cellpadding: "0",
              border: "0",
              style: it({
                width: t.bodyWidth,
                tableLayout: t.tableLayout
              })
            }, [
              ve(o, {
                columns: t.store.states.columns.value,
                "table-layout": t.tableLayout
              }, null, 8, ["columns", "table-layout"]),
              t.showHeader && t.tableLayout === "auto" ? (V(), Ce(a, {
                key: 0,
                ref: "tableHeaderRef",
                class: ee(t.ns.e("body-header")),
                border: t.border,
                "default-sort": t.defaultSort,
                store: t.store,
                onSetDragVisible: t.setDragVisible
              }, null, 8, ["class", "border", "default-sort", "store", "onSetDragVisible"])) : ye("v-if", !0),
              ve(l, {
                context: t.context,
                highlight: t.highlightCurrentRow,
                "row-class-name": t.rowClassName,
                "tooltip-effect": t.tooltipEffect,
                "tooltip-options": t.tooltipOptions,
                "row-style": t.rowStyle,
                store: t.store,
                stripe: t.stripe
              }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "tooltip-options", "row-style", "store", "stripe"]),
              t.showSummary && t.tableLayout === "auto" ? (V(), Ce(u, {
                key: 1,
                class: ee(t.ns.e("body-footer")),
                border: t.border,
                "default-sort": t.defaultSort,
                store: t.store,
                "sum-text": t.computedSumText,
                "summary-method": t.summaryMethod
              }, null, 8, ["class", "border", "default-sort", "store", "sum-text", "summary-method"])) : ye("v-if", !0)
            ], 6),
            t.isEmpty ? (V(), se("div", {
              key: 0,
              ref: "emptyBlock",
              style: it(t.emptyBlockStyle),
              class: ee(t.ns.e("empty-block"))
            }, [
              ae("span", {
                class: ee(t.ns.e("empty-text"))
              }, [
                De(t.$slots, "empty", {}, () => [
                  cn(st(t.computedEmptyText), 1)
                ])
              ], 2)
            ], 6)) : ye("v-if", !0),
            t.$slots.append ? (V(), se("div", {
              key: 1,
              ref: "appendWrapper",
              class: ee(t.ns.e("append-wrapper"))
            }, [
              De(t.$slots, "append")
            ], 2)) : ye("v-if", !0)
          ]),
          _: 3
        }, 8, ["view-style", "wrap-style", "always"])
      ], 2),
      t.showSummary && t.tableLayout === "fixed" ? $t((V(), se("div", {
        key: 1,
        ref: "footerWrapper",
        class: ee(t.ns.e("footer-wrapper"))
      }, [
        ae("table", {
          class: ee(t.ns.e("footer")),
          cellspacing: "0",
          cellpadding: "0",
          border: "0",
          style: it(t.tableBodyStyles)
        }, [
          ve(o, {
            columns: t.store.states.columns.value,
            "table-layout": t.tableLayout
          }, null, 8, ["columns", "table-layout"]),
          ve(u, {
            border: t.border,
            "default-sort": t.defaultSort,
            store: t.store,
            "sum-text": t.computedSumText,
            "summary-method": t.summaryMethod
          }, null, 8, ["border", "default-sort", "store", "sum-text", "summary-method"])
        ], 6)
      ], 2)), [
        [Yn, !t.isEmpty],
        [d, t.handleHeaderFooterMousewheel]
      ]) : ye("v-if", !0),
      t.border || t.isGroup ? (V(), se("div", {
        key: 2,
        class: ee(t.ns.e("border-left-patch"))
      }, null, 2)) : ye("v-if", !0)
    ], 6),
    $t(ae("div", {
      ref: "resizeProxy",
      class: ee(t.ns.e("column-resize-proxy"))
    }, null, 2), [
      [Yn, t.resizeProxyVisible]
    ])
  ], 46, T4);
}
var A4 = /* @__PURE__ */ qe(k4, [["render", N4], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/table/src/table.vue"]]);
const I4 = {
  selection: "table-column--selection",
  expand: "table__expand-column"
}, R4 = {
  default: {
    order: ""
  },
  selection: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  expand: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  index: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  }
}, L4 = (t) => I4[t] || "", P4 = {
  selection: {
    renderHeader({ store: t, column: e }) {
      function n() {
        return t.states.data.value && t.states.data.value.length === 0;
      }
      return et(Fi, {
        disabled: n(),
        size: t.states.tableSize.value,
        indeterminate: t.states.selection.value.length > 0 && !t.states.isAllSelected.value,
        "onUpdate:modelValue": t.toggleAllSelection,
        modelValue: t.states.isAllSelected.value,
        ariaLabel: e.label
      });
    },
    renderCell({
      row: t,
      column: e,
      store: n,
      $index: r
    }) {
      return et(Fi, {
        disabled: e.selectable ? !e.selectable.call(null, t, r) : !1,
        size: n.states.tableSize.value,
        onChange: () => {
          n.commit("rowSelectedChanged", t);
        },
        onClick: (i) => i.stopPropagation(),
        modelValue: n.isSelected(t),
        ariaLabel: e.label
      });
    },
    sortable: !1,
    resizable: !1
  },
  index: {
    renderHeader({ column: t }) {
      return t.label || "#";
    },
    renderCell({
      column: t,
      $index: e
    }) {
      let n = e + 1;
      const r = t.index;
      return typeof r == "number" ? n = e + r : typeof r == "function" && (n = r(e)), et("div", {}, [n]);
    },
    sortable: !1
  },
  expand: {
    renderHeader({ column: t }) {
      return t.label || "";
    },
    renderCell({
      row: t,
      store: e,
      expanded: n
    }) {
      const { ns: r } = e, i = [r.e("expand-icon")];
      return n && i.push(r.em("expand-icon", "expanded")), et("div", {
        class: i,
        onClick: function(o) {
          o.stopPropagation(), e.toggleRowExpansion(t);
        }
      }, {
        default: () => [
          et(_t, null, {
            default: () => [et(Ad)]
          })
        ]
      });
    },
    sortable: !1,
    resizable: !1
  }
};
function $4({
  row: t,
  column: e,
  $index: n
}) {
  var r;
  const i = e.property, s = i && RS(t, i).value;
  return e && e.formatter ? e.formatter(t, e, s, n) : ((r = s == null ? void 0 : s.toString) == null ? void 0 : r.call(s)) || "";
}
function D4({
  row: t,
  treeNode: e,
  store: n
}, r = !1) {
  const { ns: i } = n;
  if (!e)
    return r ? [
      et("span", {
        class: i.e("placeholder")
      })
    ] : null;
  const s = [], o = function(a) {
    a.stopPropagation(), !e.loading && n.loadOrToggle(t);
  };
  if (e.indent && s.push(et("span", {
    class: i.e("indent"),
    style: { "padding-left": `${e.indent}px` }
  })), typeof e.expanded == "boolean" && !e.noLazyChildren) {
    const a = [
      i.e("expand-icon"),
      e.expanded ? i.em("expand-icon", "expanded") : ""
    ];
    let l = Ad;
    e.loading && (l = Hl), s.push(et("div", {
      class: a,
      onClick: o
    }, {
      default: () => [
        et(_t, { class: { [i.is("loading")]: e.loading } }, {
          default: () => [et(l)]
        })
      ]
    }));
  } else
    s.push(et("span", {
      class: i.e("placeholder")
    }));
  return s;
}
function cp(t, e) {
  return t.reduce((n, r) => (n[r] = r, n), e);
}
function B4(t, e) {
  const n = ht();
  return {
    registerComplexWatchers: () => {
      const s = ["fixed"], o = {
        realWidth: "width",
        realMinWidth: "minWidth"
      }, a = cp(s, o);
      Object.keys(a).forEach((l) => {
        const u = o[l];
        Or(e, u) && ke(() => e[u], (c) => {
          let d = c;
          u === "width" && l === "realWidth" && (d = Xd(c)), u === "minWidth" && l === "realMinWidth" && (d = Ig(c)), n.columnConfig.value[u] = d, n.columnConfig.value[l] = d;
          const h = u === "fixed";
          t.value.store.scheduleLayout(h);
        });
      });
    },
    registerNormalWatchers: () => {
      const s = [
        "label",
        "filters",
        "filterMultiple",
        "filteredValue",
        "sortable",
        "index",
        "formatter",
        "className",
        "labelClassName",
        "showOverflowTooltip"
      ], o = {
        property: "prop",
        align: "realAlign",
        headerAlign: "realHeaderAlign"
      }, a = cp(s, o);
      Object.keys(a).forEach((l) => {
        const u = o[l];
        Or(e, u) && ke(() => e[u], (c) => {
          n.columnConfig.value[l] = c;
        });
      });
    }
  };
}
function M4(t, e, n) {
  const r = ht(), i = K(""), s = K(!1), o = K(), a = K(), l = Fe("table");
  oo(() => {
    o.value = t.align ? `is-${t.align}` : null, o.value;
  }), oo(() => {
    a.value = t.headerAlign ? `is-${t.headerAlign}` : o.value, a.value;
  });
  const u = F(() => {
    let w = r.vnode.vParent || r.parent;
    for (; w && !w.tableId && !w.columnId; )
      w = w.vnode.vParent || w.parent;
    return w;
  }), c = F(() => {
    const { store: w } = r.parent;
    if (!w)
      return !1;
    const { treeData: _ } = w.states, E = _.value;
    return E && Object.keys(E).length > 0;
  }), d = K(Xd(t.width)), h = K(Ig(t.minWidth)), v = (w) => (d.value && (w.width = d.value), h.value && (w.minWidth = h.value), !d.value && h.value && (w.width = void 0), w.minWidth || (w.minWidth = 80), w.realWidth = Number(w.width === void 0 ? w.minWidth : w.width), w), y = (w) => {
    const _ = w.type, E = P4[_] || {};
    Object.keys(E).forEach((T) => {
      const k = E[T];
      T !== "className" && k !== void 0 && (w[T] = k);
    });
    const C = L4(_);
    if (C) {
      const T = `${x(l.namespace)}-${C}`;
      w.className = w.className ? `${w.className} ${T}` : T;
    }
    return w;
  }, b = (w) => {
    Array.isArray(w) ? w.forEach((E) => _(E)) : _(w);
    function _(E) {
      var C;
      ((C = E == null ? void 0 : E.type) == null ? void 0 : C.name) === "ElTableColumn" && (E.vParent = r);
    }
  };
  return {
    columnId: i,
    realAlign: o,
    isSubColumn: s,
    realHeaderAlign: a,
    columnOrTableParent: u,
    setColumnWidth: v,
    setColumnForcedProps: y,
    setColumnRenders: (w) => {
      t.renderHeader ? Vt("TableColumn", "Comparing to render-header, scoped-slot header is easier to use. We recommend users to use scoped-slot header.") : w.type !== "selection" && (w.renderHeader = (E) => {
        r.columnConfig.value.label;
        const C = e.header;
        return C ? C(E) : w.label;
      });
      let _ = w.renderCell;
      return w.type === "expand" ? (w.renderCell = (E) => et("div", {
        class: "cell"
      }, [_(E)]), n.value.renderExpanded = (E) => e.default ? e.default(E) : e.default) : (_ = _ || $4, w.renderCell = (E) => {
        let C = null;
        if (e.default) {
          const D = e.default(E);
          C = D.some((z) => z.type !== vv) ? D : _(E);
        } else
          C = _(E);
        const { columns: T } = n.value.store.states, k = T.value.findIndex((D) => D.type === "default"), N = c.value && E.cellIndex === k, I = D4(E, N), P = {
          class: "cell",
          style: {}
        };
        return w.showOverflowTooltip && (P.class = `${P.class} ${x(l.namespace)}-tooltip`, P.style = {
          width: `${(E.column.realWidth || Number(E.column.width)) - 1}px`
        }), b(C), et("div", P, [I, C]);
      }), w;
    },
    getPropsData: (...w) => w.reduce((_, E) => (Array.isArray(E) && E.forEach((C) => {
      _[C] = t[C];
    }), _), {}),
    getColumnElIndex: (w, _) => Array.prototype.indexOf.call(w, _),
    updateColumnOrder: () => {
      n.value.store.commit("updateColumnOrder", r.columnConfig.value);
    }
  };
}
var z4 = {
  type: {
    type: String,
    default: "default"
  },
  label: String,
  className: String,
  labelClassName: String,
  property: String,
  prop: String,
  width: {
    type: [String, Number],
    default: ""
  },
  minWidth: {
    type: [String, Number],
    default: ""
  },
  renderHeader: Function,
  sortable: {
    type: [Boolean, String],
    default: !1
  },
  sortMethod: Function,
  sortBy: [String, Function, Array],
  resizable: {
    type: Boolean,
    default: !0
  },
  columnKey: String,
  align: String,
  headerAlign: String,
  showOverflowTooltip: {
    type: [Boolean, Object],
    default: void 0
  },
  fixed: [Boolean, String],
  formatter: Function,
  selectable: Function,
  reserveSelection: Boolean,
  filterMethod: Function,
  filteredValue: Array,
  filters: Array,
  filterPlacement: String,
  filterMultiple: {
    type: Boolean,
    default: !0
  },
  index: [Number, Function],
  sortOrders: {
    type: Array,
    default: () => ["ascending", "descending", null],
    validator: (t) => t.every((e) => ["ascending", "descending", null].includes(e))
  }
};
let F4 = 1;
var zg = be({
  name: "ElTableColumn",
  components: {
    ElCheckbox: Fi
  },
  props: z4,
  setup(t, { slots: e }) {
    const n = ht(), r = K({}), i = F(() => {
      let g = n.parent;
      for (; g && !g.tableId; )
        g = g.parent;
      return g;
    }), { registerNormalWatchers: s, registerComplexWatchers: o } = B4(i, t), {
      columnId: a,
      isSubColumn: l,
      realHeaderAlign: u,
      columnOrTableParent: c,
      setColumnWidth: d,
      setColumnForcedProps: h,
      setColumnRenders: v,
      getPropsData: y,
      getColumnElIndex: b,
      realAlign: p,
      updateColumnOrder: f
    } = M4(t, e, i), m = c.value;
    a.value = `${m.tableId || m.columnId}_column_${F4++}`, ld(() => {
      l.value = i.value !== m;
      const g = t.type || "default", w = t.sortable === "" ? !0 : t.sortable, _ = Er(t.showOverflowTooltip) ? m.props.showOverflowTooltip : t.showOverflowTooltip, E = {
        ...R4[g],
        id: a.value,
        type: g,
        property: t.prop || t.property,
        align: p,
        headerAlign: u,
        showOverflowTooltip: _,
        filterable: t.filters || t.filterMethod,
        filteredValue: [],
        filterPlacement: "",
        isColumnGroup: !1,
        isSubColumn: !1,
        filterOpened: !1,
        sortable: w,
        index: t.index,
        rawColumnKey: n.vnode.key
      };
      let I = y([
        "columnKey",
        "label",
        "className",
        "labelClassName",
        "type",
        "renderHeader",
        "formatter",
        "fixed",
        "resizable"
      ], ["sortMethod", "sortBy", "sortOrders"], ["selectable", "reserveSelection"], [
        "filterMethod",
        "filters",
        "filterMultiple",
        "filterOpened",
        "filteredValue",
        "filterPlacement"
      ]);
      I = FR(E, I), I = UR(v, d, h)(I), r.value = I, s(), o();
    }), Tt(() => {
      var g;
      const w = c.value, _ = l.value ? w.vnode.el.children : (g = w.refs.hiddenColumns) == null ? void 0 : g.children, E = () => b(_ || [], n.vnode.el);
      r.value.getColumnIndex = E, E() > -1 && i.value.store.commit("insertColumn", r.value, l.value ? w.columnConfig.value : null, f);
    }), Sn(() => {
      i.value.store.commit("removeColumn", r.value, l.value ? m.columnConfig.value : null, f);
    }), n.columnId = a.value, n.columnConfig = r;
  },
  render() {
    var t, e, n;
    try {
      const r = (e = (t = this.$slots).default) == null ? void 0 : e.call(t, {
        row: {},
        column: {},
        $index: -1
      }), i = [];
      if (Array.isArray(r))
        for (const o of r)
          ((n = o.type) == null ? void 0 : n.name) === "ElTableColumn" || o.shapeFlag & 2 ? i.push(o) : o.type === Ft && Array.isArray(o.children) && o.children.forEach((a) => {
            (a == null ? void 0 : a.patchFlag) !== 1024 && !qt(a == null ? void 0 : a.children) && i.push(a);
          });
      return et("div", i);
    } catch {
      return et("div", []);
    }
  }
});
const j4 = nn(A4, {
  TableColumn: zg
}), U4 = sr(zg), ws = "$treeNodeId", dp = function(t, e) {
  !e || e[ws] || Object.defineProperty(e, ws, {
    value: t.id,
    enumerable: !1,
    configurable: !1,
    writable: !1
  });
}, Jd = function(t, e) {
  return t ? e[t] : e[ws];
}, bc = (t, e, n) => {
  const r = t.value.currentNode;
  n();
  const i = t.value.currentNode;
  r !== i && e("current-change", i ? i.data : null, i);
}, wc = (t) => {
  let e = !0, n = !0, r = !0;
  for (let i = 0, s = t.length; i < s; i++) {
    const o = t[i];
    (o.checked !== !0 || o.indeterminate) && (e = !1, o.disabled || (r = !1)), (o.checked !== !1 || o.indeterminate) && (n = !1);
  }
  return { all: e, none: n, allWithoutDisable: r, half: !e && !n };
}, Ua = function(t) {
  if (t.childNodes.length === 0 || t.loading)
    return;
  const { all: e, none: n, half: r } = wc(t.childNodes);
  e ? (t.checked = !0, t.indeterminate = !1) : r ? (t.checked = !1, t.indeterminate = !0) : n && (t.checked = !1, t.indeterminate = !1);
  const i = t.parent;
  !i || i.level === 0 || t.store.checkStrictly || Ua(i);
}, Ea = function(t, e) {
  const n = t.store.props, r = t.data || {}, i = n[e];
  if (typeof i == "function")
    return i(r, t);
  if (typeof i == "string")
    return r[i];
  if (typeof i > "u") {
    const s = r[e];
    return s === void 0 ? "" : s;
  }
};
let V4 = 0, _c = class Va {
  constructor(e) {
    this.id = V4++, this.text = null, this.checked = !1, this.indeterminate = !1, this.data = null, this.expanded = !1, this.parent = null, this.visible = !0, this.isCurrent = !1, this.canFocus = !1;
    for (const n in e)
      Or(e, n) && (this[n] = e[n]);
    this.level = 0, this.loaded = !1, this.childNodes = [], this.loading = !1, this.parent && (this.level = this.parent.level + 1);
  }
  initialize() {
    const e = this.store;
    if (!e)
      throw new Error("[Node]store is required!");
    e.registerNode(this);
    const n = e.props;
    if (n && typeof n.isLeaf < "u") {
      const s = Ea(this, "isLeaf");
      typeof s == "boolean" && (this.isLeafByUser = s);
    }
    if (e.lazy !== !0 && this.data ? (this.setData(this.data), e.defaultExpandAll && (this.expanded = !0, this.canFocus = !0)) : this.level > 0 && e.lazy && e.defaultExpandAll && this.expand(), Array.isArray(this.data) || dp(this, this.data), !this.data)
      return;
    const r = e.defaultExpandedKeys, i = e.key;
    i && r && r.includes(this.key) && this.expand(null, e.autoExpandParent), i && e.currentNodeKey !== void 0 && this.key === e.currentNodeKey && (e.currentNode = this, e.currentNode.isCurrent = !0), e.lazy && e._initDefaultCheckedNode(this), this.updateLeafState(), this.parent && (this.level === 1 || this.parent.expanded === !0) && (this.canFocus = !0);
  }
  setData(e) {
    Array.isArray(e) || dp(this, e), this.data = e, this.childNodes = [];
    let n;
    this.level === 0 && Array.isArray(this.data) ? n = this.data : n = Ea(this, "children") || [];
    for (let r = 0, i = n.length; r < i; r++)
      this.insertChild({ data: n[r] });
  }
  get label() {
    return Ea(this, "label");
  }
  get key() {
    const e = this.store.key;
    return this.data ? this.data[e] : null;
  }
  get disabled() {
    return Ea(this, "disabled");
  }
  get nextSibling() {
    const e = this.parent;
    if (e) {
      const n = e.childNodes.indexOf(this);
      if (n > -1)
        return e.childNodes[n + 1];
    }
    return null;
  }
  get previousSibling() {
    const e = this.parent;
    if (e) {
      const n = e.childNodes.indexOf(this);
      if (n > -1)
        return n > 0 ? e.childNodes[n - 1] : null;
    }
    return null;
  }
  contains(e, n = !0) {
    return (this.childNodes || []).some((r) => r === e || n && r.contains(e));
  }
  remove() {
    const e = this.parent;
    e && e.removeChild(this);
  }
  insertChild(e, n, r) {
    if (!e)
      throw new Error("InsertChild error: child is required.");
    if (!(e instanceof Va)) {
      if (!r) {
        const i = this.getChildren(!0);
        i.includes(e.data) || (typeof n > "u" || n < 0 ? i.push(e.data) : i.splice(n, 0, e.data));
      }
      Object.assign(e, {
        parent: this,
        store: this.store
      }), e = Pn(new Va(e)), e instanceof Va && e.initialize();
    }
    e.level = this.level + 1, typeof n > "u" || n < 0 ? this.childNodes.push(e) : this.childNodes.splice(n, 0, e), this.updateLeafState();
  }
  insertBefore(e, n) {
    let r;
    n && (r = this.childNodes.indexOf(n)), this.insertChild(e, r);
  }
  insertAfter(e, n) {
    let r;
    n && (r = this.childNodes.indexOf(n), r !== -1 && (r += 1)), this.insertChild(e, r);
  }
  removeChild(e) {
    const n = this.getChildren() || [], r = n.indexOf(e.data);
    r > -1 && n.splice(r, 1);
    const i = this.childNodes.indexOf(e);
    i > -1 && (this.store && this.store.deregisterNode(e), e.parent = null, this.childNodes.splice(i, 1)), this.updateLeafState();
  }
  removeChildByData(e) {
    let n = null;
    for (let r = 0; r < this.childNodes.length; r++)
      if (this.childNodes[r].data === e) {
        n = this.childNodes[r];
        break;
      }
    n && this.removeChild(n);
  }
  expand(e, n) {
    const r = () => {
      if (n) {
        let i = this.parent;
        for (; i.level > 0; )
          i.expanded = !0, i = i.parent;
      }
      this.expanded = !0, e && e(), this.childNodes.forEach((i) => {
        i.canFocus = !0;
      });
    };
    this.shouldLoadData() ? this.loadData((i) => {
      Array.isArray(i) && (this.checked ? this.setChecked(!0, !0) : this.store.checkStrictly || Ua(this), r());
    }) : r();
  }
  doCreateChildren(e, n = {}) {
    e.forEach((r) => {
      this.insertChild(Object.assign({ data: r }, n), void 0, !0);
    });
  }
  collapse() {
    this.expanded = !1, this.childNodes.forEach((e) => {
      e.canFocus = !1;
    });
  }
  shouldLoadData() {
    return this.store.lazy === !0 && this.store.load && !this.loaded;
  }
  updateLeafState() {
    if (this.store.lazy === !0 && this.loaded !== !0 && typeof this.isLeafByUser < "u") {
      this.isLeaf = this.isLeafByUser;
      return;
    }
    const e = this.childNodes;
    if (!this.store.lazy || this.store.lazy === !0 && this.loaded === !0) {
      this.isLeaf = !e || e.length === 0;
      return;
    }
    this.isLeaf = !1;
  }
  setChecked(e, n, r, i) {
    if (this.indeterminate = e === "half", this.checked = e === !0, this.store.checkStrictly)
      return;
    if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
      const { all: o, allWithoutDisable: a } = wc(this.childNodes);
      !this.isLeaf && !o && a && (this.checked = !1, e = !1);
      const l = () => {
        if (n) {
          const u = this.childNodes;
          for (let h = 0, v = u.length; h < v; h++) {
            const y = u[h];
            i = i || e !== !1;
            const b = y.disabled ? y.checked : i;
            y.setChecked(b, n, !0, i);
          }
          const { half: c, all: d } = wc(u);
          d || (this.checked = d, this.indeterminate = c);
        }
      };
      if (this.shouldLoadData()) {
        this.loadData(() => {
          l(), Ua(this);
        }, {
          checked: e !== !1
        });
        return;
      } else
        l();
    }
    const s = this.parent;
    !s || s.level === 0 || r || Ua(s);
  }
  getChildren(e = !1) {
    if (this.level === 0)
      return this.data;
    const n = this.data;
    if (!n)
      return null;
    const r = this.store.props;
    let i = "children";
    return r && (i = r.children || "children"), n[i] === void 0 && (n[i] = null), e && !n[i] && (n[i] = []), n[i];
  }
  updateChildren() {
    const e = this.getChildren() || [], n = this.childNodes.map((s) => s.data), r = {}, i = [];
    e.forEach((s, o) => {
      const a = s[ws];
      !!a && n.findIndex((u) => u[ws] === a) >= 0 ? r[a] = { index: o, data: s } : i.push({ index: o, data: s });
    }), this.store.lazy || n.forEach((s) => {
      r[s[ws]] || this.removeChildByData(s);
    }), i.forEach(({ index: s, data: o }) => {
      this.insertChild({ data: o }, s);
    }), this.updateLeafState();
  }
  loadData(e, n = {}) {
    if (this.store.lazy === !0 && this.store.load && !this.loaded && (!this.loading || Object.keys(n).length)) {
      this.loading = !0;
      const r = (i) => {
        this.childNodes = [], this.doCreateChildren(i, n), this.loaded = !0, this.loading = !1, this.updateLeafState(), e && e.call(this, i);
      };
      this.store.load(this, r);
    } else
      e && e.call(this);
  }
};
class W4 {
  constructor(e) {
    this.currentNode = null, this.currentNodeKey = null;
    for (const n in e)
      Or(e, n) && (this[n] = e[n]);
    this.nodesMap = {};
  }
  initialize() {
    if (this.root = new _c({
      data: this.data,
      store: this
    }), this.root.initialize(), this.lazy && this.load) {
      const e = this.load;
      e(this.root, (n) => {
        this.root.doCreateChildren(n), this._initDefaultCheckedNodes();
      });
    } else
      this._initDefaultCheckedNodes();
  }
  filter(e) {
    const n = this.filterNodeMethod, r = this.lazy, i = function(s) {
      const o = s.root ? s.root.childNodes : s.childNodes;
      if (o.forEach((a) => {
        a.visible = n.call(a, e, a.data, a), i(a);
      }), !s.visible && o.length) {
        let a = !0;
        a = !o.some((l) => l.visible), s.root ? s.root.visible = a === !1 : s.visible = a === !1;
      }
      e && s.visible && !s.isLeaf && !r && s.expand();
    };
    i(this);
  }
  setData(e) {
    e !== this.root.data ? (this.root.setData(e), this._initDefaultCheckedNodes()) : this.root.updateChildren();
  }
  getNode(e) {
    if (e instanceof _c)
      return e;
    const n = wn(e) ? Jd(this.key, e) : e;
    return this.nodesMap[n] || null;
  }
  insertBefore(e, n) {
    const r = this.getNode(n);
    r.parent.insertBefore({ data: e }, r);
  }
  insertAfter(e, n) {
    const r = this.getNode(n);
    r.parent.insertAfter({ data: e }, r);
  }
  remove(e) {
    const n = this.getNode(e);
    n && n.parent && (n === this.currentNode && (this.currentNode = null), n.parent.removeChild(n));
  }
  append(e, n) {
    const r = n ? this.getNode(n) : this.root;
    r && r.insertChild({ data: e });
  }
  _initDefaultCheckedNodes() {
    const e = this.defaultCheckedKeys || [], n = this.nodesMap;
    e.forEach((r) => {
      const i = n[r];
      i && i.setChecked(!0, !this.checkStrictly);
    });
  }
  _initDefaultCheckedNode(e) {
    (this.defaultCheckedKeys || []).includes(e.key) && e.setChecked(!0, !this.checkStrictly);
  }
  setDefaultCheckedKey(e) {
    e !== this.defaultCheckedKeys && (this.defaultCheckedKeys = e, this._initDefaultCheckedNodes());
  }
  registerNode(e) {
    const n = this.key;
    !e || !e.data || (n ? e.key !== void 0 && (this.nodesMap[e.key] = e) : this.nodesMap[e.id] = e);
  }
  deregisterNode(e) {
    !this.key || !e || !e.data || (e.childNodes.forEach((r) => {
      this.deregisterNode(r);
    }), delete this.nodesMap[e.key]);
  }
  getCheckedNodes(e = !1, n = !1) {
    const r = [], i = function(s) {
      (s.root ? s.root.childNodes : s.childNodes).forEach((a) => {
        (a.checked || n && a.indeterminate) && (!e || e && a.isLeaf) && r.push(a.data), i(a);
      });
    };
    return i(this), r;
  }
  getCheckedKeys(e = !1) {
    return this.getCheckedNodes(e).map((n) => (n || {})[this.key]);
  }
  getHalfCheckedNodes() {
    const e = [], n = function(r) {
      (r.root ? r.root.childNodes : r.childNodes).forEach((s) => {
        s.indeterminate && e.push(s.data), n(s);
      });
    };
    return n(this), e;
  }
  getHalfCheckedKeys() {
    return this.getHalfCheckedNodes().map((e) => (e || {})[this.key]);
  }
  _getAllNodes() {
    const e = [], n = this.nodesMap;
    for (const r in n)
      Or(n, r) && e.push(n[r]);
    return e;
  }
  updateChildren(e, n) {
    const r = this.nodesMap[e];
    if (!r)
      return;
    const i = r.childNodes;
    for (let s = i.length - 1; s >= 0; s--) {
      const o = i[s];
      this.remove(o.data);
    }
    for (let s = 0, o = n.length; s < o; s++) {
      const a = n[s];
      this.append(a, r.data);
    }
  }
  _setCheckedKeys(e, n = !1, r) {
    const i = this._getAllNodes().sort((a, l) => l.level - a.level), s = /* @__PURE__ */ Object.create(null), o = Object.keys(r);
    i.forEach((a) => a.setChecked(!1, !1));
    for (let a = 0, l = i.length; a < l; a++) {
      const u = i[a], c = u.data[e].toString();
      if (!o.includes(c)) {
        u.checked && !s[c] && u.setChecked(!1, !1);
        continue;
      }
      let h = u.parent;
      for (; h && h.level > 0; )
        s[h.data[e]] = !0, h = h.parent;
      if (u.isLeaf || this.checkStrictly) {
        u.setChecked(!0, !1);
        continue;
      }
      if (u.setChecked(!0, !0), n) {
        u.setChecked(!1, !1);
        const v = function(y) {
          y.childNodes.forEach((p) => {
            p.isLeaf || p.setChecked(!1, !1), v(p);
          });
        };
        v(u);
      }
    }
  }
  setCheckedNodes(e, n = !1) {
    const r = this.key, i = {};
    e.forEach((s) => {
      i[(s || {})[r]] = !0;
    }), this._setCheckedKeys(r, n, i);
  }
  setCheckedKeys(e, n = !1) {
    this.defaultCheckedKeys = e;
    const r = this.key, i = {};
    e.forEach((s) => {
      i[s] = !0;
    }), this._setCheckedKeys(r, n, i);
  }
  setDefaultExpandedKeys(e) {
    e = e || [], this.defaultExpandedKeys = e, e.forEach((n) => {
      const r = this.getNode(n);
      r && r.expand(null, this.autoExpandParent);
    });
  }
  setChecked(e, n, r) {
    const i = this.getNode(e);
    i && i.setChecked(!!n, r);
  }
  getCurrentNode() {
    return this.currentNode;
  }
  setCurrentNode(e) {
    const n = this.currentNode;
    n && (n.isCurrent = !1), this.currentNode = e, this.currentNode.isCurrent = !0;
  }
  setUserCurrentNode(e, n = !0) {
    const r = e[this.key], i = this.nodesMap[r];
    this.setCurrentNode(i), n && this.currentNode.level > 1 && this.currentNode.parent.expand(null, !0);
  }
  setCurrentNodeKey(e, n = !0) {
    if (e == null) {
      this.currentNode && (this.currentNode.isCurrent = !1), this.currentNode = null;
      return;
    }
    const r = this.getNode(e);
    r && (this.setCurrentNode(r), n && this.currentNode.level > 1 && this.currentNode.parent.expand(null, !0));
  }
}
const H4 = be({
  name: "ElTreeNodeContent",
  props: {
    node: {
      type: Object,
      required: !0
    },
    renderContent: Function
  },
  setup(t) {
    const e = Fe("tree"), n = tt("NodeInstance"), r = tt("RootTree");
    return () => {
      const i = t.node, { data: s, store: o } = i;
      return t.renderContent ? t.renderContent(et, { _self: n, node: i, data: s, store: o }) : r.ctx.slots.default ? r.ctx.slots.default({ node: i, data: s }) : et("span", { class: e.be("node", "label") }, [i.label]);
    };
  }
});
var K4 = /* @__PURE__ */ qe(H4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node-content.vue"]]);
function Fg(t) {
  const e = tt("TreeNodeMap", null), n = {
    treeNodeExpand: (r) => {
      t.node !== r && t.node.collapse();
    },
    children: []
  };
  return e && e.children.push(n), Gt("TreeNodeMap", n), {
    broadcastExpanded: (r) => {
      if (t.accordion)
        for (const i of n.children)
          i.treeNodeExpand(r);
    }
  };
}
const jg = Symbol("dragEvents");
function q4({ props: t, ctx: e, el$: n, dropIndicator$: r, store: i }) {
  const s = Fe("tree"), o = K({
    showDropIndicator: !1,
    draggingNode: null,
    dropNode: null,
    allowDrop: !0,
    dropType: null
  });
  return Gt(jg, {
    treeNodeDragStart: ({ event: c, treeNode: d }) => {
      if (typeof t.allowDrag == "function" && !t.allowDrag(d.node))
        return c.preventDefault(), !1;
      c.dataTransfer.effectAllowed = "move";
      try {
        c.dataTransfer.setData("text/plain", "");
      } catch {
      }
      o.value.draggingNode = d, e.emit("node-drag-start", d.node, c);
    },
    treeNodeDragOver: ({ event: c, treeNode: d }) => {
      const h = d, v = o.value.dropNode;
      v && v.node.id !== h.node.id && Sr(v.$el, s.is("drop-inner"));
      const y = o.value.draggingNode;
      if (!y || !h)
        return;
      let b = !0, p = !0, f = !0, m = !0;
      typeof t.allowDrop == "function" && (b = t.allowDrop(y.node, h.node, "prev"), m = p = t.allowDrop(y.node, h.node, "inner"), f = t.allowDrop(y.node, h.node, "next")), c.dataTransfer.dropEffect = p || b || f ? "move" : "none", (b || p || f) && (v == null ? void 0 : v.node.id) !== h.node.id && (v && e.emit("node-drag-leave", y.node, v.node, c), e.emit("node-drag-enter", y.node, h.node, c)), (b || p || f) && (o.value.dropNode = h), h.node.nextSibling === y.node && (f = !1), h.node.previousSibling === y.node && (b = !1), h.node.contains(y.node, !1) && (p = !1), (y.node === h.node || y.node.contains(h.node)) && (b = !1, p = !1, f = !1);
      const g = h.$el.querySelector(`.${s.be("node", "content")}`).getBoundingClientRect(), w = n.value.getBoundingClientRect();
      let _;
      const E = b ? p ? 0.25 : f ? 0.45 : 1 : -1, C = f ? p ? 0.75 : b ? 0.55 : 0 : 1;
      let T = -9999;
      const k = c.clientY - g.top;
      k < g.height * E ? _ = "before" : k > g.height * C ? _ = "after" : p ? _ = "inner" : _ = "none";
      const N = h.$el.querySelector(`.${s.be("node", "expand-icon")}`).getBoundingClientRect(), I = r.value;
      _ === "before" ? T = N.top - w.top : _ === "after" && (T = N.bottom - w.top), I.style.top = `${T}px`, I.style.left = `${N.right - w.left}px`, _ === "inner" ? Co(h.$el, s.is("drop-inner")) : Sr(h.$el, s.is("drop-inner")), o.value.showDropIndicator = _ === "before" || _ === "after", o.value.allowDrop = o.value.showDropIndicator || m, o.value.dropType = _, e.emit("node-drag-over", y.node, h.node, c);
    },
    treeNodeDragEnd: (c) => {
      const { draggingNode: d, dropType: h, dropNode: v } = o.value;
      if (c.preventDefault(), c.dataTransfer.dropEffect = "move", d && v) {
        const y = { data: d.node.data };
        h !== "none" && d.node.remove(), h === "before" ? v.node.parent.insertBefore(y, v.node) : h === "after" ? v.node.parent.insertAfter(y, v.node) : h === "inner" && v.node.insertChild(y), h !== "none" && i.value.registerNode(y), Sr(v.$el, s.is("drop-inner")), e.emit("node-drag-end", d.node, v.node, h, c), h !== "none" && e.emit("node-drop", d.node, v.node, h, c);
      }
      d && !v && e.emit("node-drag-end", d.node, null, h, c), o.value.showDropIndicator = !1, o.value.draggingNode = null, o.value.dropNode = null, o.value.allowDrop = !0;
    }
  }), {
    dragState: o
  };
}
const G4 = be({
  name: "ElTreeNode",
  components: {
    ElCollapseTransition: TI,
    ElCheckbox: Fi,
    NodeContent: K4,
    ElIcon: _t,
    Loading: Hl
  },
  props: {
    node: {
      type: _c,
      default: () => ({})
    },
    props: {
      type: Object,
      default: () => ({})
    },
    accordion: Boolean,
    renderContent: Function,
    renderAfterExpand: Boolean,
    showCheckbox: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["node-expand"],
  setup(t, e) {
    const n = Fe("tree"), { broadcastExpanded: r } = Fg(t), i = tt("RootTree"), s = K(!1), o = K(!1), a = K(null), l = K(null), u = K(null), c = tt(jg), d = ht();
    Gt("NodeInstance", d), i || Vt("Tree", "Can not find node's tree."), t.node.expanded && (s.value = !0, o.value = !0);
    const h = i.props.props.children || "children";
    ke(() => {
      const k = t.node.data[h];
      return k && [...k];
    }, () => {
      t.node.updateChildren();
    }), ke(() => t.node.indeterminate, (k) => {
      b(t.node.checked, k);
    }), ke(() => t.node.checked, (k) => {
      b(k, t.node.indeterminate);
    }), ke(() => t.node.expanded, (k) => {
      rt(() => s.value = k), k && (o.value = !0);
    });
    const v = (k) => Jd(i.props.nodeKey, k.data), y = (k) => {
      const N = t.props.class;
      if (!N)
        return {};
      let I;
      if (mn(N)) {
        const { data: P } = k;
        I = N(P, k);
      } else
        I = N;
      return qt(I) ? { [I]: !0 } : I;
    }, b = (k, N) => {
      (a.value !== k || l.value !== N) && i.ctx.emit("check-change", t.node.data, k, N), a.value = k, l.value = N;
    }, p = (k) => {
      bc(i.store, i.ctx.emit, () => i.store.value.setCurrentNode(t.node)), i.currentNode.value = t.node, i.props.expandOnClickNode && m(), i.props.checkOnClickNode && !t.node.disabled && g(null, {
        target: { checked: !t.node.checked }
      }), i.ctx.emit("node-click", t.node.data, t.node, d, k);
    }, f = (k) => {
      i.instance.vnode.props.onNodeContextmenu && (k.stopPropagation(), k.preventDefault()), i.ctx.emit("node-contextmenu", k, t.node.data, t.node, d);
    }, m = () => {
      t.node.isLeaf || (s.value ? (i.ctx.emit("node-collapse", t.node.data, t.node, d), t.node.collapse()) : (t.node.expand(), e.emit("node-expand", t.node.data, t.node, d)));
    }, g = (k, N) => {
      t.node.setChecked(N.target.checked, !i.props.checkStrictly), rt(() => {
        const I = i.store.value;
        i.ctx.emit("check", t.node.data, {
          checkedNodes: I.getCheckedNodes(),
          checkedKeys: I.getCheckedKeys(),
          halfCheckedNodes: I.getHalfCheckedNodes(),
          halfCheckedKeys: I.getHalfCheckedKeys()
        });
      });
    };
    return {
      ns: n,
      node$: u,
      tree: i,
      expanded: s,
      childNodeRendered: o,
      oldChecked: a,
      oldIndeterminate: l,
      getNodeKey: v,
      getNodeClass: y,
      handleSelectChange: b,
      handleClick: p,
      handleContextMenu: f,
      handleExpandIconClick: m,
      handleCheckChange: g,
      handleChildNodeExpand: (k, N, I) => {
        r(N), i.ctx.emit("node-expand", k, N, I);
      },
      handleDragStart: (k) => {
        i.props.draggable && c.treeNodeDragStart({ event: k, treeNode: t });
      },
      handleDragOver: (k) => {
        k.preventDefault(), i.props.draggable && c.treeNodeDragOver({
          event: k,
          treeNode: { $el: u.value, node: t.node }
        });
      },
      handleDrop: (k) => {
        k.preventDefault();
      },
      handleDragEnd: (k) => {
        i.props.draggable && c.treeNodeDragEnd(k);
      },
      CaretRight: mx
    };
  }
}), Y4 = ["aria-expanded", "aria-disabled", "aria-checked", "draggable", "data-key"], X4 = ["aria-expanded"];
function Z4(t, e, n, r, i, s) {
  const o = Dt("el-icon"), a = Dt("el-checkbox"), l = Dt("loading"), u = Dt("node-content"), c = Dt("el-tree-node"), d = Dt("el-collapse-transition");
  return $t((V(), se("div", {
    ref: "node$",
    class: ee([
      t.ns.b("node"),
      t.ns.is("expanded", t.expanded),
      t.ns.is("current", t.node.isCurrent),
      t.ns.is("hidden", !t.node.visible),
      t.ns.is("focusable", !t.node.disabled),
      t.ns.is("checked", !t.node.disabled && t.node.checked),
      t.getNodeClass(t.node)
    ]),
    role: "treeitem",
    tabindex: "-1",
    "aria-expanded": t.expanded,
    "aria-disabled": t.node.disabled,
    "aria-checked": t.node.checked,
    draggable: t.tree.props.draggable,
    "data-key": t.getNodeKey(t.node),
    onClick: e[1] || (e[1] = ft((...h) => t.handleClick && t.handleClick(...h), ["stop"])),
    onContextmenu: e[2] || (e[2] = (...h) => t.handleContextMenu && t.handleContextMenu(...h)),
    onDragstart: e[3] || (e[3] = ft((...h) => t.handleDragStart && t.handleDragStart(...h), ["stop"])),
    onDragover: e[4] || (e[4] = ft((...h) => t.handleDragOver && t.handleDragOver(...h), ["stop"])),
    onDragend: e[5] || (e[5] = ft((...h) => t.handleDragEnd && t.handleDragEnd(...h), ["stop"])),
    onDrop: e[6] || (e[6] = ft((...h) => t.handleDrop && t.handleDrop(...h), ["stop"]))
  }, [
    ae("div", {
      class: ee(t.ns.be("node", "content")),
      style: it({ paddingLeft: (t.node.level - 1) * t.tree.props.indent + "px" })
    }, [
      t.tree.props.icon || t.CaretRight ? (V(), Ce(o, {
        key: 0,
        class: ee([
          t.ns.be("node", "expand-icon"),
          t.ns.is("leaf", t.node.isLeaf),
          {
            expanded: !t.node.isLeaf && t.expanded
          }
        ]),
        onClick: ft(t.handleExpandIconClick, ["stop"])
      }, {
        default: de(() => [
          (V(), Ce(In(t.tree.props.icon || t.CaretRight)))
        ]),
        _: 1
      }, 8, ["class", "onClick"])) : ye("v-if", !0),
      t.showCheckbox ? (V(), Ce(a, {
        key: 1,
        "model-value": t.node.checked,
        indeterminate: t.node.indeterminate,
        disabled: !!t.node.disabled,
        onClick: e[0] || (e[0] = ft(() => {
        }, ["stop"])),
        onChange: t.handleCheckChange
      }, null, 8, ["model-value", "indeterminate", "disabled", "onChange"])) : ye("v-if", !0),
      t.node.loading ? (V(), Ce(o, {
        key: 2,
        class: ee([t.ns.be("node", "loading-icon"), t.ns.is("loading")])
      }, {
        default: de(() => [
          ve(l)
        ]),
        _: 1
      }, 8, ["class"])) : ye("v-if", !0),
      ve(u, {
        node: t.node,
        "render-content": t.renderContent
      }, null, 8, ["node", "render-content"])
    ], 6),
    ve(d, null, {
      default: de(() => [
        !t.renderAfterExpand || t.childNodeRendered ? $t((V(), se("div", {
          key: 0,
          class: ee(t.ns.be("node", "children")),
          role: "group",
          "aria-expanded": t.expanded
        }, [
          (V(!0), se(Ft, null, Gn(t.node.childNodes, (h) => (V(), Ce(c, {
            key: t.getNodeKey(h),
            "render-content": t.renderContent,
            "render-after-expand": t.renderAfterExpand,
            "show-checkbox": t.showCheckbox,
            node: h,
            accordion: t.accordion,
            props: t.props,
            onNodeExpand: t.handleChildNodeExpand
          }, null, 8, ["render-content", "render-after-expand", "show-checkbox", "node", "accordion", "props", "onNodeExpand"]))), 128))
        ], 10, X4)), [
          [Yn, t.expanded]
        ]) : ye("v-if", !0)
      ]),
      _: 1
    })
  ], 42, Y4)), [
    [Yn, t.node.visible]
  ]);
}
var Q4 = /* @__PURE__ */ qe(G4, [["render", Z4], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node.vue"]]);
function J4({ el$: t }, e) {
  const n = Fe("tree"), r = Mn([]), i = Mn([]);
  Tt(() => {
    o();
  }), Dl(() => {
    r.value = Array.from(t.value.querySelectorAll("[role=treeitem]")), i.value = Array.from(t.value.querySelectorAll("input[type=checkbox]"));
  }), ke(i, (a) => {
    a.forEach((l) => {
      l.setAttribute("tabindex", "-1");
    });
  }), bn(t, "keydown", (a) => {
    const l = a.target;
    if (!l.className.includes(n.b("node")))
      return;
    const u = a.code;
    r.value = Array.from(t.value.querySelectorAll(`.${n.is("focusable")}[role=treeitem]`));
    const c = r.value.indexOf(l);
    let d;
    if ([sn.up, sn.down].includes(u)) {
      if (a.preventDefault(), u === sn.up) {
        d = c === -1 ? 0 : c !== 0 ? c - 1 : r.value.length - 1;
        const v = d;
        for (; !e.value.getNode(r.value[d].dataset.key).canFocus; ) {
          if (d--, d === v) {
            d = -1;
            break;
          }
          d < 0 && (d = r.value.length - 1);
        }
      } else {
        d = c === -1 ? 0 : c < r.value.length - 1 ? c + 1 : 0;
        const v = d;
        for (; !e.value.getNode(r.value[d].dataset.key).canFocus; ) {
          if (d++, d === v) {
            d = -1;
            break;
          }
          d >= r.value.length && (d = 0);
        }
      }
      d !== -1 && r.value[d].focus();
    }
    [sn.left, sn.right].includes(u) && (a.preventDefault(), l.click());
    const h = l.querySelector('[type="checkbox"]');
    [sn.enter, sn.space].includes(u) && h && (a.preventDefault(), h.click());
  });
  const o = () => {
    var a;
    r.value = Array.from(t.value.querySelectorAll(`.${n.is("focusable")}[role=treeitem]`)), i.value = Array.from(t.value.querySelectorAll("input[type=checkbox]"));
    const l = t.value.querySelectorAll(`.${n.is("checked")}[role=treeitem]`);
    if (l.length) {
      l[0].setAttribute("tabindex", "0");
      return;
    }
    (a = r.value[0]) == null || a.setAttribute("tabindex", "0");
  };
}
const eL = be({
  name: "ElTree",
  components: { ElTreeNode: Q4 },
  props: {
    data: {
      type: Array,
      default: () => []
    },
    emptyText: {
      type: String
    },
    renderAfterExpand: {
      type: Boolean,
      default: !0
    },
    nodeKey: String,
    checkStrictly: Boolean,
    defaultExpandAll: Boolean,
    expandOnClickNode: {
      type: Boolean,
      default: !0
    },
    checkOnClickNode: Boolean,
    checkDescendants: {
      type: Boolean,
      default: !1
    },
    autoExpandParent: {
      type: Boolean,
      default: !0
    },
    defaultCheckedKeys: Array,
    defaultExpandedKeys: Array,
    currentNodeKey: [String, Number],
    renderContent: Function,
    showCheckbox: {
      type: Boolean,
      default: !1
    },
    draggable: {
      type: Boolean,
      default: !1
    },
    allowDrag: Function,
    allowDrop: Function,
    props: {
      type: Object,
      default: () => ({
        children: "children",
        label: "label",
        disabled: "disabled"
      })
    },
    lazy: {
      type: Boolean,
      default: !1
    },
    highlightCurrent: Boolean,
    load: Function,
    filterNodeMethod: Function,
    accordion: Boolean,
    indent: {
      type: Number,
      default: 18
    },
    icon: {
      type: bi
    }
  },
  emits: [
    "check-change",
    "current-change",
    "node-click",
    "node-contextmenu",
    "node-collapse",
    "node-expand",
    "check",
    "node-drag-start",
    "node-drag-end",
    "node-drop",
    "node-drag-leave",
    "node-drag-enter",
    "node-drag-over"
  ],
  setup(t, e) {
    const { t: n } = or(), r = Fe("tree"), i = K(new W4({
      key: t.nodeKey,
      data: t.data,
      lazy: t.lazy,
      props: t.props,
      load: t.load,
      currentNodeKey: t.currentNodeKey,
      checkStrictly: t.checkStrictly,
      checkDescendants: t.checkDescendants,
      defaultCheckedKeys: t.defaultCheckedKeys,
      defaultExpandedKeys: t.defaultExpandedKeys,
      autoExpandParent: t.autoExpandParent,
      defaultExpandAll: t.defaultExpandAll,
      filterNodeMethod: t.filterNodeMethod
    }));
    i.value.initialize();
    const s = K(i.value.root), o = K(null), a = K(null), l = K(null), { broadcastExpanded: u } = Fg(t), { dragState: c } = q4({
      props: t,
      ctx: e,
      el$: a,
      dropIndicator$: l,
      store: i
    });
    J4({ el$: a }, i);
    const d = F(() => {
      const { childNodes: M } = s.value;
      return !M || M.length === 0 || M.every(({ visible: U }) => !U);
    });
    ke(() => t.currentNodeKey, (M) => {
      i.value.setCurrentNodeKey(M);
    }), ke(() => t.defaultCheckedKeys, (M) => {
      i.value.setDefaultCheckedKey(M);
    }), ke(() => t.defaultExpandedKeys, (M) => {
      i.value.setDefaultExpandedKeys(M);
    }), ke(() => t.data, (M) => {
      i.value.setData(M);
    }, { deep: !0 }), ke(() => t.checkStrictly, (M) => {
      i.value.checkStrictly = M;
    });
    const h = (M) => {
      if (!t.filterNodeMethod)
        throw new Error("[Tree] filterNodeMethod is required when filter");
      i.value.filter(M);
    }, v = (M) => Jd(t.nodeKey, M.data), y = (M) => {
      if (!t.nodeKey)
        throw new Error("[Tree] nodeKey is required in getNodePath");
      const U = i.value.getNode(M);
      if (!U)
        return [];
      const j = [U.data];
      let re = U.parent;
      for (; re && re !== s.value; )
        j.push(re.data), re = re.parent;
      return j.reverse();
    }, b = (M, U) => i.value.getCheckedNodes(M, U), p = (M) => i.value.getCheckedKeys(M), f = () => {
      const M = i.value.getCurrentNode();
      return M ? M.data : null;
    }, m = () => {
      if (!t.nodeKey)
        throw new Error("[Tree] nodeKey is required in getCurrentKey");
      const M = f();
      return M ? M[t.nodeKey] : null;
    }, g = (M, U) => {
      if (!t.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCheckedNodes");
      i.value.setCheckedNodes(M, U);
    }, w = (M, U) => {
      if (!t.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCheckedKeys");
      i.value.setCheckedKeys(M, U);
    }, _ = (M, U, j) => {
      i.value.setChecked(M, U, j);
    }, E = () => i.value.getHalfCheckedNodes(), C = () => i.value.getHalfCheckedKeys(), T = (M, U = !0) => {
      if (!t.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCurrentNode");
      bc(i, e.emit, () => i.value.setUserCurrentNode(M, U));
    }, k = (M, U = !0) => {
      if (!t.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCurrentKey");
      bc(i, e.emit, () => i.value.setCurrentNodeKey(M, U));
    }, N = (M) => i.value.getNode(M), I = (M) => {
      i.value.remove(M);
    }, P = (M, U) => {
      i.value.append(M, U);
    }, D = (M, U) => {
      i.value.insertBefore(M, U);
    }, z = (M, U) => {
      i.value.insertAfter(M, U);
    }, G = (M, U, j) => {
      u(U), e.emit("node-expand", M, U, j);
    }, J = (M, U) => {
      if (!t.nodeKey)
        throw new Error("[Tree] nodeKey is required in updateKeyChild");
      i.value.updateChildren(M, U);
    };
    return Gt("RootTree", {
      ctx: e,
      props: t,
      store: i,
      root: s,
      currentNode: o,
      instance: ht()
    }), Gt(No, void 0), {
      ns: r,
      store: i,
      root: s,
      currentNode: o,
      dragState: c,
      el$: a,
      dropIndicator$: l,
      isEmpty: d,
      filter: h,
      getNodeKey: v,
      getNodePath: y,
      getCheckedNodes: b,
      getCheckedKeys: p,
      getCurrentNode: f,
      getCurrentKey: m,
      setCheckedNodes: g,
      setCheckedKeys: w,
      setChecked: _,
      getHalfCheckedNodes: E,
      getHalfCheckedKeys: C,
      setCurrentNode: T,
      setCurrentKey: k,
      t: n,
      getNode: N,
      remove: I,
      append: P,
      insertBefore: D,
      insertAfter: z,
      handleNodeExpand: G,
      updateKeyChildren: J
    };
  }
});
function tL(t, e, n, r, i, s) {
  const o = Dt("el-tree-node");
  return V(), se("div", {
    ref: "el$",
    class: ee([
      t.ns.b(),
      t.ns.is("dragging", !!t.dragState.draggingNode),
      t.ns.is("drop-not-allow", !t.dragState.allowDrop),
      t.ns.is("drop-inner", t.dragState.dropType === "inner"),
      { [t.ns.m("highlight-current")]: t.highlightCurrent }
    ]),
    role: "tree"
  }, [
    (V(!0), se(Ft, null, Gn(t.root.childNodes, (a) => (V(), Ce(o, {
      key: t.getNodeKey(a),
      node: a,
      props: t.props,
      accordion: t.accordion,
      "render-after-expand": t.renderAfterExpand,
      "show-checkbox": t.showCheckbox,
      "render-content": t.renderContent,
      onNodeExpand: t.handleNodeExpand
    }, null, 8, ["node", "props", "accordion", "render-after-expand", "show-checkbox", "render-content", "onNodeExpand"]))), 128)),
    t.isEmpty ? (V(), se("div", {
      key: 0,
      class: ee(t.ns.e("empty-block"))
    }, [
      De(t.$slots, "empty", {}, () => {
        var a;
        return [
          ae("span", {
            class: ee(t.ns.e("empty-text"))
          }, st((a = t.emptyText) != null ? a : t.t("el.tree.emptyText")), 3)
        ];
      })
    ], 2)) : ye("v-if", !0),
    $t(ae("div", {
      ref: "dropIndicator$",
      class: ee(t.ns.e("drop-indicator"))
    }, null, 2), [
      [Yn, t.dragState.showDropIndicator]
    ])
  ], 2);
}
var Wa = /* @__PURE__ */ qe(eL, [["render", tL], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree.vue"]]);
Wa.install = (t) => {
  t.component(Wa.name, Wa);
};
const nL = Wa, rL = nL, Ug = Symbol("uploadContextKey"), iL = "ElUpload";
class sL extends Error {
  constructor(e, n, r, i) {
    super(e), this.name = "UploadAjaxError", this.status = n, this.method = r, this.url = i;
  }
}
function fp(t, e, n) {
  let r;
  return n.response ? r = `${n.response.error || n.response}` : n.responseText ? r = `${n.responseText}` : r = `fail to ${e.method} ${t} ${n.status}`, new sL(r, n.status, e.method, t);
}
function oL(t) {
  const e = t.responseText || t.response;
  if (!e)
    return e;
  try {
    return JSON.parse(e);
  } catch {
    return e;
  }
}
const aL = (t) => {
  typeof XMLHttpRequest > "u" && Gi(iL, "XMLHttpRequest is undefined");
  const e = new XMLHttpRequest(), n = t.action;
  e.upload && e.upload.addEventListener("progress", (s) => {
    const o = s;
    o.percent = s.total > 0 ? s.loaded / s.total * 100 : 0, t.onProgress(o);
  });
  const r = new FormData();
  if (t.data)
    for (const [s, o] of Object.entries(t.data))
      Nr(o) && o.length ? r.append(s, ...o) : r.append(s, o);
  r.append(t.filename, t.file, t.file.name), e.addEventListener("error", () => {
    t.onError(fp(n, t, e));
  }), e.addEventListener("load", () => {
    if (e.status < 200 || e.status >= 300)
      return t.onError(fp(n, t, e));
    t.onSuccess(oL(e));
  }), e.open(t.method, n, !0), t.withCredentials && "withCredentials" in e && (e.withCredentials = !0);
  const i = t.headers || {};
  if (i instanceof Headers)
    i.forEach((s, o) => e.setRequestHeader(o, s));
  else
    for (const [s, o] of Object.entries(i))
      er(o) || e.setRequestHeader(s, String(o));
  return e.send(r), e;
}, Vg = ["text", "picture", "picture-card"];
let lL = 1;
const Ec = () => Date.now() + lL++, Wg = ut({
  action: {
    type: String,
    default: "#"
  },
  headers: {
    type: Pe(Object)
  },
  method: {
    type: String,
    default: "post"
  },
  data: {
    type: Pe([Object, Function, Promise]),
    default: () => Ts({})
  },
  multiple: {
    type: Boolean,
    default: !1
  },
  name: {
    type: String,
    default: "file"
  },
  drag: {
    type: Boolean,
    default: !1
  },
  withCredentials: Boolean,
  showFileList: {
    type: Boolean,
    default: !0
  },
  accept: {
    type: String,
    default: ""
  },
  fileList: {
    type: Pe(Array),
    default: () => Ts([])
  },
  autoUpload: {
    type: Boolean,
    default: !0
  },
  listType: {
    type: String,
    values: Vg,
    default: "text"
  },
  httpRequest: {
    type: Pe(Function),
    default: aL
  },
  disabled: Boolean,
  limit: Number
}), uL = ut({
  ...Wg,
  beforeUpload: {
    type: Pe(Function),
    default: en
  },
  beforeRemove: {
    type: Pe(Function)
  },
  onRemove: {
    type: Pe(Function),
    default: en
  },
  onChange: {
    type: Pe(Function),
    default: en
  },
  onPreview: {
    type: Pe(Function),
    default: en
  },
  onSuccess: {
    type: Pe(Function),
    default: en
  },
  onProgress: {
    type: Pe(Function),
    default: en
  },
  onError: {
    type: Pe(Function),
    default: en
  },
  onExceed: {
    type: Pe(Function),
    default: en
  }
}), cL = ut({
  files: {
    type: Pe(Array),
    default: () => Ts([])
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  handlePreview: {
    type: Pe(Function),
    default: en
  },
  listType: {
    type: String,
    values: Vg,
    default: "text"
  }
}), dL = {
  remove: (t) => !!t
}, fL = ["onKeydown"], hL = ["src"], pL = ["onClick"], vL = ["title"], mL = ["onClick"], gL = ["onClick"], yL = be({
  name: "ElUploadList"
}), bL = /* @__PURE__ */ be({
  ...yL,
  props: cL,
  emits: dL,
  setup(t, { emit: e }) {
    const n = t, { t: r } = or(), i = Fe("upload"), s = Fe("icon"), o = Fe("list"), a = Pr(), l = K(!1), u = F(() => [
      i.b("list"),
      i.bm("list", n.listType),
      i.is("disabled", n.disabled)
    ]), c = (d) => {
      e("remove", d);
    };
    return (d, h) => (V(), Ce(Jy, {
      tag: "ul",
      class: ee(x(u)),
      name: x(o).b()
    }, {
      default: de(() => [
        (V(!0), se(Ft, null, Gn(d.files, (v) => (V(), se("li", {
          key: v.uid || v.name,
          class: ee([
            x(i).be("list", "item"),
            x(i).is(v.status),
            { focusing: l.value }
          ]),
          tabindex: "0",
          onKeydown: vn((y) => !x(a) && c(v), ["delete"]),
          onFocus: h[0] || (h[0] = (y) => l.value = !0),
          onBlur: h[1] || (h[1] = (y) => l.value = !1),
          onClick: h[2] || (h[2] = (y) => l.value = !1)
        }, [
          De(d.$slots, "default", { file: v }, () => [
            d.listType === "picture" || v.status !== "uploading" && d.listType === "picture-card" ? (V(), se("img", {
              key: 0,
              class: ee(x(i).be("list", "item-thumbnail")),
              src: v.url,
              alt: ""
            }, null, 10, hL)) : ye("v-if", !0),
            v.status === "uploading" || d.listType !== "picture-card" ? (V(), se("div", {
              key: 1,
              class: ee(x(i).be("list", "item-info"))
            }, [
              ae("a", {
                class: ee(x(i).be("list", "item-name")),
                onClick: ft((y) => d.handlePreview(v), ["prevent"])
              }, [
                ve(x(_t), {
                  class: ee(x(s).m("document"))
                }, {
                  default: de(() => [
                    ve(x(Yx))
                  ]),
                  _: 1
                }, 8, ["class"]),
                ae("span", {
                  class: ee(x(i).be("list", "item-file-name")),
                  title: v.name
                }, st(v.name), 11, vL)
              ], 10, pL),
              v.status === "uploading" ? (V(), Ce(x(Og), {
                key: 0,
                type: d.listType === "picture-card" ? "circle" : "line",
                "stroke-width": d.listType === "picture-card" ? 6 : 2,
                percentage: Number(v.percentage),
                style: it(d.listType === "picture-card" ? "" : "margin-top: 0.5rem")
              }, null, 8, ["type", "stroke-width", "percentage", "style"])) : ye("v-if", !0)
            ], 2)) : ye("v-if", !0),
            ae("label", {
              class: ee(x(i).be("list", "item-status-label"))
            }, [
              d.listType === "text" ? (V(), Ce(x(_t), {
                key: 0,
                class: ee([x(s).m("upload-success"), x(s).m("circle-check")])
              }, {
                default: de(() => [
                  ve(x(Id))
                ]),
                _: 1
              }, 8, ["class"])) : ["picture-card", "picture"].includes(d.listType) ? (V(), Ce(x(_t), {
                key: 1,
                class: ee([x(s).m("upload-success"), x(s).m("check")])
              }, {
                default: de(() => [
                  ve(x(om))
                ]),
                _: 1
              }, 8, ["class"])) : ye("v-if", !0)
            ], 2),
            x(a) ? ye("v-if", !0) : (V(), Ce(x(_t), {
              key: 2,
              class: ee(x(s).m("close")),
              onClick: (y) => c(v)
            }, {
              default: de(() => [
                ve(x(ko))
              ]),
              _: 2
            }, 1032, ["class", "onClick"])),
            ye(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"),
            ye(" This is a bug which needs to be fixed "),
            ye(" TODO: Fix the incorrect navigation interaction "),
            x(a) ? ye("v-if", !0) : (V(), se("i", {
              key: 3,
              class: ee(x(s).m("close-tip"))
            }, st(x(r)("el.upload.deleteTip")), 3)),
            d.listType === "picture-card" ? (V(), se("span", {
              key: 4,
              class: ee(x(i).be("list", "item-actions"))
            }, [
              ae("span", {
                class: ee(x(i).be("list", "item-preview")),
                onClick: (y) => d.handlePreview(v)
              }, [
                ve(x(_t), {
                  class: ee(x(s).m("zoom-in"))
                }, {
                  default: de(() => [
                    ve(x(cm))
                  ]),
                  _: 1
                }, 8, ["class"])
              ], 10, mL),
              x(a) ? ye("v-if", !0) : (V(), se("span", {
                key: 0,
                class: ee(x(i).be("list", "item-delete")),
                onClick: (y) => c(v)
              }, [
                ve(x(_t), {
                  class: ee(x(s).m("delete"))
                }, {
                  default: de(() => [
                    ve(x(am))
                  ]),
                  _: 1
                }, 8, ["class"])
              ], 10, gL))
            ], 2)) : ye("v-if", !0)
          ])
        ], 42, fL))), 128)),
        De(d.$slots, "append")
      ]),
      _: 3
    }, 8, ["class", "name"]));
  }
});
var hp = /* @__PURE__ */ qe(bL, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-list.vue"]]);
const wL = ut({
  disabled: {
    type: Boolean,
    default: !1
  }
}), _L = {
  file: (t) => Nr(t)
}, EL = ["onDrop", "onDragover"], Hg = "ElUploadDrag", SL = be({
  name: Hg
}), xL = /* @__PURE__ */ be({
  ...SL,
  props: wL,
  emits: _L,
  setup(t, { emit: e }) {
    const n = tt(Ug);
    n || Gi(Hg, "usage: <el-upload><el-upload-dragger /></el-upload>");
    const r = Fe("upload"), i = K(!1), s = Pr(), o = (l) => {
      if (s.value)
        return;
      i.value = !1, l.stopPropagation();
      const u = Array.from(l.dataTransfer.files), c = n.accept.value;
      if (!c) {
        e("file", u);
        return;
      }
      const d = u.filter((h) => {
        const { type: v, name: y } = h, b = y.includes(".") ? `.${y.split(".").pop()}` : "", p = v.replace(/\/.*$/, "");
        return c.split(",").map((f) => f.trim()).filter((f) => f).some((f) => f.startsWith(".") ? b === f : /\/\*$/.test(f) ? p === f.replace(/\/\*$/, "") : /^[^/]+\/[^/]+$/.test(f) ? v === f : !1);
      });
      e("file", d);
    }, a = () => {
      s.value || (i.value = !0);
    };
    return (l, u) => (V(), se("div", {
      class: ee([x(r).b("dragger"), x(r).is("dragover", i.value)]),
      onDrop: ft(o, ["prevent"]),
      onDragover: ft(a, ["prevent"]),
      onDragleave: u[0] || (u[0] = ft((c) => i.value = !1, ["prevent"]))
    }, [
      De(l.$slots, "default")
    ], 42, EL));
  }
});
var CL = /* @__PURE__ */ qe(xL, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-dragger.vue"]]);
const kL = ut({
  ...Wg,
  beforeUpload: {
    type: Pe(Function),
    default: en
  },
  onRemove: {
    type: Pe(Function),
    default: en
  },
  onStart: {
    type: Pe(Function),
    default: en
  },
  onSuccess: {
    type: Pe(Function),
    default: en
  },
  onProgress: {
    type: Pe(Function),
    default: en
  },
  onError: {
    type: Pe(Function),
    default: en
  },
  onExceed: {
    type: Pe(Function),
    default: en
  }
}), TL = ["onKeydown"], OL = ["name", "multiple", "accept"], NL = be({
  name: "ElUploadContent",
  inheritAttrs: !1
}), AL = /* @__PURE__ */ be({
  ...NL,
  props: kL,
  setup(t, { expose: e }) {
    const n = t, r = Fe("upload"), i = Pr(), s = Mn({}), o = Mn(), a = (b) => {
      if (b.length === 0)
        return;
      const { autoUpload: p, limit: f, fileList: m, multiple: g, onStart: w, onExceed: _ } = n;
      if (f && m.length + b.length > f) {
        _(b, m);
        return;
      }
      g || (b = b.slice(0, 1));
      for (const E of b) {
        const C = E;
        C.uid = Ec(), w(C), p && l(C);
      }
    }, l = async (b) => {
      if (o.value.value = "", !n.beforeUpload)
        return c(b);
      let p, f = {};
      try {
        const g = n.data, w = n.beforeUpload(b);
        f = Kf(n.data) ? bh(n.data) : n.data, p = await w, Kf(n.data) && ll(g, f) && (f = bh(n.data));
      } catch {
        p = !1;
      }
      if (p === !1) {
        n.onRemove(b);
        return;
      }
      let m = b;
      p instanceof Blob && (p instanceof File ? m = p : m = new File([p], b.name, {
        type: b.type
      })), c(Object.assign(m, {
        uid: b.uid
      }), f);
    }, u = async (b, p) => mn(b) ? b(p) : b, c = async (b, p) => {
      const {
        headers: f,
        data: m,
        method: g,
        withCredentials: w,
        name: _,
        action: E,
        onProgress: C,
        onSuccess: T,
        onError: k,
        httpRequest: N
      } = n;
      try {
        p = await u(p ?? m, b);
      } catch {
        n.onRemove(b);
        return;
      }
      const { uid: I } = b, P = {
        headers: f || {},
        withCredentials: w,
        file: b,
        data: p,
        method: g,
        filename: _,
        action: E,
        onProgress: (z) => {
          C(z, b);
        },
        onSuccess: (z) => {
          T(z, b), delete s.value[I];
        },
        onError: (z) => {
          k(z, b), delete s.value[I];
        }
      }, D = N(P);
      s.value[I] = D, D instanceof Promise && D.then(P.onSuccess, P.onError);
    }, d = (b) => {
      const p = b.target.files;
      p && a(Array.from(p));
    }, h = () => {
      i.value || (o.value.value = "", o.value.click());
    }, v = () => {
      h();
    };
    return e({
      abort: (b) => {
        IS(s.value).filter(b ? ([f]) => String(b.uid) === f : () => !0).forEach(([f, m]) => {
          m instanceof XMLHttpRequest && m.abort(), delete s.value[f];
        });
      },
      upload: l
    }), (b, p) => (V(), se("div", {
      class: ee([x(r).b(), x(r).m(b.listType), x(r).is("drag", b.drag)]),
      tabindex: "0",
      onClick: h,
      onKeydown: vn(ft(v, ["self"]), ["enter", "space"])
    }, [
      b.drag ? (V(), Ce(CL, {
        key: 0,
        disabled: x(i),
        onFile: a
      }, {
        default: de(() => [
          De(b.$slots, "default")
        ]),
        _: 3
      }, 8, ["disabled"])) : De(b.$slots, "default", { key: 1 }),
      ae("input", {
        ref_key: "inputRef",
        ref: o,
        class: ee(x(r).e("input")),
        name: b.name,
        multiple: b.multiple,
        accept: b.accept,
        type: "file",
        onChange: d,
        onClick: p[0] || (p[0] = ft(() => {
        }, ["stop"]))
      }, null, 42, OL)
    ], 42, TL));
  }
});
var pp = /* @__PURE__ */ qe(AL, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-content.vue"]]);
const vp = "ElUpload", mp = (t) => {
  var e;
  (e = t.url) != null && e.startsWith("blob:") && URL.revokeObjectURL(t.url);
}, IL = (t, e) => {
  const n = _b(t, "fileList", void 0, { passive: !0 }), r = (h) => n.value.find((v) => v.uid === h.uid);
  function i(h) {
    var v;
    (v = e.value) == null || v.abort(h);
  }
  function s(h = ["ready", "uploading", "success", "fail"]) {
    n.value = n.value.filter((v) => !h.includes(v.status));
  }
  const o = (h, v) => {
    const y = r(v);
    y && (console.error(h), y.status = "fail", n.value.splice(n.value.indexOf(y), 1), t.onError(h, y, n.value), t.onChange(y, n.value));
  }, a = (h, v) => {
    const y = r(v);
    y && (t.onProgress(h, y, n.value), y.status = "uploading", y.percentage = Math.round(h.percent));
  }, l = (h, v) => {
    const y = r(v);
    y && (y.status = "success", y.response = h, t.onSuccess(h, y, n.value), t.onChange(y, n.value));
  }, u = (h) => {
    er(h.uid) && (h.uid = Ec());
    const v = {
      name: h.name,
      percentage: 0,
      status: "ready",
      size: h.size,
      raw: h,
      uid: h.uid
    };
    if (t.listType === "picture-card" || t.listType === "picture")
      try {
        v.url = URL.createObjectURL(h);
      } catch (y) {
        Vt(vp, y.message), t.onError(y, v, n.value);
      }
    n.value = [...n.value, v], t.onChange(v, n.value);
  }, c = async (h) => {
    const v = h instanceof File ? r(h) : h;
    v || Gi(vp, "file to be removed not found");
    const y = (b) => {
      i(b);
      const p = n.value;
      p.splice(p.indexOf(b), 1), t.onRemove(b, p), mp(b);
    };
    t.beforeRemove ? await t.beforeRemove(v, n.value) !== !1 && y(v) : y(v);
  };
  function d() {
    n.value.filter(({ status: h }) => h === "ready").forEach(({ raw: h }) => {
      var v;
      return h && ((v = e.value) == null ? void 0 : v.upload(h));
    });
  }
  return ke(() => t.listType, (h) => {
    h !== "picture-card" && h !== "picture" || (n.value = n.value.map((v) => {
      const { raw: y, url: b } = v;
      if (!b && y)
        try {
          v.url = URL.createObjectURL(y);
        } catch (p) {
          t.onError(p, v, n.value);
        }
      return v;
    }));
  }), ke(n, (h) => {
    for (const v of h)
      v.uid || (v.uid = Ec()), v.status || (v.status = "success");
  }, { immediate: !0, deep: !0 }), {
    uploadFiles: n,
    abort: i,
    clearFiles: s,
    handleError: o,
    handleProgress: a,
    handleStart: u,
    handleSuccess: l,
    handleRemove: c,
    submit: d,
    revokeFileObjectURL: mp
  };
}, RL = be({
  name: "ElUpload"
}), LL = /* @__PURE__ */ be({
  ...RL,
  props: uL,
  setup(t, { expose: e }) {
    const n = t, r = Pr(), i = Mn(), {
      abort: s,
      submit: o,
      clearFiles: a,
      uploadFiles: l,
      handleStart: u,
      handleError: c,
      handleRemove: d,
      handleSuccess: h,
      handleProgress: v,
      revokeFileObjectURL: y
    } = IL(n, i), b = F(() => n.listType === "picture-card"), p = F(() => ({
      ...n,
      fileList: l.value,
      onStart: u,
      onProgress: v,
      onSuccess: h,
      onError: c,
      onRemove: d
    }));
    return Sn(() => {
      l.value.forEach(y);
    }), Gt(Ug, {
      accept: Tn(n, "accept")
    }), e({
      abort: s,
      submit: o,
      clearFiles: a,
      handleStart: u,
      handleRemove: d
    }), (f, m) => (V(), se("div", null, [
      x(b) && f.showFileList ? (V(), Ce(hp, {
        key: 0,
        disabled: x(r),
        "list-type": f.listType,
        files: x(l),
        "handle-preview": f.onPreview,
        onRemove: x(d)
      }, Gu({
        append: de(() => [
          ve(pp, qn({
            ref_key: "uploadRef",
            ref: i
          }, x(p)), {
            default: de(() => [
              f.$slots.trigger ? De(f.$slots, "trigger", { key: 0 }) : ye("v-if", !0),
              !f.$slots.trigger && f.$slots.default ? De(f.$slots, "default", { key: 1 }) : ye("v-if", !0)
            ]),
            _: 3
          }, 16)
        ]),
        _: 2
      }, [
        f.$slots.file ? {
          name: "default",
          fn: de(({ file: g }) => [
            De(f.$slots, "file", { file: g })
          ])
        } : void 0
      ]), 1032, ["disabled", "list-type", "files", "handle-preview", "onRemove"])) : ye("v-if", !0),
      !x(b) || x(b) && !f.showFileList ? (V(), Ce(pp, qn({
        key: 1,
        ref_key: "uploadRef",
        ref: i
      }, x(p)), {
        default: de(() => [
          f.$slots.trigger ? De(f.$slots, "trigger", { key: 0 }) : ye("v-if", !0),
          !f.$slots.trigger && f.$slots.default ? De(f.$slots, "default", { key: 1 }) : ye("v-if", !0)
        ]),
        _: 3
      }, 16)) : ye("v-if", !0),
      f.$slots.trigger ? De(f.$slots, "default", { key: 2 }) : ye("v-if", !0),
      De(f.$slots, "tip"),
      !x(b) && f.showFileList ? (V(), Ce(hp, {
        key: 3,
        disabled: x(r),
        "list-type": f.listType,
        files: x(l),
        "handle-preview": f.onPreview,
        onRemove: x(d)
      }, Gu({ _: 2 }, [
        f.$slots.file ? {
          name: "default",
          fn: de(({ file: g }) => [
            De(f.$slots, "file", { file: g })
          ])
        } : void 0
      ]), 1032, ["disabled", "list-type", "files", "handle-preview", "onRemove"])) : ye("v-if", !0)
    ]));
  }
});
var PL = /* @__PURE__ */ qe(LL, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload.vue"]]);
const $L = nn(PL);
function DL(t) {
  let e;
  const n = K(!1), r = Pn({
    ...t,
    originalPosition: "",
    originalOverflow: "",
    visible: !1
  });
  function i(h) {
    r.text = h;
  }
  function s() {
    const h = r.parent, v = d.ns;
    if (!h.vLoadingAddClassList) {
      let y = h.getAttribute("loading-number");
      y = Number.parseInt(y) - 1, y ? h.setAttribute("loading-number", y.toString()) : (Sr(h, v.bm("parent", "relative")), h.removeAttribute("loading-number")), Sr(h, v.bm("parent", "hidden"));
    }
    o(), c.unmount();
  }
  function o() {
    var h, v;
    (v = (h = d.$el) == null ? void 0 : h.parentNode) == null || v.removeChild(d.$el);
  }
  function a() {
    var h;
    t.beforeClose && !t.beforeClose() || (n.value = !0, clearTimeout(e), e = window.setTimeout(l, 400), r.visible = !1, (h = t.closed) == null || h.call(t));
  }
  function l() {
    if (!n.value)
      return;
    const h = r.parent;
    n.value = !1, h.vLoadingAddClassList = void 0, s();
  }
  const u = be({
    name: "ElLoading",
    setup(h, { expose: v }) {
      const { ns: y, zIndex: b } = SO("loading");
      return v({
        ns: y,
        zIndex: b
      }), () => {
        const p = r.spinner || r.svg, f = et("svg", {
          class: "circular",
          viewBox: r.svgViewBox ? r.svgViewBox : "0 0 50 50",
          ...p ? { innerHTML: p } : {}
        }, [
          et("circle", {
            class: "path",
            cx: "25",
            cy: "25",
            r: "20",
            fill: "none"
          })
        ]), m = r.text ? et("p", { class: y.b("text") }, [r.text]) : void 0;
        return et(gr, {
          name: y.b("fade"),
          onAfterLeave: l
        }, {
          default: de(() => [
            $t(ve("div", {
              style: {
                backgroundColor: r.background || ""
              },
              class: [
                y.b("mask"),
                r.customClass,
                r.fullscreen ? "is-fullscreen" : ""
              ]
            }, [
              et("div", {
                class: y.b("spinner")
              }, [f, m])
            ]), [[Yn, r.visible]])
          ])
        });
      };
    }
  }), c = eb(u), d = c.mount(document.createElement("div"));
  return {
    ...hn(r),
    setText: i,
    removeElLoadingChild: o,
    close: a,
    handleAfterLeave: l,
    vm: d,
    get $el() {
      return d.$el;
    }
  };
}
let Sa;
const BL = function(t = {}) {
  if (!Et)
    return;
  const e = ML(t);
  if (e.fullscreen && Sa)
    return Sa;
  const n = DL({
    ...e,
    closed: () => {
      var i;
      (i = e.closed) == null || i.call(e), e.fullscreen && (Sa = void 0);
    }
  });
  zL(e, e.parent, n), gp(e, e.parent, n), e.parent.vLoadingAddClassList = () => gp(e, e.parent, n);
  let r = e.parent.getAttribute("loading-number");
  return r ? r = `${Number.parseInt(r) + 1}` : r = "1", e.parent.setAttribute("loading-number", r), e.parent.appendChild(n.$el), rt(() => n.visible.value = e.visible), e.fullscreen && (Sa = n), n;
}, ML = (t) => {
  var e, n, r, i;
  let s;
  return qt(t.target) ? s = (e = document.querySelector(t.target)) != null ? e : document.body : s = t.target || document.body, {
    parent: s === document.body || t.body ? document.body : s,
    background: t.background || "",
    svg: t.svg || "",
    svgViewBox: t.svgViewBox || "",
    spinner: t.spinner || !1,
    text: t.text || "",
    fullscreen: s === document.body && ((n = t.fullscreen) != null ? n : !0),
    lock: (r = t.lock) != null ? r : !1,
    customClass: t.customClass || "",
    visible: (i = t.visible) != null ? i : !0,
    target: s
  };
}, zL = async (t, e, n) => {
  const { nextZIndex: r } = n.vm.zIndex || n.vm._.exposed.zIndex, i = {};
  if (t.fullscreen)
    n.originalPosition.value = fs(document.body, "position"), n.originalOverflow.value = fs(document.body, "overflow"), i.zIndex = r();
  else if (t.parent === document.body) {
    n.originalPosition.value = fs(document.body, "position"), await rt();
    for (const s of ["top", "left"]) {
      const o = s === "top" ? "scrollTop" : "scrollLeft";
      i[s] = `${t.target.getBoundingClientRect()[s] + document.body[o] + document.documentElement[o] - Number.parseInt(fs(document.body, `margin-${s}`), 10)}px`;
    }
    for (const s of ["height", "width"])
      i[s] = `${t.target.getBoundingClientRect()[s]}px`;
  } else
    n.originalPosition.value = fs(e, "position");
  for (const [s, o] of Object.entries(i))
    n.$el.style[s] = o;
}, gp = (t, e, n) => {
  const r = n.vm.ns || n.vm._.exposed.ns;
  ["absolute", "fixed", "sticky"].includes(n.originalPosition.value) ? Sr(e, r.bm("parent", "relative")) : Co(e, r.bm("parent", "relative")), t.fullscreen && t.lock ? Co(e, r.bm("parent", "hidden")) : Sr(e, r.bm("parent", "hidden"));
}, Sc = Symbol("ElLoading"), yp = (t, e) => {
  var n, r, i, s;
  const o = e.instance, a = (h) => wn(e.value) ? e.value[h] : void 0, l = (h) => {
    const v = qt(h) && (o == null ? void 0 : o[h]) || h;
    return v && K(v);
  }, u = (h) => l(a(h) || t.getAttribute(`element-loading-${Nb(h)}`)), c = (n = a("fullscreen")) != null ? n : e.modifiers.fullscreen, d = {
    text: u("text"),
    svg: u("svg"),
    svgViewBox: u("svgViewBox"),
    spinner: u("spinner"),
    background: u("background"),
    customClass: u("customClass"),
    fullscreen: c,
    target: (r = a("target")) != null ? r : c ? void 0 : t,
    body: (i = a("body")) != null ? i : e.modifiers.body,
    lock: (s = a("lock")) != null ? s : e.modifiers.lock
  };
  t[Sc] = {
    options: d,
    instance: BL(d)
  };
}, FL = (t, e) => {
  for (const n of Object.keys(e))
    on(e[n]) && (e[n].value = t[n]);
}, jL = {
  mounted(t, e) {
    e.value && yp(t, e);
  },
  updated(t, e) {
    const n = t[Sc];
    e.oldValue !== e.value && (e.value && !e.oldValue ? yp(t, e) : e.value && e.oldValue ? wn(e.value) && FL(e.value, n.options) : n == null || n.instance.close());
  },
  unmounted(t) {
    var e;
    (e = t[Sc]) == null || e.instance.close();
  }
};
const Zi = (t, e) => {
  const n = t.__vccOpts || t;
  for (const [r, i] of e)
    n[r] = i;
  return n;
}, UL = { id: "left" }, VL = ["title"], WL = { id: "right" }, HL = {
  __name: "Titlebar",
  props: {
    backdrop: {
      default: !1,
      type: Boolean
    },
    title: {
      default: "Reader",
      type: String
    }
  },
  setup(t) {
    const e = t;
    let n = !1;
    const r = (s, o) => s.length > o ? `${s.substr(0, o - 3)}...` : s, i = () => {
      if (n)
        document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitCancelFullScreen ? document.webkitCancelFullScreen() : document.msExitFullscreen && document.msExitFullscreen(), n = !1;
      else {
        const s = document.documentElement, o = s.requestFullScreen || s.webkitRequestFullScreen || s.mozRequestFullScreen || s.msRequestFullscreen;
        typeof o < "u" && o && o.call(s), n = !0;
      }
    };
    return (s, o) => {
      const a = Xi, l = FI;
      return V(), Ce(l, {
        height: "40px",
        class: ee({ backdrop: e.backdrop })
      }, {
        default: de(() => [
          ae("span", UL, [
            De(s.$slots, "default", {}, void 0, !0)
          ]),
          ae("span", {
            id: "center",
            title: e.title
          }, st(r(e.title, 15)), 9, VL),
          ae("span", WL, [
            ve(a, {
              size: "small",
              icon: x(lm),
              circle: "",
              onClick: i
            }, null, 8, ["icon"])
          ])
        ]),
        _: 3
      }, 8, ["class"]);
    };
  }
}, Kg = /* @__PURE__ */ Zi(HL, [["__scopeId", "data-v-ea5e85e1"]]);
var xc = {}, KL = {
  get exports() {
    return xc;
  },
  set exports(t) {
    xc = t;
  }
};
(function(t, e) {
  (function(n, r) {
    r();
  })(gn, function() {
    function n(u, c) {
      return typeof c > "u" ? c = { autoBom: !1 } : typeof c != "object" && (console.warn("Deprecated: Expected third argument to be a object"), c = { autoBom: !c }), c.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(u.type) ? new Blob(["\uFEFF", u], { type: u.type }) : u;
    }
    function r(u, c, d) {
      var h = new XMLHttpRequest();
      h.open("GET", u), h.responseType = "blob", h.onload = function() {
        l(h.response, c, d);
      }, h.onerror = function() {
        console.error("could not download file");
      }, h.send();
    }
    function i(u) {
      var c = new XMLHttpRequest();
      c.open("HEAD", u, !1);
      try {
        c.send();
      } catch {
      }
      return 200 <= c.status && 299 >= c.status;
    }
    function s(u) {
      try {
        u.dispatchEvent(new MouseEvent("click"));
      } catch {
        var c = document.createEvent("MouseEvents");
        c.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), u.dispatchEvent(c);
      }
    }
    var o = typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof gn == "object" && gn.global === gn ? gn : void 0, a = o.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), l = o.saveAs || (typeof window != "object" || window !== o ? function() {
    } : "download" in HTMLAnchorElement.prototype && !a ? function(u, c, d) {
      var h = o.URL || o.webkitURL, v = document.createElement("a");
      c = c || u.name || "download", v.download = c, v.rel = "noopener", typeof u == "string" ? (v.href = u, v.origin === location.origin ? s(v) : i(v.href) ? r(u, c, d) : s(v, v.target = "_blank")) : (v.href = h.createObjectURL(u), setTimeout(function() {
        h.revokeObjectURL(v.href);
      }, 4e4), setTimeout(function() {
        s(v);
      }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(u, c, d) {
      if (c = c || u.name || "download", typeof u != "string")
        navigator.msSaveOrOpenBlob(n(u, d), c);
      else if (i(u))
        r(u, c, d);
      else {
        var h = document.createElement("a");
        h.href = u, h.target = "_blank", setTimeout(function() {
          s(h);
        });
      }
    } : function(u, c, d, h) {
      if (h = h || open("", "_blank"), h && (h.document.title = h.document.body.innerText = "downloading..."), typeof u == "string")
        return r(u, c, d);
      var v = u.type === "application/octet-stream", y = /constructor/i.test(o.HTMLElement) || o.safari, b = /CriOS\/[\d]+/.test(navigator.userAgent);
      if ((b || v && y || a) && typeof FileReader < "u") {
        var p = new FileReader();
        p.onloadend = function() {
          var g = p.result;
          g = b ? g : g.replace(/^data:[^;]*;/, "data:attachment/file;"), h ? h.location.href = g : location = g, h = null;
        }, p.readAsDataURL(u);
      } else {
        var f = o.URL || o.webkitURL, m = f.createObjectURL(u);
        h ? h.location = m : location.href = m, h = null, setTimeout(function() {
          f.revokeObjectURL(m);
        }, 4e4);
      }
    });
    o.saveAs = l.saveAs = l, t.exports = l;
  });
})(KL);
const qL = xc, Ut = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, an = Object.keys, On = Array.isArray;
function Ln(t, e) {
  return typeof e != "object" || an(e).forEach(function(n) {
    t[n] = e[n];
  }), t;
}
typeof Promise > "u" || Ut.Promise || (Ut.Promise = Promise);
const Io = Object.getPrototypeOf, GL = {}.hasOwnProperty;
function Xn(t, e) {
  return GL.call(t, e);
}
function Ps(t, e) {
  typeof e == "function" && (e = e(Io(t))), (typeof Reflect > "u" ? an : Reflect.ownKeys)(e).forEach((n) => {
    qr(t, n, e[n]);
  });
}
const qg = Object.defineProperty;
function qr(t, e, n, r) {
  qg(t, e, Ln(n && Xn(n, "get") && typeof n.get == "function" ? { get: n.get, set: n.set, configurable: !0 } : { value: n, configurable: !0, writable: !0 }, r));
}
function _s(t) {
  return { from: function(e) {
    return t.prototype = Object.create(e.prototype), qr(t.prototype, "constructor", t), { extend: Ps.bind(null, t.prototype) };
  } };
}
const YL = Object.getOwnPropertyDescriptor;
function ef(t, e) {
  let n;
  return YL(t, e) || (n = Io(t)) && ef(n, e);
}
const XL = [].slice;
function fl(t, e, n) {
  return XL.call(t, e, n);
}
function Gg(t, e) {
  return e(t);
}
function ro(t) {
  if (!t)
    throw new Error("Assertion Failed");
}
function Yg(t) {
  Ut.setImmediate ? setImmediate(t) : setTimeout(t, 0);
}
function Xg(t, e) {
  return t.reduce((n, r, i) => {
    var s = e(r, i);
    return s && (n[s[0]] = s[1]), n;
  }, {});
}
function Gr(t, e) {
  if (Xn(t, e))
    return t[e];
  if (!e)
    return t;
  if (typeof e != "string") {
    for (var n = [], r = 0, i = e.length; r < i; ++r) {
      var s = Gr(t, e[r]);
      n.push(s);
    }
    return n;
  }
  var o = e.indexOf(".");
  if (o !== -1) {
    var a = t[e.substr(0, o)];
    return a === void 0 ? void 0 : Gr(a, e.substr(o + 1));
  }
}
function vr(t, e, n) {
  if (t && e !== void 0 && (!("isFrozen" in Object) || !Object.isFrozen(t)))
    if (typeof e != "string" && "length" in e) {
      ro(typeof n != "string" && "length" in n);
      for (var r = 0, i = e.length; r < i; ++r)
        vr(t, e[r], n[r]);
    } else {
      var s = e.indexOf(".");
      if (s !== -1) {
        var o = e.substr(0, s), a = e.substr(s + 1);
        if (a === "")
          n === void 0 ? On(t) && !isNaN(parseInt(o)) ? t.splice(o, 1) : delete t[o] : t[o] = n;
        else {
          var l = t[o];
          l && Xn(t, o) || (l = t[o] = {}), vr(l, a, n);
        }
      } else
        n === void 0 ? On(t) && !isNaN(parseInt(e)) ? t.splice(e, 1) : delete t[e] : t[e] = n;
    }
}
function Zg(t) {
  var e = {};
  for (var n in t)
    Xn(t, n) && (e[n] = t[n]);
  return e;
}
const ZL = [].concat;
function Qg(t) {
  return ZL.apply([], t);
}
const Jg = "Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(Qg([8, 16, 32, 64].map((t) => ["Int", "Uint", "Float"].map((e) => e + t + "Array")))).filter((t) => Ut[t]), QL = Jg.map((t) => Ut[t]);
Xg(Jg, (t) => [t, !0]);
let fi = null;
function na(t) {
  fi = typeof WeakMap < "u" && /* @__PURE__ */ new WeakMap();
  const e = Cc(t);
  return fi = null, e;
}
function Cc(t) {
  if (!t || typeof t != "object")
    return t;
  let e = fi && fi.get(t);
  if (e)
    return e;
  if (On(t)) {
    e = [], fi && fi.set(t, e);
    for (var n = 0, r = t.length; n < r; ++n)
      e.push(Cc(t[n]));
  } else if (QL.indexOf(t.constructor) >= 0)
    e = t;
  else {
    const s = Io(t);
    for (var i in e = s === Object.prototype ? {} : Object.create(s), fi && fi.set(t, e), t)
      Xn(t, i) && (e[i] = Cc(t[i]));
  }
  return e;
}
const { toString: JL } = {};
function kc(t) {
  return JL.call(t).slice(8, -1);
}
const Tc = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", e8 = typeof Tc == "symbol" ? function(t) {
  var e;
  return t != null && (e = t[Tc]) && e.apply(t);
} : function() {
  return null;
}, ps = {};
function Wr(t) {
  var e, n, r, i;
  if (arguments.length === 1) {
    if (On(t))
      return t.slice();
    if (this === ps && typeof t == "string")
      return [t];
    if (i = e8(t)) {
      for (n = []; !(r = i.next()).done; )
        n.push(r.value);
      return n;
    }
    if (t == null)
      return [t];
    if (typeof (e = t.length) == "number") {
      for (n = new Array(e); e--; )
        n[e] = t[e];
      return n;
    }
    return [t];
  }
  for (e = arguments.length, n = new Array(e); e--; )
    n[e] = arguments[e];
  return n;
}
const tf = typeof Symbol < "u" ? (t) => t[Symbol.toStringTag] === "AsyncFunction" : () => !1;
var Dr = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
function e0(t, e) {
  Dr = t, t0 = e;
}
var t0 = () => !0;
const t8 = !new Error("").stack;
function Qi() {
  if (t8)
    try {
      throw Qi.arguments, new Error();
    } catch (t) {
      return t;
    }
  return new Error();
}
function Oc(t, e) {
  var n = t.stack;
  return n ? (e = e || 0, n.indexOf(t.name) === 0 && (e += (t.name + t.message).split(`
`).length), n.split(`
`).slice(e).filter(t0).map((r) => `
` + r).join("")) : "";
}
var n0 = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], nf = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(n0), n8 = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
function Es(t, e) {
  this._e = Qi(), this.name = t, this.message = e;
}
function r0(t, e) {
  return t + ". Errors: " + Object.keys(e).map((n) => e[n].toString()).filter((n, r, i) => i.indexOf(n) === r).join(`
`);
}
function hl(t, e, n, r) {
  this._e = Qi(), this.failures = e, this.failedKeys = r, this.successCount = n, this.message = r0(t, e);
}
function ho(t, e) {
  this._e = Qi(), this.name = "BulkError", this.failures = Object.keys(e).map((n) => e[n]), this.failuresByPos = e, this.message = r0(t, e);
}
_s(Es).from(Error).extend({ stack: { get: function() {
  return this._stack || (this._stack = this.name + ": " + this.message + Oc(this._e, 2));
} }, toString: function() {
  return this.name + ": " + this.message;
} }), _s(hl).from(Es), _s(ho).from(Es);
var rf = nf.reduce((t, e) => (t[e] = e + "Error", t), {});
const r8 = Es;
var Je = nf.reduce((t, e) => {
  var n = e + "Error";
  function r(i, s) {
    this._e = Qi(), this.name = n, i ? typeof i == "string" ? (this.message = `${i}${s ? `
 ` + s : ""}`, this.inner = s || null) : typeof i == "object" && (this.message = `${i.name} ${i.message}`, this.inner = i) : (this.message = n8[e] || n, this.inner = null);
  }
  return _s(r).from(r8), t[e] = r, t;
}, {});
Je.Syntax = SyntaxError, Je.Type = TypeError, Je.Range = RangeError;
var bp = n0.reduce((t, e) => (t[e + "Error"] = Je[e], t), {}), Ha = nf.reduce((t, e) => (["Syntax", "Type", "Range"].indexOf(e) === -1 && (t[e + "Error"] = Je[e]), t), {});
function Bt() {
}
function Ro(t) {
  return t;
}
function i8(t, e) {
  return t == null || t === Ro ? e : function(n) {
    return e(t(n));
  };
}
function ji(t, e) {
  return function() {
    t.apply(this, arguments), e.apply(this, arguments);
  };
}
function s8(t, e) {
  return t === Bt ? e : function() {
    var n = t.apply(this, arguments);
    n !== void 0 && (arguments[0] = n);
    var r = this.onsuccess, i = this.onerror;
    this.onsuccess = null, this.onerror = null;
    var s = e.apply(this, arguments);
    return r && (this.onsuccess = this.onsuccess ? ji(r, this.onsuccess) : r), i && (this.onerror = this.onerror ? ji(i, this.onerror) : i), s !== void 0 ? s : n;
  };
}
function o8(t, e) {
  return t === Bt ? e : function() {
    t.apply(this, arguments);
    var n = this.onsuccess, r = this.onerror;
    this.onsuccess = this.onerror = null, e.apply(this, arguments), n && (this.onsuccess = this.onsuccess ? ji(n, this.onsuccess) : n), r && (this.onerror = this.onerror ? ji(r, this.onerror) : r);
  };
}
function a8(t, e) {
  return t === Bt ? e : function(n) {
    var r = t.apply(this, arguments);
    Ln(n, r);
    var i = this.onsuccess, s = this.onerror;
    this.onsuccess = null, this.onerror = null;
    var o = e.apply(this, arguments);
    return i && (this.onsuccess = this.onsuccess ? ji(i, this.onsuccess) : i), s && (this.onerror = this.onerror ? ji(s, this.onerror) : s), r === void 0 ? o === void 0 ? void 0 : o : Ln(r, o);
  };
}
function l8(t, e) {
  return t === Bt ? e : function() {
    return e.apply(this, arguments) !== !1 && t.apply(this, arguments);
  };
}
function sf(t, e) {
  return t === Bt ? e : function() {
    var n = t.apply(this, arguments);
    if (n && typeof n.then == "function") {
      for (var r = this, i = arguments.length, s = new Array(i); i--; )
        s[i] = arguments[i];
      return n.then(function() {
        return e.apply(r, s);
      });
    }
    return e.apply(this, arguments);
  };
}
Ha.ModifyError = hl, Ha.DexieError = Es, Ha.BulkError = ho;
var Lo = {};
const i0 = 100, [Nc, pl, Ac] = typeof Promise > "u" ? [] : (() => {
  let t = Promise.resolve();
  if (typeof crypto > "u" || !crypto.subtle)
    return [t, Io(t), t];
  const e = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
  return [e, Io(e), t];
})(), s0 = pl && pl.then, Ka = Nc && Nc.constructor, of = !!Ac;
var Ic = !1, u8 = Ac ? () => {
  Ac.then(xa);
} : Ut.setImmediate ? setImmediate.bind(null, xa) : Ut.MutationObserver ? () => {
  var t = document.createElement("div");
  new MutationObserver(() => {
    xa(), t = null;
  }).observe(t, { attributes: !0 }), t.setAttribute("i", "1");
} : () => {
  setTimeout(xa, 0);
}, po = function(t, e) {
  io.push([t, e]), vl && (u8(), vl = !1);
}, Rc = !0, vl = !0, $i = [], qa = [], Lc = null, Pc = Ro, Ss = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: Ep, pgp: !1, env: {}, finalize: function() {
  this.unhandleds.forEach((t) => {
    try {
      Ep(t[0], t[1]);
    } catch {
    }
  });
} }, Ke = Ss, io = [], Di = 0, Ga = [];
function Me(t) {
  if (typeof this != "object")
    throw new TypeError("Promises must be constructed via new");
  this._listeners = [], this.onuncatched = Bt, this._lib = !1;
  var e = this._PSD = Ke;
  if (Dr && (this._stackHolder = Qi(), this._prev = null, this._numPrev = 0), typeof t != "function") {
    if (t !== Lo)
      throw new TypeError("Not a function");
    return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && Dc(this, this._value));
  }
  this._state = null, this._value = null, ++e.ref, a0(this, t);
}
const $c = { get: function() {
  var t = Ke, e = ml;
  function n(r, i) {
    var s = !t.global && (t !== Ke || e !== ml);
    const o = s && !Jr();
    var a = new Me((l, u) => {
      af(this, new o0(gl(r, t, s, o), gl(i, t, s, o), l, u, t));
    });
    return Dr && c0(a, this), a;
  }
  return n.prototype = Lo, n;
}, set: function(t) {
  qr(this, "then", t && t.prototype === Lo ? $c : { get: function() {
    return t;
  }, set: $c.set });
} };
function o0(t, e, n, r, i) {
  this.onFulfilled = typeof t == "function" ? t : null, this.onRejected = typeof e == "function" ? e : null, this.resolve = n, this.reject = r, this.psd = i;
}
function a0(t, e) {
  try {
    e((n) => {
      if (t._state === null) {
        if (n === t)
          throw new TypeError("A promise cannot be resolved with itself.");
        var r = t._lib && ra();
        n && typeof n.then == "function" ? a0(t, (i, s) => {
          n instanceof Me ? n._then(i, s) : n.then(i, s);
        }) : (t._state = !0, t._value = n, l0(t)), r && ia();
      }
    }, Dc.bind(null, t));
  } catch (n) {
    Dc(t, n);
  }
}
function Dc(t, e) {
  if (qa.push(e), t._state === null) {
    var n = t._lib && ra();
    e = Pc(e), t._state = !1, t._value = e, Dr && e !== null && typeof e == "object" && !e._promise && function(r, i, s) {
      try {
        r.apply(null, s);
      } catch (o) {
        i && i(o);
      }
    }(() => {
      var r = ef(e, "stack");
      e._promise = t, qr(e, "stack", { get: () => Ic ? r && (r.get ? r.get.apply(e) : r.value) : t.stack });
    }), function(r) {
      $i.some((i) => i._value === r._value) || $i.push(r);
    }(t), l0(t), n && ia();
  }
}
function l0(t) {
  var e = t._listeners;
  t._listeners = [];
  for (var n = 0, r = e.length; n < r; ++n)
    af(t, e[n]);
  var i = t._PSD;
  --i.ref || i.finalize(), Di === 0 && (++Di, po(() => {
    --Di == 0 && lf();
  }, []));
}
function af(t, e) {
  if (t._state !== null) {
    var n = t._state ? e.onFulfilled : e.onRejected;
    if (n === null)
      return (t._state ? e.resolve : e.reject)(t._value);
    ++e.psd.ref, ++Di, po(c8, [n, t, e]);
  } else
    t._listeners.push(e);
}
function c8(t, e, n) {
  try {
    Lc = e;
    var r, i = e._value;
    e._state ? r = t(i) : (qa.length && (qa = []), r = t(i), qa.indexOf(i) === -1 && function(s) {
      for (var o = $i.length; o; )
        if ($i[--o]._value === s._value)
          return void $i.splice(o, 1);
    }(e)), n.resolve(r);
  } catch (s) {
    n.reject(s);
  } finally {
    Lc = null, --Di == 0 && lf(), --n.psd.ref || n.psd.finalize();
  }
}
function u0(t, e, n) {
  if (e.length === n)
    return e;
  var r = "";
  if (t._state === !1) {
    var i, s, o = t._value;
    o != null ? (i = o.name || "Error", s = o.message || o, r = Oc(o, 0)) : (i = o, s = ""), e.push(i + (s ? ": " + s : "") + r);
  }
  return Dr && ((r = Oc(t._stackHolder, 2)) && e.indexOf(r) === -1 && e.push(r), t._prev && u0(t._prev, e, n)), e;
}
function c0(t, e) {
  var n = e ? e._numPrev + 1 : 0;
  n < 100 && (t._prev = e, t._numPrev = n);
}
function xa() {
  ra() && ia();
}
function ra() {
  var t = Rc;
  return Rc = !1, vl = !1, t;
}
function ia() {
  var t, e, n;
  do
    for (; io.length > 0; )
      for (t = io, io = [], n = t.length, e = 0; e < n; ++e) {
        var r = t[e];
        r[0].apply(null, r[1]);
      }
  while (io.length > 0);
  Rc = !0, vl = !0;
}
function lf() {
  var t = $i;
  $i = [], t.forEach((r) => {
    r._PSD.onunhandled.call(null, r._value, r);
  });
  for (var e = Ga.slice(0), n = e.length; n; )
    e[--n]();
}
function Ca(t) {
  return new Me(Lo, !1, t);
}
function Ht(t, e) {
  var n = Ke;
  return function() {
    var r = ra(), i = Ke;
    try {
      return _i(n, !0), t.apply(this, arguments);
    } catch (s) {
      e && e(s);
    } finally {
      _i(i, !1), r && ia();
    }
  };
}
Ps(Me.prototype, { then: $c, _then: function(t, e) {
  af(this, new o0(null, null, t, e, Ke));
}, catch: function(t) {
  if (arguments.length === 1)
    return this.then(null, t);
  var e = arguments[0], n = arguments[1];
  return typeof e == "function" ? this.then(null, (r) => r instanceof e ? n(r) : Ca(r)) : this.then(null, (r) => r && r.name === e ? n(r) : Ca(r));
}, finally: function(t) {
  return this.then((e) => (t(), e), (e) => (t(), Ca(e)));
}, stack: { get: function() {
  if (this._stack)
    return this._stack;
  try {
    Ic = !0;
    var t = u0(this, [], 20).join(`
From previous: `);
    return this._state !== null && (this._stack = t), t;
  } finally {
    Ic = !1;
  }
} }, timeout: function(t, e) {
  return t < 1 / 0 ? new Me((n, r) => {
    var i = setTimeout(() => r(new Je.Timeout(e)), t);
    this.then(n, r).finally(clearTimeout.bind(null, i));
  }) : this;
} }), typeof Symbol < "u" && Symbol.toStringTag && qr(Me.prototype, Symbol.toStringTag, "Dexie.Promise"), Ss.env = d0(), Ps(Me, { all: function() {
  var t = Wr.apply(null, arguments).map(ka);
  return new Me(function(e, n) {
    t.length === 0 && e([]);
    var r = t.length;
    t.forEach((i, s) => Me.resolve(i).then((o) => {
      t[s] = o, --r || e(t);
    }, n));
  });
}, resolve: (t) => {
  if (t instanceof Me)
    return t;
  if (t && typeof t.then == "function")
    return new Me((n, r) => {
      t.then(n, r);
    });
  var e = new Me(Lo, !0, t);
  return c0(e, Lc), e;
}, reject: Ca, race: function() {
  var t = Wr.apply(null, arguments).map(ka);
  return new Me((e, n) => {
    t.map((r) => Me.resolve(r).then(e, n));
  });
}, PSD: { get: () => Ke, set: (t) => Ke = t }, totalEchoes: { get: () => ml }, newPSD: wi, usePSD: Vs, scheduler: { get: () => po, set: (t) => {
  po = t;
} }, rejectionMapper: { get: () => Pc, set: (t) => {
  Pc = t;
} }, follow: (t, e) => new Me((n, r) => wi((i, s) => {
  var o = Ke;
  o.unhandleds = [], o.onunhandled = s, o.finalize = ji(function() {
    (function(a) {
      function l() {
        a(), Ga.splice(Ga.indexOf(l), 1);
      }
      Ga.push(l), ++Di, po(() => {
        --Di == 0 && lf();
      }, []);
    })(() => {
      this.unhandleds.length === 0 ? i() : s(this.unhandleds[0]);
    });
  }, o.finalize), t();
}, e, n, r)) }), Ka && (Ka.allSettled && qr(Me, "allSettled", function() {
  const t = Wr.apply(null, arguments).map(ka);
  return new Me((e) => {
    t.length === 0 && e([]);
    let n = t.length;
    const r = new Array(n);
    t.forEach((i, s) => Me.resolve(i).then((o) => r[s] = { status: "fulfilled", value: o }, (o) => r[s] = { status: "rejected", reason: o }).then(() => --n || e(r)));
  });
}), Ka.any && typeof AggregateError < "u" && qr(Me, "any", function() {
  const t = Wr.apply(null, arguments).map(ka);
  return new Me((e, n) => {
    t.length === 0 && n(new AggregateError([]));
    let r = t.length;
    const i = new Array(r);
    t.forEach((s, o) => Me.resolve(s).then((a) => e(a), (a) => {
      i[o] = a, --r || n(new AggregateError(i));
    }));
  });
}));
const kn = { awaits: 0, echoes: 0, id: 0 };
var d8 = 0, Ya = [], Ou = 0, ml = 0, f8 = 0;
function wi(t, e, n, r) {
  var i = Ke, s = Object.create(i);
  s.parent = i, s.ref = 0, s.global = !1, s.id = ++f8;
  var o = Ss.env;
  s.env = of ? { Promise: Me, PromiseProp: { value: Me, configurable: !0, writable: !0 }, all: Me.all, race: Me.race, allSettled: Me.allSettled, any: Me.any, resolve: Me.resolve, reject: Me.reject, nthen: wp(o.nthen, s), gthen: wp(o.gthen, s) } : {}, e && Ln(s, e), ++i.ref, s.finalize = function() {
    --this.parent.ref || this.parent.finalize();
  };
  var a = Vs(s, t, n, r);
  return s.ref === 0 && s.finalize(), a;
}
function Us() {
  return kn.id || (kn.id = ++d8), ++kn.awaits, kn.echoes += i0, kn.id;
}
function Jr() {
  return !!kn.awaits && (--kn.awaits == 0 && (kn.id = 0), kn.echoes = kn.awaits * i0, !0);
}
function ka(t) {
  return kn.echoes && t && t.constructor === Ka ? (Us(), t.then((e) => (Jr(), e), (e) => (Jr(), dn(e)))) : t;
}
function h8(t) {
  ++ml, kn.echoes && --kn.echoes != 0 || (kn.echoes = kn.id = 0), Ya.push(Ke), _i(t, !0);
}
function p8() {
  var t = Ya[Ya.length - 1];
  Ya.pop(), _i(t, !1);
}
function _i(t, e) {
  var n = Ke;
  if ((e ? !kn.echoes || Ou++ && t === Ke : !Ou || --Ou && t === Ke) || f0(e ? h8.bind(null, t) : p8), t !== Ke && (Ke = t, n === Ss && (Ss.env = d0()), of)) {
    var r = Ss.env.Promise, i = t.env;
    pl.then = i.nthen, r.prototype.then = i.gthen, (n.global || t.global) && (Object.defineProperty(Ut, "Promise", i.PromiseProp), r.all = i.all, r.race = i.race, r.resolve = i.resolve, r.reject = i.reject, i.allSettled && (r.allSettled = i.allSettled), i.any && (r.any = i.any));
  }
}
function d0() {
  var t = Ut.Promise;
  return of ? { Promise: t, PromiseProp: Object.getOwnPropertyDescriptor(Ut, "Promise"), all: t.all, race: t.race, allSettled: t.allSettled, any: t.any, resolve: t.resolve, reject: t.reject, nthen: pl.then, gthen: t.prototype.then } : {};
}
function Vs(t, e, n, r, i) {
  var s = Ke;
  try {
    return _i(t, !0), e(n, r, i);
  } finally {
    _i(s, !1);
  }
}
function f0(t) {
  s0.call(Nc, t);
}
function gl(t, e, n, r) {
  return typeof t != "function" ? t : function() {
    var i = Ke;
    n && Us(), _i(e, !0);
    try {
      return t.apply(this, arguments);
    } finally {
      _i(i, !1), r && f0(Jr);
    }
  };
}
function wp(t, e) {
  return function(n, r) {
    return t.call(this, gl(n, e), gl(r, e));
  };
}
("" + s0).indexOf("[native code]") === -1 && (Us = Jr = Bt);
const _p = "unhandledrejection";
function Ep(t, e) {
  var n;
  try {
    n = e.onuncatched(t);
  } catch {
  }
  if (n !== !1)
    try {
      var r, i = { promise: e, reason: t };
      if (Ut.document && document.createEvent ? ((r = document.createEvent("Event")).initEvent(_p, !0, !0), Ln(r, i)) : Ut.CustomEvent && Ln(r = new CustomEvent(_p, { detail: i }), i), r && Ut.dispatchEvent && (dispatchEvent(r), !Ut.PromiseRejectionEvent && Ut.onunhandledrejection))
        try {
          Ut.onunhandledrejection(r);
        } catch {
        }
      Dr && r && !r.defaultPrevented && console.warn(`Unhandled rejection: ${t.stack || t}`);
    } catch {
    }
}
var dn = Me.reject;
function Bc(t, e, n, r) {
  if (t.idbdb && (t._state.openComplete || Ke.letThrough || t._vip)) {
    var i = t._createTransaction(e, n, t._dbSchema);
    try {
      i.create(), t._state.PR1398_maxLoop = 3;
    } catch (s) {
      return s.name === rf.InvalidState && t.isOpen() && --t._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), t._close(), t.open().then(() => Bc(t, e, n, r))) : dn(s);
    }
    return i._promise(e, (s, o) => wi(() => (Ke.trans = i, r(s, o, i)))).then((s) => i._completion.then(() => s));
  }
  if (t._state.openComplete)
    return dn(new Je.DatabaseClosed(t._state.dbOpenError));
  if (!t._state.isBeingOpened) {
    if (!t._options.autoOpen)
      return dn(new Je.DatabaseClosed());
    t.open().catch(Bt);
  }
  return t._state.dbReadyPromise.then(() => Bc(t, e, n, r));
}
const Sp = "3.2.4", Ri = String.fromCharCode(65535), Mc = -1 / 0, zr = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", h0 = "String expected.", vo = [], Jl = typeof navigator < "u" && /(MSIE|Trident|Edge)/.test(navigator.userAgent), v8 = Jl, m8 = Jl, p0 = (t) => !/(dexie\.js|dexie\.min\.js)/.test(t), eu = "__dbnames", Nu = "readonly", Au = "readwrite";
function Ui(t, e) {
  return t ? e ? function() {
    return t.apply(this, arguments) && e.apply(this, arguments);
  } : t : e;
}
const v0 = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
function Ta(t) {
  return typeof t != "string" || /\./.test(t) ? (e) => e : (e) => (e[t] === void 0 && t in e && delete (e = na(e))[t], e);
}
class g8 {
  _trans(e, n, r) {
    const i = this._tx || Ke.trans, s = this.name;
    function o(l, u, c) {
      if (!c.schema[s])
        throw new Je.NotFound("Table " + s + " not part of transaction");
      return n(c.idbtrans, c);
    }
    const a = ra();
    try {
      return i && i.db === this.db ? i === Ke.trans ? i._promise(e, o, r) : wi(() => i._promise(e, o, r), { trans: i, transless: Ke.transless || Ke }) : Bc(this.db, e, [this.name], o);
    } finally {
      a && ia();
    }
  }
  get(e, n) {
    return e && e.constructor === Object ? this.where(e).first(n) : this._trans("readonly", (r) => this.core.get({ trans: r, key: e }).then((i) => this.hook.reading.fire(i))).then(n);
  }
  where(e) {
    if (typeof e == "string")
      return new this.db.WhereClause(this, e);
    if (On(e))
      return new this.db.WhereClause(this, `[${e.join("+")}]`);
    const n = an(e);
    if (n.length === 1)
      return this.where(n[0]).equals(e[n[0]]);
    const r = this.schema.indexes.concat(this.schema.primKey).filter((u) => u.compound && n.every((c) => u.keyPath.indexOf(c) >= 0) && u.keyPath.every((c) => n.indexOf(c) >= 0))[0];
    if (r && this.db._maxKey !== Ri)
      return this.where(r.name).equals(r.keyPath.map((u) => e[u]));
    !r && Dr && console.warn(`The query ${JSON.stringify(e)} on ${this.name} would benefit of a compound index [${n.join("+")}]`);
    const { idxByName: i } = this.schema, s = this.db._deps.indexedDB;
    function o(u, c) {
      try {
        return s.cmp(u, c) === 0;
      } catch {
        return !1;
      }
    }
    const [a, l] = n.reduce(([u, c], d) => {
      const h = i[d], v = e[d];
      return [u || h, u || !h ? Ui(c, h && h.multi ? (y) => {
        const b = Gr(y, d);
        return On(b) && b.some((p) => o(v, p));
      } : (y) => o(v, Gr(y, d))) : c];
    }, [null, null]);
    return a ? this.where(a.name).equals(e[a.keyPath]).filter(l) : r ? this.filter(l) : this.where(n).equals("");
  }
  filter(e) {
    return this.toCollection().and(e);
  }
  count(e) {
    return this.toCollection().count(e);
  }
  offset(e) {
    return this.toCollection().offset(e);
  }
  limit(e) {
    return this.toCollection().limit(e);
  }
  each(e) {
    return this.toCollection().each(e);
  }
  toArray(e) {
    return this.toCollection().toArray(e);
  }
  toCollection() {
    return new this.db.Collection(new this.db.WhereClause(this));
  }
  orderBy(e) {
    return new this.db.Collection(new this.db.WhereClause(this, On(e) ? `[${e.join("+")}]` : e));
  }
  reverse() {
    return this.toCollection().reverse();
  }
  mapToClass(e) {
    this.schema.mappedClass = e;
    const n = (r) => {
      if (!r)
        return r;
      const i = Object.create(e.prototype);
      for (var s in r)
        if (Xn(r, s))
          try {
            i[s] = r[s];
          } catch {
          }
      return i;
    };
    return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = n, this.hook("reading", n), e;
  }
  defineClass() {
    return this.mapToClass(function(e) {
      Ln(this, e);
    });
  }
  add(e, n) {
    const { auto: r, keyPath: i } = this.schema.primKey;
    let s = e;
    return i && r && (s = Ta(i)(e)), this._trans("readwrite", (o) => this.core.mutate({ trans: o, type: "add", keys: n != null ? [n] : null, values: [s] })).then((o) => o.numFailures ? Me.reject(o.failures[0]) : o.lastResult).then((o) => {
      if (i)
        try {
          vr(e, i, o);
        } catch {
        }
      return o;
    });
  }
  update(e, n) {
    if (typeof e != "object" || On(e))
      return this.where(":id").equals(e).modify(n);
    {
      const r = Gr(e, this.schema.primKey.keyPath);
      if (r === void 0)
        return dn(new Je.InvalidArgument("Given object does not contain its primary key"));
      try {
        typeof n != "function" ? an(n).forEach((i) => {
          vr(e, i, n[i]);
        }) : n(e, { value: e, primKey: r });
      } catch {
      }
      return this.where(":id").equals(r).modify(n);
    }
  }
  put(e, n) {
    const { auto: r, keyPath: i } = this.schema.primKey;
    let s = e;
    return i && r && (s = Ta(i)(e)), this._trans("readwrite", (o) => this.core.mutate({ trans: o, type: "put", values: [s], keys: n != null ? [n] : null })).then((o) => o.numFailures ? Me.reject(o.failures[0]) : o.lastResult).then((o) => {
      if (i)
        try {
          vr(e, i, o);
        } catch {
        }
      return o;
    });
  }
  delete(e) {
    return this._trans("readwrite", (n) => this.core.mutate({ trans: n, type: "delete", keys: [e] })).then((n) => n.numFailures ? Me.reject(n.failures[0]) : void 0);
  }
  clear() {
    return this._trans("readwrite", (e) => this.core.mutate({ trans: e, type: "deleteRange", range: v0 })).then((e) => e.numFailures ? Me.reject(e.failures[0]) : void 0);
  }
  bulkGet(e) {
    return this._trans("readonly", (n) => this.core.getMany({ keys: e, trans: n }).then((r) => r.map((i) => this.hook.reading.fire(i))));
  }
  bulkAdd(e, n, r) {
    const i = Array.isArray(n) ? n : void 0, s = (r = r || (i ? void 0 : n)) ? r.allKeys : void 0;
    return this._trans("readwrite", (o) => {
      const { auto: a, keyPath: l } = this.schema.primKey;
      if (l && i)
        throw new Je.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
      if (i && i.length !== e.length)
        throw new Je.InvalidArgument("Arguments objects and keys must have the same length");
      const u = e.length;
      let c = l && a ? e.map(Ta(l)) : e;
      return this.core.mutate({ trans: o, type: "add", keys: i, values: c, wantResults: s }).then(({ numFailures: d, results: h, lastResult: v, failures: y }) => {
        if (d === 0)
          return s ? h : v;
        throw new ho(`${this.name}.bulkAdd(): ${d} of ${u} operations failed`, y);
      });
    });
  }
  bulkPut(e, n, r) {
    const i = Array.isArray(n) ? n : void 0, s = (r = r || (i ? void 0 : n)) ? r.allKeys : void 0;
    return this._trans("readwrite", (o) => {
      const { auto: a, keyPath: l } = this.schema.primKey;
      if (l && i)
        throw new Je.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
      if (i && i.length !== e.length)
        throw new Je.InvalidArgument("Arguments objects and keys must have the same length");
      const u = e.length;
      let c = l && a ? e.map(Ta(l)) : e;
      return this.core.mutate({ trans: o, type: "put", keys: i, values: c, wantResults: s }).then(({ numFailures: d, results: h, lastResult: v, failures: y }) => {
        if (d === 0)
          return s ? h : v;
        throw new ho(`${this.name}.bulkPut(): ${d} of ${u} operations failed`, y);
      });
    });
  }
  bulkDelete(e) {
    const n = e.length;
    return this._trans("readwrite", (r) => this.core.mutate({ trans: r, type: "delete", keys: e })).then(({ numFailures: r, lastResult: i, failures: s }) => {
      if (r === 0)
        return i;
      throw new ho(`${this.name}.bulkDelete(): ${r} of ${n} operations failed`, s);
    });
  }
}
function mo(t) {
  var e = {}, n = function(o, a) {
    if (a) {
      for (var l = arguments.length, u = new Array(l - 1); --l; )
        u[l - 1] = arguments[l];
      return e[o].subscribe.apply(null, u), t;
    }
    if (typeof o == "string")
      return e[o];
  };
  n.addEventType = s;
  for (var r = 1, i = arguments.length; r < i; ++r)
    s(arguments[r]);
  return n;
  function s(o, a, l) {
    if (typeof o != "object") {
      var u;
      a || (a = l8), l || (l = Bt);
      var c = { subscribers: [], fire: l, subscribe: function(d) {
        c.subscribers.indexOf(d) === -1 && (c.subscribers.push(d), c.fire = a(c.fire, d));
      }, unsubscribe: function(d) {
        c.subscribers = c.subscribers.filter(function(h) {
          return h !== d;
        }), c.fire = c.subscribers.reduce(a, l);
      } };
      return e[o] = n[o] = c, c;
    }
    an(u = o).forEach(function(d) {
      var h = u[d];
      if (On(h))
        s(d, u[d][0], u[d][1]);
      else {
        if (h !== "asap")
          throw new Je.InvalidArgument("Invalid event config");
        var v = s(d, Ro, function() {
          for (var y = arguments.length, b = new Array(y); y--; )
            b[y] = arguments[y];
          v.subscribers.forEach(function(p) {
            Yg(function() {
              p.apply(null, b);
            });
          });
        });
      }
    });
  }
}
function Zs(t, e) {
  return _s(e).from({ prototype: t }), e;
}
function is(t, e) {
  return !(t.filter || t.algorithm || t.or) && (e ? t.justLimit : !t.replayFilter);
}
function Iu(t, e) {
  t.filter = Ui(t.filter, e);
}
function Ru(t, e, n) {
  var r = t.replayFilter;
  t.replayFilter = r ? () => Ui(r(), e()) : e, t.justLimit = n && !r;
}
function Xa(t, e) {
  if (t.isPrimKey)
    return e.primaryKey;
  const n = e.getIndexByKeyPath(t.index);
  if (!n)
    throw new Je.Schema("KeyPath " + t.index + " on object store " + e.name + " is not indexed");
  return n;
}
function xp(t, e, n) {
  const r = Xa(t, e.schema);
  return e.openCursor({ trans: n, values: !t.keysOnly, reverse: t.dir === "prev", unique: !!t.unique, query: { index: r, range: t.range } });
}
function Oa(t, e, n, r) {
  const i = t.replayFilter ? Ui(t.filter, t.replayFilter()) : t.filter;
  if (t.or) {
    const s = {}, o = (a, l, u) => {
      if (!i || i(l, u, (h) => l.stop(h), (h) => l.fail(h))) {
        var c = l.primaryKey, d = "" + c;
        d === "[object ArrayBuffer]" && (d = "" + new Uint8Array(c)), Xn(s, d) || (s[d] = !0, e(a, l, u));
      }
    };
    return Promise.all([t.or._iterate(o, n), Cp(xp(t, r, n), t.algorithm, o, !t.keysOnly && t.valueMapper)]);
  }
  return Cp(xp(t, r, n), Ui(t.algorithm, i), e, !t.keysOnly && t.valueMapper);
}
function Cp(t, e, n, r) {
  var i = Ht(r ? (s, o, a) => n(r(s), o, a) : n);
  return t.then((s) => {
    if (s)
      return s.start(() => {
        var o = () => s.continue();
        e && !e(s, (a) => o = a, (a) => {
          s.stop(a), o = Bt;
        }, (a) => {
          s.fail(a), o = Bt;
        }) || i(s.value, s, (a) => o = a), o();
      });
  });
}
function An(t, e) {
  try {
    const n = kp(t), r = kp(e);
    if (n !== r)
      return n === "Array" ? 1 : r === "Array" ? -1 : n === "binary" ? 1 : r === "binary" ? -1 : n === "string" ? 1 : r === "string" ? -1 : n === "Date" ? 1 : r !== "Date" ? NaN : -1;
    switch (n) {
      case "number":
      case "Date":
      case "string":
        return t > e ? 1 : t < e ? -1 : 0;
      case "binary":
        return function(i, s) {
          const o = i.length, a = s.length, l = o < a ? o : a;
          for (let u = 0; u < l; ++u)
            if (i[u] !== s[u])
              return i[u] < s[u] ? -1 : 1;
          return o === a ? 0 : o < a ? -1 : 1;
        }(Tp(t), Tp(e));
      case "Array":
        return function(i, s) {
          const o = i.length, a = s.length, l = o < a ? o : a;
          for (let u = 0; u < l; ++u) {
            const c = An(i[u], s[u]);
            if (c !== 0)
              return c;
          }
          return o === a ? 0 : o < a ? -1 : 1;
        }(t, e);
    }
  } catch {
  }
  return NaN;
}
function kp(t) {
  const e = typeof t;
  if (e !== "object")
    return e;
  if (ArrayBuffer.isView(t))
    return "binary";
  const n = kc(t);
  return n === "ArrayBuffer" ? "binary" : n;
}
function Tp(t) {
  return t instanceof Uint8Array ? t : ArrayBuffer.isView(t) ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : new Uint8Array(t);
}
class y8 {
  _read(e, n) {
    var r = this._ctx;
    return r.error ? r.table._trans(null, dn.bind(null, r.error)) : r.table._trans("readonly", e).then(n);
  }
  _write(e) {
    var n = this._ctx;
    return n.error ? n.table._trans(null, dn.bind(null, n.error)) : n.table._trans("readwrite", e, "locked");
  }
  _addAlgorithm(e) {
    var n = this._ctx;
    n.algorithm = Ui(n.algorithm, e);
  }
  _iterate(e, n) {
    return Oa(this._ctx, e, n, this._ctx.table.core);
  }
  clone(e) {
    var n = Object.create(this.constructor.prototype), r = Object.create(this._ctx);
    return e && Ln(r, e), n._ctx = r, n;
  }
  raw() {
    return this._ctx.valueMapper = null, this;
  }
  each(e) {
    var n = this._ctx;
    return this._read((r) => Oa(n, e, r, n.table.core));
  }
  count(e) {
    return this._read((n) => {
      const r = this._ctx, i = r.table.core;
      if (is(r, !0))
        return i.count({ trans: n, query: { index: Xa(r, i.schema), range: r.range } }).then((o) => Math.min(o, r.limit));
      var s = 0;
      return Oa(r, () => (++s, !1), n, i).then(() => s);
    }).then(e);
  }
  sortBy(e, n) {
    const r = e.split(".").reverse(), i = r[0], s = r.length - 1;
    function o(u, c) {
      return c ? o(u[r[c]], c - 1) : u[i];
    }
    var a = this._ctx.dir === "next" ? 1 : -1;
    function l(u, c) {
      var d = o(u, s), h = o(c, s);
      return d < h ? -a : d > h ? a : 0;
    }
    return this.toArray(function(u) {
      return u.sort(l);
    }).then(n);
  }
  toArray(e) {
    return this._read((n) => {
      var r = this._ctx;
      if (r.dir === "next" && is(r, !0) && r.limit > 0) {
        const { valueMapper: i } = r, s = Xa(r, r.table.core.schema);
        return r.table.core.query({ trans: n, limit: r.limit, values: !0, query: { index: s, range: r.range } }).then(({ result: o }) => i ? o.map(i) : o);
      }
      {
        const i = [];
        return Oa(r, (s) => i.push(s), n, r.table.core).then(() => i);
      }
    }, e);
  }
  offset(e) {
    var n = this._ctx;
    return e <= 0 || (n.offset += e, is(n) ? Ru(n, () => {
      var r = e;
      return (i, s) => r === 0 || (r === 1 ? (--r, !1) : (s(() => {
        i.advance(r), r = 0;
      }), !1));
    }) : Ru(n, () => {
      var r = e;
      return () => --r < 0;
    })), this;
  }
  limit(e) {
    return this._ctx.limit = Math.min(this._ctx.limit, e), Ru(this._ctx, () => {
      var n = e;
      return function(r, i, s) {
        return --n <= 0 && i(s), n >= 0;
      };
    }, !0), this;
  }
  until(e, n) {
    return Iu(this._ctx, function(r, i, s) {
      return !e(r.value) || (i(s), n);
    }), this;
  }
  first(e) {
    return this.limit(1).toArray(function(n) {
      return n[0];
    }).then(e);
  }
  last(e) {
    return this.reverse().first(e);
  }
  filter(e) {
    var n, r;
    return Iu(this._ctx, function(i) {
      return e(i.value);
    }), n = this._ctx, r = e, n.isMatch = Ui(n.isMatch, r), this;
  }
  and(e) {
    return this.filter(e);
  }
  or(e) {
    return new this.db.WhereClause(this._ctx.table, e, this);
  }
  reverse() {
    return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
  }
  desc() {
    return this.reverse();
  }
  eachKey(e) {
    var n = this._ctx;
    return n.keysOnly = !n.isMatch, this.each(function(r, i) {
      e(i.key, i);
    });
  }
  eachUniqueKey(e) {
    return this._ctx.unique = "unique", this.eachKey(e);
  }
  eachPrimaryKey(e) {
    var n = this._ctx;
    return n.keysOnly = !n.isMatch, this.each(function(r, i) {
      e(i.primaryKey, i);
    });
  }
  keys(e) {
    var n = this._ctx;
    n.keysOnly = !n.isMatch;
    var r = [];
    return this.each(function(i, s) {
      r.push(s.key);
    }).then(function() {
      return r;
    }).then(e);
  }
  primaryKeys(e) {
    var n = this._ctx;
    if (n.dir === "next" && is(n, !0) && n.limit > 0)
      return this._read((i) => {
        var s = Xa(n, n.table.core.schema);
        return n.table.core.query({ trans: i, values: !1, limit: n.limit, query: { index: s, range: n.range } });
      }).then(({ result: i }) => i).then(e);
    n.keysOnly = !n.isMatch;
    var r = [];
    return this.each(function(i, s) {
      r.push(s.primaryKey);
    }).then(function() {
      return r;
    }).then(e);
  }
  uniqueKeys(e) {
    return this._ctx.unique = "unique", this.keys(e);
  }
  firstKey(e) {
    return this.limit(1).keys(function(n) {
      return n[0];
    }).then(e);
  }
  lastKey(e) {
    return this.reverse().firstKey(e);
  }
  distinct() {
    var e = this._ctx, n = e.index && e.table.schema.idxByName[e.index];
    if (!n || !n.multi)
      return this;
    var r = {};
    return Iu(this._ctx, function(i) {
      var s = i.primaryKey.toString(), o = Xn(r, s);
      return r[s] = !0, !o;
    }), this;
  }
  modify(e) {
    var n = this._ctx;
    return this._write((r) => {
      var i;
      if (typeof e == "function")
        i = e;
      else {
        var s = an(e), o = s.length;
        i = function(b) {
          for (var p = !1, f = 0; f < o; ++f) {
            var m = s[f], g = e[m];
            Gr(b, m) !== g && (vr(b, m, g), p = !0);
          }
          return p;
        };
      }
      const a = n.table.core, { outbound: l, extractKey: u } = a.schema.primaryKey, c = this.db._options.modifyChunkSize || 200, d = [];
      let h = 0;
      const v = [], y = (b, p) => {
        const { failures: f, numFailures: m } = p;
        h += b - m;
        for (let g of an(f))
          d.push(f[g]);
      };
      return this.clone().primaryKeys().then((b) => {
        const p = (f) => {
          const m = Math.min(c, b.length - f);
          return a.getMany({ trans: r, keys: b.slice(f, f + m), cache: "immutable" }).then((g) => {
            const w = [], _ = [], E = l ? [] : null, C = [];
            for (let k = 0; k < m; ++k) {
              const N = g[k], I = { value: na(N), primKey: b[f + k] };
              i.call(I, I.value, I) !== !1 && (I.value == null ? C.push(b[f + k]) : l || An(u(N), u(I.value)) === 0 ? (_.push(I.value), l && E.push(b[f + k])) : (C.push(b[f + k]), w.push(I.value)));
            }
            const T = is(n) && n.limit === 1 / 0 && (typeof e != "function" || e === Lu) && { index: n.index, range: n.range };
            return Promise.resolve(w.length > 0 && a.mutate({ trans: r, type: "add", values: w }).then((k) => {
              for (let N in k.failures)
                C.splice(parseInt(N), 1);
              y(w.length, k);
            })).then(() => (_.length > 0 || T && typeof e == "object") && a.mutate({ trans: r, type: "put", keys: E, values: _, criteria: T, changeSpec: typeof e != "function" && e }).then((k) => y(_.length, k))).then(() => (C.length > 0 || T && e === Lu) && a.mutate({ trans: r, type: "delete", keys: C, criteria: T }).then((k) => y(C.length, k))).then(() => b.length > f + m && p(f + c));
          });
        };
        return p(0).then(() => {
          if (d.length > 0)
            throw new hl("Error modifying one or more objects", d, h, v);
          return b.length;
        });
      });
    });
  }
  delete() {
    var e = this._ctx, n = e.range;
    return is(e) && (e.isPrimKey && !m8 || n.type === 3) ? this._write((r) => {
      const { primaryKey: i } = e.table.core.schema, s = n;
      return e.table.core.count({ trans: r, query: { index: i, range: s } }).then((o) => e.table.core.mutate({ trans: r, type: "deleteRange", range: s }).then(({ failures: a, lastResult: l, results: u, numFailures: c }) => {
        if (c)
          throw new hl("Could not delete some values", Object.keys(a).map((d) => a[d]), o - c);
        return o - c;
      }));
    }) : this.modify(Lu);
  }
}
const Lu = (t, e) => e.value = null;
function b8(t, e) {
  return t < e ? -1 : t === e ? 0 : 1;
}
function w8(t, e) {
  return t > e ? -1 : t === e ? 0 : 1;
}
function Hn(t, e, n) {
  var r = t instanceof g0 ? new t.Collection(t) : t;
  return r._ctx.error = n ? new n(e) : new TypeError(e), r;
}
function ss(t) {
  return new t.Collection(t, () => m0("")).limit(0);
}
function _8(t, e, n, r, i, s) {
  for (var o = Math.min(t.length, r.length), a = -1, l = 0; l < o; ++l) {
    var u = e[l];
    if (u !== r[l])
      return i(t[l], n[l]) < 0 ? t.substr(0, l) + n[l] + n.substr(l + 1) : i(t[l], r[l]) < 0 ? t.substr(0, l) + r[l] + n.substr(l + 1) : a >= 0 ? t.substr(0, a) + e[a] + n.substr(a + 1) : null;
    i(t[l], u) < 0 && (a = l);
  }
  return o < r.length && s === "next" ? t + n.substr(t.length) : o < t.length && s === "prev" ? t.substr(0, n.length) : a < 0 ? null : t.substr(0, a) + r[a] + n.substr(a + 1);
}
function Na(t, e, n, r) {
  var i, s, o, a, l, u, c, d = n.length;
  if (!n.every((b) => typeof b == "string"))
    return Hn(t, h0);
  function h(b) {
    i = function(f) {
      return f === "next" ? (m) => m.toUpperCase() : (m) => m.toLowerCase();
    }(b), s = function(f) {
      return f === "next" ? (m) => m.toLowerCase() : (m) => m.toUpperCase();
    }(b), o = b === "next" ? b8 : w8;
    var p = n.map(function(f) {
      return { lower: s(f), upper: i(f) };
    }).sort(function(f, m) {
      return o(f.lower, m.lower);
    });
    a = p.map(function(f) {
      return f.upper;
    }), l = p.map(function(f) {
      return f.lower;
    }), u = b, c = b === "next" ? "" : r;
  }
  h("next");
  var v = new t.Collection(t, () => di(a[0], l[d - 1] + r));
  v._ondirectionchange = function(b) {
    h(b);
  };
  var y = 0;
  return v._addAlgorithm(function(b, p, f) {
    var m = b.key;
    if (typeof m != "string")
      return !1;
    var g = s(m);
    if (e(g, l, y))
      return !0;
    for (var w = null, _ = y; _ < d; ++_) {
      var E = _8(m, g, a[_], l[_], o, u);
      E === null && w === null ? y = _ + 1 : (w === null || o(w, E) > 0) && (w = E);
    }
    return p(w !== null ? function() {
      b.continue(w + c);
    } : f), !1;
  }), v;
}
function di(t, e, n, r) {
  return { type: 2, lower: t, upper: e, lowerOpen: n, upperOpen: r };
}
function m0(t) {
  return { type: 1, lower: t, upper: t };
}
class g0 {
  get Collection() {
    return this._ctx.table.db.Collection;
  }
  between(e, n, r, i) {
    r = r !== !1, i = i === !0;
    try {
      return this._cmp(e, n) > 0 || this._cmp(e, n) === 0 && (r || i) && (!r || !i) ? ss(this) : new this.Collection(this, () => di(e, n, !r, !i));
    } catch {
      return Hn(this, zr);
    }
  }
  equals(e) {
    return e == null ? Hn(this, zr) : new this.Collection(this, () => m0(e));
  }
  above(e) {
    return e == null ? Hn(this, zr) : new this.Collection(this, () => di(e, void 0, !0));
  }
  aboveOrEqual(e) {
    return e == null ? Hn(this, zr) : new this.Collection(this, () => di(e, void 0, !1));
  }
  below(e) {
    return e == null ? Hn(this, zr) : new this.Collection(this, () => di(void 0, e, !1, !0));
  }
  belowOrEqual(e) {
    return e == null ? Hn(this, zr) : new this.Collection(this, () => di(void 0, e));
  }
  startsWith(e) {
    return typeof e != "string" ? Hn(this, h0) : this.between(e, e + Ri, !0, !0);
  }
  startsWithIgnoreCase(e) {
    return e === "" ? this.startsWith(e) : Na(this, (n, r) => n.indexOf(r[0]) === 0, [e], Ri);
  }
  equalsIgnoreCase(e) {
    return Na(this, (n, r) => n === r[0], [e], "");
  }
  anyOfIgnoreCase() {
    var e = Wr.apply(ps, arguments);
    return e.length === 0 ? ss(this) : Na(this, (n, r) => r.indexOf(n) !== -1, e, "");
  }
  startsWithAnyOfIgnoreCase() {
    var e = Wr.apply(ps, arguments);
    return e.length === 0 ? ss(this) : Na(this, (n, r) => r.some((i) => n.indexOf(i) === 0), e, Ri);
  }
  anyOf() {
    const e = Wr.apply(ps, arguments);
    let n = this._cmp;
    try {
      e.sort(n);
    } catch {
      return Hn(this, zr);
    }
    if (e.length === 0)
      return ss(this);
    const r = new this.Collection(this, () => di(e[0], e[e.length - 1]));
    r._ondirectionchange = (s) => {
      n = s === "next" ? this._ascending : this._descending, e.sort(n);
    };
    let i = 0;
    return r._addAlgorithm((s, o, a) => {
      const l = s.key;
      for (; n(l, e[i]) > 0; )
        if (++i, i === e.length)
          return o(a), !1;
      return n(l, e[i]) === 0 || (o(() => {
        s.continue(e[i]);
      }), !1);
    }), r;
  }
  notEqual(e) {
    return this.inAnyRange([[Mc, e], [e, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
  }
  noneOf() {
    const e = Wr.apply(ps, arguments);
    if (e.length === 0)
      return new this.Collection(this);
    try {
      e.sort(this._ascending);
    } catch {
      return Hn(this, zr);
    }
    const n = e.reduce((r, i) => r ? r.concat([[r[r.length - 1][1], i]]) : [[Mc, i]], null);
    return n.push([e[e.length - 1], this.db._maxKey]), this.inAnyRange(n, { includeLowers: !1, includeUppers: !1 });
  }
  inAnyRange(e, n) {
    const r = this._cmp, i = this._ascending, s = this._descending, o = this._min, a = this._max;
    if (e.length === 0)
      return ss(this);
    if (!e.every((m) => m[0] !== void 0 && m[1] !== void 0 && i(m[0], m[1]) <= 0))
      return Hn(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", Je.InvalidArgument);
    const l = !n || n.includeLowers !== !1, u = n && n.includeUppers === !0;
    let c, d = i;
    function h(m, g) {
      return d(m[0], g[0]);
    }
    try {
      c = e.reduce(function(m, g) {
        let w = 0, _ = m.length;
        for (; w < _; ++w) {
          const E = m[w];
          if (r(g[0], E[1]) < 0 && r(g[1], E[0]) > 0) {
            E[0] = o(E[0], g[0]), E[1] = a(E[1], g[1]);
            break;
          }
        }
        return w === _ && m.push(g), m;
      }, []), c.sort(h);
    } catch {
      return Hn(this, zr);
    }
    let v = 0;
    const y = u ? (m) => i(m, c[v][1]) > 0 : (m) => i(m, c[v][1]) >= 0, b = l ? (m) => s(m, c[v][0]) > 0 : (m) => s(m, c[v][0]) >= 0;
    let p = y;
    const f = new this.Collection(this, () => di(c[0][0], c[c.length - 1][1], !l, !u));
    return f._ondirectionchange = (m) => {
      m === "next" ? (p = y, d = i) : (p = b, d = s), c.sort(h);
    }, f._addAlgorithm((m, g, w) => {
      for (var _ = m.key; p(_); )
        if (++v, v === c.length)
          return g(w), !1;
      return !!function(E) {
        return !y(E) && !b(E);
      }(_) || (this._cmp(_, c[v][1]) === 0 || this._cmp(_, c[v][0]) === 0 || g(() => {
        d === i ? m.continue(c[v][0]) : m.continue(c[v][1]);
      }), !1);
    }), f;
  }
  startsWithAnyOf() {
    const e = Wr.apply(ps, arguments);
    return e.every((n) => typeof n == "string") ? e.length === 0 ? ss(this) : this.inAnyRange(e.map((n) => [n, n + Ri])) : Hn(this, "startsWithAnyOf() only works with strings");
  }
}
function _r(t) {
  return Ht(function(e) {
    return Po(e), t(e.target.error), !1;
  });
}
function Po(t) {
  t.stopPropagation && t.stopPropagation(), t.preventDefault && t.preventDefault();
}
const $o = "storagemutated", hi = "x-storagemutated-1", Ei = mo(null, $o);
class E8 {
  _lock() {
    return ro(!Ke.global), ++this._reculock, this._reculock !== 1 || Ke.global || (Ke.lockOwnerFor = this), this;
  }
  _unlock() {
    if (ro(!Ke.global), --this._reculock == 0)
      for (Ke.global || (Ke.lockOwnerFor = null); this._blockedFuncs.length > 0 && !this._locked(); ) {
        var e = this._blockedFuncs.shift();
        try {
          Vs(e[1], e[0]);
        } catch {
        }
      }
    return this;
  }
  _locked() {
    return this._reculock && Ke.lockOwnerFor !== this;
  }
  create(e) {
    if (!this.mode)
      return this;
    const n = this.db.idbdb, r = this.db._state.dbOpenError;
    if (ro(!this.idbtrans), !e && !n)
      switch (r && r.name) {
        case "DatabaseClosedError":
          throw new Je.DatabaseClosed(r);
        case "MissingAPIError":
          throw new Je.MissingAPI(r.message, r);
        default:
          throw new Je.OpenFailed(r);
      }
    if (!this.active)
      throw new Je.TransactionInactive();
    return ro(this._completion._state === null), (e = this.idbtrans = e || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : n.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }))).onerror = Ht((i) => {
      Po(i), this._reject(e.error);
    }), e.onabort = Ht((i) => {
      Po(i), this.active && this._reject(new Je.Abort(e.error)), this.active = !1, this.on("abort").fire(i);
    }), e.oncomplete = Ht(() => {
      this.active = !1, this._resolve(), "mutatedParts" in e && Ei.storagemutated.fire(e.mutatedParts);
    }), this;
  }
  _promise(e, n, r) {
    if (e === "readwrite" && this.mode !== "readwrite")
      return dn(new Je.ReadOnly("Transaction is readonly"));
    if (!this.active)
      return dn(new Je.TransactionInactive());
    if (this._locked())
      return new Me((s, o) => {
        this._blockedFuncs.push([() => {
          this._promise(e, n, r).then(s, o);
        }, Ke]);
      });
    if (r)
      return wi(() => {
        var s = new Me((o, a) => {
          this._lock();
          const l = n(o, a, this);
          l && l.then && l.then(o, a);
        });
        return s.finally(() => this._unlock()), s._lib = !0, s;
      });
    var i = new Me((s, o) => {
      var a = n(s, o, this);
      a && a.then && a.then(s, o);
    });
    return i._lib = !0, i;
  }
  _root() {
    return this.parent ? this.parent._root() : this;
  }
  waitFor(e) {
    var n = this._root();
    const r = Me.resolve(e);
    if (n._waitingFor)
      n._waitingFor = n._waitingFor.then(() => r);
    else {
      n._waitingFor = r, n._waitingQueue = [];
      var i = n.idbtrans.objectStore(n.storeNames[0]);
      (function o() {
        for (++n._spinCount; n._waitingQueue.length; )
          n._waitingQueue.shift()();
        n._waitingFor && (i.get(-1 / 0).onsuccess = o);
      })();
    }
    var s = n._waitingFor;
    return new Me((o, a) => {
      r.then((l) => n._waitingQueue.push(Ht(o.bind(null, l))), (l) => n._waitingQueue.push(Ht(a.bind(null, l)))).finally(() => {
        n._waitingFor === s && (n._waitingFor = null);
      });
    });
  }
  abort() {
    this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new Je.Abort()));
  }
  table(e) {
    const n = this._memoizedTables || (this._memoizedTables = {});
    if (Xn(n, e))
      return n[e];
    const r = this.schema[e];
    if (!r)
      throw new Je.NotFound("Table " + e + " not part of transaction");
    const i = new this.db.Table(e, r, this);
    return i.core = this.db.core.table(e), n[e] = i, i;
  }
}
function zc(t, e, n, r, i, s, o) {
  return { name: t, keyPath: e, unique: n, multi: r, auto: i, compound: s, src: (n && !o ? "&" : "") + (r ? "*" : "") + (i ? "++" : "") + y0(e) };
}
function y0(t) {
  return typeof t == "string" ? t : t ? "[" + [].join.call(t, "+") + "]" : "";
}
function b0(t, e, n) {
  return { name: t, primKey: e, indexes: n, mappedClass: null, idxByName: Xg(n, (r) => [r.name, r]) };
}
let Do = (t) => {
  try {
    return t.only([[]]), Do = () => [[]], [[]];
  } catch {
    return Do = () => Ri, Ri;
  }
};
function Fc(t) {
  return t == null ? () => {
  } : typeof t == "string" ? function(e) {
    return e.split(".").length === 1 ? (r) => r[e] : (r) => Gr(r, e);
  }(t) : (e) => Gr(e, t);
}
function Op(t) {
  return [].slice.call(t);
}
let S8 = 0;
function go(t) {
  return t == null ? ":id" : typeof t == "string" ? t : `[${t.join("+")}]`;
}
function x8(t, e, n) {
  function r(l) {
    if (l.type === 3)
      return null;
    if (l.type === 4)
      throw new Error("Cannot convert never type to IDBKeyRange");
    const { lower: u, upper: c, lowerOpen: d, upperOpen: h } = l;
    return u === void 0 ? c === void 0 ? null : e.upperBound(c, !!h) : c === void 0 ? e.lowerBound(u, !!d) : e.bound(u, c, !!d, !!h);
  }
  const { schema: i, hasGetAll: s } = function(l, u) {
    const c = Op(l.objectStoreNames);
    return { schema: { name: l.name, tables: c.map((d) => u.objectStore(d)).map((d) => {
      const { keyPath: h, autoIncrement: v } = d, y = On(h), b = h == null, p = {}, f = { name: d.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: b, compound: y, keyPath: h, autoIncrement: v, unique: !0, extractKey: Fc(h) }, indexes: Op(d.indexNames).map((m) => d.index(m)).map((m) => {
        const { name: g, unique: w, multiEntry: _, keyPath: E } = m, C = { name: g, compound: On(E), keyPath: E, unique: w, multiEntry: _, extractKey: Fc(E) };
        return p[go(E)] = C, C;
      }), getIndexByKeyPath: (m) => p[go(m)] };
      return p[":id"] = f.primaryKey, h != null && (p[go(h)] = f.primaryKey), f;
    }) }, hasGetAll: c.length > 0 && "getAll" in u.objectStore(c[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) };
  }(t, n), o = i.tables.map((l) => function(u) {
    const c = u.name;
    return { name: c, schema: u, mutate: function({ trans: d, type: h, keys: v, values: y, range: b }) {
      return new Promise((p, f) => {
        p = Ht(p);
        const m = d.objectStore(c), g = m.keyPath == null, w = h === "put" || h === "add";
        if (!w && h !== "delete" && h !== "deleteRange")
          throw new Error("Invalid operation type: " + h);
        const { length: _ } = v || y || { length: 1 };
        if (v && y && v.length !== y.length)
          throw new Error("Given keys array must have same length as given values array.");
        if (_ === 0)
          return p({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
        let E;
        const C = [], T = [];
        let k = 0;
        const N = (P) => {
          ++k, Po(P);
        };
        if (h === "deleteRange") {
          if (b.type === 4)
            return p({ numFailures: k, failures: T, results: [], lastResult: void 0 });
          b.type === 3 ? C.push(E = m.clear()) : C.push(E = m.delete(r(b)));
        } else {
          const [P, D] = w ? g ? [y, v] : [y, null] : [v, null];
          if (w)
            for (let z = 0; z < _; ++z)
              C.push(E = D && D[z] !== void 0 ? m[h](P[z], D[z]) : m[h](P[z])), E.onerror = N;
          else
            for (let z = 0; z < _; ++z)
              C.push(E = m[h](P[z])), E.onerror = N;
        }
        const I = (P) => {
          const D = P.target.result;
          C.forEach((z, G) => z.error != null && (T[G] = z.error)), p({ numFailures: k, failures: T, results: h === "delete" ? v : C.map((z) => z.result), lastResult: D });
        };
        E.onerror = (P) => {
          N(P), I(P);
        }, E.onsuccess = I;
      });
    }, getMany: ({ trans: d, keys: h }) => new Promise((v, y) => {
      v = Ht(v);
      const b = d.objectStore(c), p = h.length, f = new Array(p);
      let m, g = 0, w = 0;
      const _ = (C) => {
        const T = C.target;
        f[T._pos] = T.result, ++w === g && v(f);
      }, E = _r(y);
      for (let C = 0; C < p; ++C)
        h[C] != null && (m = b.get(h[C]), m._pos = C, m.onsuccess = _, m.onerror = E, ++g);
      g === 0 && v(f);
    }), get: ({ trans: d, key: h }) => new Promise((v, y) => {
      v = Ht(v);
      const b = d.objectStore(c).get(h);
      b.onsuccess = (p) => v(p.target.result), b.onerror = _r(y);
    }), query: function(d) {
      return (h) => new Promise((v, y) => {
        v = Ht(v);
        const { trans: b, values: p, limit: f, query: m } = h, g = f === 1 / 0 ? void 0 : f, { index: w, range: _ } = m, E = b.objectStore(c), C = w.isPrimaryKey ? E : E.index(w.name), T = r(_);
        if (f === 0)
          return v({ result: [] });
        if (d) {
          const k = p ? C.getAll(T, g) : C.getAllKeys(T, g);
          k.onsuccess = (N) => v({ result: N.target.result }), k.onerror = _r(y);
        } else {
          let k = 0;
          const N = p || !("openKeyCursor" in C) ? C.openCursor(T) : C.openKeyCursor(T), I = [];
          N.onsuccess = (P) => {
            const D = N.result;
            return D ? (I.push(p ? D.value : D.primaryKey), ++k === f ? v({ result: I }) : void D.continue()) : v({ result: I });
          }, N.onerror = _r(y);
        }
      });
    }(s), openCursor: function({ trans: d, values: h, query: v, reverse: y, unique: b }) {
      return new Promise((p, f) => {
        p = Ht(p);
        const { index: m, range: g } = v, w = d.objectStore(c), _ = m.isPrimaryKey ? w : w.index(m.name), E = y ? b ? "prevunique" : "prev" : b ? "nextunique" : "next", C = h || !("openKeyCursor" in _) ? _.openCursor(r(g), E) : _.openKeyCursor(r(g), E);
        C.onerror = _r(f), C.onsuccess = Ht((T) => {
          const k = C.result;
          if (!k)
            return void p(null);
          k.___id = ++S8, k.done = !1;
          const N = k.continue.bind(k);
          let I = k.continuePrimaryKey;
          I && (I = I.bind(k));
          const P = k.advance.bind(k), D = () => {
            throw new Error("Cursor not stopped");
          };
          k.trans = d, k.stop = k.continue = k.continuePrimaryKey = k.advance = () => {
            throw new Error("Cursor not started");
          }, k.fail = Ht(f), k.next = function() {
            let z = 1;
            return this.start(() => z-- ? this.continue() : this.stop()).then(() => this);
          }, k.start = (z) => {
            const G = new Promise((M, U) => {
              M = Ht(M), C.onerror = _r(U), k.fail = U, k.stop = (j) => {
                k.stop = k.continue = k.continuePrimaryKey = k.advance = D, M(j);
              };
            }), J = () => {
              if (C.result)
                try {
                  z();
                } catch (M) {
                  k.fail(M);
                }
              else
                k.done = !0, k.start = () => {
                  throw new Error("Cursor behind last entry");
                }, k.stop();
            };
            return C.onsuccess = Ht((M) => {
              C.onsuccess = J, J();
            }), k.continue = N, k.continuePrimaryKey = I, k.advance = P, J(), G;
          }, p(k);
        }, f);
      });
    }, count({ query: d, trans: h }) {
      const { index: v, range: y } = d;
      return new Promise((b, p) => {
        const f = h.objectStore(c), m = v.isPrimaryKey ? f : f.index(v.name), g = r(y), w = g ? m.count(g) : m.count();
        w.onsuccess = Ht((_) => b(_.target.result)), w.onerror = _r(p);
      });
    } };
  }(l)), a = {};
  return o.forEach((l) => a[l.name] = l), { stack: "dbcore", transaction: t.transaction.bind(t), table(l) {
    if (!a[l])
      throw new Error(`Table '${l}' not found`);
    return a[l];
  }, MIN_KEY: -1 / 0, MAX_KEY: Do(e), schema: i };
}
function jc({ _novip: t }, e) {
  const n = e.db, r = function(i, s, { IDBKeyRange: o, indexedDB: a }, l) {
    return { dbcore: function(c, d) {
      return d.reduce((h, { create: v }) => ({ ...h, ...v(h) }), c);
    }(x8(s, o, l), i.dbcore) };
  }(t._middlewares, n, t._deps, e);
  t.core = r.dbcore, t.tables.forEach((i) => {
    const s = i.name;
    t.core.schema.tables.some((o) => o.name === s) && (i.core = t.core.table(s), t[s] instanceof t.Table && (t[s].core = i.core));
  });
}
function yl({ _novip: t }, e, n, r) {
  n.forEach((i) => {
    const s = r[i];
    e.forEach((o) => {
      const a = ef(o, i);
      (!a || "value" in a && a.value === void 0) && (o === t.Transaction.prototype || o instanceof t.Transaction ? qr(o, i, { get() {
        return this.table(i);
      }, set(l) {
        qg(this, i, { value: l, writable: !0, configurable: !0, enumerable: !0 });
      } }) : o[i] = new t.Table(i, s));
    });
  });
}
function Uc({ _novip: t }, e) {
  e.forEach((n) => {
    for (let r in n)
      n[r] instanceof t.Table && delete n[r];
  });
}
function C8(t, e) {
  return t._cfg.version - e._cfg.version;
}
function k8(t, e, n, r) {
  const i = t._dbSchema, s = t._createTransaction("readwrite", t._storeNames, i);
  s.create(n), s._completion.catch(r);
  const o = s._reject.bind(s), a = Ke.transless || Ke;
  wi(() => {
    Ke.trans = s, Ke.transless = a, e === 0 ? (an(i).forEach((l) => {
      Pu(n, l, i[l].primKey, i[l].indexes);
    }), jc(t, n), Me.follow(() => t.on.populate.fire(s)).catch(o)) : function({ _novip: l }, u, c, d) {
      const h = [], v = l._versions;
      let y = l._dbSchema = Wc(l, l.idbdb, d), b = !1;
      const p = v.filter((m) => m._cfg.version >= u);
      function f() {
        return h.length ? Me.resolve(h.shift()(c.idbtrans)).then(f) : Me.resolve();
      }
      return p.forEach((m) => {
        h.push(() => {
          const g = y, w = m._cfg.dbschema;
          Hc(l, g, d), Hc(l, w, d), y = l._dbSchema = w;
          const _ = w0(g, w);
          _.add.forEach((C) => {
            Pu(d, C[0], C[1].primKey, C[1].indexes);
          }), _.change.forEach((C) => {
            if (C.recreate)
              throw new Je.Upgrade("Not yet support for changing primary key");
            {
              const T = d.objectStore(C.name);
              C.add.forEach((k) => Vc(T, k)), C.change.forEach((k) => {
                T.deleteIndex(k.name), Vc(T, k);
              }), C.del.forEach((k) => T.deleteIndex(k));
            }
          });
          const E = m._cfg.contentUpgrade;
          if (E && m._cfg.version > u) {
            jc(l, d), c._memoizedTables = {}, b = !0;
            let C = Zg(w);
            _.del.forEach((I) => {
              C[I] = g[I];
            }), Uc(l, [l.Transaction.prototype]), yl(l, [l.Transaction.prototype], an(C), C), c.schema = C;
            const T = tf(E);
            let k;
            T && Us();
            const N = Me.follow(() => {
              if (k = E(c), k && T) {
                var I = Jr.bind(null, null);
                k.then(I, I);
              }
            });
            return k && typeof k.then == "function" ? Me.resolve(k) : N.then(() => k);
          }
        }), h.push((g) => {
          (!b || !v8) && function(w, _) {
            [].slice.call(_.db.objectStoreNames).forEach((E) => w[E] == null && _.db.deleteObjectStore(E));
          }(m._cfg.dbschema, g), Uc(l, [l.Transaction.prototype]), yl(l, [l.Transaction.prototype], l._storeNames, l._dbSchema), c.schema = l._dbSchema;
        });
      }), f().then(() => {
        var m, g;
        g = d, an(m = y).forEach((w) => {
          g.db.objectStoreNames.contains(w) || Pu(g, w, m[w].primKey, m[w].indexes);
        });
      });
    }(t, e, s, n).catch(o);
  });
}
function w0(t, e) {
  const n = { del: [], add: [], change: [] };
  let r;
  for (r in t)
    e[r] || n.del.push(r);
  for (r in e) {
    const i = t[r], s = e[r];
    if (i) {
      const o = { name: r, def: s, recreate: !1, del: [], add: [], change: [] };
      if ("" + (i.primKey.keyPath || "") != "" + (s.primKey.keyPath || "") || i.primKey.auto !== s.primKey.auto && !Jl)
        o.recreate = !0, n.change.push(o);
      else {
        const a = i.idxByName, l = s.idxByName;
        let u;
        for (u in a)
          l[u] || o.del.push(u);
        for (u in l) {
          const c = a[u], d = l[u];
          c ? c.src !== d.src && o.change.push(d) : o.add.push(d);
        }
        (o.del.length > 0 || o.add.length > 0 || o.change.length > 0) && n.change.push(o);
      }
    } else
      n.add.push([r, s]);
  }
  return n;
}
function Pu(t, e, n, r) {
  const i = t.db.createObjectStore(e, n.keyPath ? { keyPath: n.keyPath, autoIncrement: n.auto } : { autoIncrement: n.auto });
  return r.forEach((s) => Vc(i, s)), i;
}
function Vc(t, e) {
  t.createIndex(e.name, e.keyPath, { unique: e.unique, multiEntry: e.multi });
}
function Wc(t, e, n) {
  const r = {};
  return fl(e.objectStoreNames, 0).forEach((i) => {
    const s = n.objectStore(i);
    let o = s.keyPath;
    const a = zc(y0(o), o || "", !1, !1, !!s.autoIncrement, o && typeof o != "string", !0), l = [];
    for (let c = 0; c < s.indexNames.length; ++c) {
      const d = s.index(s.indexNames[c]);
      o = d.keyPath;
      var u = zc(d.name, o, !!d.unique, !!d.multiEntry, !1, o && typeof o != "string", !1);
      l.push(u);
    }
    r[i] = b0(i, a, l);
  }), r;
}
function Hc({ _novip: t }, e, n) {
  const r = n.db.objectStoreNames;
  for (let i = 0; i < r.length; ++i) {
    const s = r[i], o = n.objectStore(s);
    t._hasGetAll = "getAll" in o;
    for (let a = 0; a < o.indexNames.length; ++a) {
      const l = o.indexNames[a], u = o.index(l).keyPath, c = typeof u == "string" ? u : "[" + fl(u).join("+") + "]";
      if (e[s]) {
        const d = e[s].idxByName[c];
        d && (d.name = l, delete e[s].idxByName[c], e[s].idxByName[l] = d);
      }
    }
  }
  typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && Ut.WorkerGlobalScope && Ut instanceof Ut.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (t._hasGetAll = !1);
}
class T8 {
  _parseStoresSpec(e, n) {
    an(e).forEach((r) => {
      if (e[r] !== null) {
        var i = e[r].split(",").map((o, a) => {
          const l = (o = o.trim()).replace(/([&*]|\+\+)/g, ""), u = /^\[/.test(l) ? l.match(/^\[(.*)\]$/)[1].split("+") : l;
          return zc(l, u || null, /\&/.test(o), /\*/.test(o), /\+\+/.test(o), On(u), a === 0);
        }), s = i.shift();
        if (s.multi)
          throw new Je.Schema("Primary key cannot be multi-valued");
        i.forEach((o) => {
          if (o.auto)
            throw new Je.Schema("Only primary key can be marked as autoIncrement (++)");
          if (!o.keyPath)
            throw new Je.Schema("Index must have a name and cannot be an empty string");
        }), n[r] = b0(r, s, i);
      }
    });
  }
  stores(e) {
    const n = this.db;
    this._cfg.storesSource = this._cfg.storesSource ? Ln(this._cfg.storesSource, e) : e;
    const r = n._versions, i = {};
    let s = {};
    return r.forEach((o) => {
      Ln(i, o._cfg.storesSource), s = o._cfg.dbschema = {}, o._parseStoresSpec(i, s);
    }), n._dbSchema = s, Uc(n, [n._allTables, n, n.Transaction.prototype]), yl(n, [n._allTables, n, n.Transaction.prototype, this._cfg.tables], an(s), s), n._storeNames = an(s), this;
  }
  upgrade(e) {
    return this._cfg.contentUpgrade = sf(this._cfg.contentUpgrade || Bt, e), this;
  }
}
function uf(t, e) {
  let n = t._dbNamesDB;
  return n || (n = t._dbNamesDB = new Bi(eu, { addons: [], indexedDB: t, IDBKeyRange: e }), n.version(1).stores({ dbnames: "name" })), n.table("dbnames");
}
function cf(t) {
  return t && typeof t.databases == "function";
}
function Kc(t) {
  return wi(function() {
    return Ke.letThrough = !0, t();
  });
}
function O8() {
  var t;
  return !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(e) {
    var n = function() {
      return indexedDB.databases().finally(e);
    };
    t = setInterval(n, 100), n();
  }).finally(function() {
    return clearInterval(t);
  }) : Promise.resolve();
}
function N8(t) {
  const e = t._state, { indexedDB: n } = t._deps;
  if (e.isBeingOpened || t.idbdb)
    return e.dbReadyPromise.then(() => e.dbOpenError ? dn(e.dbOpenError) : t);
  Dr && (e.openCanceller._stackHolder = Qi()), e.isBeingOpened = !0, e.dbOpenError = null, e.openComplete = !1;
  const r = e.openCanceller;
  function i() {
    if (e.openCanceller !== r)
      throw new Je.DatabaseClosed("db.open() was cancelled");
  }
  let s = e.dbReadyResolve, o = null, a = !1;
  return Me.race([r, (typeof navigator > "u" ? Me.resolve() : O8()).then(() => new Me((l, u) => {
    if (i(), !n)
      throw new Je.MissingAPI();
    const c = t.name, d = e.autoSchema ? n.open(c) : n.open(c, Math.round(10 * t.verno));
    if (!d)
      throw new Je.MissingAPI();
    d.onerror = _r(u), d.onblocked = Ht(t._fireOnBlocked), d.onupgradeneeded = Ht((h) => {
      if (o = d.transaction, e.autoSchema && !t._options.allowEmptyDB) {
        d.onerror = Po, o.abort(), d.result.close();
        const y = n.deleteDatabase(c);
        y.onsuccess = y.onerror = Ht(() => {
          u(new Je.NoSuchDatabase(`Database ${c} doesnt exist`));
        });
      } else {
        o.onerror = _r(u);
        var v = h.oldVersion > Math.pow(2, 62) ? 0 : h.oldVersion;
        a = v < 1, t._novip.idbdb = d.result, k8(t, v / 10, o, u);
      }
    }, u), d.onsuccess = Ht(() => {
      o = null;
      const h = t._novip.idbdb = d.result, v = fl(h.objectStoreNames);
      if (v.length > 0)
        try {
          const b = h.transaction((y = v).length === 1 ? y[0] : y, "readonly");
          e.autoSchema ? function({ _novip: p }, f, m) {
            p.verno = f.version / 10;
            const g = p._dbSchema = Wc(0, f, m);
            p._storeNames = fl(f.objectStoreNames, 0), yl(p, [p._allTables], an(g), g);
          }(t, h, b) : (Hc(t, t._dbSchema, b), function(p, f) {
            const m = w0(Wc(0, p.idbdb, f), p._dbSchema);
            return !(m.add.length || m.change.some((g) => g.add.length || g.change.length));
          }(t, b) || console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.")), jc(t, b);
        } catch {
        }
      var y;
      vo.push(t), h.onversionchange = Ht((b) => {
        e.vcFired = !0, t.on("versionchange").fire(b);
      }), h.onclose = Ht((b) => {
        t.on("close").fire(b);
      }), a && function({ indexedDB: b, IDBKeyRange: p }, f) {
        !cf(b) && f !== eu && uf(b, p).put({ name: f }).catch(Bt);
      }(t._deps, c), l();
    }, u);
  }))]).then(() => (i(), e.onReadyBeingFired = [], Me.resolve(Kc(() => t.on.ready.fire(t.vip))).then(function l() {
    if (e.onReadyBeingFired.length > 0) {
      let u = e.onReadyBeingFired.reduce(sf, Bt);
      return e.onReadyBeingFired = [], Me.resolve(Kc(() => u(t.vip))).then(l);
    }
  }))).finally(() => {
    e.onReadyBeingFired = null, e.isBeingOpened = !1;
  }).then(() => t).catch((l) => {
    e.dbOpenError = l;
    try {
      o && o.abort();
    } catch {
    }
    return r === e.openCanceller && t._close(), dn(l);
  }).finally(() => {
    e.openComplete = !0, s();
  });
}
function qc(t) {
  var e = (s) => t.next(s), n = i(e), r = i((s) => t.throw(s));
  function i(s) {
    return (o) => {
      var a = s(o), l = a.value;
      return a.done ? l : l && typeof l.then == "function" ? l.then(n, r) : On(l) ? Promise.all(l).then(n, r) : n(l);
    };
  }
  return i(e)();
}
function A8(t, e, n) {
  var r = arguments.length;
  if (r < 2)
    throw new Je.InvalidArgument("Too few arguments");
  for (var i = new Array(r - 1); --r; )
    i[r - 1] = arguments[r];
  return n = i.pop(), [t, Qg(i), n];
}
function _0(t, e, n, r, i) {
  return Me.resolve().then(() => {
    const s = Ke.transless || Ke, o = t._createTransaction(e, n, t._dbSchema, r), a = { trans: o, transless: s };
    if (r)
      o.idbtrans = r.idbtrans;
    else
      try {
        o.create(), t._state.PR1398_maxLoop = 3;
      } catch (d) {
        return d.name === rf.InvalidState && t.isOpen() && --t._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), t._close(), t.open().then(() => _0(t, e, n, null, i))) : dn(d);
      }
    const l = tf(i);
    let u;
    l && Us();
    const c = Me.follow(() => {
      if (u = i.call(o, o), u)
        if (l) {
          var d = Jr.bind(null, null);
          u.then(d, d);
        } else
          typeof u.next == "function" && typeof u.throw == "function" && (u = qc(u));
    }, a);
    return (u && typeof u.then == "function" ? Me.resolve(u).then((d) => o.active ? d : dn(new Je.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"))) : c.then(() => u)).then((d) => (r && o._resolve(), o._completion.then(() => d))).catch((d) => (o._reject(d), dn(d)));
  });
}
function Aa(t, e, n) {
  const r = On(t) ? t.slice() : [t];
  for (let i = 0; i < n; ++i)
    r.push(e);
  return r;
}
const I8 = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(t) {
  return { ...t, table(e) {
    const n = t.table(e), { schema: r } = n, i = {}, s = [];
    function o(c, d, h) {
      const v = go(c), y = i[v] = i[v] || [], b = c == null ? 0 : typeof c == "string" ? 1 : c.length, p = d > 0, f = { ...h, isVirtual: p, keyTail: d, keyLength: b, extractKey: Fc(c), unique: !p && h.unique };
      return y.push(f), f.isPrimaryKey || s.push(f), b > 1 && o(b === 2 ? c[0] : c.slice(0, b - 1), d + 1, h), y.sort((m, g) => m.keyTail - g.keyTail), f;
    }
    const a = o(r.primaryKey.keyPath, 0, r.primaryKey);
    i[":id"] = [a];
    for (const c of r.indexes)
      o(c.keyPath, 0, c);
    function l(c) {
      const d = c.query.index;
      return d.isVirtual ? { ...c, query: { index: d, range: (h = c.query.range, v = d.keyTail, { type: h.type === 1 ? 2 : h.type, lower: Aa(h.lower, h.lowerOpen ? t.MAX_KEY : t.MIN_KEY, v), lowerOpen: !0, upper: Aa(h.upper, h.upperOpen ? t.MIN_KEY : t.MAX_KEY, v), upperOpen: !0 }) } } : c;
      var h, v;
    }
    return { ...n, schema: { ...r, primaryKey: a, indexes: s, getIndexByKeyPath: function(c) {
      const d = i[go(c)];
      return d && d[0];
    } }, count: (c) => n.count(l(c)), query: (c) => n.query(l(c)), openCursor(c) {
      const { keyTail: d, isVirtual: h, keyLength: v } = c.query.index;
      return h ? n.openCursor(l(c)).then((y) => y && function(b) {
        return Object.create(b, { continue: { value: function(f) {
          f != null ? b.continue(Aa(f, c.reverse ? t.MAX_KEY : t.MIN_KEY, d)) : c.unique ? b.continue(b.key.slice(0, v).concat(c.reverse ? t.MIN_KEY : t.MAX_KEY, d)) : b.continue();
        } }, continuePrimaryKey: { value(f, m) {
          b.continuePrimaryKey(Aa(f, t.MAX_KEY, d), m);
        } }, primaryKey: { get: () => b.primaryKey }, key: { get() {
          const f = b.key;
          return v === 1 ? f[0] : f.slice(0, v);
        } }, value: { get: () => b.value } });
      }(y)) : n.openCursor(c);
    } };
  } };
} };
function df(t, e, n, r) {
  return n = n || {}, r = r || "", an(t).forEach((i) => {
    if (Xn(e, i)) {
      var s = t[i], o = e[i];
      if (typeof s == "object" && typeof o == "object" && s && o) {
        const a = kc(s);
        a !== kc(o) ? n[r + i] = e[i] : a === "Object" ? df(s, o, n, r + i + ".") : s !== o && (n[r + i] = e[i]);
      } else
        s !== o && (n[r + i] = e[i]);
    } else
      n[r + i] = void 0;
  }), an(e).forEach((i) => {
    Xn(t, i) || (n[r + i] = e[i]);
  }), n;
}
const R8 = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: (t) => ({ ...t, table(e) {
  const n = t.table(e), { primaryKey: r } = n.schema;
  return { ...n, mutate(s) {
    const o = Ke.trans, { deleting: a, creating: l, updating: u } = o.table(e).hook;
    switch (s.type) {
      case "add":
        if (l.fire === Bt)
          break;
        return o._promise("readwrite", () => c(s), !0);
      case "put":
        if (l.fire === Bt && u.fire === Bt)
          break;
        return o._promise("readwrite", () => c(s), !0);
      case "delete":
        if (a.fire === Bt)
          break;
        return o._promise("readwrite", () => c(s), !0);
      case "deleteRange":
        if (a.fire === Bt)
          break;
        return o._promise("readwrite", () => function(h) {
          return d(h.trans, h.range, 1e4);
        }(s), !0);
    }
    return n.mutate(s);
    function c(h) {
      const v = Ke.trans, y = h.keys || function(b, p) {
        return p.type === "delete" ? p.keys : p.keys || p.values.map(b.extractKey);
      }(r, h);
      if (!y)
        throw new Error("Keys missing");
      return (h = h.type === "add" || h.type === "put" ? { ...h, keys: y } : { ...h }).type !== "delete" && (h.values = [...h.values]), h.keys && (h.keys = [...h.keys]), function(b, p, f) {
        return p.type === "add" ? Promise.resolve([]) : b.getMany({ trans: p.trans, keys: f, cache: "immutable" });
      }(n, h, y).then((b) => {
        const p = y.map((f, m) => {
          const g = b[m], w = { onerror: null, onsuccess: null };
          if (h.type === "delete")
            a.fire.call(w, f, g, v);
          else if (h.type === "add" || g === void 0) {
            const _ = l.fire.call(w, f, h.values[m], v);
            f == null && _ != null && (f = _, h.keys[m] = f, r.outbound || vr(h.values[m], r.keyPath, f));
          } else {
            const _ = df(g, h.values[m]), E = u.fire.call(w, _, f, g, v);
            if (E) {
              const C = h.values[m];
              Object.keys(E).forEach((T) => {
                Xn(C, T) ? C[T] = E[T] : vr(C, T, E[T]);
              });
            }
          }
          return w;
        });
        return n.mutate(h).then(({ failures: f, results: m, numFailures: g, lastResult: w }) => {
          for (let _ = 0; _ < y.length; ++_) {
            const E = m ? m[_] : y[_], C = p[_];
            E == null ? C.onerror && C.onerror(f[_]) : C.onsuccess && C.onsuccess(h.type === "put" && b[_] ? h.values[_] : E);
          }
          return { failures: f, results: m, numFailures: g, lastResult: w };
        }).catch((f) => (p.forEach((m) => m.onerror && m.onerror(f)), Promise.reject(f)));
      });
    }
    function d(h, v, y) {
      return n.query({ trans: h, values: !1, query: { index: r, range: v }, limit: y }).then(({ result: b }) => c({ type: "delete", keys: b, trans: h }).then((p) => p.numFailures > 0 ? Promise.reject(p.failures[0]) : b.length < y ? { failures: [], numFailures: 0, lastResult: void 0 } : d(h, { ...v, lower: b[b.length - 1], lowerOpen: !0 }, y)));
    }
  } };
} }) };
function E0(t, e, n) {
  try {
    if (!e || e.keys.length < t.length)
      return null;
    const r = [];
    for (let i = 0, s = 0; i < e.keys.length && s < t.length; ++i)
      An(e.keys[i], t[s]) === 0 && (r.push(n ? na(e.values[i]) : e.values[i]), ++s);
    return r.length === t.length ? r : null;
  } catch {
    return null;
  }
}
const L8 = { stack: "dbcore", level: -1, create: (t) => ({ table: (e) => {
  const n = t.table(e);
  return { ...n, getMany: (r) => {
    if (!r.cache)
      return n.getMany(r);
    const i = E0(r.keys, r.trans._cache, r.cache === "clone");
    return i ? Me.resolve(i) : n.getMany(r).then((s) => (r.trans._cache = { keys: r.keys, values: r.cache === "clone" ? na(s) : s }, s));
  }, mutate: (r) => (r.type !== "add" && (r.trans._cache = null), n.mutate(r)) };
} }) };
function ff(t) {
  return !("from" in t);
}
const Vr = function(t, e) {
  if (!this) {
    const n = new Vr();
    return t && "d" in t && Ln(n, t), n;
  }
  Ln(this, arguments.length ? { d: 1, from: t, to: arguments.length > 1 ? e : t } : { d: 0 });
};
function Bo(t, e, n) {
  const r = An(e, n);
  if (isNaN(r))
    return;
  if (r > 0)
    throw RangeError();
  if (ff(t))
    return Ln(t, { from: e, to: n, d: 1 });
  const i = t.l, s = t.r;
  if (An(n, t.from) < 0)
    return i ? Bo(i, e, n) : t.l = { from: e, to: n, d: 1, l: null, r: null }, Np(t);
  if (An(e, t.to) > 0)
    return s ? Bo(s, e, n) : t.r = { from: e, to: n, d: 1, l: null, r: null }, Np(t);
  An(e, t.from) < 0 && (t.from = e, t.l = null, t.d = s ? s.d + 1 : 1), An(n, t.to) > 0 && (t.to = n, t.r = null, t.d = t.l ? t.l.d + 1 : 1);
  const o = !t.r;
  i && !t.l && bl(t, i), s && o && bl(t, s);
}
function bl(t, e) {
  ff(e) || function n(r, { from: i, to: s, l: o, r: a }) {
    Bo(r, i, s), o && n(r, o), a && n(r, a);
  }(t, e);
}
function P8(t, e) {
  const n = Gc(e);
  let r = n.next();
  if (r.done)
    return !1;
  let i = r.value;
  const s = Gc(t);
  let o = s.next(i.from), a = o.value;
  for (; !r.done && !o.done; ) {
    if (An(a.from, i.to) <= 0 && An(a.to, i.from) >= 0)
      return !0;
    An(i.from, a.from) < 0 ? i = (r = n.next(a.from)).value : a = (o = s.next(i.from)).value;
  }
  return !1;
}
function Gc(t) {
  let e = ff(t) ? null : { s: 0, n: t };
  return { next(n) {
    const r = arguments.length > 0;
    for (; e; )
      switch (e.s) {
        case 0:
          if (e.s = 1, r)
            for (; e.n.l && An(n, e.n.from) < 0; )
              e = { up: e, n: e.n.l, s: 1 };
          else
            for (; e.n.l; )
              e = { up: e, n: e.n.l, s: 1 };
        case 1:
          if (e.s = 2, !r || An(n, e.n.to) <= 0)
            return { value: e.n, done: !1 };
        case 2:
          if (e.n.r) {
            e.s = 3, e = { up: e, n: e.n.r, s: 0 };
            continue;
          }
        case 3:
          e = e.up;
      }
    return { done: !0 };
  } };
}
function Np(t) {
  var e, n;
  const r = (((e = t.r) === null || e === void 0 ? void 0 : e.d) || 0) - (((n = t.l) === null || n === void 0 ? void 0 : n.d) || 0), i = r > 1 ? "r" : r < -1 ? "l" : "";
  if (i) {
    const s = i === "r" ? "l" : "r", o = { ...t }, a = t[i];
    t.from = a.from, t.to = a.to, t[i] = a[i], o[i] = a[s], t[s] = o, o.d = Ap(o);
  }
  t.d = Ap(t);
}
function Ap({ r: t, l: e }) {
  return (t ? e ? Math.max(t.d, e.d) : t.d : e ? e.d : 0) + 1;
}
Ps(Vr.prototype, { add(t) {
  return bl(this, t), this;
}, addKey(t) {
  return Bo(this, t, t), this;
}, addKeys(t) {
  return t.forEach((e) => Bo(this, e, e)), this;
}, [Tc]() {
  return Gc(this);
} });
const $8 = { stack: "dbcore", level: 0, create: (t) => {
  const e = t.schema.name, n = new Vr(t.MIN_KEY, t.MAX_KEY);
  return { ...t, table: (r) => {
    const i = t.table(r), { schema: s } = i, { primaryKey: o } = s, { extractKey: a, outbound: l } = o, u = { ...i, mutate: (h) => {
      const v = h.trans, y = v.mutatedParts || (v.mutatedParts = {}), b = (E) => {
        const C = `idb://${e}/${r}/${E}`;
        return y[C] || (y[C] = new Vr());
      }, p = b(""), f = b(":dels"), { type: m } = h;
      let [g, w] = h.type === "deleteRange" ? [h.range] : h.type === "delete" ? [h.keys] : h.values.length < 50 ? [[], h.values] : [];
      const _ = h.trans._cache;
      return i.mutate(h).then((E) => {
        if (On(g)) {
          m !== "delete" && (g = E.results), p.addKeys(g);
          const C = E0(g, _);
          C || m === "add" || f.addKeys(g), (C || w) && function(T, k, N, I) {
            function P(D) {
              const z = T(D.name || "");
              function G(M) {
                return M != null ? D.extractKey(M) : null;
              }
              const J = (M) => D.multiEntry && On(M) ? M.forEach((U) => z.addKey(U)) : z.addKey(M);
              (N || I).forEach((M, U) => {
                const j = N && G(N[U]), re = I && G(I[U]);
                An(j, re) !== 0 && (j != null && J(j), re != null && J(re));
              });
            }
            k.indexes.forEach(P);
          }(b, s, C, w);
        } else if (g) {
          const C = { from: g.lower, to: g.upper };
          f.add(C), p.add(C);
        } else
          p.add(n), f.add(n), s.indexes.forEach((C) => b(C.name).add(n));
        return E;
      });
    } }, c = ({ query: { index: h, range: v } }) => {
      var y, b;
      return [h, new Vr((y = v.lower) !== null && y !== void 0 ? y : t.MIN_KEY, (b = v.upper) !== null && b !== void 0 ? b : t.MAX_KEY)];
    }, d = { get: (h) => [o, new Vr(h.key)], getMany: (h) => [o, new Vr().addKeys(h.keys)], count: c, query: c, openCursor: c };
    return an(d).forEach((h) => {
      u[h] = function(v) {
        const { subscr: y } = Ke;
        if (y) {
          const b = (w) => {
            const _ = `idb://${e}/${r}/${w}`;
            return y[_] || (y[_] = new Vr());
          }, p = b(""), f = b(":dels"), [m, g] = d[h](v);
          if (b(m.name || "").add(g), !m.isPrimaryKey) {
            if (h !== "count") {
              const w = h === "query" && l && v.values && i.query({ ...v, values: !1 });
              return i[h].apply(this, arguments).then((_) => {
                if (h === "query") {
                  if (l && v.values)
                    return w.then(({ result: C }) => (p.addKeys(C), _));
                  const E = v.values ? _.result.map(a) : _.result;
                  v.values ? p.addKeys(E) : f.addKeys(E);
                } else if (h === "openCursor") {
                  const E = _, C = v.values;
                  return E && Object.create(E, { key: { get: () => (f.addKey(E.primaryKey), E.key) }, primaryKey: { get() {
                    const T = E.primaryKey;
                    return f.addKey(T), T;
                  } }, value: { get: () => (C && p.addKey(E.primaryKey), E.value) } });
                }
                return _;
              });
            }
            f.add(n);
          }
        }
        return i[h].apply(this, arguments);
      };
    }), u;
  } };
} };
class Bi {
  constructor(e, n) {
    this._middlewares = {}, this.verno = 0;
    const r = Bi.dependencies;
    this._options = n = { addons: Bi.addons, autoOpen: !0, indexedDB: r.indexedDB, IDBKeyRange: r.IDBKeyRange, ...n }, this._deps = { indexedDB: n.indexedDB, IDBKeyRange: n.IDBKeyRange };
    const { addons: i } = n;
    this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
    const s = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: Bt, dbReadyPromise: null, cancelOpen: Bt, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3 };
    var o;
    s.dbReadyPromise = new Me((a) => {
      s.dbReadyResolve = a;
    }), s.openCanceller = new Me((a, l) => {
      s.cancelOpen = l;
    }), this._state = s, this.name = e, this.on = mo(this, "populate", "blocked", "versionchange", "close", { ready: [sf, Bt] }), this.on.ready.subscribe = Gg(this.on.ready.subscribe, (a) => (l, u) => {
      Bi.vip(() => {
        const c = this._state;
        if (c.openComplete)
          c.dbOpenError || Me.resolve().then(l), u && a(l);
        else if (c.onReadyBeingFired)
          c.onReadyBeingFired.push(l), u && a(l);
        else {
          a(l);
          const d = this;
          u || a(function h() {
            d.on.ready.unsubscribe(l), d.on.ready.unsubscribe(h);
          });
        }
      });
    }), this.Collection = (o = this, Zs(y8.prototype, function(a, l) {
      this.db = o;
      let u = v0, c = null;
      if (l)
        try {
          u = l();
        } catch (y) {
          c = y;
        }
      const d = a._ctx, h = d.table, v = h.hook.reading.fire;
      this._ctx = { table: h, index: d.index, isPrimKey: !d.index || h.schema.primKey.keyPath && d.index === h.schema.primKey.name, range: u, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: c, or: d.or, valueMapper: v !== Ro ? v : null };
    })), this.Table = function(a) {
      return Zs(g8.prototype, function(l, u, c) {
        this.db = a, this._tx = c, this.name = l, this.schema = u, this.hook = a._allTables[l] ? a._allTables[l].hook : mo(null, { creating: [s8, Bt], reading: [i8, Ro], updating: [a8, Bt], deleting: [o8, Bt] });
      });
    }(this), this.Transaction = function(a) {
      return Zs(E8.prototype, function(l, u, c, d, h) {
        this.db = a, this.mode = l, this.storeNames = u, this.schema = c, this.chromeTransactionDurability = d, this.idbtrans = null, this.on = mo(this, "complete", "error", "abort"), this.parent = h || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new Me((v, y) => {
          this._resolve = v, this._reject = y;
        }), this._completion.then(() => {
          this.active = !1, this.on.complete.fire();
        }, (v) => {
          var y = this.active;
          return this.active = !1, this.on.error.fire(v), this.parent ? this.parent._reject(v) : y && this.idbtrans && this.idbtrans.abort(), dn(v);
        });
      });
    }(this), this.Version = function(a) {
      return Zs(T8.prototype, function(l) {
        this.db = a, this._cfg = { version: l, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
      });
    }(this), this.WhereClause = function(a) {
      return Zs(g0.prototype, function(l, u, c) {
        this.db = a, this._ctx = { table: l, index: u === ":id" ? null : u, or: c };
        const d = a._deps.indexedDB;
        if (!d)
          throw new Je.MissingAPI();
        this._cmp = this._ascending = d.cmp.bind(d), this._descending = (h, v) => d.cmp(v, h), this._max = (h, v) => d.cmp(h, v) > 0 ? h : v, this._min = (h, v) => d.cmp(h, v) < 0 ? h : v, this._IDBKeyRange = a._deps.IDBKeyRange;
      });
    }(this), this.on("versionchange", (a) => {
      a.newVersion > 0 ? console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`) : console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`), this.close();
    }), this.on("blocked", (a) => {
      !a.newVersion || a.newVersion < a.oldVersion ? console.warn(`Dexie.delete('${this.name}') was blocked`) : console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${a.oldVersion / 10}`);
    }), this._maxKey = Do(n.IDBKeyRange), this._createTransaction = (a, l, u, c) => new this.Transaction(a, l, u, this._options.chromeTransactionDurability, c), this._fireOnBlocked = (a) => {
      this.on("blocked").fire(a), vo.filter((l) => l.name === this.name && l !== this && !l._state.vcFired).map((l) => l.on("versionchange").fire(a));
    }, this.use(I8), this.use(R8), this.use($8), this.use(L8), this.vip = Object.create(this, { _vip: { value: !0 } }), i.forEach((a) => a(this));
  }
  version(e) {
    if (isNaN(e) || e < 0.1)
      throw new Je.Type("Given version is not a positive number");
    if (e = Math.round(10 * e) / 10, this.idbdb || this._state.isBeingOpened)
      throw new Je.Schema("Cannot add version when database is open");
    this.verno = Math.max(this.verno, e);
    const n = this._versions;
    var r = n.filter((i) => i._cfg.version === e)[0];
    return r || (r = new this.Version(e), n.push(r), n.sort(C8), r.stores({}), this._state.autoSchema = !1, r);
  }
  _whenReady(e) {
    return this.idbdb && (this._state.openComplete || Ke.letThrough || this._vip) ? e() : new Me((n, r) => {
      if (this._state.openComplete)
        return r(new Je.DatabaseClosed(this._state.dbOpenError));
      if (!this._state.isBeingOpened) {
        if (!this._options.autoOpen)
          return void r(new Je.DatabaseClosed());
        this.open().catch(Bt);
      }
      this._state.dbReadyPromise.then(n, r);
    }).then(e);
  }
  use({ stack: e, create: n, level: r, name: i }) {
    i && this.unuse({ stack: e, name: i });
    const s = this._middlewares[e] || (this._middlewares[e] = []);
    return s.push({ stack: e, create: n, level: r ?? 10, name: i }), s.sort((o, a) => o.level - a.level), this;
  }
  unuse({ stack: e, name: n, create: r }) {
    return e && this._middlewares[e] && (this._middlewares[e] = this._middlewares[e].filter((i) => r ? i.create !== r : !!n && i.name !== n)), this;
  }
  open() {
    return N8(this);
  }
  _close() {
    const e = this._state, n = vo.indexOf(this);
    if (n >= 0 && vo.splice(n, 1), this.idbdb) {
      try {
        this.idbdb.close();
      } catch {
      }
      this._novip.idbdb = null;
    }
    e.dbReadyPromise = new Me((r) => {
      e.dbReadyResolve = r;
    }), e.openCanceller = new Me((r, i) => {
      e.cancelOpen = i;
    });
  }
  close() {
    this._close();
    const e = this._state;
    this._options.autoOpen = !1, e.dbOpenError = new Je.DatabaseClosed(), e.isBeingOpened && e.cancelOpen(e.dbOpenError);
  }
  delete() {
    const e = arguments.length > 0, n = this._state;
    return new Me((r, i) => {
      const s = () => {
        this.close();
        var o = this._deps.indexedDB.deleteDatabase(this.name);
        o.onsuccess = Ht(() => {
          (function({ indexedDB: a, IDBKeyRange: l }, u) {
            !cf(a) && u !== eu && uf(a, l).delete(u).catch(Bt);
          })(this._deps, this.name), r();
        }), o.onerror = _r(i), o.onblocked = this._fireOnBlocked;
      };
      if (e)
        throw new Je.InvalidArgument("Arguments not allowed in db.delete()");
      n.isBeingOpened ? n.dbReadyPromise.then(s) : s();
    });
  }
  backendDB() {
    return this.idbdb;
  }
  isOpen() {
    return this.idbdb !== null;
  }
  hasBeenClosed() {
    const e = this._state.dbOpenError;
    return e && e.name === "DatabaseClosed";
  }
  hasFailed() {
    return this._state.dbOpenError !== null;
  }
  dynamicallyOpened() {
    return this._state.autoSchema;
  }
  get tables() {
    return an(this._allTables).map((e) => this._allTables[e]);
  }
  transaction() {
    const e = A8.apply(this, arguments);
    return this._transaction.apply(this, e);
  }
  _transaction(e, n, r) {
    let i = Ke.trans;
    i && i.db === this && e.indexOf("!") === -1 || (i = null);
    const s = e.indexOf("?") !== -1;
    let o, a;
    e = e.replace("!", "").replace("?", "");
    try {
      if (a = n.map((u) => {
        var c = u instanceof this.Table ? u.name : u;
        if (typeof c != "string")
          throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
        return c;
      }), e == "r" || e === Nu)
        o = Nu;
      else {
        if (e != "rw" && e != Au)
          throw new Je.InvalidArgument("Invalid transaction mode: " + e);
        o = Au;
      }
      if (i) {
        if (i.mode === Nu && o === Au) {
          if (!s)
            throw new Je.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
          i = null;
        }
        i && a.forEach((u) => {
          if (i && i.storeNames.indexOf(u) === -1) {
            if (!s)
              throw new Je.SubTransaction("Table " + u + " not included in parent transaction.");
            i = null;
          }
        }), s && i && !i.active && (i = null);
      }
    } catch (u) {
      return i ? i._promise(null, (c, d) => {
        d(u);
      }) : dn(u);
    }
    const l = _0.bind(null, this, o, a, i, r);
    return i ? i._promise(o, l, "lock") : Ke.trans ? Vs(Ke.transless, () => this._whenReady(l)) : this._whenReady(l);
  }
  table(e) {
    if (!Xn(this._allTables, e))
      throw new Je.InvalidTable(`Table ${e} does not exist`);
    return this._allTables[e];
  }
}
const D8 = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable";
class B8 {
  constructor(e) {
    this._subscribe = e;
  }
  subscribe(e, n, r) {
    return this._subscribe(e && typeof e != "function" ? e : { next: e, error: n, complete: r });
  }
  [D8]() {
    return this;
  }
}
function S0(t, e) {
  return an(e).forEach((n) => {
    bl(t[n] || (t[n] = new Vr()), e[n]);
  }), t;
}
function M8(t) {
  let e, n = !1;
  const r = new B8((i) => {
    const s = tf(t);
    let o = !1, a = {}, l = {};
    const u = { get closed() {
      return o;
    }, unsubscribe: () => {
      o = !0, Ei.storagemutated.unsubscribe(v);
    } };
    i.start && i.start(u);
    let c = !1, d = !1;
    function h() {
      return an(l).some((b) => a[b] && P8(a[b], l[b]));
    }
    const v = (b) => {
      S0(a, b), h() && y();
    }, y = () => {
      if (c || o)
        return;
      a = {};
      const b = {}, p = function(f) {
        s && Us();
        const m = () => wi(t, { subscr: f, trans: null }), g = Ke.trans ? Vs(Ke.transless, m) : m();
        return s && g.then(Jr, Jr), g;
      }(b);
      d || (Ei($o, v), d = !0), c = !0, Promise.resolve(p).then((f) => {
        n = !0, e = f, c = !1, o || (h() ? y() : (a = {}, l = b, i.next && i.next(f)));
      }, (f) => {
        c = !1, n = !1, i.error && i.error(f), u.unsubscribe();
      });
    };
    return y(), u;
  });
  return r.hasValue = () => n, r.getValue = () => e, r;
}
let Yc;
try {
  Yc = { indexedDB: Ut.indexedDB || Ut.mozIndexedDB || Ut.webkitIndexedDB || Ut.msIndexedDB, IDBKeyRange: Ut.IDBKeyRange || Ut.webkitIDBKeyRange };
} catch {
  Yc = { indexedDB: null, IDBKeyRange: null };
}
const Ti = Bi;
function Za(t) {
  let e = Hr;
  try {
    Hr = !0, Ei.storagemutated.fire(t);
  } finally {
    Hr = e;
  }
}
Ps(Ti, { ...Ha, delete: (t) => new Ti(t, { addons: [] }).delete(), exists: (t) => new Ti(t, { addons: [] }).open().then((e) => (e.close(), !0)).catch("NoSuchDatabaseError", () => !1), getDatabaseNames(t) {
  try {
    return function({ indexedDB: e, IDBKeyRange: n }) {
      return cf(e) ? Promise.resolve(e.databases()).then((r) => r.map((i) => i.name).filter((i) => i !== eu)) : uf(e, n).toCollection().primaryKeys();
    }(Ti.dependencies).then(t);
  } catch {
    return dn(new Je.MissingAPI());
  }
}, defineClass: () => function(t) {
  Ln(this, t);
}, ignoreTransaction: (t) => Ke.trans ? Vs(Ke.transless, t) : t(), vip: Kc, async: function(t) {
  return function() {
    try {
      var e = qc(t.apply(this, arguments));
      return e && typeof e.then == "function" ? e : Me.resolve(e);
    } catch (n) {
      return dn(n);
    }
  };
}, spawn: function(t, e, n) {
  try {
    var r = qc(t.apply(n, e || []));
    return r && typeof r.then == "function" ? r : Me.resolve(r);
  } catch (i) {
    return dn(i);
  }
}, currentTransaction: { get: () => Ke.trans || null }, waitFor: function(t, e) {
  const n = Me.resolve(typeof t == "function" ? Ti.ignoreTransaction(t) : t).timeout(e || 6e4);
  return Ke.trans ? Ke.trans.waitFor(n) : n;
}, Promise: Me, debug: { get: () => Dr, set: (t) => {
  e0(t, t === "dexie" ? () => !0 : p0);
} }, derive: _s, extend: Ln, props: Ps, override: Gg, Events: mo, on: Ei, liveQuery: M8, extendObservabilitySet: S0, getByKeyPath: Gr, setByKeyPath: vr, delByKeyPath: function(t, e) {
  typeof e == "string" ? vr(t, e, void 0) : "length" in e && [].map.call(e, function(n) {
    vr(t, n, void 0);
  });
}, shallowClone: Zg, deepClone: na, getObjectDiff: df, cmp: An, asap: Yg, minKey: Mc, addons: [], connections: vo, errnames: rf, dependencies: Yc, semVer: Sp, version: Sp.split(".").map((t) => parseInt(t)).reduce((t, e, n) => t + e / Math.pow(10, 2 * n)) }), Ti.maxKey = Do(Ti.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (Ei($o, (t) => {
  if (!Hr) {
    let e;
    Jl ? (e = document.createEvent("CustomEvent"), e.initCustomEvent(hi, !0, !0, t)) : e = new CustomEvent(hi, { detail: t }), Hr = !0, dispatchEvent(e), Hr = !1;
  }
}), addEventListener(hi, ({ detail: t }) => {
  Hr || Za(t);
}));
let Hr = !1;
if (typeof BroadcastChannel < "u") {
  const t = new BroadcastChannel(hi);
  typeof t.unref == "function" && t.unref(), Ei($o, (e) => {
    Hr || t.postMessage(e);
  }), t.onmessage = (e) => {
    e.data && Za(e.data);
  };
} else if (typeof self < "u" && typeof navigator < "u") {
  Ei($o, (e) => {
    try {
      Hr || (typeof localStorage < "u" && localStorage.setItem(hi, JSON.stringify({ trig: Math.random(), changedParts: e })), typeof self.clients == "object" && [...self.clients.matchAll({ includeUncontrolled: !0 })].forEach((n) => n.postMessage({ type: hi, changedParts: e })));
    } catch {
    }
  }), typeof addEventListener < "u" && addEventListener("storage", (e) => {
    if (e.key === hi) {
      const n = JSON.parse(e.newValue);
      n && Za(n.changedParts);
    }
  });
  const t = self.document && navigator.serviceWorker;
  t && t.addEventListener("message", function({ data: e }) {
    e && e.type === hi && Za(e.changedParts);
  });
}
Me.rejectionMapper = function(t, e) {
  if (!t || t instanceof Es || t instanceof TypeError || t instanceof SyntaxError || !t.name || !bp[t.name])
    return t;
  var n = new bp[t.name](e || t.message, t);
  return "stack" in t && qr(n, "stack", { get: function() {
    return this.inner.stack;
  } }), n;
}, e0(Dr, p0);
const z8 = new Bi("library");
z8.version(1).stores({
  books: "++id, name, buffer, md5 ,size"
});
var Ip = {}, F8 = {
  get exports() {
    return Ip;
  },
  set exports(t) {
    Ip = t;
  }
};
(function(t, e) {
  (function(n) {
    t.exports = n();
  })(function(n) {
    var r = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    function i(f, m) {
      var g = f[0], w = f[1], _ = f[2], E = f[3];
      g += (w & _ | ~w & E) + m[0] - 680876936 | 0, g = (g << 7 | g >>> 25) + w | 0, E += (g & w | ~g & _) + m[1] - 389564586 | 0, E = (E << 12 | E >>> 20) + g | 0, _ += (E & g | ~E & w) + m[2] + 606105819 | 0, _ = (_ << 17 | _ >>> 15) + E | 0, w += (_ & E | ~_ & g) + m[3] - 1044525330 | 0, w = (w << 22 | w >>> 10) + _ | 0, g += (w & _ | ~w & E) + m[4] - 176418897 | 0, g = (g << 7 | g >>> 25) + w | 0, E += (g & w | ~g & _) + m[5] + 1200080426 | 0, E = (E << 12 | E >>> 20) + g | 0, _ += (E & g | ~E & w) + m[6] - 1473231341 | 0, _ = (_ << 17 | _ >>> 15) + E | 0, w += (_ & E | ~_ & g) + m[7] - 45705983 | 0, w = (w << 22 | w >>> 10) + _ | 0, g += (w & _ | ~w & E) + m[8] + 1770035416 | 0, g = (g << 7 | g >>> 25) + w | 0, E += (g & w | ~g & _) + m[9] - 1958414417 | 0, E = (E << 12 | E >>> 20) + g | 0, _ += (E & g | ~E & w) + m[10] - 42063 | 0, _ = (_ << 17 | _ >>> 15) + E | 0, w += (_ & E | ~_ & g) + m[11] - 1990404162 | 0, w = (w << 22 | w >>> 10) + _ | 0, g += (w & _ | ~w & E) + m[12] + 1804603682 | 0, g = (g << 7 | g >>> 25) + w | 0, E += (g & w | ~g & _) + m[13] - 40341101 | 0, E = (E << 12 | E >>> 20) + g | 0, _ += (E & g | ~E & w) + m[14] - 1502002290 | 0, _ = (_ << 17 | _ >>> 15) + E | 0, w += (_ & E | ~_ & g) + m[15] + 1236535329 | 0, w = (w << 22 | w >>> 10) + _ | 0, g += (w & E | _ & ~E) + m[1] - 165796510 | 0, g = (g << 5 | g >>> 27) + w | 0, E += (g & _ | w & ~_) + m[6] - 1069501632 | 0, E = (E << 9 | E >>> 23) + g | 0, _ += (E & w | g & ~w) + m[11] + 643717713 | 0, _ = (_ << 14 | _ >>> 18) + E | 0, w += (_ & g | E & ~g) + m[0] - 373897302 | 0, w = (w << 20 | w >>> 12) + _ | 0, g += (w & E | _ & ~E) + m[5] - 701558691 | 0, g = (g << 5 | g >>> 27) + w | 0, E += (g & _ | w & ~_) + m[10] + 38016083 | 0, E = (E << 9 | E >>> 23) + g | 0, _ += (E & w | g & ~w) + m[15] - 660478335 | 0, _ = (_ << 14 | _ >>> 18) + E | 0, w += (_ & g | E & ~g) + m[4] - 405537848 | 0, w = (w << 20 | w >>> 12) + _ | 0, g += (w & E | _ & ~E) + m[9] + 568446438 | 0, g = (g << 5 | g >>> 27) + w | 0, E += (g & _ | w & ~_) + m[14] - 1019803690 | 0, E = (E << 9 | E >>> 23) + g | 0, _ += (E & w | g & ~w) + m[3] - 187363961 | 0, _ = (_ << 14 | _ >>> 18) + E | 0, w += (_ & g | E & ~g) + m[8] + 1163531501 | 0, w = (w << 20 | w >>> 12) + _ | 0, g += (w & E | _ & ~E) + m[13] - 1444681467 | 0, g = (g << 5 | g >>> 27) + w | 0, E += (g & _ | w & ~_) + m[2] - 51403784 | 0, E = (E << 9 | E >>> 23) + g | 0, _ += (E & w | g & ~w) + m[7] + 1735328473 | 0, _ = (_ << 14 | _ >>> 18) + E | 0, w += (_ & g | E & ~g) + m[12] - 1926607734 | 0, w = (w << 20 | w >>> 12) + _ | 0, g += (w ^ _ ^ E) + m[5] - 378558 | 0, g = (g << 4 | g >>> 28) + w | 0, E += (g ^ w ^ _) + m[8] - 2022574463 | 0, E = (E << 11 | E >>> 21) + g | 0, _ += (E ^ g ^ w) + m[11] + 1839030562 | 0, _ = (_ << 16 | _ >>> 16) + E | 0, w += (_ ^ E ^ g) + m[14] - 35309556 | 0, w = (w << 23 | w >>> 9) + _ | 0, g += (w ^ _ ^ E) + m[1] - 1530992060 | 0, g = (g << 4 | g >>> 28) + w | 0, E += (g ^ w ^ _) + m[4] + 1272893353 | 0, E = (E << 11 | E >>> 21) + g | 0, _ += (E ^ g ^ w) + m[7] - 155497632 | 0, _ = (_ << 16 | _ >>> 16) + E | 0, w += (_ ^ E ^ g) + m[10] - 1094730640 | 0, w = (w << 23 | w >>> 9) + _ | 0, g += (w ^ _ ^ E) + m[13] + 681279174 | 0, g = (g << 4 | g >>> 28) + w | 0, E += (g ^ w ^ _) + m[0] - 358537222 | 0, E = (E << 11 | E >>> 21) + g | 0, _ += (E ^ g ^ w) + m[3] - 722521979 | 0, _ = (_ << 16 | _ >>> 16) + E | 0, w += (_ ^ E ^ g) + m[6] + 76029189 | 0, w = (w << 23 | w >>> 9) + _ | 0, g += (w ^ _ ^ E) + m[9] - 640364487 | 0, g = (g << 4 | g >>> 28) + w | 0, E += (g ^ w ^ _) + m[12] - 421815835 | 0, E = (E << 11 | E >>> 21) + g | 0, _ += (E ^ g ^ w) + m[15] + 530742520 | 0, _ = (_ << 16 | _ >>> 16) + E | 0, w += (_ ^ E ^ g) + m[2] - 995338651 | 0, w = (w << 23 | w >>> 9) + _ | 0, g += (_ ^ (w | ~E)) + m[0] - 198630844 | 0, g = (g << 6 | g >>> 26) + w | 0, E += (w ^ (g | ~_)) + m[7] + 1126891415 | 0, E = (E << 10 | E >>> 22) + g | 0, _ += (g ^ (E | ~w)) + m[14] - 1416354905 | 0, _ = (_ << 15 | _ >>> 17) + E | 0, w += (E ^ (_ | ~g)) + m[5] - 57434055 | 0, w = (w << 21 | w >>> 11) + _ | 0, g += (_ ^ (w | ~E)) + m[12] + 1700485571 | 0, g = (g << 6 | g >>> 26) + w | 0, E += (w ^ (g | ~_)) + m[3] - 1894986606 | 0, E = (E << 10 | E >>> 22) + g | 0, _ += (g ^ (E | ~w)) + m[10] - 1051523 | 0, _ = (_ << 15 | _ >>> 17) + E | 0, w += (E ^ (_ | ~g)) + m[1] - 2054922799 | 0, w = (w << 21 | w >>> 11) + _ | 0, g += (_ ^ (w | ~E)) + m[8] + 1873313359 | 0, g = (g << 6 | g >>> 26) + w | 0, E += (w ^ (g | ~_)) + m[15] - 30611744 | 0, E = (E << 10 | E >>> 22) + g | 0, _ += (g ^ (E | ~w)) + m[6] - 1560198380 | 0, _ = (_ << 15 | _ >>> 17) + E | 0, w += (E ^ (_ | ~g)) + m[13] + 1309151649 | 0, w = (w << 21 | w >>> 11) + _ | 0, g += (_ ^ (w | ~E)) + m[4] - 145523070 | 0, g = (g << 6 | g >>> 26) + w | 0, E += (w ^ (g | ~_)) + m[11] - 1120210379 | 0, E = (E << 10 | E >>> 22) + g | 0, _ += (g ^ (E | ~w)) + m[2] + 718787259 | 0, _ = (_ << 15 | _ >>> 17) + E | 0, w += (E ^ (_ | ~g)) + m[9] - 343485551 | 0, w = (w << 21 | w >>> 11) + _ | 0, f[0] = g + f[0] | 0, f[1] = w + f[1] | 0, f[2] = _ + f[2] | 0, f[3] = E + f[3] | 0;
    }
    function s(f) {
      var m = [], g;
      for (g = 0; g < 64; g += 4)
        m[g >> 2] = f.charCodeAt(g) + (f.charCodeAt(g + 1) << 8) + (f.charCodeAt(g + 2) << 16) + (f.charCodeAt(g + 3) << 24);
      return m;
    }
    function o(f) {
      var m = [], g;
      for (g = 0; g < 64; g += 4)
        m[g >> 2] = f[g] + (f[g + 1] << 8) + (f[g + 2] << 16) + (f[g + 3] << 24);
      return m;
    }
    function a(f) {
      var m = f.length, g = [1732584193, -271733879, -1732584194, 271733878], w, _, E, C, T, k;
      for (w = 64; w <= m; w += 64)
        i(g, s(f.substring(w - 64, w)));
      for (f = f.substring(w - 64), _ = f.length, E = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], w = 0; w < _; w += 1)
        E[w >> 2] |= f.charCodeAt(w) << (w % 4 << 3);
      if (E[w >> 2] |= 128 << (w % 4 << 3), w > 55)
        for (i(g, E), w = 0; w < 16; w += 1)
          E[w] = 0;
      return C = m * 8, C = C.toString(16).match(/(.*?)(.{0,8})$/), T = parseInt(C[2], 16), k = parseInt(C[1], 16) || 0, E[14] = T, E[15] = k, i(g, E), g;
    }
    function l(f) {
      var m = f.length, g = [1732584193, -271733879, -1732584194, 271733878], w, _, E, C, T, k;
      for (w = 64; w <= m; w += 64)
        i(g, o(f.subarray(w - 64, w)));
      for (f = w - 64 < m ? f.subarray(w - 64) : new Uint8Array(0), _ = f.length, E = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], w = 0; w < _; w += 1)
        E[w >> 2] |= f[w] << (w % 4 << 3);
      if (E[w >> 2] |= 128 << (w % 4 << 3), w > 55)
        for (i(g, E), w = 0; w < 16; w += 1)
          E[w] = 0;
      return C = m * 8, C = C.toString(16).match(/(.*?)(.{0,8})$/), T = parseInt(C[2], 16), k = parseInt(C[1], 16) || 0, E[14] = T, E[15] = k, i(g, E), g;
    }
    function u(f) {
      var m = "", g;
      for (g = 0; g < 4; g += 1)
        m += r[f >> g * 8 + 4 & 15] + r[f >> g * 8 & 15];
      return m;
    }
    function c(f) {
      var m;
      for (m = 0; m < f.length; m += 1)
        f[m] = u(f[m]);
      return f.join("");
    }
    c(a("hello")), typeof ArrayBuffer < "u" && !ArrayBuffer.prototype.slice && function() {
      function f(m, g) {
        return m = m | 0 || 0, m < 0 ? Math.max(m + g, 0) : Math.min(m, g);
      }
      ArrayBuffer.prototype.slice = function(m, g) {
        var w = this.byteLength, _ = f(m, w), E = w, C, T, k, N;
        return g !== n && (E = f(g, w)), _ > E ? new ArrayBuffer(0) : (C = E - _, T = new ArrayBuffer(C), k = new Uint8Array(T), N = new Uint8Array(this, _, C), k.set(N), T);
      };
    }();
    function d(f) {
      return /[\u0080-\uFFFF]/.test(f) && (f = unescape(encodeURIComponent(f))), f;
    }
    function h(f, m) {
      var g = f.length, w = new ArrayBuffer(g), _ = new Uint8Array(w), E;
      for (E = 0; E < g; E += 1)
        _[E] = f.charCodeAt(E);
      return m ? _ : w;
    }
    function v(f) {
      return String.fromCharCode.apply(null, new Uint8Array(f));
    }
    function y(f, m, g) {
      var w = new Uint8Array(f.byteLength + m.byteLength);
      return w.set(new Uint8Array(f)), w.set(new Uint8Array(m), f.byteLength), g ? w : w.buffer;
    }
    function b(f) {
      var m = [], g = f.length, w;
      for (w = 0; w < g - 1; w += 2)
        m.push(parseInt(f.substr(w, 2), 16));
      return String.fromCharCode.apply(String, m);
    }
    function p() {
      this.reset();
    }
    return p.prototype.append = function(f) {
      return this.appendBinary(d(f)), this;
    }, p.prototype.appendBinary = function(f) {
      this._buff += f, this._length += f.length;
      var m = this._buff.length, g;
      for (g = 64; g <= m; g += 64)
        i(this._hash, s(this._buff.substring(g - 64, g)));
      return this._buff = this._buff.substring(g - 64), this;
    }, p.prototype.end = function(f) {
      var m = this._buff, g = m.length, w, _ = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], E;
      for (w = 0; w < g; w += 1)
        _[w >> 2] |= m.charCodeAt(w) << (w % 4 << 3);
      return this._finish(_, g), E = c(this._hash), f && (E = b(E)), this.reset(), E;
    }, p.prototype.reset = function() {
      return this._buff = "", this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this;
    }, p.prototype.getState = function() {
      return {
        buff: this._buff,
        length: this._length,
        hash: this._hash.slice()
      };
    }, p.prototype.setState = function(f) {
      return this._buff = f.buff, this._length = f.length, this._hash = f.hash, this;
    }, p.prototype.destroy = function() {
      delete this._hash, delete this._buff, delete this._length;
    }, p.prototype._finish = function(f, m) {
      var g = m, w, _, E;
      if (f[g >> 2] |= 128 << (g % 4 << 3), g > 55)
        for (i(this._hash, f), g = 0; g < 16; g += 1)
          f[g] = 0;
      w = this._length * 8, w = w.toString(16).match(/(.*?)(.{0,8})$/), _ = parseInt(w[2], 16), E = parseInt(w[1], 16) || 0, f[14] = _, f[15] = E, i(this._hash, f);
    }, p.hash = function(f, m) {
      return p.hashBinary(d(f), m);
    }, p.hashBinary = function(f, m) {
      var g = a(f), w = c(g);
      return m ? b(w) : w;
    }, p.ArrayBuffer = function() {
      this.reset();
    }, p.ArrayBuffer.prototype.append = function(f) {
      var m = y(this._buff.buffer, f, !0), g = m.length, w;
      for (this._length += f.byteLength, w = 64; w <= g; w += 64)
        i(this._hash, o(m.subarray(w - 64, w)));
      return this._buff = w - 64 < g ? new Uint8Array(m.buffer.slice(w - 64)) : new Uint8Array(0), this;
    }, p.ArrayBuffer.prototype.end = function(f) {
      var m = this._buff, g = m.length, w = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], _, E;
      for (_ = 0; _ < g; _ += 1)
        w[_ >> 2] |= m[_] << (_ % 4 << 3);
      return this._finish(w, g), E = c(this._hash), f && (E = b(E)), this.reset(), E;
    }, p.ArrayBuffer.prototype.reset = function() {
      return this._buff = new Uint8Array(0), this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this;
    }, p.ArrayBuffer.prototype.getState = function() {
      var f = p.prototype.getState.call(this);
      return f.buff = v(f.buff), f;
    }, p.ArrayBuffer.prototype.setState = function(f) {
      return f.buff = h(f.buff, !0), p.prototype.setState.call(this, f);
    }, p.ArrayBuffer.prototype.destroy = p.prototype.destroy, p.ArrayBuffer.prototype._finish = p.prototype._finish, p.ArrayBuffer.hash = function(f, m) {
      var g = l(new Uint8Array(f)), w = c(g);
      return m ? b(w) : w;
    }, p;
  });
})(F8);
/*!
  * pinia v2.0.23
  * (c) 2022 Eduardo San Martin Morote
  * @license MIT
  */
let so;
const wl = (t) => so = t, j8 = process.env.NODE_ENV !== "production" ? Symbol("pinia") : (
  /* istanbul ignore next */
  Symbol()
);
function Vi(t) {
  return t && typeof t == "object" && Object.prototype.toString.call(t) === "[object Object]" && typeof t.toJSON != "function";
}
var yo;
(function(t) {
  t.direct = "direct", t.patchObject = "patch object", t.patchFunction = "patch function";
})(yo || (yo = {}));
const hf = typeof window < "u", $u = (process.env.NODE_ENV !== "production" || !1) && process.env.NODE_ENV !== "test" && hf;
function x0(t, e) {
  for (const n in e) {
    const r = e[n];
    if (!(n in t))
      continue;
    const i = t[n];
    Vi(i) && Vi(r) && !on(r) && !Bl(r) ? t[n] = x0(i, r) : t[n] = r;
  }
  return t;
}
const C0 = () => {
};
function Rp(t, e, n, r = C0) {
  t.push(e);
  const i = () => {
    const s = t.indexOf(e);
    s > -1 && (t.splice(s, 1), r());
  };
  return !n && ht() && Wo(i), i;
}
function os(t, ...e) {
  t.slice().forEach((n) => {
    n(...e);
  });
}
function Xc(t, e) {
  t instanceof Map && e instanceof Map && e.forEach((n, r) => t.set(r, n)), t instanceof Set && e instanceof Set && e.forEach(t.add, t);
  for (const n in e) {
    if (!e.hasOwnProperty(n))
      continue;
    const r = e[n], i = t[n];
    Vi(i) && Vi(r) && t.hasOwnProperty(n) && !on(r) && !Bl(r) ? t[n] = Xc(i, r) : t[n] = r;
  }
  return t;
}
const U8 = process.env.NODE_ENV !== "production" ? Symbol("pinia:skipHydration") : (
  /* istanbul ignore next */
  Symbol()
);
function V8(t) {
  return !Vi(t) || !t.hasOwnProperty(U8);
}
const { assign: dr } = Object;
function Lp(t) {
  return !!(on(t) && t.effect);
}
function Pp(t, e, n, r) {
  const { state: i, actions: s, getters: o } = e, a = n.state.value[t];
  let l;
  function u() {
    !a && (process.env.NODE_ENV === "production" || !r) && (n.state.value[t] = i ? i() : {});
    const c = process.env.NODE_ENV !== "production" && r ? (
      // use ref() to unwrap refs inside state TODO: check if this is still necessary
      hn(K(i ? i() : {}).value)
    ) : hn(n.state.value[t]);
    return dr(c, s, Object.keys(o || {}).reduce((d, h) => (process.env.NODE_ENV !== "production" && h in c && console.warn(`[🍍]: A getter cannot have the same name as another state property. Rename one of them. Found with "${h}" in store "${t}".`), d[h] = Ur(F(() => {
      wl(n);
      const v = n._s.get(t);
      return o[h].call(v, v);
    })), d), {}));
  }
  return l = Zc(t, u, e, n, r, !0), l.$reset = function() {
    const d = i ? i() : {};
    this.$patch((h) => {
      dr(h, d);
    });
  }, l;
}
function Zc(t, e, n = {}, r, i, s) {
  let o;
  const a = dr({ actions: {} }, n);
  if (process.env.NODE_ENV !== "production" && !r._e.active)
    throw new Error("Pinia destroyed");
  const l = {
    deep: !0
    // flush: 'post',
  };
  process.env.NODE_ENV !== "production" && !tb && (l.onTrigger = (k) => {
    u ? v = k : u == !1 && !C._hotUpdating && (Array.isArray(v) ? v.push(k) : console.error("🍍 debuggerEvents should be an array. This is most likely an internal Pinia bug."));
  });
  let u, c, d = Ur([]), h = Ur([]), v;
  const y = r.state.value[t];
  !s && !y && (process.env.NODE_ENV === "production" || !i) && (r.state.value[t] = {});
  const b = K({});
  let p;
  function f(k) {
    let N;
    u = c = !1, process.env.NODE_ENV !== "production" && (v = []), typeof k == "function" ? (k(r.state.value[t]), N = {
      type: yo.patchFunction,
      storeId: t,
      events: v
    }) : (Xc(r.state.value[t], k), N = {
      type: yo.patchObject,
      payload: k,
      storeId: t,
      events: v
    });
    const I = p = Symbol();
    rt().then(() => {
      p === I && (u = !0);
    }), c = !0, os(d, N, r.state.value[t]);
  }
  const m = process.env.NODE_ENV !== "production" ? () => {
    throw new Error(`🍍: Store "${t}" is built using the setup syntax and does not implement $reset().`);
  } : C0;
  function g() {
    o.stop(), d = [], h = [], r._s.delete(t);
  }
  function w(k, N) {
    return function() {
      wl(r);
      const I = Array.from(arguments), P = [], D = [];
      function z(M) {
        P.push(M);
      }
      function G(M) {
        D.push(M);
      }
      os(h, {
        args: I,
        name: k,
        store: C,
        after: z,
        onError: G
      });
      let J;
      try {
        J = N.apply(this && this.$id === t ? this : C, I);
      } catch (M) {
        throw os(D, M), M;
      }
      return J instanceof Promise ? J.then((M) => (os(P, M), M)).catch((M) => (os(D, M), Promise.reject(M))) : (os(P, J), J);
    };
  }
  const _ = /* @__PURE__ */ Ur({
    actions: {},
    getters: {},
    state: [],
    hotState: b
  }), E = {
    _p: r,
    // _s: scope,
    $id: t,
    $onAction: Rp.bind(null, h),
    $patch: f,
    $reset: m,
    $subscribe(k, N = {}) {
      const I = Rp(d, k, N.detached, () => P()), P = o.run(() => ke(() => r.state.value[t], (D) => {
        (N.flush === "sync" ? c : u) && k({
          storeId: t,
          type: yo.direct,
          events: v
        }, D);
      }, dr({}, l, N)));
      return I;
    },
    $dispose: g
  }, C = Pn(process.env.NODE_ENV !== "production" || $u ? dr(
    {
      _hmrPayload: _,
      _customProperties: Ur(/* @__PURE__ */ new Set())
      // devtools custom properties
    },
    E
    // must be added later
    // setupStore
  ) : E);
  r._s.set(t, C);
  const T = r._e.run(() => (o = yv(), o.run(() => e())));
  for (const k in T) {
    const N = T[k];
    if (on(N) && !Lp(N) || Bl(N))
      process.env.NODE_ENV !== "production" && i ? ha(b.value, k, Tn(T, k)) : s || (y && V8(N) && (on(N) ? N.value = y[k] : Xc(N, y[k])), r.state.value[t][k] = N), process.env.NODE_ENV !== "production" && _.state.push(k);
    else if (typeof N == "function") {
      const I = process.env.NODE_ENV !== "production" && i ? N : w(k, N);
      T[k] = I, process.env.NODE_ENV !== "production" && (_.actions[k] = N), a.actions[k] = N;
    } else
      process.env.NODE_ENV !== "production" && Lp(N) && (_.getters[k] = s ? (
        // @ts-expect-error
        n.getters[k]
      ) : N, hf && (T._getters || // @ts-expect-error: same
      (T._getters = Ur([]))).push(k));
  }
  if (dr(C, T), dr(yi(C), T), Object.defineProperty(C, "$state", {
    get: () => process.env.NODE_ENV !== "production" && i ? b.value : r.state.value[t],
    set: (k) => {
      if (process.env.NODE_ENV !== "production" && i)
        throw new Error("cannot set hotState");
      f((N) => {
        dr(N, k);
      });
    }
  }), process.env.NODE_ENV !== "production" && (C._hotUpdate = Ur((k) => {
    C._hotUpdating = !0, k._hmrPayload.state.forEach((N) => {
      if (N in C.$state) {
        const I = k.$state[N], P = C.$state[N];
        typeof I == "object" && Vi(I) && Vi(P) ? x0(I, P) : k.$state[N] = P;
      }
      ha(C, N, Tn(k.$state, N));
    }), Object.keys(C.$state).forEach((N) => {
      N in k.$state || fu(C, N);
    }), u = !1, c = !1, r.state.value[t] = Tn(k._hmrPayload, "hotState"), c = !0, rt().then(() => {
      u = !0;
    });
    for (const N in k._hmrPayload.actions) {
      const I = k[N];
      ha(C, N, w(N, I));
    }
    for (const N in k._hmrPayload.getters) {
      const I = k._hmrPayload.getters[N], P = s ? (
        // special handling of options api
        F(() => (wl(r), I.call(C, C)))
      ) : I;
      ha(C, N, P);
    }
    Object.keys(C._hmrPayload.getters).forEach((N) => {
      N in k._hmrPayload.getters || fu(C, N);
    }), Object.keys(C._hmrPayload.actions).forEach((N) => {
      N in k._hmrPayload.actions || fu(C, N);
    }), C._hmrPayload = k._hmrPayload, C._getters = k._getters, C._hotUpdating = !1;
  })), $u) {
    const k = {
      writable: !0,
      configurable: !0,
      // avoid warning on devtools trying to display this property
      enumerable: !1
    };
    ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach((N) => {
      Object.defineProperty(C, N, {
        value: C[N],
        ...k
      });
    });
  }
  return r._p.forEach((k) => {
    if ($u) {
      const N = o.run(() => k({
        store: C,
        app: r._a,
        pinia: r,
        options: a
      }));
      Object.keys(N || {}).forEach((I) => C._customProperties.add(I)), dr(C, N);
    } else
      dr(C, o.run(() => k({
        store: C,
        app: r._a,
        pinia: r,
        options: a
      })));
  }), process.env.NODE_ENV !== "production" && C.$state && typeof C.$state == "object" && typeof C.$state.constructor == "function" && !C.$state.constructor.toString().includes("[native code]") && console.warn(`[🍍]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${C.$id}".`), y && s && n.hydrate && n.hydrate(C.$state, y), u = !0, c = !0, C;
}
function W8(t, e, n) {
  let r, i;
  const s = typeof e == "function";
  typeof t == "string" ? (r = t, i = s ? n : e) : (i = t, r = t.id);
  function o(a, l) {
    const u = ht();
    if (a = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    (process.env.NODE_ENV === "test" && so && so._testing ? null : a) || u && tt(j8), a && wl(a), process.env.NODE_ENV !== "production" && !so)
      throw new Error(`[🍍]: getActivePinia was called with no active Pinia. Did you forget to install pinia?
	const pinia = createPinia()
	app.use(pinia)
This will fail in production.`);
    a = so, a._s.has(r) || (s ? Zc(r, e, i, a) : Pp(r, i, a), process.env.NODE_ENV !== "production" && (o._pinia = a));
    const c = a._s.get(r);
    if (process.env.NODE_ENV !== "production" && l) {
      const d = "__hot:" + r, h = s ? Zc(d, e, i, a, !0) : Pp(d, dr({}, i), a, !0);
      l._hotUpdate(h), delete a.state.value[d], a._s.delete(d);
    }
    if (process.env.NODE_ENV !== "production" && hf && u && u.proxy && // avoid adding stores that are just built for hot module replacement
    !l) {
      const d = u.proxy, h = "_pStores" in d ? d._pStores : d._pStores = {};
      h[r] = c;
    }
    return c;
  }
  return o.$id = r, o;
}
function H8(t) {
  {
    t = yi(t);
    const e = {};
    for (const n in t) {
      const r = t[n];
      (on(r) || Bl(r)) && (e[n] = // ---
      Tn(t, n));
    }
    return e;
  }
}
const K8 = [
  {
    date: "2018-10-20T16:00:00+00:00",
    creator: "陈浩基",
    creatorFileAs: "陈浩基",
    UUID: "DB108833-1D43-4711-A2D0-240E07B37352",
    language: "zh",
    title: "13.67",
    "calibre:timestamp": "2019-09-20T03:57:38.859000+00:00",
    "calibre:title_sort": "13.67",
    cover: "cover",
    id: "54a785173f1a484c02e53418730b24b5",
    coverPath: "https://firebasestorage.googleapis.com/v0/b/nuxtbooks-4972c.appspot.com/o/images%2FWomanCover.png?alt=media&token=b24ccf50-be46-43d4-88f2-b332f282eeec",
    url: "https://firebasestorage.googleapis.com/v0/b/nuxtbooks-4972c.appspot.com/o/bookFiles%2Falice.epub?alt=media&token=4e9e82e6-b7c9-4448-8405-4b0d994a3957",
    bgColorFromCover: "#076184",
    size: 435507,
    from: "url"
  }
], Ws = W8("reader", {
  state: () => ({
    theme: "default",
    flow: "paginated",
    font: "",
    lineSpacing: 1.5,
    fontSize: 100,
    bookList: K8
  }),
  actions: {
    setTheme(t) {
      this.theme = t;
    },
    reset() {
      this.theme = "default", this.flow = "paginated", this.font = "", this.lineSpacing = 1.5, this.fontSize = 100;
    },
    setBook(t, e) {
      const n = this.bookList.findIndex((r) => r.id === t);
      n > -1 && (this.bookList[n] = e);
    },
    addBook({ id: t, uuid: e, pubDate: n, author: r, language: i, title: s, coverPath: o, url: a }) {
      const l = {
        readibleId: t,
        date: n,
        creator: r,
        UUID: e,
        language: i,
        title: s,
        coverPath: o,
        url: a,
        bgColorFromCover: "#076184",
        size: 435507,
        from: "url"
      };
      this.bookList.push(l);
    },
    hasBook(t) {
      for (let e = 0; e < this.bookList.length; e++)
        if (this.bookList[e].readibleId && this.bookList[e].readibleId === t)
          return !0;
      return !1;
    },
    delBook(t) {
      const e = this.bookList.findIndex((n) => t === n.id);
      e > -1 && this.bookList.splice(e, 1);
    },
    delBookByID(t) {
      for (let e = 0; e < this.bookList.length; e++)
        if (this.bookList[e].readibleId && this.bookList[e].readibleId === t) {
          this.delBook(e);
          return;
        }
    }
  },
  persist: !0
});
const q8 = { class: "image-slot" }, G8 = { key: 0 }, Y8 = { key: 1 }, X8 = { key: 2 }, Z8 = ["title"], Q8 = { key: 3 }, J8 = { key: 4 }, eP = { key: 5 }, tP = { key: 6 }, nP = {
  __name: "Home",
  props: {
    useMin: {
      type: Boolean,
      default: !1
    },
    maxCols: {
      type: Number,
      // Maximum number of colums. Default: Infinite
      default: 1 / 0
    }
  },
  emits: ["update:currentBook"],
  setup(t, { emit: e }) {
    const n = Ws();
    console.log("Imported Books: ", n.bookList.length);
    const r = n.bookList.sort((z, G) => z.lastOpen && G.lastOpen ? G.lastOpen - z.lastOpen : 1);
    console.log("Books: ", r);
    const { saveAs: i } = qL, s = K(null), o = K(null), a = Pn({
      maxColWidth: 280,
      gap: 32
    });
    let l = [];
    const { maxColWidth: u, gap: c } = hn(a), d = t, { useMin: h, maxCols: v } = d;
    Tt(async () => {
      r.length && (p(), f(), window.addEventListener("resize", C));
    }), Sn(() => {
      window.removeEventListener("resize", C);
    });
    const y = (z, G) => z.length > G ? `${z.substr(0, G - 3)}...` : z, b = (z) => {
      const G = new Date(z), J = G.getFullYear(), M = G.getMonth() + 1, U = G.getDay();
      return `${J}-${M}-${U}`;
    }, p = () => {
      l = s.value.children, l.length !== 0 && (o.value.$el.style.position = "relative", Array.prototype.forEach.call(l, (z) => {
        z.style.position = "absolute", z.style.maxWidth = `${u.value}px`, z.style.transition = "top 0.2s ease, left 0.2s ease, right 0.2s ease, buttom 0.2s ease";
      }));
    }, f = () => {
      if (l.length === 0)
        return;
      let { cols: z, wSpace: G } = E();
      G = Math.floor(G / 2), Array.prototype.forEach.call(l, (J, M) => {
        const U = m(z, M), j = U.index * g() + G;
        J.style.left = `${j}px`, J.style.top = `${U.height + U.top}px`, U.height += U.top + J.getBoundingClientRect().height, U.top = c.value;
      }), o.value.$el.style.height = `${_(z).height}px`;
    }, m = (z, G) => h ? w(z) : z[G % z.length], g = () => l[0].getBoundingClientRect().width + c.value, w = (z) => {
      let G = z[0];
      return z.forEach((J) => {
        J.height < G.height && (G = J);
      }), G;
    }, _ = (z) => {
      let G = z[0];
      return z.forEach((J) => {
        J.height > G.height && (G = J);
      }), G;
    }, E = () => {
      const { width: z } = o.value.$el.getBoundingClientRect();
      let G = Math.floor(z / g()) || 1;
      const J = [];
      v && G > v && (G = v);
      for (let U = 0; U < G; U += 1)
        J[U] = {
          height: 0,
          top: 0,
          index: U
        };
      const M = z - G * g() + c.value;
      return {
        cols: J,
        wSpace: M
      };
    }, C = () => {
      setTimeout(f(), 200);
    }, T = (z) => z / 1024 / 1024 > 1 ? parseFloat(z / 1024 / 1024 + "").toFixed(2) + "Mb" : parseInt(z / 1024 + "") + "Kb", k = (z) => {
      i("/books/" + z, z);
    }, N = e, I = (z) => {
      console.log("Reader book url type: ", typeof z.url), console.log("Reader book byte length: ", z.url.byteLength), console.log("Reader book url: ", z.url), N("update:currentBook", z);
    }, P = async (z) => {
      const { raw: G, name: J, size: M } = z, U = new FileReader();
      U.onerror = (j) => {
        console.log(j);
      }, U.onloadend = (j) => {
        console.log(U), N("update:currentBook", U.result);
      }, U.readAsArrayBuffer(G);
    }, D = (z) => {
      n.delBook(z);
    };
    return (z, G) => {
      const J = Xi, M = $L, U = _t, j = p3, re = HI, fe = ta, Y = zA, le = Sg, ce = Eg;
      return V(), Ce(ce, { direction: "vertical" }, {
        default: de(() => [
          ve(Kg, {
            backdrop: "",
            shadow: ""
          }, {
            default: de(() => [
              ve(M, {
                "auto-upload": !1,
                accept: ".epub",
                "on-change": P,
                multiple: !1,
                "show-file-list": !1
              }, {
                default: de(() => [
                  ve(J, {
                    size: "small",
                    icon: x(um),
                    circle: "",
                    title: "Add To Library"
                  }, null, 8, ["icon"])
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          ve(le, {
            class: "main",
            ref_key: "main",
            ref: o
          }, {
            default: de(() => [
              ae("div", {
                class: "grid",
                ref_key: "grid",
                ref: s
              }, [
                (V(!0), se(Ft, null, Gn(x(r), (me, _e) => (V(), se("div", { key: _e }, [
                  ve(Y, {
                    onClick: (ze) => I(me),
                    ref_for: !0,
                    ref: "card",
                    shadow: "hover",
                    class: "box-card",
                    "body-style": { padding: "0px" }
                  }, {
                    default: de(() => [
                      ve(j, {
                        lazy: !0,
                        src: me.coverPath,
                        fit: "fill",
                        class: "el-image"
                      }, {
                        error: de(() => [
                          ae("div", q8, [
                            ve(U, null, {
                              default: de(() => [
                                ve(x(VC))
                              ]),
                              _: 1
                            })
                          ])
                        ]),
                        _: 2
                      }, 1032, ["src"]),
                      ve(fe, {
                        trigger: "hover",
                        placement: "right"
                      }, {
                        reference: de(() => [
                          ae("div", {
                            class: "title",
                            style: it({
                              background: me.bgColorFromCover ? me.bgColorFromCover : "#6d6d6d"
                            })
                          }, st(y(me.title, 12)), 5)
                        ]),
                        default: de(() => [
                          ae("div", null, [
                            ae("p", null, [
                              ve(J, {
                                type: "primary",
                                round: "",
                                icon: x(tC),
                                onClick: (ze) => k(me.url)
                              }, {
                                default: de(() => [
                                  cn("Download")
                                ]),
                                _: 2
                              }, 1032, ["icon", "onClick"])
                            ]),
                            ae("p", null, [
                              ve(J, {
                                type: "primary",
                                round: "",
                                icon: x(am),
                                onClick: (ze) => D(me.id)
                              }, {
                                default: de(() => [
                                  cn("Delete")
                                ]),
                                _: 2
                              }, 1032, ["icon", "onClick"])
                            ]),
                            ve(re),
                            me.title ? (V(), se("p", G8, "Title: " + st(me.title), 1)) : ye("", !0),
                            me.creator ? (V(), se("p", Y8, "Creator: " + st(me.creator), 1)) : ye("", !0),
                            me.description ? (V(), se("p", X8, [
                              cn(" Description: "),
                              ae("span", {
                                title: me.description
                              }, st(y(me.description, 30)), 9, Z8)
                            ])) : ye("", !0),
                            me.publisher ? (V(), se("p", Q8, "Publisher: " + st(me.publisher), 1)) : ye("", !0),
                            me.date ? (V(), se("p", J8, " Pub Date: " + st(b(me.date) || b(me.publishDate)), 1)) : ye("", !0),
                            me.language ? (V(), se("p", eP, "Language: " + st(me.language), 1)) : ye("", !0),
                            me.size ? (V(), se("p", tP, "File Size: " + st(T(me.size)), 1)) : ye("", !0)
                          ])
                        ]),
                        _: 2
                      }, 1024)
                    ]),
                    _: 2
                  }, 1032, ["onClick"])
                ]))), 128))
              ], 512)
            ]),
            _: 1
          }, 512)
        ]),
        _: 1
      });
    };
  }
}, rP = /* @__PURE__ */ Zi(nP, [["__scopeId", "data-v-8880a628"]]);
var _l = {}, iP = {
  get exports() {
    return _l;
  },
  set exports(t) {
    _l = t;
  }
}, Qc = {}, sP = {
  get exports() {
    return Qc;
  },
  set exports(t) {
    Qc = t;
  }
}, oP = void 0, k0 = function(t) {
  return t !== oP && t !== null;
}, aP = k0, lP = {
  object: !0,
  function: !0,
  undefined: !0
  /* document.all */
}, uP = function(t) {
  return aP(t) ? hasOwnProperty.call(lP, typeof t) : !1;
}, cP = uP, dP = function(t) {
  if (!cP(t))
    return !1;
  try {
    return t.constructor ? t.constructor.prototype === t : !1;
  } catch {
    return !1;
  }
}, fP = dP, hP = function(t) {
  if (typeof t != "function" || !hasOwnProperty.call(t, "length"))
    return !1;
  try {
    if (typeof t.length != "number" || typeof t.call != "function" || typeof t.apply != "function")
      return !1;
  } catch {
    return !1;
  }
  return !fP(t);
}, pP = hP, vP = /^\s*class[\s{/}]/, mP = Function.prototype.toString, gP = function(t) {
  return !(!pP(t) || vP.test(mP.call(t)));
}, yP = function() {
  var t = Object.assign, e;
  return typeof t != "function" ? !1 : (e = { foo: "raz" }, t(e, { bar: "dwa" }, { trzy: "trzy" }), e.foo + e.bar + e.trzy === "razdwatrzy");
}, Du, $p;
function bP() {
  return $p || ($p = 1, Du = function() {
    try {
      return Object.keys("primitive"), !0;
    } catch {
      return !1;
    }
  }), Du;
}
var wP = function() {
}, _P = wP(), pf = function(t) {
  return t !== _P && t !== null;
}, Bu, Dp;
function EP() {
  if (Dp)
    return Bu;
  Dp = 1;
  var t = pf, e = Object.keys;
  return Bu = function(n) {
    return e(t(n) ? Object(n) : n);
  }, Bu;
}
var Mu, Bp;
function SP() {
  return Bp || (Bp = 1, Mu = bP()() ? Object.keys : EP()), Mu;
}
var zu, Mp;
function xP() {
  if (Mp)
    return zu;
  Mp = 1;
  var t = pf;
  return zu = function(e) {
    if (!t(e))
      throw new TypeError("Cannot use null or undefined");
    return e;
  }, zu;
}
var Fu, zp;
function CP() {
  if (zp)
    return Fu;
  zp = 1;
  var t = SP(), e = xP(), n = Math.max;
  return Fu = function(r, i) {
    var s, o, a = n(arguments.length, 2), l;
    for (r = Object(e(r)), l = function(u) {
      try {
        r[u] = i[u];
      } catch (c) {
        s || (s = c);
      }
    }, o = 1; o < a; ++o)
      i = arguments[o], t(i).forEach(l);
    if (s !== void 0)
      throw s;
    return r;
  }, Fu;
}
var kP = yP() ? Object.assign : CP(), TP = pf, OP = Array.prototype.forEach, NP = Object.create, AP = function(t, e) {
  var n;
  for (n in t)
    e[n] = t[n];
}, IP = function(t) {
  var e = NP(null);
  return OP.call(arguments, function(n) {
    TP(n) && AP(Object(n), e);
  }), e;
}, ju = "razdwatrzy", RP = function() {
  return typeof ju.contains != "function" ? !1 : ju.contains("dwa") === !0 && ju.contains("foo") === !1;
}, Uu, Fp;
function LP() {
  if (Fp)
    return Uu;
  Fp = 1;
  var t = String.prototype.indexOf;
  return Uu = function(e) {
    return t.call(this, e, arguments[1]) > -1;
  }, Uu;
}
var PP = RP() ? String.prototype.contains : LP(), Qa = k0, jp = gP, T0 = kP, O0 = IP, bo = PP, $P = sP.exports = function(t, e) {
  var n, r, i, s, o;
  return arguments.length < 2 || typeof t != "string" ? (s = e, e = t, t = null) : s = arguments[2], Qa(t) ? (n = bo.call(t, "c"), r = bo.call(t, "e"), i = bo.call(t, "w")) : (n = i = !0, r = !1), o = { value: e, configurable: n, enumerable: r, writable: i }, s ? T0(O0(s), o) : o;
};
$P.gs = function(t, e, n) {
  var r, i, s, o;
  return typeof t != "string" ? (s = n, n = e, e = t, t = null) : s = arguments[3], Qa(e) ? jp(e) ? Qa(n) ? jp(n) || (s = n, n = void 0) : n = void 0 : (s = e, e = n = void 0) : e = void 0, Qa(t) ? (r = bo.call(t, "c"), i = bo.call(t, "e")) : (r = !0, i = !1), o = { get: e, set: n, configurable: r, enumerable: i }, s ? T0(O0(s), o) : o;
};
var DP = function(t) {
  if (typeof t != "function")
    throw new TypeError(t + " is not a function");
  return t;
};
(function(t, e) {
  var n = Qc, r = DP, i = Function.prototype.apply, s = Function.prototype.call, o = Object.create, a = Object.defineProperty, l = Object.defineProperties, u = Object.prototype.hasOwnProperty, c = { configurable: !0, enumerable: !1, writable: !0 }, d, h, v, y, b, p, f;
  d = function(m, g) {
    var w;
    return r(g), u.call(this, "__ee__") ? w = this.__ee__ : (w = c.value = o(null), a(this, "__ee__", c), c.value = null), w[m] ? typeof w[m] == "object" ? w[m].push(g) : w[m] = [w[m], g] : w[m] = g, this;
  }, h = function(m, g) {
    var w, _;
    return r(g), _ = this, d.call(this, m, w = function() {
      v.call(_, m, w), i.call(g, this, arguments);
    }), w.__eeOnceListener__ = g, this;
  }, v = function(m, g) {
    var w, _, E, C;
    if (r(g), !u.call(this, "__ee__"))
      return this;
    if (w = this.__ee__, !w[m])
      return this;
    if (_ = w[m], typeof _ == "object")
      for (C = 0; E = _[C]; ++C)
        (E === g || E.__eeOnceListener__ === g) && (_.length === 2 ? w[m] = _[C ? 0 : 1] : _.splice(C, 1));
    else
      (_ === g || _.__eeOnceListener__ === g) && delete w[m];
    return this;
  }, y = function(m) {
    var g, w, _, E, C;
    if (u.call(this, "__ee__") && (E = this.__ee__[m], !!E))
      if (typeof E == "object") {
        for (w = arguments.length, C = new Array(w - 1), g = 1; g < w; ++g)
          C[g - 1] = arguments[g];
        for (E = E.slice(), g = 0; _ = E[g]; ++g)
          i.call(_, this, C);
      } else
        switch (arguments.length) {
          case 1:
            s.call(E, this);
            break;
          case 2:
            s.call(E, this, arguments[1]);
            break;
          case 3:
            s.call(E, this, arguments[1], arguments[2]);
            break;
          default:
            for (w = arguments.length, C = new Array(w - 1), g = 1; g < w; ++g)
              C[g - 1] = arguments[g];
            i.call(E, this, C);
        }
  }, b = {
    on: d,
    once: h,
    off: v,
    emit: y
  }, p = {
    on: n(d),
    once: n(h),
    off: n(v),
    emit: n(y)
  }, f = l({}, p), t.exports = e = function(m) {
    return m == null ? o(f) : l(Object(m), p);
  }, e.methods = b;
})(iP, _l);
const Br = _l;
var xi = {}, Ci = {};
function BP(t, e, n) {
  if (n === void 0 && (n = Array.prototype), t && typeof n.find == "function")
    return n.find.call(t, e);
  for (var r = 0; r < t.length; r++)
    if (Object.prototype.hasOwnProperty.call(t, r)) {
      var i = t[r];
      if (e.call(void 0, i, r, t))
        return i;
    }
}
function vf(t, e) {
  return e === void 0 && (e = Object), e && typeof e.freeze == "function" ? e.freeze(t) : t;
}
var N0 = vf({
  /**
   * `text/html`, the only mime type that triggers treating an XML document as HTML.
   *
   * @see DOMParser.SupportedType.isHTML
   * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/HTML Wikipedia
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
   * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
   */
  HTML: "text/html",
  /**
   * Helper method to check a mime type if it indicates an HTML document
   *
   * @param {string} [value]
   * @returns {boolean}
   *
   * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/HTML Wikipedia
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
   * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
  isHTML: function(t) {
    return t === N0.HTML;
  },
  /**
   * `application/xml`, the standard mime type for XML documents.
   *
   * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
   * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
   * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
   */
  XML_APPLICATION: "application/xml",
  /**
   * `text/html`, an alias for `application/xml`.
   *
   * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
   * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
   */
  XML_TEXT: "text/xml",
  /**
   * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
   * but is parsed as an XML document.
   *
   * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
   * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
   */
  XML_XHTML_APPLICATION: "application/xhtml+xml",
  /**
   * `image/svg+xml`,
   *
   * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
   * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
   * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
   */
  XML_SVG_IMAGE: "image/svg+xml"
}), A0 = vf({
  /**
   * The XHTML namespace.
   *
   * @see http://www.w3.org/1999/xhtml
   */
  HTML: "http://www.w3.org/1999/xhtml",
  /**
   * Checks if `uri` equals `NAMESPACE.HTML`.
   *
   * @param {string} [uri]
   *
   * @see NAMESPACE.HTML
   */
  isHTML: function(t) {
    return t === A0.HTML;
  },
  /**
   * The SVG namespace.
   *
   * @see http://www.w3.org/2000/svg
   */
  SVG: "http://www.w3.org/2000/svg",
  /**
   * The `xml:` namespace.
   *
   * @see http://www.w3.org/XML/1998/namespace
   */
  XML: "http://www.w3.org/XML/1998/namespace",
  /**
   * The `xmlns:` namespace
   *
   * @see https://www.w3.org/2000/xmlns/
   */
  XMLNS: "http://www.w3.org/2000/xmlns/"
});
Ci.find = BP;
Ci.freeze = vf;
Ci.MIME_TYPE = N0;
Ci.NAMESPACE = A0;
var I0 = Ci, Cr = I0.find, Mo = I0.NAMESPACE;
function MP(t) {
  return t !== "";
}
function zP(t) {
  return t ? t.split(/[\t\n\f\r ]+/).filter(MP) : [];
}
function FP(t, e) {
  return t.hasOwnProperty(e) || (t[e] = !0), t;
}
function Up(t) {
  if (!t)
    return [];
  var e = zP(t);
  return Object.keys(e.reduce(FP, {}));
}
function jP(t) {
  return function(e) {
    return t && t.indexOf(e) !== -1;
  };
}
function sa(t, e) {
  for (var n in t)
    Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
}
function Un(t, e) {
  var n = t.prototype;
  if (!(n instanceof e)) {
    let r = function() {
    };
    r.prototype = e.prototype, r = new r(), sa(n, r), t.prototype = n = r;
  }
  n.constructor != t && (typeof t != "function" && console.error("unknown Class:" + t), n.constructor = t);
}
var Vn = {}, mr = Vn.ELEMENT_NODE = 1, $s = Vn.ATTRIBUTE_NODE = 2, El = Vn.TEXT_NODE = 3, R0 = Vn.CDATA_SECTION_NODE = 4, L0 = Vn.ENTITY_REFERENCE_NODE = 5, UP = Vn.ENTITY_NODE = 6, P0 = Vn.PROCESSING_INSTRUCTION_NODE = 7, $0 = Vn.COMMENT_NODE = 8, D0 = Vn.DOCUMENT_NODE = 9, B0 = Vn.DOCUMENT_TYPE_NODE = 10, ei = Vn.DOCUMENT_FRAGMENT_NODE = 11, VP = Vn.NOTATION_NODE = 12, Nn = {}, pn = {};
Nn.INDEX_SIZE_ERR = (pn[1] = "Index size error", 1);
Nn.DOMSTRING_SIZE_ERR = (pn[2] = "DOMString size error", 2);
var Bn = Nn.HIERARCHY_REQUEST_ERR = (pn[3] = "Hierarchy request error", 3);
Nn.WRONG_DOCUMENT_ERR = (pn[4] = "Wrong document", 4);
Nn.INVALID_CHARACTER_ERR = (pn[5] = "Invalid character", 5);
Nn.NO_DATA_ALLOWED_ERR = (pn[6] = "No data allowed", 6);
Nn.NO_MODIFICATION_ALLOWED_ERR = (pn[7] = "No modification allowed", 7);
var M0 = Nn.NOT_FOUND_ERR = (pn[8] = "Not found", 8);
Nn.NOT_SUPPORTED_ERR = (pn[9] = "Not supported", 9);
var Vp = Nn.INUSE_ATTRIBUTE_ERR = (pn[10] = "Attribute in use", 10);
Nn.INVALID_STATE_ERR = (pn[11] = "Invalid state", 11);
Nn.SYNTAX_ERR = (pn[12] = "Syntax error", 12);
Nn.INVALID_MODIFICATION_ERR = (pn[13] = "Invalid modification", 13);
Nn.NAMESPACE_ERR = (pn[14] = "Invalid namespace", 14);
Nn.INVALID_ACCESS_ERR = (pn[15] = "Invalid access", 15);
function tn(t, e) {
  if (e instanceof Error)
    var n = e;
  else
    n = this, Error.call(this, pn[t]), this.message = pn[t], Error.captureStackTrace && Error.captureStackTrace(this, tn);
  return n.code = t, e && (this.message = this.message + ": " + e), n;
}
tn.prototype = Error.prototype;
sa(Nn, tn);
function Yr() {
}
Yr.prototype = {
  /**
   * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
   * @standard level1
   */
  length: 0,
  /**
   * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
   * @standard level1
   * @param index  unsigned long
   *   Index into the collection.
   * @return Node
   * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
   */
  item: function(t) {
    return this[t] || null;
  },
  toString: function(t, e) {
    for (var n = [], r = 0; r < this.length; r++)
      bs(this[r], n, t, e);
    return n.join("");
  },
  /**
   * @private
   * @param {function (Node):boolean} predicate
   * @returns {Node[]}
   */
  filter: function(t) {
    return Array.prototype.filter.call(this, t);
  },
  /**
   * @private
   * @param {Node} item
   * @returns {number}
   */
  indexOf: function(t) {
    return Array.prototype.indexOf.call(this, t);
  }
};
function Ds(t, e) {
  this._node = t, this._refresh = e, mf(this);
}
function mf(t) {
  var e = t._node._inc || t._node.ownerDocument._inc;
  if (t._inc != e) {
    var n = t._refresh(t._node);
    X0(t, "length", n.length), sa(n, t), t._inc = e;
  }
}
Ds.prototype.item = function(t) {
  return mf(this), this[t];
};
Un(Ds, Yr);
function Sl() {
}
function z0(t, e) {
  for (var n = t.length; n--; )
    if (t[n] === e)
      return n;
}
function Wp(t, e, n, r) {
  if (r ? e[z0(e, r)] = n : e[e.length++] = n, t) {
    n.ownerElement = t;
    var i = t.ownerDocument;
    i && (r && U0(i, t, r), WP(i, t, n));
  }
}
function Hp(t, e, n) {
  var r = z0(e, n);
  if (r >= 0) {
    for (var i = e.length - 1; r < i; )
      e[r] = e[++r];
    if (e.length = i, t) {
      var s = t.ownerDocument;
      s && (U0(s, t, n), n.ownerElement = null);
    }
  } else
    throw new tn(M0, new Error(t.tagName + "@" + n));
}
Sl.prototype = {
  length: 0,
  item: Yr.prototype.item,
  getNamedItem: function(t) {
    for (var e = this.length; e--; ) {
      var n = this[e];
      if (n.nodeName == t)
        return n;
    }
  },
  setNamedItem: function(t) {
    var e = t.ownerElement;
    if (e && e != this._ownerElement)
      throw new tn(Vp);
    var n = this.getNamedItem(t.nodeName);
    return Wp(this._ownerElement, this, t, n), n;
  },
  /* returns Node */
  setNamedItemNS: function(t) {
    var e = t.ownerElement, n;
    if (e && e != this._ownerElement)
      throw new tn(Vp);
    return n = this.getNamedItemNS(t.namespaceURI, t.localName), Wp(this._ownerElement, this, t, n), n;
  },
  /* returns Node */
  removeNamedItem: function(t) {
    var e = this.getNamedItem(t);
    return Hp(this._ownerElement, this, e), e;
  },
  // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
  //for level2
  removeNamedItemNS: function(t, e) {
    var n = this.getNamedItemNS(t, e);
    return Hp(this._ownerElement, this, n), n;
  },
  getNamedItemNS: function(t, e) {
    for (var n = this.length; n--; ) {
      var r = this[n];
      if (r.localName == e && r.namespaceURI == t)
        return r;
    }
    return null;
  }
};
function F0() {
}
F0.prototype = {
  /**
   * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
   * The different implementations fairly diverged in what kind of features were reported.
   * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
   *
   * @deprecated It is deprecated and modern browsers return true in all cases.
   *
   * @param {string} feature
   * @param {string} [version]
   * @returns {boolean} always true
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
   * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
   */
  hasFeature: function(t, e) {
    return !0;
  },
  /**
   * Creates an XML Document object of the specified type with its document element.
   *
   * __It behaves slightly different from the description in the living standard__:
   * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
   * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
   * - this implementation is not validating names or qualified names
   *   (when parsing XML strings, the SAX parser takes care of that)
   *
   * @param {string|null} namespaceURI
   * @param {string} qualifiedName
   * @param {DocumentType=null} doctype
   * @returns {Document}
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
   * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
   *
   * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
   * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
   * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
   */
  createDocument: function(t, e, n) {
    var r = new oa();
    if (r.implementation = this, r.childNodes = new Yr(), r.doctype = n || null, n && r.appendChild(n), e) {
      var i = r.createElementNS(t, e);
      r.appendChild(i);
    }
    return r;
  },
  /**
   * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
   *
   * __This behavior is slightly different from the in the specs__:
   * - this implementation is not validating names or qualified names
   *   (when parsing XML strings, the SAX parser takes care of that)
   *
   * @param {string} qualifiedName
   * @param {string} [publicId]
   * @param {string} [systemId]
   * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
   * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
   * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
   *
   * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
   * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
   * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
   */
  createDocumentType: function(t, e, n) {
    var r = new tu();
    return r.name = t, r.nodeName = t, r.publicId = e || "", r.systemId = n || "", r;
  }
};
function At() {
}
At.prototype = {
  firstChild: null,
  lastChild: null,
  previousSibling: null,
  nextSibling: null,
  attributes: null,
  parentNode: null,
  childNodes: null,
  ownerDocument: null,
  nodeValue: null,
  namespaceURI: null,
  prefix: null,
  localName: null,
  // Modified in DOM Level 2:
  insertBefore: function(t, e) {
    return xl(this, t, e);
  },
  replaceChild: function(t, e) {
    xl(this, t, e, W0), e && this.removeChild(e);
  },
  removeChild: function(t) {
    return V0(this, t);
  },
  appendChild: function(t) {
    return this.insertBefore(t, null);
  },
  hasChildNodes: function() {
    return this.firstChild != null;
  },
  cloneNode: function(t) {
    return Jc(this.ownerDocument || this, this, t);
  },
  // Modified in DOM Level 2:
  normalize: function() {
    for (var t = this.firstChild; t; ) {
      var e = t.nextSibling;
      e && e.nodeType == El && t.nodeType == El ? (this.removeChild(e), t.appendData(e.data)) : (t.normalize(), t = e);
    }
  },
  // Introduced in DOM Level 2:
  isSupported: function(t, e) {
    return this.ownerDocument.implementation.hasFeature(t, e);
  },
  // Introduced in DOM Level 2:
  hasAttributes: function() {
    return this.attributes.length > 0;
  },
  /**
   * Look up the prefix associated to the given namespace URI, starting from this node.
   * **The default namespace declarations are ignored by this method.**
   * See Namespace Prefix Lookup for details on the algorithm used by this method.
   *
   * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
   *
   * @param {string | null} namespaceURI
   * @returns {string | null}
   * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
   * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
   * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
   * @see https://github.com/xmldom/xmldom/issues/322
   */
  lookupPrefix: function(t) {
    for (var e = this; e; ) {
      var n = e._nsMap;
      if (n) {
        for (var r in n)
          if (Object.prototype.hasOwnProperty.call(n, r) && n[r] === t)
            return r;
      }
      e = e.nodeType == $s ? e.ownerDocument : e.parentNode;
    }
    return null;
  },
  // Introduced in DOM Level 3:
  lookupNamespaceURI: function(t) {
    for (var e = this; e; ) {
      var n = e._nsMap;
      if (n && t in n && Object.prototype.hasOwnProperty.call(n, t))
        return n[t];
      e = e.nodeType == $s ? e.ownerDocument : e.parentNode;
    }
    return null;
  },
  // Introduced in DOM Level 3:
  isDefaultNamespace: function(t) {
    var e = this.lookupPrefix(t);
    return e == null;
  }
};
function j0(t) {
  return t == "<" && "&lt;" || t == ">" && "&gt;" || t == "&" && "&amp;" || t == '"' && "&quot;" || "&#" + t.charCodeAt() + ";";
}
sa(Vn, At);
sa(Vn, At.prototype);
function zo(t, e) {
  if (e(t))
    return !0;
  if (t = t.firstChild)
    do
      if (zo(t, e))
        return !0;
    while (t = t.nextSibling);
}
function oa() {
  this.ownerDocument = this;
}
function WP(t, e, n) {
  t && t._inc++;
  var r = n.namespaceURI;
  r === Mo.XMLNS && (e._nsMap[n.prefix ? n.localName : ""] = n.value);
}
function U0(t, e, n, r) {
  t && t._inc++;
  var i = n.namespaceURI;
  i === Mo.XMLNS && delete e._nsMap[n.prefix ? n.localName : ""];
}
function gf(t, e, n) {
  if (t && t._inc) {
    t._inc++;
    var r = e.childNodes;
    if (n)
      r[r.length++] = n;
    else {
      for (var i = e.firstChild, s = 0; i; )
        r[s++] = i, i = i.nextSibling;
      r.length = s, delete r[r.length];
    }
  }
}
function V0(t, e) {
  var n = e.previousSibling, r = e.nextSibling;
  return n ? n.nextSibling = r : t.firstChild = r, r ? r.previousSibling = n : t.lastChild = n, e.parentNode = null, e.previousSibling = null, e.nextSibling = null, gf(t.ownerDocument, t), e;
}
function HP(t) {
  return t && (t.nodeType === At.DOCUMENT_NODE || t.nodeType === At.DOCUMENT_FRAGMENT_NODE || t.nodeType === At.ELEMENT_NODE);
}
function KP(t) {
  return t && (kr(t) || yf(t) || ti(t) || t.nodeType === At.DOCUMENT_FRAGMENT_NODE || t.nodeType === At.COMMENT_NODE || t.nodeType === At.PROCESSING_INSTRUCTION_NODE);
}
function ti(t) {
  return t && t.nodeType === At.DOCUMENT_TYPE_NODE;
}
function kr(t) {
  return t && t.nodeType === At.ELEMENT_NODE;
}
function yf(t) {
  return t && t.nodeType === At.TEXT_NODE;
}
function Kp(t, e) {
  var n = t.childNodes || [];
  if (Cr(n, kr) || ti(e))
    return !1;
  var r = Cr(n, ti);
  return !(e && r && n.indexOf(r) > n.indexOf(e));
}
function qp(t, e) {
  var n = t.childNodes || [];
  function r(s) {
    return kr(s) && s !== e;
  }
  if (Cr(n, r))
    return !1;
  var i = Cr(n, ti);
  return !(e && i && n.indexOf(i) > n.indexOf(e));
}
function qP(t, e, n) {
  if (!HP(t))
    throw new tn(Bn, "Unexpected parent node type " + t.nodeType);
  if (n && n.parentNode !== t)
    throw new tn(M0, "child not in parent");
  if (
    // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
    !KP(e) || // 5. If either `node` is a Text node and `parent` is a document,
    // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
    // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
    // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
    ti(e) && t.nodeType !== At.DOCUMENT_NODE
  )
    throw new tn(
      Bn,
      "Unexpected node type " + e.nodeType + " for parent node type " + t.nodeType
    );
}
function GP(t, e, n) {
  var r = t.childNodes || [], i = e.childNodes || [];
  if (e.nodeType === At.DOCUMENT_FRAGMENT_NODE) {
    var s = i.filter(kr);
    if (s.length > 1 || Cr(i, yf))
      throw new tn(Bn, "More than one element or text in fragment");
    if (s.length === 1 && !Kp(t, n))
      throw new tn(Bn, "Element in fragment can not be inserted before doctype");
  }
  if (kr(e) && !Kp(t, n))
    throw new tn(Bn, "Only one element can be added and only after doctype");
  if (ti(e)) {
    if (Cr(r, ti))
      throw new tn(Bn, "Only one doctype is allowed");
    var o = Cr(r, kr);
    if (n && r.indexOf(o) < r.indexOf(n))
      throw new tn(Bn, "Doctype can only be inserted before an element");
    if (!n && o)
      throw new tn(Bn, "Doctype can not be appended since element is present");
  }
}
function W0(t, e, n) {
  var r = t.childNodes || [], i = e.childNodes || [];
  if (e.nodeType === At.DOCUMENT_FRAGMENT_NODE) {
    var s = i.filter(kr);
    if (s.length > 1 || Cr(i, yf))
      throw new tn(Bn, "More than one element or text in fragment");
    if (s.length === 1 && !qp(t, n))
      throw new tn(Bn, "Element in fragment can not be inserted before doctype");
  }
  if (kr(e) && !qp(t, n))
    throw new tn(Bn, "Only one element can be added and only after doctype");
  if (ti(e)) {
    if (Cr(r, function(l) {
      return ti(l) && l !== n;
    }))
      throw new tn(Bn, "Only one doctype is allowed");
    var o = Cr(r, kr);
    if (n && r.indexOf(o) < r.indexOf(n))
      throw new tn(Bn, "Doctype can only be inserted before an element");
  }
}
function xl(t, e, n, r) {
  qP(t, e, n), t.nodeType === At.DOCUMENT_NODE && (r || GP)(t, e, n);
  var i = e.parentNode;
  if (i && i.removeChild(e), e.nodeType === ei) {
    var s = e.firstChild;
    if (s == null)
      return e;
    var o = e.lastChild;
  } else
    s = o = e;
  var a = n ? n.previousSibling : t.lastChild;
  s.previousSibling = a, o.nextSibling = n, a ? a.nextSibling = s : t.firstChild = s, n == null ? t.lastChild = o : n.previousSibling = o;
  do
    s.parentNode = t;
  while (s !== o && (s = s.nextSibling));
  return gf(t.ownerDocument || t, t), e.nodeType == ei && (e.firstChild = e.lastChild = null), e;
}
function YP(t, e) {
  return e.parentNode && e.parentNode.removeChild(e), e.parentNode = t, e.previousSibling = t.lastChild, e.nextSibling = null, e.previousSibling ? e.previousSibling.nextSibling = e : t.firstChild = e, t.lastChild = e, gf(t.ownerDocument, t, e), e;
}
oa.prototype = {
  //implementation : null,
  nodeName: "#document",
  nodeType: D0,
  /**
   * The DocumentType node of the document.
   *
   * @readonly
   * @type DocumentType
   */
  doctype: null,
  documentElement: null,
  _inc: 1,
  insertBefore: function(t, e) {
    if (t.nodeType == ei) {
      for (var n = t.firstChild; n; ) {
        var r = n.nextSibling;
        this.insertBefore(n, e), n = r;
      }
      return t;
    }
    return xl(this, t, e), t.ownerDocument = this, this.documentElement === null && t.nodeType === mr && (this.documentElement = t), t;
  },
  removeChild: function(t) {
    return this.documentElement == t && (this.documentElement = null), V0(this, t);
  },
  replaceChild: function(t, e) {
    xl(this, t, e, W0), t.ownerDocument = this, e && this.removeChild(e), kr(t) && (this.documentElement = t);
  },
  // Introduced in DOM Level 2:
  importNode: function(t, e) {
    return Y0(this, t, e);
  },
  // Introduced in DOM Level 2:
  getElementById: function(t) {
    var e = null;
    return zo(this.documentElement, function(n) {
      if (n.nodeType == mr && n.getAttribute("id") == t)
        return e = n, !0;
    }), e;
  },
  /**
   * The `getElementsByClassName` method of `Document` interface returns an array-like object
   * of all child elements which have **all** of the given class name(s).
   *
   * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
   *
   *
   * Warning: This is a live LiveNodeList.
   * Changes in the DOM will reflect in the array as the changes occur.
   * If an element selected by this array no longer qualifies for the selector,
   * it will automatically be removed. Be aware of this for iteration purposes.
   *
   * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
   * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
   */
  getElementsByClassName: function(t) {
    var e = Up(t);
    return new Ds(this, function(n) {
      var r = [];
      return e.length > 0 && zo(n.documentElement, function(i) {
        if (i !== n && i.nodeType === mr) {
          var s = i.getAttribute("class");
          if (s) {
            var o = t === s;
            if (!o) {
              var a = Up(s);
              o = e.every(jP(a));
            }
            o && r.push(i);
          }
        }
      }), r;
    });
  },
  //document factory method:
  createElement: function(t) {
    var e = new Wi();
    e.ownerDocument = this, e.nodeName = t, e.tagName = t, e.localName = t, e.childNodes = new Yr();
    var n = e.attributes = new Sl();
    return n._ownerElement = e, e;
  },
  createDocumentFragment: function() {
    var t = new nu();
    return t.ownerDocument = this, t.childNodes = new Yr(), t;
  },
  createTextNode: function(t) {
    var e = new bf();
    return e.ownerDocument = this, e.appendData(t), e;
  },
  createComment: function(t) {
    var e = new wf();
    return e.ownerDocument = this, e.appendData(t), e;
  },
  createCDATASection: function(t) {
    var e = new _f();
    return e.ownerDocument = this, e.appendData(t), e;
  },
  createProcessingInstruction: function(t, e) {
    var n = new Sf();
    return n.ownerDocument = this, n.tagName = n.target = t, n.nodeValue = n.data = e, n;
  },
  createAttribute: function(t) {
    var e = new Cl();
    return e.ownerDocument = this, e.name = t, e.nodeName = t, e.localName = t, e.specified = !0, e;
  },
  createEntityReference: function(t) {
    var e = new Ef();
    return e.ownerDocument = this, e.nodeName = t, e;
  },
  // Introduced in DOM Level 2:
  createElementNS: function(t, e) {
    var n = new Wi(), r = e.split(":"), i = n.attributes = new Sl();
    return n.childNodes = new Yr(), n.ownerDocument = this, n.nodeName = e, n.tagName = e, n.namespaceURI = t, r.length == 2 ? (n.prefix = r[0], n.localName = r[1]) : n.localName = e, i._ownerElement = n, n;
  },
  // Introduced in DOM Level 2:
  createAttributeNS: function(t, e) {
    var n = new Cl(), r = e.split(":");
    return n.ownerDocument = this, n.nodeName = e, n.name = e, n.namespaceURI = t, n.specified = !0, r.length == 2 ? (n.prefix = r[0], n.localName = r[1]) : n.localName = e, n;
  }
};
Un(oa, At);
function Wi() {
  this._nsMap = {};
}
Wi.prototype = {
  nodeType: mr,
  hasAttribute: function(t) {
    return this.getAttributeNode(t) != null;
  },
  getAttribute: function(t) {
    var e = this.getAttributeNode(t);
    return e && e.value || "";
  },
  getAttributeNode: function(t) {
    return this.attributes.getNamedItem(t);
  },
  setAttribute: function(t, e) {
    var n = this.ownerDocument.createAttribute(t);
    n.value = n.nodeValue = "" + e, this.setAttributeNode(n);
  },
  removeAttribute: function(t) {
    var e = this.getAttributeNode(t);
    e && this.removeAttributeNode(e);
  },
  //four real opeartion method
  appendChild: function(t) {
    return t.nodeType === ei ? this.insertBefore(t, null) : YP(this, t);
  },
  setAttributeNode: function(t) {
    return this.attributes.setNamedItem(t);
  },
  setAttributeNodeNS: function(t) {
    return this.attributes.setNamedItemNS(t);
  },
  removeAttributeNode: function(t) {
    return this.attributes.removeNamedItem(t.nodeName);
  },
  //get real attribute name,and remove it by removeAttributeNode
  removeAttributeNS: function(t, e) {
    var n = this.getAttributeNodeNS(t, e);
    n && this.removeAttributeNode(n);
  },
  hasAttributeNS: function(t, e) {
    return this.getAttributeNodeNS(t, e) != null;
  },
  getAttributeNS: function(t, e) {
    var n = this.getAttributeNodeNS(t, e);
    return n && n.value || "";
  },
  setAttributeNS: function(t, e, n) {
    var r = this.ownerDocument.createAttributeNS(t, e);
    r.value = r.nodeValue = "" + n, this.setAttributeNode(r);
  },
  getAttributeNodeNS: function(t, e) {
    return this.attributes.getNamedItemNS(t, e);
  },
  getElementsByTagName: function(t) {
    return new Ds(this, function(e) {
      var n = [];
      return zo(e, function(r) {
        r !== e && r.nodeType == mr && (t === "*" || r.tagName == t) && n.push(r);
      }), n;
    });
  },
  getElementsByTagNameNS: function(t, e) {
    return new Ds(this, function(n) {
      var r = [];
      return zo(n, function(i) {
        i !== n && i.nodeType === mr && (t === "*" || i.namespaceURI === t) && (e === "*" || i.localName == e) && r.push(i);
      }), r;
    });
  }
};
oa.prototype.getElementsByTagName = Wi.prototype.getElementsByTagName;
oa.prototype.getElementsByTagNameNS = Wi.prototype.getElementsByTagNameNS;
Un(Wi, At);
function Cl() {
}
Cl.prototype.nodeType = $s;
Un(Cl, At);
function aa() {
}
aa.prototype = {
  data: "",
  substringData: function(t, e) {
    return this.data.substring(t, t + e);
  },
  appendData: function(t) {
    t = this.data + t, this.nodeValue = this.data = t, this.length = t.length;
  },
  insertData: function(t, e) {
    this.replaceData(t, 0, e);
  },
  appendChild: function(t) {
    throw new Error(pn[Bn]);
  },
  deleteData: function(t, e) {
    this.replaceData(t, e, "");
  },
  replaceData: function(t, e, n) {
    var r = this.data.substring(0, t), i = this.data.substring(t + e);
    n = r + n + i, this.nodeValue = this.data = n, this.length = n.length;
  }
};
Un(aa, At);
function bf() {
}
bf.prototype = {
  nodeName: "#text",
  nodeType: El,
  splitText: function(t) {
    var e = this.data, n = e.substring(t);
    e = e.substring(0, t), this.data = this.nodeValue = e, this.length = e.length;
    var r = this.ownerDocument.createTextNode(n);
    return this.parentNode && this.parentNode.insertBefore(r, this.nextSibling), r;
  }
};
Un(bf, aa);
function wf() {
}
wf.prototype = {
  nodeName: "#comment",
  nodeType: $0
};
Un(wf, aa);
function _f() {
}
_f.prototype = {
  nodeName: "#cdata-section",
  nodeType: R0
};
Un(_f, aa);
function tu() {
}
tu.prototype.nodeType = B0;
Un(tu, At);
function H0() {
}
H0.prototype.nodeType = VP;
Un(H0, At);
function K0() {
}
K0.prototype.nodeType = UP;
Un(K0, At);
function Ef() {
}
Ef.prototype.nodeType = L0;
Un(Ef, At);
function nu() {
}
nu.prototype.nodeName = "#document-fragment";
nu.prototype.nodeType = ei;
Un(nu, At);
function Sf() {
}
Sf.prototype.nodeType = P0;
Un(Sf, At);
function q0() {
}
q0.prototype.serializeToString = function(t, e, n) {
  return G0.call(t, e, n);
};
At.prototype.toString = G0;
function G0(t, e) {
  var n = [], r = this.nodeType == 9 && this.documentElement || this, i = r.prefix, s = r.namespaceURI;
  if (s && i == null) {
    var i = r.lookupPrefix(s);
    if (i == null)
      var o = [
        { namespace: s, prefix: null }
        //{namespace:uri,prefix:''}
      ];
  }
  return bs(this, n, t, e, o), n.join("");
}
function Gp(t, e, n) {
  var r = t.prefix || "", i = t.namespaceURI;
  if (!i || r === "xml" && i === Mo.XML || i === Mo.XMLNS)
    return !1;
  for (var s = n.length; s--; ) {
    var o = n[s];
    if (o.prefix === r)
      return o.namespace !== i;
  }
  return !0;
}
function Vu(t, e, n) {
  t.push(" ", e, '="', n.replace(/[<&"]/g, j0), '"');
}
function bs(t, e, n, r, i) {
  if (i || (i = []), r)
    if (t = r(t), t) {
      if (typeof t == "string") {
        e.push(t);
        return;
      }
    } else
      return;
  switch (t.nodeType) {
    case mr:
      var s = t.attributes, o = s.length, f = t.firstChild, a = t.tagName;
      n = Mo.isHTML(t.namespaceURI) || n;
      var l = a;
      if (!n && !t.prefix && t.namespaceURI) {
        for (var u, c = 0; c < s.length; c++)
          if (s.item(c).name === "xmlns") {
            u = s.item(c).value;
            break;
          }
        if (!u)
          for (var d = i.length - 1; d >= 0; d--) {
            var h = i[d];
            if (h.prefix === "" && h.namespace === t.namespaceURI) {
              u = h.namespace;
              break;
            }
          }
        if (u !== t.namespaceURI)
          for (var d = i.length - 1; d >= 0; d--) {
            var h = i[d];
            if (h.namespace === t.namespaceURI) {
              h.prefix && (l = h.prefix + ":" + a);
              break;
            }
          }
      }
      e.push("<", l);
      for (var v = 0; v < o; v++) {
        var y = s.item(v);
        y.prefix == "xmlns" ? i.push({ prefix: y.localName, namespace: y.value }) : y.nodeName == "xmlns" && i.push({ prefix: "", namespace: y.value });
      }
      for (var v = 0; v < o; v++) {
        var y = s.item(v);
        if (Gp(y, n, i)) {
          var b = y.prefix || "", p = y.namespaceURI;
          Vu(e, b ? "xmlns:" + b : "xmlns", p), i.push({ prefix: b, namespace: p });
        }
        bs(y, e, n, r, i);
      }
      if (a === l && Gp(t, n, i)) {
        var b = t.prefix || "", p = t.namespaceURI;
        Vu(e, b ? "xmlns:" + b : "xmlns", p), i.push({ prefix: b, namespace: p });
      }
      if (f || n && !/^(?:meta|link|img|br|hr|input)$/i.test(a)) {
        if (e.push(">"), n && /^script$/i.test(a))
          for (; f; )
            f.data ? e.push(f.data) : bs(f, e, n, r, i.slice()), f = f.nextSibling;
        else
          for (; f; )
            bs(f, e, n, r, i.slice()), f = f.nextSibling;
        e.push("</", l, ">");
      } else
        e.push("/>");
      return;
    case D0:
    case ei:
      for (var f = t.firstChild; f; )
        bs(f, e, n, r, i.slice()), f = f.nextSibling;
      return;
    case $s:
      return Vu(e, t.name, t.value);
    case El:
      return e.push(
        t.data.replace(/[<&]/g, j0).replace(/]]>/g, "]]&gt;")
      );
    case R0:
      return e.push("<![CDATA[", t.data, "]]>");
    case $0:
      return e.push("<!--", t.data, "-->");
    case B0:
      var m = t.publicId, g = t.systemId;
      if (e.push("<!DOCTYPE ", t.name), m)
        e.push(" PUBLIC ", m), g && g != "." && e.push(" ", g), e.push(">");
      else if (g && g != ".")
        e.push(" SYSTEM ", g, ">");
      else {
        var w = t.internalSubset;
        w && e.push(" [", w, "]"), e.push(">");
      }
      return;
    case P0:
      return e.push("<?", t.target, " ", t.data, "?>");
    case L0:
      return e.push("&", t.nodeName, ";");
    default:
      e.push("??", t.nodeName);
  }
}
function Y0(t, e, n) {
  var r;
  switch (e.nodeType) {
    case mr:
      r = e.cloneNode(!1), r.ownerDocument = t;
    case ei:
      break;
    case $s:
      n = !0;
      break;
  }
  if (r || (r = e.cloneNode(!1)), r.ownerDocument = t, r.parentNode = null, n)
    for (var i = e.firstChild; i; )
      r.appendChild(Y0(t, i, n)), i = i.nextSibling;
  return r;
}
function Jc(t, e, n) {
  var r = new e.constructor();
  for (var i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      var s = e[i];
      typeof s != "object" && s != r[i] && (r[i] = s);
    }
  switch (e.childNodes && (r.childNodes = new Yr()), r.ownerDocument = t, r.nodeType) {
    case mr:
      var o = e.attributes, a = r.attributes = new Sl(), l = o.length;
      a._ownerElement = r;
      for (var u = 0; u < l; u++)
        r.setAttributeNode(Jc(t, o.item(u), !0));
      break;
    case $s:
      n = !0;
  }
  if (n)
    for (var c = e.firstChild; c; )
      r.appendChild(Jc(t, c, n)), c = c.nextSibling;
  return r;
}
function X0(t, e, n) {
  t[e] = n;
}
try {
  if (Object.defineProperty) {
    let t = function(e) {
      switch (e.nodeType) {
        case mr:
        case ei:
          var n = [];
          for (e = e.firstChild; e; )
            e.nodeType !== 7 && e.nodeType !== 8 && n.push(t(e)), e = e.nextSibling;
          return n.join("");
        default:
          return e.nodeValue;
      }
    };
    Object.defineProperty(Ds.prototype, "length", {
      get: function() {
        return mf(this), this.$$length;
      }
    }), Object.defineProperty(At.prototype, "textContent", {
      get: function() {
        return t(this);
      },
      set: function(e) {
        switch (this.nodeType) {
          case mr:
          case ei:
            for (; this.firstChild; )
              this.removeChild(this.firstChild);
            (e || String(e)) && this.appendChild(this.ownerDocument.createTextNode(e));
            break;
          default:
            this.data = e, this.value = e, this.nodeValue = e;
        }
      }
    }), X0 = function(e, n, r) {
      e["$$" + n] = r;
    };
  }
} catch {
}
xi.DocumentType = tu;
xi.DOMException = tn;
xi.DOMImplementation = F0;
xi.Element = Wi;
xi.Node = At;
xi.NodeList = Yr;
xi.XMLSerializer = q0;
var la = {}, Z0 = {};
(function(t) {
  var e = Ci.freeze;
  t.XML_ENTITIES = e({ amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' }), t.HTML_ENTITIES = e({
    lt: "<",
    gt: ">",
    amp: "&",
    quot: '"',
    apos: "'",
    Agrave: "À",
    Aacute: "Á",
    Acirc: "Â",
    Atilde: "Ã",
    Auml: "Ä",
    Aring: "Å",
    AElig: "Æ",
    Ccedil: "Ç",
    Egrave: "È",
    Eacute: "É",
    Ecirc: "Ê",
    Euml: "Ë",
    Igrave: "Ì",
    Iacute: "Í",
    Icirc: "Î",
    Iuml: "Ï",
    ETH: "Ð",
    Ntilde: "Ñ",
    Ograve: "Ò",
    Oacute: "Ó",
    Ocirc: "Ô",
    Otilde: "Õ",
    Ouml: "Ö",
    Oslash: "Ø",
    Ugrave: "Ù",
    Uacute: "Ú",
    Ucirc: "Û",
    Uuml: "Ü",
    Yacute: "Ý",
    THORN: "Þ",
    szlig: "ß",
    agrave: "à",
    aacute: "á",
    acirc: "â",
    atilde: "ã",
    auml: "ä",
    aring: "å",
    aelig: "æ",
    ccedil: "ç",
    egrave: "è",
    eacute: "é",
    ecirc: "ê",
    euml: "ë",
    igrave: "ì",
    iacute: "í",
    icirc: "î",
    iuml: "ï",
    eth: "ð",
    ntilde: "ñ",
    ograve: "ò",
    oacute: "ó",
    ocirc: "ô",
    otilde: "õ",
    ouml: "ö",
    oslash: "ø",
    ugrave: "ù",
    uacute: "ú",
    ucirc: "û",
    uuml: "ü",
    yacute: "ý",
    thorn: "þ",
    yuml: "ÿ",
    nbsp: " ",
    iexcl: "¡",
    cent: "¢",
    pound: "£",
    curren: "¤",
    yen: "¥",
    brvbar: "¦",
    sect: "§",
    uml: "¨",
    copy: "©",
    ordf: "ª",
    laquo: "«",
    not: "¬",
    shy: "­­",
    reg: "®",
    macr: "¯",
    deg: "°",
    plusmn: "±",
    sup2: "²",
    sup3: "³",
    acute: "´",
    micro: "µ",
    para: "¶",
    middot: "·",
    cedil: "¸",
    sup1: "¹",
    ordm: "º",
    raquo: "»",
    frac14: "¼",
    frac12: "½",
    frac34: "¾",
    iquest: "¿",
    times: "×",
    divide: "÷",
    forall: "∀",
    part: "∂",
    exist: "∃",
    empty: "∅",
    nabla: "∇",
    isin: "∈",
    notin: "∉",
    ni: "∋",
    prod: "∏",
    sum: "∑",
    minus: "−",
    lowast: "∗",
    radic: "√",
    prop: "∝",
    infin: "∞",
    ang: "∠",
    and: "∧",
    or: "∨",
    cap: "∩",
    cup: "∪",
    int: "∫",
    there4: "∴",
    sim: "∼",
    cong: "≅",
    asymp: "≈",
    ne: "≠",
    equiv: "≡",
    le: "≤",
    ge: "≥",
    sub: "⊂",
    sup: "⊃",
    nsub: "⊄",
    sube: "⊆",
    supe: "⊇",
    oplus: "⊕",
    otimes: "⊗",
    perp: "⊥",
    sdot: "⋅",
    Alpha: "Α",
    Beta: "Β",
    Gamma: "Γ",
    Delta: "Δ",
    Epsilon: "Ε",
    Zeta: "Ζ",
    Eta: "Η",
    Theta: "Θ",
    Iota: "Ι",
    Kappa: "Κ",
    Lambda: "Λ",
    Mu: "Μ",
    Nu: "Ν",
    Xi: "Ξ",
    Omicron: "Ο",
    Pi: "Π",
    Rho: "Ρ",
    Sigma: "Σ",
    Tau: "Τ",
    Upsilon: "Υ",
    Phi: "Φ",
    Chi: "Χ",
    Psi: "Ψ",
    Omega: "Ω",
    alpha: "α",
    beta: "β",
    gamma: "γ",
    delta: "δ",
    epsilon: "ε",
    zeta: "ζ",
    eta: "η",
    theta: "θ",
    iota: "ι",
    kappa: "κ",
    lambda: "λ",
    mu: "μ",
    nu: "ν",
    xi: "ξ",
    omicron: "ο",
    pi: "π",
    rho: "ρ",
    sigmaf: "ς",
    sigma: "σ",
    tau: "τ",
    upsilon: "υ",
    phi: "φ",
    chi: "χ",
    psi: "ψ",
    omega: "ω",
    thetasym: "ϑ",
    upsih: "ϒ",
    piv: "ϖ",
    OElig: "Œ",
    oelig: "œ",
    Scaron: "Š",
    scaron: "š",
    Yuml: "Ÿ",
    fnof: "ƒ",
    circ: "ˆ",
    tilde: "˜",
    ensp: " ",
    emsp: " ",
    thinsp: " ",
    zwnj: "‌",
    zwj: "‍",
    lrm: "‎",
    rlm: "‏",
    ndash: "–",
    mdash: "—",
    lsquo: "‘",
    rsquo: "’",
    sbquo: "‚",
    ldquo: "“",
    rdquo: "”",
    bdquo: "„",
    dagger: "†",
    Dagger: "‡",
    bull: "•",
    hellip: "…",
    permil: "‰",
    prime: "′",
    Prime: "″",
    lsaquo: "‹",
    rsaquo: "›",
    oline: "‾",
    euro: "€",
    trade: "™",
    larr: "←",
    uarr: "↑",
    rarr: "→",
    darr: "↓",
    harr: "↔",
    crarr: "↵",
    lceil: "⌈",
    rceil: "⌉",
    lfloor: "⌊",
    rfloor: "⌋",
    loz: "◊",
    spades: "♠",
    clubs: "♣",
    hearts: "♥",
    diams: "♦"
  }), t.entityMap = t.HTML_ENTITIES;
})(Z0);
var xf = {}, Fo = Ci.NAMESPACE, ed = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, Yp = new RegExp("[\\-\\.0-9" + ed.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"), Xp = new RegExp("^" + ed.source + Yp.source + "*(?::" + ed.source + Yp.source + "*)?$"), Qs = 0, li = 1, as = 2, Js = 3, ls = 4, us = 5, eo = 6, Ia = 7;
function Bs(t, e) {
  this.message = t, this.locator = e, Error.captureStackTrace && Error.captureStackTrace(this, Bs);
}
Bs.prototype = new Error();
Bs.prototype.name = Bs.name;
function Q0() {
}
Q0.prototype = {
  parse: function(t, e, n) {
    var r = this.domBuilder;
    r.startDocument(), J0(e, e = {}), XP(
      t,
      e,
      n,
      r,
      this.errorHandler
    ), r.endDocument();
  }
};
function XP(t, e, n, r, i) {
  function s(J) {
    if (J > 65535) {
      J -= 65536;
      var M = 55296 + (J >> 10), U = 56320 + (J & 1023);
      return String.fromCharCode(M, U);
    } else
      return String.fromCharCode(J);
  }
  function o(J) {
    var M = J.slice(1, -1);
    return M in n ? n[M] : M.charAt(0) === "#" ? s(parseInt(M.substr(1).replace("x", "0x"))) : (i.error("entity not found:" + J), J);
  }
  function a(J) {
    if (J > b) {
      var M = t.substring(b, J).replace(/&#?\w+;/g, o);
      h && l(b), r.characters(M, 0, J - b), b = J;
    }
  }
  function l(J, M) {
    for (; J >= c && (M = d.exec(t)); )
      u = M.index, c = u + M[0].length, h.lineNumber++;
    h.columnNumber = J - u + 1;
  }
  for (var u = 0, c = 0, d = /.*(?:\r\n?|\n)|.*$/g, h = r.locator, v = [{ currentNSMap: e }], y = {}, b = 0; ; ) {
    try {
      var p = t.indexOf("<", b);
      if (p < 0) {
        if (!t.substr(b).match(/^\s*$/)) {
          var f = r.doc, m = f.createTextNode(t.substr(b));
          f.appendChild(m), r.currentElement = m;
        }
        return;
      }
      switch (p > b && a(p), t.charAt(p + 1)) {
        case "/":
          var I = t.indexOf(">", p + 3), g = t.substring(p + 2, I).replace(/[ \t\n\r]+$/g, ""), w = v.pop();
          I < 0 ? (g = t.substring(p + 2).replace(/[\s<].*/, ""), i.error("end tag name: " + g + " is not complete:" + w.tagName), I = p + 1 + g.length) : g.match(/\s</) && (g = g.replace(/[\s<].*/, ""), i.error("end tag name: " + g + " maybe not complete"), I = p + 1 + g.length);
          var _ = w.localNSMap, E = w.tagName == g, C = E || w.tagName && w.tagName.toLowerCase() == g.toLowerCase();
          if (C) {
            if (r.endElement(w.uri, w.localName, g), _)
              for (var T in _)
                Object.prototype.hasOwnProperty.call(_, T) && r.endPrefixMapping(T);
            E || i.fatalError("end tag name: " + g + " is not match the current start tagName:" + w.tagName);
          } else
            v.push(w);
          I++;
          break;
        case "?":
          h && l(p), I = t$(t, p, r);
          break;
        case "!":
          h && l(p), I = e$(t, p, r, i);
          break;
        default:
          h && l(p);
          var k = new ey(), N = v[v.length - 1].currentNSMap, I = ZP(t, p, k, N, o, i), P = k.length;
          if (!k.closed && JP(t, I, k.tagName, y) && (k.closed = !0, n.nbsp || i.warning("unclosed xml attribute")), h && P) {
            for (var D = Zp(h, {}), z = 0; z < P; z++) {
              var G = k[z];
              l(G.offset), G.locator = Zp(h, {});
            }
            r.locator = D, Qp(k, r, N) && v.push(k), r.locator = h;
          } else
            Qp(k, r, N) && v.push(k);
          Fo.isHTML(k.uri) && !k.closed ? I = QP(t, I, k.tagName, o, r) : I++;
      }
    } catch (J) {
      if (J instanceof Bs)
        throw J;
      i.error("element parse error: " + J), I = -1;
    }
    I > b ? b = I : a(Math.max(p, b) + 1);
  }
}
function Zp(t, e) {
  return e.lineNumber = t.lineNumber, e.columnNumber = t.columnNumber, e;
}
function ZP(t, e, n, r, i, s) {
  function o(h, v, y) {
    n.attributeNames.hasOwnProperty(h) && s.fatalError("Attribute " + h + " redefined"), n.addValue(h, v, y);
  }
  for (var a, l, u = ++e, c = Qs; ; ) {
    var d = t.charAt(u);
    switch (d) {
      case "=":
        if (c === li)
          a = t.slice(e, u), c = Js;
        else if (c === as)
          c = Js;
        else
          throw new Error("attribute equal must after attrName");
        break;
      case "'":
      case '"':
        if (c === Js || c === li)
          if (c === li && (s.warning('attribute value must after "="'), a = t.slice(e, u)), e = u + 1, u = t.indexOf(d, e), u > 0)
            l = t.slice(e, u).replace(/&#?\w+;/g, i), o(a, l, e - 1), c = us;
          else
            throw new Error("attribute value no end '" + d + "' match");
        else if (c == ls)
          l = t.slice(e, u).replace(/&#?\w+;/g, i), o(a, l, e), s.warning('attribute "' + a + '" missed start quot(' + d + ")!!"), e = u + 1, c = us;
        else
          throw new Error('attribute value must after "="');
        break;
      case "/":
        switch (c) {
          case Qs:
            n.setTagName(t.slice(e, u));
          case us:
          case eo:
          case Ia:
            c = Ia, n.closed = !0;
          case ls:
          case li:
            break;
          case as:
            n.closed = !0;
            break;
          default:
            throw new Error("attribute invalid close char('/')");
        }
        break;
      case "":
        return s.error("unexpected end of input"), c == Qs && n.setTagName(t.slice(e, u)), u;
      case ">":
        switch (c) {
          case Qs:
            n.setTagName(t.slice(e, u));
          case us:
          case eo:
          case Ia:
            break;
          case ls:
          case li:
            l = t.slice(e, u), l.slice(-1) === "/" && (n.closed = !0, l = l.slice(0, -1));
          case as:
            c === as && (l = a), c == ls ? (s.warning('attribute "' + l + '" missed quot(")!'), o(a, l.replace(/&#?\w+;/g, i), e)) : ((!Fo.isHTML(r[""]) || !l.match(/^(?:disabled|checked|selected)$/i)) && s.warning('attribute "' + l + '" missed value!! "' + l + '" instead!!'), o(l, l, e));
            break;
          case Js:
            throw new Error("attribute value missed!!");
        }
        return u;
      case "":
        d = " ";
      default:
        if (d <= " ")
          switch (c) {
            case Qs:
              n.setTagName(t.slice(e, u)), c = eo;
              break;
            case li:
              a = t.slice(e, u), c = as;
              break;
            case ls:
              var l = t.slice(e, u).replace(/&#?\w+;/g, i);
              s.warning('attribute "' + l + '" missed quot(")!!'), o(a, l, e);
            case us:
              c = eo;
              break;
          }
        else
          switch (c) {
            case as:
              n.tagName, (!Fo.isHTML(r[""]) || !a.match(/^(?:disabled|checked|selected)$/i)) && s.warning('attribute "' + a + '" missed value!! "' + a + '" instead2!!'), o(a, a, e), e = u, c = li;
              break;
            case us:
              s.warning('attribute space is required"' + a + '"!!');
            case eo:
              c = li, e = u;
              break;
            case Js:
              c = ls, e = u;
              break;
            case Ia:
              throw new Error("elements closed character '/' and '>' must be connected to");
          }
    }
    u++;
  }
}
function Qp(t, e, n) {
  for (var r = t.tagName, i = null, d = t.length; d--; ) {
    var s = t[d], o = s.qName, a = s.value, h = o.indexOf(":");
    if (h > 0)
      var l = s.prefix = o.slice(0, h), u = o.slice(h + 1), c = l === "xmlns" && u;
    else
      u = o, l = null, c = o === "xmlns" && "";
    s.localName = u, c !== !1 && (i == null && (i = {}, J0(n, n = {})), n[c] = i[c] = a, s.uri = Fo.XMLNS, e.startPrefixMapping(c, a));
  }
  for (var d = t.length; d--; ) {
    s = t[d];
    var l = s.prefix;
    l && (l === "xml" && (s.uri = Fo.XML), l !== "xmlns" && (s.uri = n[l || ""]));
  }
  var h = r.indexOf(":");
  h > 0 ? (l = t.prefix = r.slice(0, h), u = t.localName = r.slice(h + 1)) : (l = null, u = t.localName = r);
  var v = t.uri = n[l || ""];
  if (e.startElement(v, u, r, t), t.closed) {
    if (e.endElement(v, u, r), i)
      for (l in i)
        Object.prototype.hasOwnProperty.call(i, l) && e.endPrefixMapping(l);
  } else
    return t.currentNSMap = n, t.localNSMap = i, !0;
}
function QP(t, e, n, r, i) {
  if (/^(?:script|textarea)$/i.test(n)) {
    var s = t.indexOf("</" + n + ">", e), o = t.substring(e + 1, s);
    if (/[&<]/.test(o))
      return /^script$/i.test(n) ? (i.characters(o, 0, o.length), s) : (o = o.replace(/&#?\w+;/g, r), i.characters(o, 0, o.length), s);
  }
  return e + 1;
}
function JP(t, e, n, r) {
  var i = r[n];
  return i == null && (i = t.lastIndexOf("</" + n + ">"), i < e && (i = t.lastIndexOf("</" + n)), r[n] = i), i < e;
}
function J0(t, e) {
  for (var n in t)
    Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
}
function e$(t, e, n, r) {
  var i = t.charAt(e + 2);
  switch (i) {
    case "-":
      if (t.charAt(e + 3) === "-") {
        var s = t.indexOf("-->", e + 4);
        return s > e ? (n.comment(t, e + 4, s - e - 4), s + 3) : (r.error("Unclosed comment"), -1);
      } else
        return -1;
    default:
      if (t.substr(e + 3, 6) == "CDATA[") {
        var s = t.indexOf("]]>", e + 9);
        return n.startCDATA(), n.characters(t, e + 9, s - e - 9), n.endCDATA(), s + 3;
      }
      var o = n$(t, e), a = o.length;
      if (a > 1 && /!doctype/i.test(o[0][0])) {
        var l = o[1][0], u = !1, c = !1;
        a > 3 && (/^public$/i.test(o[2][0]) ? (u = o[3][0], c = a > 4 && o[4][0]) : /^system$/i.test(o[2][0]) && (c = o[3][0]));
        var d = o[a - 1];
        return n.startDTD(l, u, c), n.endDTD(), d.index + d[0].length;
      }
  }
  return -1;
}
function t$(t, e, n) {
  var r = t.indexOf("?>", e);
  if (r) {
    var i = t.substring(e, r).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
    return i ? (i[0].length, n.processingInstruction(i[1], i[2]), r + 2) : -1;
  }
  return -1;
}
function ey() {
  this.attributeNames = {};
}
ey.prototype = {
  setTagName: function(t) {
    if (!Xp.test(t))
      throw new Error("invalid tagName:" + t);
    this.tagName = t;
  },
  addValue: function(t, e, n) {
    if (!Xp.test(t))
      throw new Error("invalid attribute:" + t);
    this.attributeNames[t] = this.length, this[this.length++] = { qName: t, value: e, offset: n };
  },
  length: 0,
  getLocalName: function(t) {
    return this[t].localName;
  },
  getLocator: function(t) {
    return this[t].locator;
  },
  getQName: function(t) {
    return this[t].qName;
  },
  getURI: function(t) {
    return this[t].uri;
  },
  getValue: function(t) {
    return this[t].value;
  }
  //	,getIndex:function(uri, localName)){
  //		if(localName){
  //
  //		}else{
  //			var qName = uri
  //		}
  //	},
  //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
  //	getType:function(uri,localName){}
  //	getType:function(i){},
};
function n$(t, e) {
  var n, r = [], i = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
  for (i.lastIndex = e, i.exec(t); n = i.exec(t); )
    if (r.push(n), n[1])
      return r;
}
xf.XMLReader = Q0;
xf.ParseError = Bs;
var r$ = Ci, Cf = xi, Jp = Z0, ty = xf, i$ = Cf.DOMImplementation, ev = r$.NAMESPACE, s$ = ty.ParseError, o$ = ty.XMLReader;
function ny(t) {
  this.options = t || { locator: {} };
}
ny.prototype.parseFromString = function(t, e) {
  var n = this.options, r = new o$(), i = n.domBuilder || new ua(), s = n.errorHandler, o = n.locator, a = n.xmlns || {}, l = /\/x?html?$/.test(e), u = l ? Jp.HTML_ENTITIES : Jp.XML_ENTITIES;
  return o && i.setDocumentLocator(o), r.errorHandler = a$(s, i, o), r.domBuilder = n.domBuilder || i, l && (a[""] = ev.HTML), a.xml = a.xml || ev.XML, t && typeof t == "string" ? r.parse(t, a, u) : r.errorHandler.error("invalid doc source"), i.doc;
};
function a$(t, e, n) {
  if (!t) {
    if (e instanceof ua)
      return e;
    t = e;
  }
  var r = {}, i = t instanceof Function;
  n = n || {};
  function s(o) {
    var a = t[o];
    !a && i && (a = t.length == 2 ? function(l) {
      t(o, l);
    } : t), r[o] = a && function(l) {
      a("[xmldom " + o + "]	" + l + td(n));
    } || function() {
    };
  }
  return s("warning"), s("error"), s("fatalError"), r;
}
function ua() {
  this.cdata = !1;
}
function cs(t, e) {
  e.lineNumber = t.lineNumber, e.columnNumber = t.columnNumber;
}
ua.prototype = {
  startDocument: function() {
    this.doc = new i$().createDocument(null, null, null), this.locator && (this.doc.documentURI = this.locator.systemId);
  },
  startElement: function(t, e, n, r) {
    var i = this.doc, s = i.createElementNS(t, n || e), o = r.length;
    Ra(this, s), this.currentElement = s, this.locator && cs(this.locator, s);
    for (var a = 0; a < o; a++) {
      var t = r.getURI(a), l = r.getValue(a), n = r.getQName(a), u = i.createAttributeNS(t, n);
      this.locator && cs(r.getLocator(a), u), u.value = u.nodeValue = l, s.setAttributeNode(u);
    }
  },
  endElement: function(t, e, n) {
    var r = this.currentElement;
    r.tagName, this.currentElement = r.parentNode;
  },
  startPrefixMapping: function(t, e) {
  },
  endPrefixMapping: function(t) {
  },
  processingInstruction: function(t, e) {
    var n = this.doc.createProcessingInstruction(t, e);
    this.locator && cs(this.locator, n), Ra(this, n);
  },
  ignorableWhitespace: function(t, e, n) {
  },
  characters: function(t, e, n) {
    if (t = tv.apply(this, arguments), t) {
      if (this.cdata)
        var r = this.doc.createCDATASection(t);
      else
        var r = this.doc.createTextNode(t);
      this.currentElement ? this.currentElement.appendChild(r) : /^\s*$/.test(t) && this.doc.appendChild(r), this.locator && cs(this.locator, r);
    }
  },
  skippedEntity: function(t) {
  },
  endDocument: function() {
    this.doc.normalize();
  },
  setDocumentLocator: function(t) {
    (this.locator = t) && (t.lineNumber = 0);
  },
  //LexicalHandler
  comment: function(t, e, n) {
    t = tv.apply(this, arguments);
    var r = this.doc.createComment(t);
    this.locator && cs(this.locator, r), Ra(this, r);
  },
  startCDATA: function() {
    this.cdata = !0;
  },
  endCDATA: function() {
    this.cdata = !1;
  },
  startDTD: function(t, e, n) {
    var r = this.doc.implementation;
    if (r && r.createDocumentType) {
      var i = r.createDocumentType(t, e, n);
      this.locator && cs(this.locator, i), Ra(this, i), this.doc.doctype = i;
    }
  },
  /**
   * @see org.xml.sax.ErrorHandler
   * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
   */
  warning: function(t) {
    console.warn("[xmldom warning]	" + t, td(this.locator));
  },
  error: function(t) {
    console.error("[xmldom error]	" + t, td(this.locator));
  },
  fatalError: function(t) {
    throw new s$(t, this.locator);
  }
};
function td(t) {
  if (t)
    return `
@` + (t.systemId || "") + "#[line:" + t.lineNumber + ",col:" + t.columnNumber + "]";
}
function tv(t, e, n) {
  return typeof t == "string" ? t.substr(e, n) : t.length >= e + n || e ? new java.lang.String(t, e, n) + "" : t;
}
"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(t) {
  ua.prototype[t] = function() {
    return null;
  };
});
function Ra(t, e) {
  t.currentElement ? t.currentElement.appendChild(e) : t.doc.appendChild(e);
}
la.__DOMHandler = ua;
la.DOMParser = ny;
la.DOMImplementation = Cf.DOMImplementation;
la.XMLSerializer = Cf.XMLSerializer;
var ry = la.DOMParser;
const kf = typeof window < "u" ? window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame : !1, l$ = 1, u$ = 3, iy = typeof URL < "u" ? URL : typeof window < "u" ? window.URL || window.webkitURL || window.mozURL : void 0;
function ru() {
  var t = (/* @__PURE__ */ new Date()).getTime(), e = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(n) {
    var r = (t + Math.random() * 16) % 16 | 0;
    return t = Math.floor(t / 16), (n == "x" ? r : r & 7 | 8).toString(16);
  });
  return e;
}
function c$() {
  return Math.max(
    document.documentElement.clientHeight,
    document.body.scrollHeight,
    document.documentElement.scrollHeight,
    document.body.offsetHeight,
    document.documentElement.offsetHeight
  );
}
function sy(t) {
  return !!(t && t.nodeType == 1);
}
function Xt(t) {
  return !isNaN(parseFloat(t)) && isFinite(t);
}
function oy(t) {
  let e = parseFloat(t);
  return Xt(t) === !1 ? !1 : typeof t == "string" && t.indexOf(".") > -1 ? !0 : Math.floor(e) !== e;
}
function vs(t) {
  var e = ["Webkit", "webkit", "Moz", "O", "ms"], n = ["-webkit-", "-webkit-", "-moz-", "-o-", "-ms-"], r = t.toLowerCase(), i = e.length;
  if (typeof document > "u" || typeof document.body.style[r] < "u")
    return t;
  for (var s = 0; s < i; s++)
    if (typeof document.body.style[n[s] + r] < "u")
      return n[s] + r;
  return t;
}
function ay(t) {
  for (var e = 1, n = arguments.length; e < n; e++) {
    var r = arguments[e];
    for (var i in r)
      t[i] === void 0 && (t[i] = r[i]);
  }
  return t;
}
function En(t) {
  var e = [].slice.call(arguments, 1);
  return e.forEach(function(n) {
    n && Object.getOwnPropertyNames(n).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }), t;
}
function d$(t, e, n) {
  var r = Ms(t, e, n);
  return e.splice(r, 0, t), r;
}
function Ms(t, e, n, r, i) {
  var s = r || 0, o = i || e.length, a = parseInt(s + (o - s) / 2), l;
  return n || (n = function(u, c) {
    if (u > c)
      return 1;
    if (u < c)
      return -1;
    if (u == c)
      return 0;
  }), o - s <= 0 ? a : (l = n(e[a], t), o - s === 1 ? l >= 0 ? a : a + 1 : l === 0 ? a : l === -1 ? Ms(t, e, n, a, o) : Ms(t, e, n, s, a));
}
function kl(t, e, n, r, i) {
  var s = r || 0, o = i || e.length, a = parseInt(s + (o - s) / 2), l;
  return n || (n = function(u, c) {
    if (u > c)
      return 1;
    if (u < c)
      return -1;
    if (u == c)
      return 0;
  }), o - s <= 0 ? -1 : (l = n(e[a], t), o - s === 1 ? l === 0 ? a : -1 : l === 0 ? a : l === -1 ? kl(t, e, n, a, o) : kl(t, e, n, s, a));
}
function Ja(t) {
  var e = window.getComputedStyle(t), n = ["width", "paddingRight", "paddingLeft", "marginRight", "marginLeft", "borderRightWidth", "borderLeftWidth"], r = ["height", "paddingTop", "paddingBottom", "marginTop", "marginBottom", "borderTopWidth", "borderBottomWidth"], i = 0, s = 0;
  return n.forEach(function(o) {
    i += parseFloat(e[o]) || 0;
  }), r.forEach(function(o) {
    s += parseFloat(e[o]) || 0;
  }), {
    height: s,
    width: i
  };
}
function Tl(t) {
  var e = window.getComputedStyle(t), n = ["paddingRight", "paddingLeft", "marginRight", "marginLeft", "borderRightWidth", "borderLeftWidth"], r = ["paddingTop", "paddingBottom", "marginTop", "marginBottom", "borderTopWidth", "borderBottomWidth"], i = 0, s = 0;
  return n.forEach(function(o) {
    i += parseFloat(e[o]) || 0;
  }), r.forEach(function(o) {
    s += parseFloat(e[o]) || 0;
  }), {
    height: s,
    width: i
  };
}
function nd(t) {
  let e, n = t.ownerDocument;
  if (t.nodeType == Node.TEXT_NODE) {
    let r = n.createRange();
    r.selectNodeContents(t), e = r.getBoundingClientRect();
  } else
    e = t.getBoundingClientRect();
  return e;
}
function Ol() {
  var t = window.innerWidth, e = window.innerHeight;
  return {
    top: 0,
    left: 0,
    right: t,
    bottom: e,
    width: t,
    height: e
  };
}
function Tf(t, e) {
  for (var n = t.parentNode, r = n.childNodes, i, s = -1, o = 0; o < r.length && (i = r[o], i.nodeType === e && s++, i != t); o++)
    ;
  return s;
}
function f$(t) {
  return Tf(t, u$);
}
function ly(t) {
  return Tf(t, l$);
}
function jo(t) {
  return ["xml", "opf", "ncx"].indexOf(t) > -1;
}
function uy(t, e) {
  return new Blob([t], { type: e });
}
function Nl(t, e) {
  var n, r = uy(t, e);
  return n = iy.createObjectURL(r), n;
}
function cy(t) {
  return iy.revokeObjectURL(t);
}
function rd(t, e) {
  var n, r;
  if (typeof t == "string")
    return n = btoa(t), r = "data:" + e + ";base64," + n, r;
}
function dy(t) {
  return Object.prototype.toString.call(t).slice(8, -1);
}
function Tr(t, e, n) {
  var r, i;
  return typeof DOMParser > "u" || n ? i = ry : i = DOMParser, t.charCodeAt(0) === 65279 && (t = t.slice(1)), r = new i().parseFromString(t, e), r;
}
function Mt(t, e) {
  var n;
  if (!t)
    throw new Error("No Element Provided");
  if (typeof t.querySelector < "u")
    return t.querySelector(e);
  if (n = t.getElementsByTagName(e), n.length)
    return n[0];
}
function ni(t, e) {
  return typeof t.querySelector < "u" ? t.querySelectorAll(e) : t.getElementsByTagName(e);
}
function ms(t, e, n) {
  var r, i;
  if (typeof t.querySelector < "u") {
    e += "[";
    for (var s in n)
      e += s + "~='" + n[s] + "'";
    return e += "]", t.querySelector(e);
  } else if (r = t.getElementsByTagName(e), i = Array.prototype.slice.call(r, 0).filter(function(o) {
    for (var a in n)
      if (o.getAttribute(a) === n[a])
        return !0;
    return !1;
  }), i)
    return i[0];
}
function Al(t, e) {
  var n = t.ownerDocument || t;
  typeof n.createTreeWalker < "u" ? fy(t, e, NodeFilter.SHOW_TEXT) : Of(t, function(r) {
    r && r.nodeType === 3 && e(r);
  });
}
function fy(t, e, n) {
  var r = document.createTreeWalker(t, n, null, !1);
  let i;
  for (; i = r.nextNode(); )
    e(i);
}
function Of(t, e) {
  if (e(t))
    return !0;
  if (t = t.firstChild, t)
    do {
      if (Of(t, e))
        return !0;
      t = t.nextSibling;
    } while (t);
}
function hy(t) {
  return new Promise(function(e, n) {
    var r = new FileReader();
    r.readAsDataURL(t), r.onloadend = function() {
      e(r.result);
    };
  });
}
function vt() {
  this.resolve = null, this.reject = null, this.id = ru(), this.promise = new Promise((t, e) => {
    this.resolve = t, this.reject = e;
  }), Object.freeze(this);
}
function Il(t, e, n) {
  var r;
  if (typeof t.querySelector < "u" && (r = t.querySelector(`${e}[*|type="${n}"]`)), !r || r.length === 0) {
    r = ni(t, e);
    for (var i = 0; i < r.length; i++)
      if (r[i].getAttributeNS("http://www.idpf.org/2007/ops", "type") === n || r[i].getAttribute("epub:type") === n)
        return r[i];
  } else
    return r;
}
function id(t) {
  for (var e = [], n = t.childNodes, r = 0; r < n.length; r++) {
    let i = n[r];
    i.nodeType === 1 && e.push(i);
  }
  return e;
}
function sd(t) {
  for (var e = [t]; t; t = t.parentNode)
    e.unshift(t);
  return e;
}
function gs(t, e, n) {
  for (var r = [], i = t.childNodes, s = 0; s < i.length; s++) {
    let o = i[s];
    if (o.nodeType === 1 && o.nodeName.toLowerCase() === e) {
      if (n)
        return o;
      r.push(o);
    }
  }
  if (!n)
    return r;
}
function h$(t, e) {
  let n;
  if (!(t === null || e === ""))
    for (n = t.parentNode; n.nodeType === 1; ) {
      if (n.tagName.toLowerCase() === e)
        return n;
      n = n.parentNode;
    }
}
class py {
  constructor() {
    this.collapsed = !1, this.commonAncestorContainer = void 0, this.endContainer = void 0, this.endOffset = void 0, this.startContainer = void 0, this.startOffset = void 0;
  }
  setStart(e, n) {
    this.startContainer = e, this.startOffset = n, this.endContainer ? this.commonAncestorContainer = this._commonAncestorContainer() : this.collapse(!0), this._checkCollapsed();
  }
  setEnd(e, n) {
    this.endContainer = e, this.endOffset = n, this.startContainer ? (this.collapsed = !1, this.commonAncestorContainer = this._commonAncestorContainer()) : this.collapse(!1), this._checkCollapsed();
  }
  collapse(e) {
    this.collapsed = !0, e ? (this.endContainer = this.startContainer, this.endOffset = this.startOffset, this.commonAncestorContainer = this.startContainer.parentNode) : (this.startContainer = this.endContainer, this.startOffset = this.endOffset, this.commonAncestorContainer = this.endOffset.parentNode);
  }
  selectNode(e) {
    let n = e.parentNode, r = Array.prototype.indexOf.call(n.childNodes, e);
    this.setStart(n, r), this.setEnd(n, r + 1);
  }
  selectNodeContents(e) {
    e.childNodes[e.childNodes - 1];
    let n = e.nodeType === 3 ? e.textContent.length : parent.childNodes.length;
    this.setStart(e, 0), this.setEnd(e, n);
  }
  _commonAncestorContainer(e, n) {
    var r = sd(e || this.startContainer), i = sd(n || this.endContainer);
    if (r[0] == i[0]) {
      for (var s = 0; s < r.length; s++)
        if (r[s] != i[s])
          return r[s - 1];
    }
  }
  _checkCollapsed() {
    this.startContainer === this.endContainer && this.startOffset === this.endOffset ? this.collapsed = !0 : this.collapsed = !1;
  }
  toString() {
  }
}
const p$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RangeObject: py,
  blob2base64: hy,
  borders: Tl,
  bounds: Ja,
  createBase64Url: rd,
  createBlob: uy,
  createBlobUrl: Nl,
  defaults: ay,
  defer: vt,
  documentHeight: c$,
  extend: En,
  filterChildren: gs,
  findChildren: id,
  getParentByTagName: h$,
  indexOfElementNode: ly,
  indexOfNode: Tf,
  indexOfSorted: kl,
  indexOfTextNode: f$,
  insert: d$,
  isElement: sy,
  isFloat: oy,
  isNumber: Xt,
  isXml: jo,
  locationOf: Ms,
  nodeBounds: nd,
  parents: sd,
  parse: Tr,
  prefixed: vs,
  qs: Mt,
  qsa: ni,
  qsp: ms,
  querySelectorByType: Il,
  requestAnimationFrame: kf,
  revokeBlobUrl: cy,
  sprint: Al,
  treeWalker: fy,
  type: dy,
  uuid: ru,
  walk: Of,
  windowBounds: Ol
}, Symbol.toStringTag, { value: "Module" }));
if (!vy)
  var vy = {
    cwd: function() {
      return "/";
    }
  };
function wr(t) {
  if (typeof t != "string")
    throw new TypeError("Path must be a string. Received " + t);
}
function nv(t, e) {
  for (var n = "", r = -1, i = 0, s, o = 0; o <= t.length; ++o) {
    if (o < t.length)
      s = t.charCodeAt(o);
    else {
      if (s === 47)
        break;
      s = 47;
    }
    if (s === 47) {
      if (!(r === o - 1 || i === 1))
        if (r !== o - 1 && i === 2) {
          if (n.length < 2 || n.charCodeAt(n.length - 1) !== 46 || n.charCodeAt(n.length - 2) !== 46) {
            if (n.length > 2) {
              for (var a = n.length - 1, l = a; l >= 0 && n.charCodeAt(l) !== 47; --l)
                ;
              if (l !== a) {
                l === -1 ? n = "" : n = n.slice(0, l), r = o, i = 0;
                continue;
              }
            } else if (n.length === 2 || n.length === 1) {
              n = "", r = o, i = 0;
              continue;
            }
          }
          e && (n.length > 0 ? n += "/.." : n = "..");
        } else
          n.length > 0 ? n += "/" + t.slice(r + 1, o) : n = t.slice(r + 1, o);
      r = o, i = 0;
    } else
      s === 46 && i !== -1 ? ++i : i = -1;
  }
  return n;
}
function v$(t, e) {
  var n = e.dir || e.root, r = e.base || (e.name || "") + (e.ext || "");
  return n ? n === e.root ? n + r : n + t + r : r;
}
var el = {
  // path.resolve([from ...], to)
  resolve: function() {
    for (var e = "", n = !1, r, i = arguments.length - 1; i >= -1 && !n; i--) {
      var s;
      i >= 0 ? s = arguments[i] : (r === void 0 && (r = vy.cwd()), s = r), wr(s), s.length !== 0 && (e = s + "/" + e, n = s.charCodeAt(0) === 47);
    }
    return e = nv(e, !n), n ? e.length > 0 ? "/" + e : "/" : e.length > 0 ? e : ".";
  },
  normalize: function(e) {
    if (wr(e), e.length === 0)
      return ".";
    var n = e.charCodeAt(0) === 47, r = e.charCodeAt(e.length - 1) === 47;
    return e = nv(e, !n), e.length === 0 && !n && (e = "."), e.length > 0 && r && (e += "/"), n ? "/" + e : e;
  },
  isAbsolute: function(e) {
    return wr(e), e.length > 0 && e.charCodeAt(0) === 47;
  },
  join: function() {
    if (arguments.length === 0)
      return ".";
    for (var e, n = 0; n < arguments.length; ++n) {
      var r = arguments[n];
      wr(r), r.length > 0 && (e === void 0 ? e = r : e += "/" + r);
    }
    return e === void 0 ? "." : el.normalize(e);
  },
  relative: function(e, n) {
    if (wr(e), wr(n), e === n || (e = el.resolve(e), n = el.resolve(n), e === n))
      return "";
    for (var r = 1; r < e.length && e.charCodeAt(r) === 47; ++r)
      ;
    for (var i = e.length, s = i - r, o = 1; o < n.length && n.charCodeAt(o) === 47; ++o)
      ;
    for (var a = n.length, l = a - o, u = s < l ? s : l, c = -1, d = 0; d <= u; ++d) {
      if (d === u) {
        if (l > u) {
          if (n.charCodeAt(o + d) === 47)
            return n.slice(o + d + 1);
          if (d === 0)
            return n.slice(o + d);
        } else
          s > u && (e.charCodeAt(r + d) === 47 ? c = d : d === 0 && (c = 0));
        break;
      }
      var h = e.charCodeAt(r + d), v = n.charCodeAt(o + d);
      if (h !== v)
        break;
      h === 47 && (c = d);
    }
    var y = "";
    for (d = r + c + 1; d <= i; ++d)
      (d === i || e.charCodeAt(d) === 47) && (y.length === 0 ? y += ".." : y += "/..");
    return y.length > 0 ? y + n.slice(o + c) : (o += c, n.charCodeAt(o) === 47 && ++o, n.slice(o));
  },
  _makeLong: function(e) {
    return e;
  },
  dirname: function(e) {
    if (wr(e), e.length === 0)
      return ".";
    for (var n = e.charCodeAt(0), r = n === 47, i = -1, s = !0, o = e.length - 1; o >= 1; --o)
      if (n = e.charCodeAt(o), n === 47) {
        if (!s) {
          i = o;
          break;
        }
      } else
        s = !1;
    return i === -1 ? r ? "/" : "." : r && i === 1 ? "//" : e.slice(0, i);
  },
  basename: function(e, n) {
    if (n !== void 0 && typeof n != "string")
      throw new TypeError('"ext" argument must be a string');
    wr(e);
    var r = 0, i = -1, s = !0, o;
    if (n !== void 0 && n.length > 0 && n.length <= e.length) {
      if (n.length === e.length && n === e)
        return "";
      var a = n.length - 1, l = -1;
      for (o = e.length - 1; o >= 0; --o) {
        var u = e.charCodeAt(o);
        if (u === 47) {
          if (!s) {
            r = o + 1;
            break;
          }
        } else
          l === -1 && (s = !1, l = o + 1), a >= 0 && (u === n.charCodeAt(a) ? --a === -1 && (i = o) : (a = -1, i = l));
      }
      return r === i ? i = l : i === -1 && (i = e.length), e.slice(r, i);
    } else {
      for (o = e.length - 1; o >= 0; --o)
        if (e.charCodeAt(o) === 47) {
          if (!s) {
            r = o + 1;
            break;
          }
        } else
          i === -1 && (s = !1, i = o + 1);
      return i === -1 ? "" : e.slice(r, i);
    }
  },
  extname: function(e) {
    wr(e);
    for (var n = -1, r = 0, i = -1, s = !0, o = 0, a = e.length - 1; a >= 0; --a) {
      var l = e.charCodeAt(a);
      if (l === 47) {
        if (!s) {
          r = a + 1;
          break;
        }
        continue;
      }
      i === -1 && (s = !1, i = a + 1), l === 46 ? n === -1 ? n = a : o !== 1 && (o = 1) : n !== -1 && (o = -1);
    }
    return n === -1 || i === -1 || // We saw a non-dot character immediately before the dot
    o === 0 || // The (right-most) trimmed path component is exactly '..'
    o === 1 && n === i - 1 && n === r + 1 ? "" : e.slice(n, i);
  },
  format: function(e) {
    if (e === null || typeof e != "object")
      throw new TypeError(
        'Parameter "pathObject" must be an object, not ' + typeof e
      );
    return v$("/", e);
  },
  parse: function(e) {
    wr(e);
    var n = { root: "", dir: "", base: "", ext: "", name: "" };
    if (e.length === 0)
      return n;
    var r = e.charCodeAt(0), i = r === 47, s;
    i ? (n.root = "/", s = 1) : s = 0;
    for (var o = -1, a = 0, l = -1, u = !0, c = e.length - 1, d = 0; c >= s; --c) {
      if (r = e.charCodeAt(c), r === 47) {
        if (!u) {
          a = c + 1;
          break;
        }
        continue;
      }
      l === -1 && (u = !1, l = c + 1), r === 46 ? o === -1 ? o = c : d !== 1 && (d = 1) : o !== -1 && (d = -1);
    }
    return o === -1 || l === -1 || // We saw a non-dot character immediately before the dot
    d === 0 || // The (right-most) trimmed path component is exactly '..'
    d === 1 && o === l - 1 && o === a + 1 ? l !== -1 && (a === 0 && i ? n.base = n.name = e.slice(1, l) : n.base = n.name = e.slice(a, l)) : (a === 0 && i ? (n.name = e.slice(1, o), n.base = e.slice(1, l)) : (n.name = e.slice(a, o), n.base = e.slice(a, l)), n.ext = e.slice(o, l)), a > 0 ? n.dir = e.slice(0, a - 1) : i && (n.dir = "/"), n;
  },
  sep: "/",
  delimiter: ":",
  posix: null
}, mi = el;
class ri {
  constructor(e) {
    var n, r;
    n = e.indexOf("://"), n > -1 && (e = new URL(e).pathname), r = this.parse(e), this.path = e, this.isDirectory(e) ? this.directory = e : this.directory = r.dir + "/", this.filename = r.base, this.extension = r.ext.slice(1);
  }
  /**
   * Parse the path: https://nodejs.org/api/path.html#path_path_parse_path
   * @param	{string} what
   * @returns {object}
   */
  parse(e) {
    return mi.parse(e);
  }
  /**
   * @param	{string} what
   * @returns {boolean}
   */
  isAbsolute(e) {
    return mi.isAbsolute(e || this.path);
  }
  /**
   * Check if path ends with a directory
   * @param	{string} what
   * @returns {boolean}
   */
  isDirectory(e) {
    return e.charAt(e.length - 1) === "/";
  }
  /**
   * Resolve a path against the directory of the Path
   *
   * https://nodejs.org/api/path.html#path_path_resolve_paths
   * @param	{string} what
   * @returns {string} resolved
   */
  resolve(e) {
    return mi.resolve(this.directory, e);
  }
  /**
   * Resolve a path relative to the directory of the Path
   *
   * https://nodejs.org/api/path.html#path_path_relative_from_to
   * @param	{string} what
   * @returns {string} relative
   */
  relative(e) {
    var n = e && e.indexOf("://") > -1;
    return n ? e : mi.relative(this.directory, e);
  }
  splitPath(e) {
    return this.splitPathRe.exec(e).slice(1);
  }
  /**
   * Return the path string
   * @returns {string} path
   */
  toString() {
    return this.path;
  }
}
class fr {
  constructor(e, n) {
    var r = e.indexOf("://") > -1, i = e, s;
    if (this.Url = void 0, this.href = e, this.protocol = "", this.origin = "", this.hash = "", this.hash = "", this.search = "", this.base = n, !r && n !== !1 && typeof n != "string" && window && window.location && (this.base = window.location.href), r || this.base)
      try {
        this.base ? this.Url = new URL(e, this.base) : this.Url = new URL(e), this.href = this.Url.href, this.protocol = this.Url.protocol, this.origin = this.Url.origin, this.hash = this.Url.hash, this.search = this.Url.search, i = this.Url.pathname + (this.Url.search ? this.Url.search : "");
      } catch {
        this.Url = void 0, this.base && (s = new ri(this.base), i = s.resolve(i));
      }
    this.Path = new ri(i), this.directory = this.Path.directory, this.filename = this.Path.filename, this.extension = this.Path.extension;
  }
  /**
   * @returns {Path}
   */
  path() {
    return this.Path;
  }
  /**
   * Resolves a relative path to a absolute url
   * @param {string} what
   * @returns {string} url
   */
  resolve(e) {
    var n = e.indexOf("://") > -1, r;
    return n ? e : (r = mi.resolve(this.directory, e), this.origin + r);
  }
  /**
   * Resolve a path relative to the url
   * @param {string} what
   * @returns {string} path
   */
  relative(e) {
    return mi.relative(e, this.directory);
  }
  /**
   * @returns {string}
   */
  toString() {
    return this.href;
  }
}
const ds = 1, Jn = 3, m$ = 9;
class mt {
  constructor(e, n, r) {
    var i;
    if (this.str = "", this.base = {}, this.spinePos = 0, this.range = !1, this.path = {}, this.start = null, this.end = null, !(this instanceof mt))
      return new mt(e, n, r);
    if (typeof n == "string" ? this.base = this.parseComponent(n) : typeof n == "object" && n.steps && (this.base = n), i = this.checkType(e), i === "string")
      return this.str = e, En(this, this.parse(e));
    if (i === "range")
      return En(this, this.fromRange(e, this.base, r));
    if (i === "node")
      return En(this, this.fromNode(e, this.base, r));
    if (i === "EpubCFI" && e.path)
      return e;
    if (e)
      throw new TypeError("not a valid argument for EpubCFI");
    return this;
  }
  /**
   * Check the type of constructor input
   * @private
   */
  checkType(e) {
    return this.isCfiString(e) ? "string" : e && typeof e == "object" && (dy(e) === "Range" || typeof e.startContainer < "u") ? "range" : e && typeof e == "object" && typeof e.nodeType < "u" ? "node" : e && typeof e == "object" && e instanceof mt ? "EpubCFI" : !1;
  }
  /**
   * Parse a cfi string to a CFI object representation
   * @param {string} cfiStr
   * @returns {object} cfi
   */
  parse(e) {
    var n = {
      spinePos: -1,
      range: !1,
      base: {},
      path: {},
      start: null,
      end: null
    }, r, i, s;
    return typeof e != "string" ? { spinePos: -1 } : (e.indexOf("epubcfi(") === 0 && e[e.length - 1] === ")" && (e = e.slice(8, e.length - 1)), r = this.getChapterComponent(e), r ? (n.base = this.parseComponent(r), i = this.getPathComponent(e), n.path = this.parseComponent(i), s = this.getRange(e), s && (n.range = !0, n.start = this.parseComponent(s[0]), n.end = this.parseComponent(s[1])), n.spinePos = n.base.steps[1].index, n) : { spinePos: -1 });
  }
  parseComponent(e) {
    var n = {
      steps: [],
      terminal: {
        offset: null,
        assertion: null
      }
    }, r = e.split(":"), i = r[0].split("/"), s;
    return r.length > 1 && (s = r[1], n.terminal = this.parseTerminal(s)), i[0] === "" && i.shift(), n.steps = i.map(function(o) {
      return this.parseStep(o);
    }.bind(this)), n;
  }
  parseStep(e) {
    var n, r, i, s, o;
    if (s = e.match(/\[(.*)\]/), s && s[1] && (o = s[1]), r = parseInt(e), !isNaN(r))
      return r % 2 === 0 ? (n = "element", i = r / 2 - 1) : (n = "text", i = (r - 1) / 2), {
        type: n,
        index: i,
        id: o || null
      };
  }
  parseTerminal(e) {
    var n, r, i = e.match(/\[(.*)\]/);
    return i && i[1] ? (n = parseInt(e.split("[")[0]), r = i[1]) : n = parseInt(e), Xt(n) || (n = null), {
      offset: n,
      assertion: r
    };
  }
  getChapterComponent(e) {
    var n = e.split("!");
    return n[0];
  }
  getPathComponent(e) {
    var n = e.split("!");
    if (n[1])
      return n[1].split(",")[0];
  }
  getRange(e) {
    var n = e.split(",");
    return n.length === 3 ? [
      n[1],
      n[2]
    ] : !1;
  }
  getCharecterOffsetComponent(e) {
    var n = e.split(":");
    return n[1] || "";
  }
  joinSteps(e) {
    return e ? e.map(function(n) {
      var r = "";
      return n.type === "element" && (r += (n.index + 1) * 2), n.type === "text" && (r += 1 + 2 * n.index), n.id && (r += "[" + n.id + "]"), r;
    }).join("/") : "";
  }
  segmentString(e) {
    var n = "/";
    return n += this.joinSteps(e.steps), e.terminal && e.terminal.offset != null && (n += ":" + e.terminal.offset), e.terminal && e.terminal.assertion != null && (n += "[" + e.terminal.assertion + "]"), n;
  }
  /**
   * Convert CFI to a epubcfi(...) string
   * @returns {string} epubcfi
   */
  toString() {
    var e = "epubcfi(";
    return e += this.segmentString(this.base), e += "!", e += this.segmentString(this.path), this.range && this.start && (e += ",", e += this.segmentString(this.start)), this.range && this.end && (e += ",", e += this.segmentString(this.end)), e += ")", e;
  }
  /**
   * Compare which of two CFIs is earlier in the text
   * @returns {number} First is earlier = -1, Second is earlier = 1, They are equal = 0
   */
  compare(e, n) {
    var r, i, s, o;
    if (typeof e == "string" && (e = new mt(e)), typeof n == "string" && (n = new mt(n)), e.spinePos > n.spinePos)
      return 1;
    if (e.spinePos < n.spinePos)
      return -1;
    e.range ? (r = e.path.steps.concat(e.start.steps), s = e.start.terminal) : (r = e.path.steps, s = e.path.terminal), n.range ? (i = n.path.steps.concat(n.start.steps), o = n.start.terminal) : (i = n.path.steps, o = n.path.terminal);
    for (var a = 0; a < r.length; a++) {
      if (!r[a])
        return -1;
      if (!i[a] || r[a].index > i[a].index)
        return 1;
      if (r[a].index < i[a].index)
        return -1;
    }
    return r.length < i.length ? -1 : s.offset > o.offset ? 1 : s.offset < o.offset ? -1 : 0;
  }
  step(e) {
    var n = e.nodeType === Jn ? "text" : "element";
    return {
      id: e.id,
      tagName: e.tagName,
      type: n,
      index: this.position(e)
    };
  }
  filteredStep(e, n) {
    var r = this.filter(e, n), i;
    if (r)
      return i = r.nodeType === Jn ? "text" : "element", {
        id: r.id,
        tagName: r.tagName,
        type: i,
        index: this.filteredPosition(r, n)
      };
  }
  pathTo(e, n, r) {
    for (var i = {
      steps: [],
      terminal: {
        offset: null,
        assertion: null
      }
    }, s = e, o; s && s.parentNode && s.parentNode.nodeType != m$; )
      r ? o = this.filteredStep(s, r) : o = this.step(s), o && i.steps.unshift(o), s = s.parentNode;
    return n != null && n >= 0 && (i.terminal.offset = n, i.steps[i.steps.length - 1].type != "text" && i.steps.push({
      type: "text",
      index: 0
    })), i;
  }
  equalStep(e, n) {
    return !e || !n ? !1 : e.index === n.index && e.id === n.id && e.type === n.type;
  }
  /**
   * Create a CFI object from a Range
   * @param {Range} range
   * @param {string | object} base
   * @param {string} [ignoreClass]
   * @returns {object} cfi
   */
  fromRange(e, n, r) {
    var i = {
      range: !1,
      base: {},
      path: {},
      start: null,
      end: null
    }, s = e.startContainer, o = e.endContainer, a = e.startOffset, l = e.endOffset, u = !1;
    if (r && (u = s.ownerDocument.querySelector("." + r) != null), typeof n == "string" ? (i.base = this.parseComponent(n), i.spinePos = i.base.steps[1].index) : typeof n == "object" && (i.base = n), e.collapsed)
      u && (a = this.patchOffset(s, a, r)), i.path = this.pathTo(s, a, r);
    else {
      i.range = !0, u && (a = this.patchOffset(s, a, r)), i.start = this.pathTo(s, a, r), u && (l = this.patchOffset(o, l, r)), i.end = this.pathTo(o, l, r), i.path = {
        steps: [],
        terminal: null
      };
      var c = i.start.steps.length, d;
      for (d = 0; d < c && this.equalStep(i.start.steps[d], i.end.steps[d]); d++)
        d === c - 1 ? i.start.terminal === i.end.terminal && (i.path.steps.push(i.start.steps[d]), i.range = !1) : i.path.steps.push(i.start.steps[d]);
      i.start.steps = i.start.steps.slice(i.path.steps.length), i.end.steps = i.end.steps.slice(i.path.steps.length);
    }
    return i;
  }
  /**
   * Create a CFI object from a Node
   * @param {Node} anchor
   * @param {string | object} base
   * @param {string} [ignoreClass]
   * @returns {object} cfi
   */
  fromNode(e, n, r) {
    var i = {
      range: !1,
      base: {},
      path: {},
      start: null,
      end: null
    };
    return typeof n == "string" ? (i.base = this.parseComponent(n), i.spinePos = i.base.steps[1].index) : typeof n == "object" && (i.base = n), i.path = this.pathTo(e, null, r), i;
  }
  filter(e, n) {
    var r, i, s, o, a, l = !1;
    return e.nodeType === Jn ? (l = !0, s = e.parentNode, r = e.parentNode.classList.contains(n)) : (l = !1, r = e.classList.contains(n)), r && l ? (o = s.previousSibling, a = s.nextSibling, o && o.nodeType === Jn ? i = o : a && a.nodeType === Jn && (i = a), i || e) : r && !l ? !1 : e;
  }
  patchOffset(e, n, r) {
    if (e.nodeType != Jn)
      throw new Error("Anchor must be a text node");
    var i = e, s = n;
    for (e.parentNode.classList.contains(r) && (i = e.parentNode); i.previousSibling; ) {
      if (i.previousSibling.nodeType === ds)
        if (i.previousSibling.classList.contains(r))
          s += i.previousSibling.textContent.length;
        else
          break;
      else
        s += i.previousSibling.textContent.length;
      i = i.previousSibling;
    }
    return s;
  }
  normalizedMap(e, n, r) {
    var i = {}, s = -1, o, a = e.length, l, u;
    for (o = 0; o < a; o++)
      l = e[o].nodeType, l === ds && e[o].classList.contains(r) && (l = Jn), o > 0 && l === Jn && u === Jn ? i[o] = s : n === l && (s = s + 1, i[o] = s), u = l;
    return i;
  }
  position(e) {
    var n, r;
    return e.nodeType === ds ? (n = e.parentNode.children, n || (n = id(e.parentNode)), r = Array.prototype.indexOf.call(n, e)) : (n = this.textNodes(e.parentNode), r = n.indexOf(e)), r;
  }
  filteredPosition(e, n) {
    var r, i, s;
    return e.nodeType === ds ? (r = e.parentNode.children, s = this.normalizedMap(r, ds, n)) : (r = e.parentNode.childNodes, e.parentNode.classList.contains(n) && (e = e.parentNode, r = e.parentNode.childNodes), s = this.normalizedMap(r, Jn, n)), i = Array.prototype.indexOf.call(r, e), s[i];
  }
  stepsToXpath(e) {
    var n = [".", "*"];
    return e.forEach(function(r) {
      var i = r.index + 1;
      r.id ? n.push("*[position()=" + i + " and @id='" + r.id + "']") : r.type === "text" ? n.push("text()[" + i + "]") : n.push("*[" + i + "]");
    }), n.join("/");
  }
  /*
  
  	To get the last step if needed:
  
  	// Get the terminal step
  	lastStep = steps[steps.length-1];
  	// Get the query string
  	query = this.stepsToQuery(steps);
  	// Find the containing element
  	startContainerParent = doc.querySelector(query);
  	// Find the text node within that element
  	if(startContainerParent && lastStep.type == "text") {
  		container = startContainerParent.childNodes[lastStep.index];
  	}
  	*/
  stepsToQuerySelector(e) {
    var n = ["html"];
    return e.forEach(function(r) {
      var i = r.index + 1;
      r.id ? n.push("#" + r.id) : r.type === "text" || n.push("*:nth-child(" + i + ")");
    }), n.join(">");
  }
  textNodes(e, n) {
    return Array.prototype.slice.call(e.childNodes).filter(function(r) {
      return r.nodeType === Jn ? !0 : !!(n && r.classList.contains(n));
    });
  }
  walkToNode(e, n, r) {
    var i = n || document, s = i.documentElement, o, a, l = e.length, u;
    for (u = 0; u < l && (a = e[u], a.type === "element" ? a.id ? s = i.getElementById(a.id) : (o = s.children || id(s), s = o[a.index]) : a.type === "text" && (s = this.textNodes(s, r)[a.index]), !!s); u++)
      ;
    return s;
  }
  findNode(e, n, r) {
    var i = n || document, s, o;
    return !r && typeof i.evaluate < "u" ? (o = this.stepsToXpath(e), s = i.evaluate(o, i, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue) : r ? s = this.walkToNode(e, i, r) : s = this.walkToNode(e, i), s;
  }
  fixMiss(e, n, r, i) {
    var s = this.findNode(e.slice(0, -1), r, i), o = s.childNodes, a = this.normalizedMap(o, Jn, i), l, u, c = e[e.length - 1].index;
    for (let d in a) {
      if (!a.hasOwnProperty(d))
        return;
      if (a[d] === c)
        if (l = o[d], u = l.textContent.length, n > u)
          n = n - u;
        else {
          l.nodeType === ds ? s = l.childNodes[0] : s = l;
          break;
        }
    }
    return {
      container: s,
      offset: n
    };
  }
  /**
   * Creates a DOM range representing a CFI
   * @param {document} _doc document referenced in the base
   * @param {string} [ignoreClass]
   * @return {Range}
   */
  toRange(e, n) {
    var r = e || document, i, s, o, a, l, u = this, c, d, h = n ? r.querySelector("." + n) != null : !1, v;
    if (typeof r.createRange < "u" ? i = r.createRange() : i = new py(), u.range ? (s = u.start, c = u.path.steps.concat(s.steps), a = this.findNode(c, r, h ? n : null), o = u.end, d = u.path.steps.concat(o.steps), l = this.findNode(d, r, h ? n : null)) : (s = u.path, c = u.path.steps, a = this.findNode(u.path.steps, r, h ? n : null)), a)
      try {
        s.terminal.offset != null ? i.setStart(a, s.terminal.offset) : i.setStart(a, 0);
      } catch {
        v = this.fixMiss(c, s.terminal.offset, r, h ? n : null), i.setStart(v.container, v.offset);
      }
    else
      return console.log("No startContainer found for", this.toString()), null;
    if (l)
      try {
        o.terminal.offset != null ? i.setEnd(l, o.terminal.offset) : i.setEnd(l, 0);
      } catch {
        v = this.fixMiss(d, u.end.terminal.offset, r, h ? n : null), i.setEnd(v.container, v.offset);
      }
    return i;
  }
  /**
   * Check if a string is wrapped with "epubcfi()"
   * @param {string} str
   * @returns {boolean}
   */
  isCfiString(e) {
    return typeof e == "string" && e.indexOf("epubcfi(") === 0 && e[e.length - 1] === ")";
  }
  generateChapterComponent(e, n, r) {
    var i = parseInt(n), s = (e + 1) * 2, o = "/" + s + "/";
    return o += (i + 1) * 2, r && (o += "[" + r + "]"), o;
  }
  /**
   * Collapse a CFI Range to a single CFI Position
   * @param {boolean} [toStart=false]
   */
  collapse(e) {
    this.range && (this.range = !1, e ? (this.path.steps = this.path.steps.concat(this.start.steps), this.path.terminal = this.start.terminal) : (this.path.steps = this.path.steps.concat(this.end.steps), this.path.terminal = this.end.terminal));
  }
}
class hr {
  constructor(e) {
    this.context = e || this, this.hooks = [];
  }
  /**
   * Adds a function to be run before a hook completes
   * @example this.content.register(function(){...});
   */
  register() {
    for (var e = 0; e < arguments.length; ++e)
      if (typeof arguments[e] == "function")
        this.hooks.push(arguments[e]);
      else
        for (var n = 0; n < arguments[e].length; ++n)
          this.hooks.push(arguments[e][n]);
  }
  /**
   * Removes a function
   * @example this.content.deregister(function(){...});
   */
  deregister(e) {
    let n;
    for (let r = 0; r < this.hooks.length; r++)
      if (n = this.hooks[r], n === e) {
        this.hooks.splice(r, 1);
        break;
      }
  }
  /**
   * Triggers a hook to run all functions
   * @example this.content.trigger(args).then(function(){...});
   */
  trigger() {
    var e = arguments, n = this.context, r = [];
    return this.hooks.forEach(function(i) {
      try {
        var s = i.apply(n, e);
      } catch (o) {
        console.log(o);
      }
      s && typeof s.then == "function" && r.push(s);
    }), Promise.all(r);
  }
  // Adds a function to be run before a hook completes
  list() {
    return this.hooks;
  }
  clear() {
    return this.hooks = [];
  }
}
function my(t, e) {
  var n, r, i = e.url, s = i.indexOf("://") > -1;
  t && (r = Mt(t, "head"), n = Mt(r, "base"), n || (n = t.createElement("base"), r.insertBefore(n, r.firstChild)), !s && window && window.location && (i = window.location.origin + i), n.setAttribute("href", i));
}
function g$(t, e) {
  var n, r, i = e.canonical;
  t && (n = Mt(t, "head"), r = Mt(n, "link[rel='canonical']"), r ? r.setAttribute("href", i) : (r = t.createElement("link"), r.setAttribute("rel", "canonical"), r.setAttribute("href", i), n.appendChild(r)));
}
function y$(t, e) {
  var n, r, i = e.idref;
  t && (n = Mt(t, "head"), r = Mt(n, "link[property='dc.identifier']"), r ? r.setAttribute("content", i) : (r = t.createElement("meta"), r.setAttribute("name", "dc.identifier"), r.setAttribute("content", i), n.appendChild(r)));
}
function b$(t, e) {
  var n = t.querySelectorAll("a[href]");
  if (n.length)
    for (var r = Mt(t.ownerDocument, "base"), i = r ? r.getAttribute("href") : void 0, s = function(a) {
      var l = a.getAttribute("href");
      if (l.indexOf("mailto:") !== 0) {
        var u = l.indexOf("://") > -1;
        if (u)
          a.setAttribute("target", "_blank");
        else {
          var c;
          try {
            c = new fr(l, i);
          } catch {
          }
          a.onclick = function() {
            return c && c.hash ? e(c.Path.path + c.hash) : e(c ? c.Path.path : l), !1;
          };
        }
      }
    }.bind(this), o = 0; o < n.length; o++)
      s(n[o]);
}
function rv(t, e, n) {
  return e.forEach(function(r, i) {
    r && n[i] && (r = r.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), t = t.replace(new RegExp(r, "g"), n[i]));
  }), t;
}
function Uo(t, e, n, r) {
  var i = typeof window < "u" ? window.URL : !1, s = i ? "blob" : "arraybuffer", o = new vt(), a = new XMLHttpRequest(), l = XMLHttpRequest.prototype, u;
  "overrideMimeType" in l || Object.defineProperty(l, "overrideMimeType", {
    value: function() {
    }
  }), n && (a.withCredentials = !0), a.onreadystatechange = d, a.onerror = c, a.open("GET", t, !0);
  for (u in r)
    a.setRequestHeader(u, r[u]);
  e == "json" && a.setRequestHeader("Accept", "application/json"), e || (e = new ri(t).extension), e == "blob" && (a.responseType = s), jo(e) && a.overrideMimeType("text/xml"), e == "binary" && (a.responseType = "arraybuffer"), a.send();
  function c(h) {
    o.reject(h);
  }
  function d() {
    if (this.readyState === XMLHttpRequest.DONE) {
      var h = !1;
      if ((this.responseType === "" || this.responseType === "document") && (h = this.responseXML), this.status === 200 || this.status === 0 || h) {
        var v;
        if (!this.response && !h)
          return o.reject({
            status: this.status,
            message: "Empty Response",
            stack: new Error().stack
          }), o.promise;
        if (this.status === 403)
          return o.reject({
            status: this.status,
            response: this.response,
            message: "Forbidden",
            stack: new Error().stack
          }), o.promise;
        h ? v = this.responseXML : jo(e) ? v = Tr(this.response, "text/xml") : e == "xhtml" ? v = Tr(this.response, "application/xhtml+xml") : e == "html" || e == "htm" ? v = Tr(this.response, "text/html") : e == "json" ? v = JSON.parse(this.response) : e == "blob" ? i ? v = this.response : v = new Blob([this.response]) : v = this.response, o.resolve(v);
      } else
        o.reject({
          status: this.status,
          message: this.response,
          stack: new Error().stack
        });
    }
  }
  return o.promise;
}
class w$ {
  constructor(e, n) {
    this.idref = e.idref, this.linear = e.linear === "yes", this.properties = e.properties, this.index = e.index, this.href = e.href, this.url = e.url, this.canonical = e.canonical, this.next = e.next, this.prev = e.prev, this.cfiBase = e.cfiBase, n ? this.hooks = n : (this.hooks = {}, this.hooks.serialize = new hr(this), this.hooks.content = new hr(this)), this.document = void 0, this.contents = void 0, this.output = void 0;
  }
  /**
   * Load the section from its url
   * @param  {method} [_request] a request method to use for loading
   * @return {document} a promise with the xml document
   */
  load(e) {
    var n = e || this.request || Uo, r = new vt(), i = r.promise;
    return this.contents ? r.resolve(this.contents) : n(this.url).then(function(s) {
      return this.document = s, this.contents = s.documentElement, this.hooks.content.trigger(this.document, this);
    }.bind(this)).then(function() {
      r.resolve(this.contents);
    }.bind(this)).catch(function(s) {
      r.reject(s);
    }), i;
  }
  /**
   * Adds a base tag for resolving urls in the section
   * @private
   */
  base() {
    return my(this.document, this);
  }
  /**
   * Render the contents of a section
   * @param  {method} [_request] a request method to use for loading
   * @return {string} output a serialized XML Document
   */
  render(e) {
    var n = new vt(), r = n.promise;
    return this.output, this.load(e).then(function(i) {
      var s = typeof navigator < "u" && navigator.userAgent || "", o = s.indexOf("Trident") >= 0, a;
      typeof XMLSerializer > "u" || o ? a = ry : a = XMLSerializer;
      var l = new a();
      return this.output = l.serializeToString(i), this.output;
    }.bind(this)).then(function() {
      return this.hooks.serialize.trigger(this.output, this);
    }.bind(this)).then(function() {
      n.resolve(this.output);
    }.bind(this)).catch(function(i) {
      n.reject(i);
    }), r;
  }
  /**
   * Find a string in a section
   * @param  {string} _query The query string to find
   * @return {object[]} A list of matches, with form {cfi, excerpt}
   */
  find(e) {
    var n = this, r = [], i = e.toLowerCase(), s = function(o) {
      for (var a = o.textContent.toLowerCase(), l = n.document.createRange(), u, c, d = -1, h, v = 150; c != -1; )
        c = a.indexOf(i, d + 1), c != -1 && (l = n.document.createRange(), l.setStart(o, c), l.setEnd(o, c + i.length), u = n.cfiFromRange(l), o.textContent.length < v ? h = o.textContent : (h = o.textContent.substring(c - v / 2, c + v / 2), h = "..." + h + "..."), r.push({
          cfi: u,
          excerpt: h
        })), d = c;
    };
    return Al(n.document, function(o) {
      s(o);
    }), r;
  }
  /**
   * Search a string in multiple sequential Element of the section. If the document.createTreeWalker api is missed(eg: IE8), use `find` as a fallback.
   * @param  {string} _query The query string to search
   * @param  {int} maxSeqEle The maximum number of Element that are combined for search, default value is 5.
   * @return {object[]} A list of matches, with form {cfi, excerpt}
   */
  search(e, n = 5) {
    if (typeof document.createTreeWalker > "u")
      return this.find(e);
    let r = [];
    const i = 150, s = this, o = e.toLowerCase(), a = function(d) {
      const y = d.reduce((b, p) => b + p.textContent, "").toLowerCase().indexOf(o);
      if (y != -1) {
        const p = y + o.length;
        let f = 0, m = 0;
        if (y < d[0].length) {
          let g;
          for (; f < d.length - 1 && (m += d[f].length, !(p <= m)); )
            f += 1;
          let w = d[0], _ = d[f], E = s.document.createRange();
          E.setStart(w, y);
          let C = d.slice(0, f).reduce((k, N) => k + N.textContent.length, 0);
          E.setEnd(_, C > p ? p : p - C), g = s.cfiFromRange(E);
          let T = d.slice(0, f + 1).reduce((k, N) => k + N.textContent, "");
          T.length > i && (T = T.substring(y - i / 2, y + i / 2), T = "..." + T + "..."), r.push({
            cfi: g,
            excerpt: T
          });
        }
      }
    }, l = document.createTreeWalker(s.document, NodeFilter.SHOW_TEXT, null, !1);
    let u, c = [];
    for (; u = l.nextNode(); )
      c.push(u), c.length == n && (a(c.slice(0, n)), c = c.slice(1, n));
    return c.length > 0 && a(c), r;
  }
  /**
  * Reconciles the current chapters layout properties with
  * the global layout properties.
  * @param {object} globalLayout  The global layout settings object, chapter properties string
  * @return {object} layoutProperties Object with layout properties
  */
  reconcileLayoutSettings(e) {
    var n = {
      layout: e.layout,
      spread: e.spread,
      orientation: e.orientation
    };
    return this.properties.forEach(function(r) {
      var i = r.replace("rendition:", ""), s = i.indexOf("-"), o, a;
      s != -1 && (o = i.slice(0, s), a = i.slice(s + 1), n[o] = a);
    }), n;
  }
  /**
   * Get a CFI from a Range in the Section
   * @param  {range} _range
   * @return {string} cfi an EpubCFI string
   */
  cfiFromRange(e) {
    return new mt(e, this.cfiBase).toString();
  }
  /**
   * Get a CFI from an Element in the Section
   * @param  {element} el
   * @return {string} cfi an EpubCFI string
   */
  cfiFromElement(e) {
    return new mt(e, this.cfiBase).toString();
  }
  /**
   * Unload the section document
   */
  unload() {
    this.document = void 0, this.contents = void 0, this.output = void 0;
  }
  destroy() {
    this.unload(), this.hooks.serialize.clear(), this.hooks.content.clear(), this.hooks = void 0, this.idref = void 0, this.linear = void 0, this.properties = void 0, this.index = void 0, this.href = void 0, this.url = void 0, this.next = void 0, this.prev = void 0, this.cfiBase = void 0;
  }
}
class _$ {
  constructor() {
    this.spineItems = [], this.spineByHref = {}, this.spineById = {}, this.hooks = {}, this.hooks.serialize = new hr(), this.hooks.content = new hr(), this.hooks.content.register(my), this.hooks.content.register(g$), this.hooks.content.register(y$), this.epubcfi = new mt(), this.loaded = !1, this.items = void 0, this.manifest = void 0, this.spineNodeIndex = void 0, this.baseUrl = void 0, this.length = void 0;
  }
  /**
   * Unpack items from a opf into spine items
   * @param  {Packaging} _package
   * @param  {method} resolver URL resolver
   * @param  {method} canonical Resolve canonical url
   */
  unpack(e, n, r) {
    this.items = e.spine, this.manifest = e.manifest, this.spineNodeIndex = e.spineNodeIndex, this.baseUrl = e.baseUrl || e.basePath || "", this.length = this.items.length, this.items.forEach((i, s) => {
      var o = this.manifest[i.idref], a;
      i.index = s, i.cfiBase = this.epubcfi.generateChapterComponent(this.spineNodeIndex, i.index, i.id), i.href && (i.url = n(i.href, !0), i.canonical = r(i.href)), o && (i.href = o.href, i.url = n(i.href, !0), i.canonical = r(i.href), o.properties.length && i.properties.push.apply(i.properties, o.properties)), i.linear === "yes" ? (i.prev = function() {
        let l = i.index;
        for (; l > 0; ) {
          let u = this.get(l - 1);
          if (u && u.linear)
            return u;
          l -= 1;
        }
      }.bind(this), i.next = function() {
        let l = i.index;
        for (; l < this.spineItems.length - 1; ) {
          let u = this.get(l + 1);
          if (u && u.linear)
            return u;
          l += 1;
        }
      }.bind(this)) : (i.prev = function() {
      }, i.next = function() {
      }), a = new w$(i, this.hooks), this.append(a);
    }), this.loaded = !0;
  }
  /**
   * Get an item from the spine
   * @param  {string|number} [target]
   * @return {Section} section
   * @example spine.get();
   * @example spine.get(1);
   * @example spine.get("chap1.html");
   * @example spine.get("#id1234");
   */
  get(e) {
    var n = 0;
    if (typeof e > "u")
      for (; n < this.spineItems.length; ) {
        let r = this.spineItems[n];
        if (r && r.linear)
          break;
        n += 1;
      }
    else
      this.epubcfi.isCfiString(e) ? n = new mt(e).spinePos : typeof e == "number" || isNaN(e) === !1 ? n = e : typeof e == "string" && e.indexOf("#") === 0 ? n = this.spineById[e.substring(1)] : typeof e == "string" && (e = e.split("#")[0], n = this.spineByHref[e] || this.spineByHref[encodeURI(e)]);
    return this.spineItems[n] || null;
  }
  /**
   * Append a Section to the Spine
   * @private
   * @param  {Section} section
   */
  append(e) {
    var n = this.spineItems.length;
    return e.index = n, this.spineItems.push(e), this.spineByHref[decodeURI(e.href)] = n, this.spineByHref[encodeURI(e.href)] = n, this.spineByHref[e.href] = n, this.spineById[e.idref] = n, n;
  }
  /**
   * Prepend a Section to the Spine
   * @private
   * @param  {Section} section
   */
  prepend(e) {
    return this.spineByHref[e.href] = 0, this.spineById[e.idref] = 0, this.spineItems.forEach(function(n, r) {
      n.index = r;
    }), 0;
  }
  // insert(section, index) {
  //
  // };
  /**
   * Remove a Section from the Spine
   * @private
   * @param  {Section} section
   */
  remove(e) {
    var n = this.spineItems.indexOf(e);
    if (n > -1)
      return delete this.spineByHref[e.href], delete this.spineById[e.idref], this.spineItems.splice(n, 1);
  }
  /**
   * Loop over the Sections in the Spine
   * @return {method} forEach
   */
  each() {
    return this.spineItems.forEach.apply(this.spineItems, arguments);
  }
  /**
   * Find the first Section in the Spine
   * @return {Section} first section
   */
  first() {
    let e = 0;
    do {
      let n = this.get(e);
      if (n && n.linear)
        return n;
      e += 1;
    } while (e < this.spineItems.length);
  }
  /**
   * Find the last Section in the Spine
   * @return {Section} last section
   */
  last() {
    let e = this.spineItems.length - 1;
    do {
      let n = this.get(e);
      if (n && n.linear)
        return n;
      e -= 1;
    } while (e >= 0);
  }
  destroy() {
    this.each((e) => e.destroy()), this.spineItems = void 0, this.spineByHref = void 0, this.spineById = void 0, this.hooks.serialize.clear(), this.hooks.content.clear(), this.hooks = void 0, this.epubcfi = void 0, this.loaded = !1, this.items = void 0, this.manifest = void 0, this.spineNodeIndex = void 0, this.baseUrl = void 0, this.length = void 0;
  }
}
class Nf {
  constructor(e) {
    this._q = [], this.context = e, this.tick = kf, this.running = !1, this.paused = !1;
  }
  /**
   * Add an item to the queue
   * @return {Promise}
   */
  enqueue() {
    var e, n, r, i = [].shift.call(arguments), s = arguments;
    if (!i)
      throw new Error("No Task Provided");
    return typeof i == "function" ? (e = new vt(), n = e.promise, r = {
      task: i,
      args: s,
      //"context"  : context,
      deferred: e,
      promise: n
    }) : r = {
      promise: i
    }, this._q.push(r), this.paused == !1 && !this.running && this.run(), r.promise;
  }
  /**
   * Run one item
   * @return {Promise}
   */
  dequeue() {
    var e, n, r;
    if (this._q.length && !this.paused) {
      if (e = this._q.shift(), n = e.task, n)
        return r = n.apply(this.context, e.args), r && typeof r.then == "function" ? r.then(function() {
          e.deferred.resolve.apply(this.context, arguments);
        }.bind(this), function() {
          e.deferred.reject.apply(this.context, arguments);
        }.bind(this)) : (e.deferred.resolve.apply(this.context, r), e.promise);
      if (e.promise)
        return e.promise;
    } else
      return e = new vt(), e.deferred.resolve(), e.promise;
  }
  // Run All Immediately
  dump() {
    for (; this._q.length; )
      this.dequeue();
  }
  /**
   * Run all tasks sequentially, at convince
   * @return {Promise}
   */
  run() {
    return this.running || (this.running = !0, this.defered = new vt()), this.tick.call(window, () => {
      this._q.length ? this.dequeue().then(function() {
        this.run();
      }.bind(this)) : (this.defered.resolve(), this.running = void 0);
    }), this.paused == !0 && (this.paused = !1), this.defered.promise;
  }
  /**
   * Flush all, as quickly as possible
   * @return {Promise}
   */
  flush() {
    if (this.running)
      return this.running;
    if (this._q.length)
      return this.running = this.dequeue().then(function() {
        return this.running = void 0, this.flush();
      }.bind(this)), this.running;
  }
  /**
   * Clear all items in wait
   */
  clear() {
    this._q = [];
  }
  /**
   * Get the number of tasks in the queue
   * @return {number} tasks
   */
  length() {
    return this._q.length;
  }
  /**
   * Pause a running queue
   */
  pause() {
    this.paused = !0;
  }
  /**
   * End the queue
   */
  stop() {
    this._q = [], this.running = !1, this.paused = !0;
  }
}
const iu = "0.3", tl = ["keydown", "keyup", "keypressed", "mouseup", "mousedown", "mousemove", "click", "touchend", "touchstart", "touchmove"], Re = {
  BOOK: {
    OPEN_FAILED: "openFailed"
  },
  CONTENTS: {
    EXPAND: "expand",
    RESIZE: "resize",
    SELECTED: "selected",
    SELECTED_RANGE: "selectedRange",
    LINK_CLICKED: "linkClicked"
  },
  LOCATIONS: {
    CHANGED: "changed"
  },
  MANAGERS: {
    RESIZE: "resize",
    RESIZED: "resized",
    ORIENTATION_CHANGE: "orientationchange",
    ADDED: "added",
    SCROLL: "scroll",
    SCROLLED: "scrolled",
    REMOVED: "removed"
  },
  VIEWS: {
    AXIS: "axis",
    WRITING_MODE: "writingMode",
    LOAD_ERROR: "loaderror",
    RENDERED: "rendered",
    RESIZED: "resized",
    DISPLAYED: "displayed",
    SHOWN: "shown",
    HIDDEN: "hidden",
    MARK_CLICKED: "markClicked"
  },
  RENDITION: {
    STARTED: "started",
    ATTACHED: "attached",
    DISPLAYED: "displayed",
    DISPLAY_ERROR: "displayerror",
    RENDERED: "rendered",
    REMOVED: "removed",
    RESIZED: "resized",
    ORIENTATION_CHANGE: "orientationchange",
    LOCATION_CHANGED: "locationChanged",
    RELOCATED: "relocated",
    MARK_CLICKED: "markClicked",
    SELECTED: "selected",
    LAYOUT: "layout"
  },
  LAYOUT: {
    UPDATED: "updated"
  },
  ANNOTATION: {
    ATTACH: "attach",
    DETACH: "detach"
  }
};
class gy {
  constructor(e, n, r) {
    this.spine = e, this.request = n, this.pause = r || 100, this.q = new Nf(this), this.epubcfi = new mt(), this._locations = [], this._locationsWords = [], this.total = 0, this.break = 150, this._current = 0, this._wordCounter = 0, this.currentLocation = "", this._currentCfi = "", this.processingTimeout = void 0;
  }
  /**
   * Load all of sections in the book to generate locations
   * @param  {int} chars how many chars to split on
   * @return {Promise<Array<string>>} locations
   */
  generate(e) {
    return e && (this.break = e), this.q.pause(), this.spine.each(function(n) {
      n.linear && this.q.enqueue(this.process.bind(this), n);
    }.bind(this)), this.q.run().then(function() {
      return this.total = this._locations.length - 1, this._currentCfi && (this.currentLocation = this._currentCfi), this._locations;
    }.bind(this));
  }
  createRange() {
    return {
      startContainer: void 0,
      startOffset: void 0,
      endContainer: void 0,
      endOffset: void 0
    };
  }
  process(e) {
    return e.load(this.request).then(function(n) {
      var r = new vt(), i = this.parse(n, e.cfiBase);
      return this._locations = this._locations.concat(i), e.unload(), this.processingTimeout = setTimeout(() => r.resolve(i), this.pause), r.promise;
    }.bind(this));
  }
  parse(e, n, r) {
    var i = [], s, o = e.ownerDocument, a = Mt(o, "body"), l = 0, u, c = r || this.break, d = function(h) {
      var v = h.length, y, b = 0;
      if (h.textContent.trim().length === 0)
        return !1;
      for (l == 0 && (s = this.createRange(), s.startContainer = h, s.startOffset = 0), y = c - l, y > v && (l += v, b = v); b < v; )
        if (y = c - l, l === 0 && (b += 1, s = this.createRange(), s.startContainer = h, s.startOffset = b), b + y >= v)
          l += v - b, b = v;
        else {
          b += y, s.endContainer = h, s.endOffset = b;
          let p = new mt(s, n).toString();
          i.push(p), l = 0;
        }
      u = h;
    };
    if (Al(a, d.bind(this)), s && s.startContainer && u) {
      s.endContainer = u, s.endOffset = u.length;
      let h = new mt(s, n).toString();
      i.push(h), l = 0;
    }
    return i;
  }
  /**
   * Load all of sections in the book to generate locations
   * @param  {string} startCfi start position
   * @param  {int} wordCount how many words to split on
   * @param  {int} count result count
   * @return {object} locations
   */
  generateFromWords(e, n, r) {
    var i = e ? new mt(e) : void 0;
    return this.q.pause(), this._locationsWords = [], this._wordCounter = 0, this.spine.each(function(s) {
      s.linear && (i ? s.index >= i.spinePos && this.q.enqueue(this.processWords.bind(this), s, n, i, r) : this.q.enqueue(this.processWords.bind(this), s, n, i, r));
    }.bind(this)), this.q.run().then(function() {
      return this._currentCfi && (this.currentLocation = this._currentCfi), this._locationsWords;
    }.bind(this));
  }
  processWords(e, n, r, i) {
    return i && this._locationsWords.length >= i ? Promise.resolve() : e.load(this.request).then(function(s) {
      var o = new vt(), a = this.parseWords(s, e, n, r), l = i - this._locationsWords.length;
      return this._locationsWords = this._locationsWords.concat(a.length >= i ? a.slice(0, l) : a), e.unload(), this.processingTimeout = setTimeout(() => o.resolve(a), this.pause), o.promise;
    }.bind(this));
  }
  //http://stackoverflow.com/questions/18679576/counting-words-in-string
  countWords(e) {
    return e = e.replace(/(^\s*)|(\s*$)/gi, ""), e = e.replace(/[ ]{2,}/gi, " "), e = e.replace(/\n /, `
`), e.split(" ").length;
  }
  parseWords(e, n, r, i) {
    var s = n.cfiBase, o = [], a = e.ownerDocument, l = Mt(a, "body"), u = r, c = i ? i.spinePos !== n.index : !0, d;
    i && n.index === i.spinePos && (d = i.findNode(i.range ? i.path.steps.concat(i.start.steps) : i.path.steps, e.ownerDocument));
    var h = function(v) {
      if (!c)
        if (v === d)
          c = !0;
        else
          return !1;
      if (v.textContent.length < 10 && v.textContent.trim().length === 0)
        return !1;
      var y = this.countWords(v.textContent), b, p = 0;
      if (y === 0)
        return !1;
      for (b = u - this._wordCounter, b > y && (this._wordCounter += y, p = y); p < y; )
        if (b = u - this._wordCounter, p + b >= y)
          this._wordCounter += y - p, p = y;
        else {
          p += b;
          let f = new mt(v, s);
          o.push({ cfi: f.toString(), wordCount: this._wordCounter }), this._wordCounter = 0;
        }
    };
    return Al(l, h.bind(this)), o;
  }
  /**
   * Get a location from an EpubCFI
   * @param {EpubCFI} cfi
   * @return {number}
   */
  locationFromCfi(e) {
    let n;
    return mt.prototype.isCfiString(e) && (e = new mt(e)), this._locations.length === 0 ? -1 : (n = Ms(e, this._locations, this.epubcfi.compare), n > this.total ? this.total : n);
  }
  /**
   * Get a percentage position in locations from an EpubCFI
   * @param {EpubCFI} cfi
   * @return {number}
   */
  percentageFromCfi(e) {
    if (this._locations.length === 0)
      return null;
    var n = this.locationFromCfi(e);
    return this.percentageFromLocation(n);
  }
  /**
   * Get a percentage position from a location index
   * @param {number} location
   * @return {number}
   */
  percentageFromLocation(e) {
    return !e || !this.total ? 0 : e / this.total;
  }
  /**
   * Get an EpubCFI from location index
   * @param {number} loc
   * @return {EpubCFI} cfi
   */
  cfiFromLocation(e) {
    var n = -1;
    return typeof e != "number" && (e = parseInt(e)), e >= 0 && e < this._locations.length && (n = this._locations[e]), n;
  }
  /**
   * Get an EpubCFI from location percentage
   * @param {number} percentage
   * @return {EpubCFI} cfi
   */
  cfiFromPercentage(e) {
    let n;
    if (e > 1 && console.warn("Normalize cfiFromPercentage value to between 0 - 1"), e >= 1) {
      let r = new mt(this._locations[this.total]);
      return r.collapse(), r.toString();
    }
    return n = Math.ceil(this.total * e), this.cfiFromLocation(n);
  }
  /**
   * Load locations from JSON
   * @param {json} locations
   */
  load(e) {
    return typeof e == "string" ? this._locations = JSON.parse(e) : this._locations = e, this.total = this._locations.length - 1, this._locations;
  }
  /**
   * Save locations to JSON
   * @return {json}
   */
  save() {
    return JSON.stringify(this._locations);
  }
  getCurrent() {
    return this._current;
  }
  setCurrent(e) {
    var n;
    if (typeof e == "string")
      this._currentCfi = e;
    else if (typeof e == "number")
      this._current = e;
    else
      return;
    this._locations.length !== 0 && (typeof e == "string" ? (n = this.locationFromCfi(e), this._current = n) : n = e, this.emit(Re.LOCATIONS.CHANGED, {
      percentage: this.percentageFromLocation(n)
    }));
  }
  /**
   * Get the current location
   */
  get currentLocation() {
    return this._current;
  }
  /**
   * Set the current location
   */
  set currentLocation(e) {
    this.setCurrent(e);
  }
  /**
   * Locations length
   */
  length() {
    return this._locations.length;
  }
  destroy() {
    this.spine = void 0, this.request = void 0, this.pause = void 0, this.q.stop(), this.q = void 0, this.epubcfi = void 0, this._locations = void 0, this.total = void 0, this.break = void 0, this._current = void 0, this.currentLocation = void 0, this._currentCfi = void 0, clearTimeout(this.processingTimeout);
  }
}
Br(gy.prototype);
class E$ {
  constructor(e) {
    this.packagePath = "", this.directory = "", this.encoding = "", e && this.parse(e);
  }
  /**
   * Parse the Container XML
   * @param  {document} containerDocument
   */
  parse(e) {
    var n;
    if (!e)
      throw new Error("Container File Not Found");
    if (n = Mt(e, "rootfile"), !n)
      throw new Error("No RootFile Found");
    this.packagePath = n.getAttribute("full-path"), this.directory = mi.dirname(this.packagePath), this.encoding = e.xmlEncoding;
  }
  destroy() {
    this.packagePath = void 0, this.directory = void 0, this.encoding = void 0;
  }
}
class iv {
  constructor(e) {
    this.manifest = {}, this.navPath = "", this.ncxPath = "", this.coverPath = "", this.spineNodeIndex = 0, this.spine = [], this.metadata = {}, e && this.parse(e);
  }
  /**
   * Parse OPF XML
   * @param  {document} packageDocument OPF XML
   * @return {object} parsed package parts
   */
  parse(e) {
    var n, r, i;
    if (!e)
      throw new Error("Package File Not Found");
    if (n = Mt(e, "metadata"), !n)
      throw new Error("No Metadata Found");
    if (r = Mt(e, "manifest"), !r)
      throw new Error("No Manifest Found");
    if (i = Mt(e, "spine"), !i)
      throw new Error("No Spine Found");
    return this.manifest = this.parseManifest(r), this.navPath = this.findNavPath(r), this.ncxPath = this.findNcxPath(r, i), this.coverPath = this.findCoverPath(e), this.spineNodeIndex = ly(i), this.spine = this.parseSpine(i, this.manifest), this.uniqueIdentifier = this.findUniqueIdentifier(e), this.metadata = this.parseMetadata(n), this.metadata.direction = i.getAttribute("page-progression-direction"), {
      metadata: this.metadata,
      spine: this.spine,
      manifest: this.manifest,
      navPath: this.navPath,
      ncxPath: this.ncxPath,
      coverPath: this.coverPath,
      spineNodeIndex: this.spineNodeIndex
    };
  }
  /**
   * Parse Metadata
   * @private
   * @param  {node} xml
   * @return {object} metadata
   */
  parseMetadata(e) {
    var n = {};
    return n.title = this.getElementText(e, "title"), n.creator = this.getElementText(e, "creator"), n.description = this.getElementText(e, "description"), n.pubdate = this.getElementText(e, "date"), n.publisher = this.getElementText(e, "publisher"), n.identifier = this.getElementText(e, "identifier"), n.language = this.getElementText(e, "language"), n.rights = this.getElementText(e, "rights"), n.modified_date = this.getPropertyText(e, "dcterms:modified"), n.layout = this.getPropertyText(e, "rendition:layout"), n.orientation = this.getPropertyText(e, "rendition:orientation"), n.flow = this.getPropertyText(e, "rendition:flow"), n.viewport = this.getPropertyText(e, "rendition:viewport"), n.media_active_class = this.getPropertyText(e, "media:active-class"), n.spread = this.getPropertyText(e, "rendition:spread"), n;
  }
  /**
   * Parse Manifest
   * @private
   * @param  {node} manifestXml
   * @return {object} manifest
   */
  parseManifest(e) {
    var n = {}, r = ni(e, "item"), i = Array.prototype.slice.call(r);
    return i.forEach(function(s) {
      var o = s.getAttribute("id"), a = s.getAttribute("href") || "", l = s.getAttribute("media-type") || "", u = s.getAttribute("media-overlay") || "", c = s.getAttribute("properties") || "";
      n[o] = {
        href: a,
        // "url" : href,
        type: l,
        overlay: u,
        properties: c.length ? c.split(" ") : []
      };
    }), n;
  }
  /**
   * Parse Spine
   * @private
   * @param  {node} spineXml
   * @param  {Packaging.manifest} manifest
   * @return {object} spine
   */
  parseSpine(e, n) {
    var r = [], i = ni(e, "itemref"), s = Array.prototype.slice.call(i);
    return s.forEach(function(o, a) {
      var l = o.getAttribute("idref"), u = o.getAttribute("properties") || "", c = u.length ? u.split(" ") : [], d = {
        id: o.getAttribute("id"),
        idref: l,
        linear: o.getAttribute("linear") || "yes",
        properties: c,
        // "href" : manifest[Id].href,
        // "url" :  manifest[Id].url,
        index: a
        // "cfiBase" : cfiBase
      };
      r.push(d);
    }), r;
  }
  /**
   * Find Unique Identifier
   * @private
   * @param  {node} packageXml
   * @return {string} Unique Identifier text
   */
  findUniqueIdentifier(e) {
    var n = e.documentElement.getAttribute("unique-identifier");
    if (!n)
      return "";
    var r = e.getElementById(n);
    return r && r.localName === "identifier" && r.namespaceURI === "http://purl.org/dc/elements/1.1/" && r.childNodes.length > 0 ? r.childNodes[0].nodeValue.trim() : "";
  }
  /**
   * Find TOC NAV
   * @private
   * @param {element} manifestNode
   * @return {string}
   */
  findNavPath(e) {
    var n = ms(e, "item", { properties: "nav" });
    return n ? n.getAttribute("href") : !1;
  }
  /**
   * Find TOC NCX
   * media-type="application/x-dtbncx+xml" href="toc.ncx"
   * @private
   * @param {element} manifestNode
   * @param {element} spineNode
   * @return {string}
   */
  findNcxPath(e, n) {
    var r = ms(e, "item", { "media-type": "application/x-dtbncx+xml" }), i;
    return r || (i = n.getAttribute("toc"), i && (r = e.querySelector(`#${i}`))), r ? r.getAttribute("href") : !1;
  }
  /**
   * Find the Cover Path
   * <item properties="cover-image" id="ci" href="cover.svg" media-type="image/svg+xml" />
   * Fallback for Epub 2.0
   * @private
   * @param  {node} packageXml
   * @return {string} href
   */
  findCoverPath(e) {
    var n = Mt(e, "package");
    n.getAttribute("version");
    var r = ms(e, "item", { properties: "cover-image" });
    if (r)
      return r.getAttribute("href");
    var i = ms(e, "meta", { name: "cover" });
    if (i) {
      var s = i.getAttribute("content"), o = e.getElementById(s);
      return o ? o.getAttribute("href") : "";
    } else
      return !1;
  }
  /**
   * Get text of a namespaced element
   * @private
   * @param  {node} xml
   * @param  {string} tag
   * @return {string} text
   */
  getElementText(e, n) {
    var r = e.getElementsByTagNameNS("http://purl.org/dc/elements/1.1/", n), i;
    return !r || r.length === 0 ? "" : (i = r[0], i.childNodes.length ? i.childNodes[0].nodeValue : "");
  }
  /**
   * Get text by property
   * @private
   * @param  {node} xml
   * @param  {string} property
   * @return {string} text
   */
  getPropertyText(e, n) {
    var r = ms(e, "meta", { property: n });
    return r && r.childNodes.length ? r.childNodes[0].nodeValue : "";
  }
  /**
   * Load JSON Manifest
   * @param  {document} packageDocument OPF XML
   * @return {object} parsed package parts
   */
  load(e) {
    this.metadata = e.metadata;
    let n = e.readingOrder || e.spine;
    return this.spine = n.map((r, i) => (r.index = i, r.linear = r.linear || "yes", r)), e.resources.forEach((r, i) => {
      this.manifest[i] = r, r.rel && r.rel[0] === "cover" && (this.coverPath = r.href);
    }), this.spineNodeIndex = 0, this.toc = e.toc.map((r, i) => (r.label = r.title, r)), {
      metadata: this.metadata,
      spine: this.spine,
      manifest: this.manifest,
      navPath: this.navPath,
      ncxPath: this.ncxPath,
      coverPath: this.coverPath,
      spineNodeIndex: this.spineNodeIndex,
      toc: this.toc
    };
  }
  destroy() {
    this.manifest = void 0, this.navPath = void 0, this.ncxPath = void 0, this.coverPath = void 0, this.spineNodeIndex = void 0, this.spine = void 0, this.metadata = void 0;
  }
}
class Wu {
  constructor(e) {
    this.toc = [], this.tocByHref = {}, this.tocById = {}, this.landmarks = [], this.landmarksByType = {}, this.length = 0, e && this.parse(e);
  }
  /**
   * Parse out the navigation items
   * @param {document} xml navigation html / xhtml / ncx
   */
  parse(e) {
    let n = e.nodeType, r, i;
    n && (r = Mt(e, "html"), i = Mt(e, "ncx")), n ? r ? (this.toc = this.parseNav(e), this.landmarks = this.parseLandmarks(e)) : i && (this.toc = this.parseNcx(e)) : this.toc = this.load(e), this.length = 0, this.unpack(this.toc);
  }
  /**
   * Unpack navigation items
   * @private
   * @param  {array} toc
   */
  unpack(e) {
    for (var n, r = 0; r < e.length; r++)
      n = e[r], n.href && (this.tocByHref[n.href] = r), n.id && (this.tocById[n.id] = r), this.length++, n.subitems.length && this.unpack(n.subitems);
  }
  /**
   * Get an item from the navigation
   * @param  {string} target
   * @return {object} navItem
   */
  get(e) {
    var n;
    return e ? (e.indexOf("#") === 0 ? n = this.tocById[e.substring(1)] : e in this.tocByHref && (n = this.tocByHref[e]), this.getByIndex(e, n, this.toc)) : this.toc;
  }
  /**
   * Get an item from navigation subitems recursively by index
   * @param  {string} target
   * @param  {number} index
   * @param  {array} navItems
   * @return {object} navItem
   */
  getByIndex(e, n, r) {
    if (r.length === 0)
      return;
    const i = r[n];
    if (i && (e === i.id || e === i.href))
      return i;
    {
      let s;
      for (let o = 0; o < r.length && (s = this.getByIndex(e, n, r[o].subitems), !s); ++o)
        ;
      return s;
    }
  }
  /**
   * Get a landmark by type
   * List of types: https://idpf.github.io/epub-vocabs/structure/
   * @param  {string} type
   * @return {object} landmarkItem
   */
  landmark(e) {
    var n;
    return e ? (n = this.landmarksByType[e], this.landmarks[n]) : this.landmarks;
  }
  /**
   * Parse toc from a Epub > 3.0 Nav
   * @private
   * @param  {document} navHtml
   * @return {array} navigation list
   */
  parseNav(e) {
    var n = Il(e, "nav", "toc"), r = [];
    if (!n)
      return r;
    let i = gs(n, "ol", !0);
    return i && (r = this.parseNavList(i)), r;
  }
  /**
   * Parses lists in the toc
   * @param  {document} navListHtml
   * @param  {string} parent id
   * @return {array} navigation list
   */
  parseNavList(e, n) {
    const r = [];
    if (!e || !e.children)
      return r;
    for (let i = 0; i < e.children.length; i++) {
      const s = this.navItem(e.children[i], n);
      s && r.push(s);
    }
    return r;
  }
  /**
   * Create a navItem
   * @private
   * @param  {element} item
   * @return {object} navItem
   */
  navItem(e, n) {
    let r = e.getAttribute("id") || void 0, i = gs(e, "a", !0) || gs(e, "span", !0);
    if (!i)
      return;
    let s = i.getAttribute("href") || "";
    r || (r = s);
    let o = i.textContent || "", a = [], l = gs(e, "ol", !0);
    return l && (a = this.parseNavList(l, r)), {
      id: r,
      href: s,
      label: o,
      subitems: a,
      parent: n
    };
  }
  /**
   * Parse landmarks from a Epub > 3.0 Nav
   * @private
   * @param  {document} navHtml
   * @return {array} landmarks list
   */
  parseLandmarks(e) {
    var n = Il(e, "nav", "landmarks"), r = n ? ni(n, "li") : [], i = r.length, s, o = [], a;
    if (!r || i === 0)
      return o;
    for (s = 0; s < i; ++s)
      a = this.landmarkItem(r[s]), a && (o.push(a), this.landmarksByType[a.type] = s);
    return o;
  }
  /**
   * Create a landmarkItem
   * @private
   * @param  {element} item
   * @return {object} landmarkItem
   */
  landmarkItem(e) {
    let n = gs(e, "a", !0);
    if (!n)
      return;
    let r = n.getAttributeNS("http://www.idpf.org/2007/ops", "type") || void 0, i = n.getAttribute("href") || "", s = n.textContent || "";
    return {
      href: i,
      label: s,
      type: r
    };
  }
  /**
   * Parse from a Epub > 3.0 NC
   * @private
   * @param  {document} navHtml
   * @return {array} navigation list
   */
  parseNcx(e) {
    var n = ni(e, "navPoint"), r = n.length, i, s = {}, o = [], a, l;
    if (!n || r === 0)
      return o;
    for (i = 0; i < r; ++i)
      a = this.ncxItem(n[i]), s[a.id] = a, a.parent ? (l = s[a.parent], l.subitems.push(a)) : o.push(a);
    return o;
  }
  /**
   * Create a ncxItem
   * @private
   * @param  {element} item
   * @return {object} ncxItem
   */
  ncxItem(e) {
    var n = e.getAttribute("id") || !1, r = Mt(e, "content"), i = r.getAttribute("src"), s = Mt(e, "navLabel"), o = s.textContent ? s.textContent : "", a = [], l = e.parentNode, u;
    return l && (l.nodeName === "navPoint" || l.nodeName.split(":").slice(-1)[0] === "navPoint") && (u = l.getAttribute("id")), {
      id: n,
      href: i,
      label: o,
      subitems: a,
      parent: u
    };
  }
  /**
   * Load Spine Items
   * @param  {object} json the items to be loaded
   * @return {Array} navItems
   */
  load(e) {
    return e.map((n) => (n.label = n.title, n.subitems = n.children ? this.load(n.children) : [], n));
  }
  /**
   * forEach pass through
   * @param  {Function} fn function to run on each item
   * @return {method} forEach loop
   */
  forEach(e) {
    return this.toc.forEach(e);
  }
}
var to = {
  application: {
    ecmascript: ["es", "ecma"],
    javascript: "js",
    ogg: "ogx",
    pdf: "pdf",
    postscript: ["ps", "ai", "eps", "epsi", "epsf", "eps2", "eps3"],
    "rdf+xml": "rdf",
    smil: ["smi", "smil"],
    "xhtml+xml": ["xhtml", "xht"],
    xml: ["xml", "xsl", "xsd", "opf", "ncx"],
    zip: "zip",
    "x-httpd-eruby": "rhtml",
    "x-latex": "latex",
    "x-maker": ["frm", "maker", "frame", "fm", "fb", "book", "fbdoc"],
    "x-object": "o",
    "x-shockwave-flash": ["swf", "swfl"],
    "x-silverlight": "scr",
    "epub+zip": "epub",
    "font-tdpfr": "pfr",
    "inkml+xml": ["ink", "inkml"],
    json: "json",
    "jsonml+json": "jsonml",
    "mathml+xml": "mathml",
    "metalink+xml": "metalink",
    mp4: "mp4s",
    // "oebps-package+xml" : "opf",
    "omdoc+xml": "omdoc",
    oxps: "oxps",
    "vnd.amazon.ebook": "azw",
    widget: "wgt",
    // "x-dtbncx+xml" : "ncx",
    "x-dtbook+xml": "dtb",
    "x-dtbresource+xml": "res",
    "x-font-bdf": "bdf",
    "x-font-ghostscript": "gsf",
    "x-font-linux-psf": "psf",
    "x-font-otf": "otf",
    "x-font-pcf": "pcf",
    "x-font-snf": "snf",
    "x-font-ttf": ["ttf", "ttc"],
    "x-font-type1": ["pfa", "pfb", "pfm", "afm"],
    "x-font-woff": "woff",
    "x-mobipocket-ebook": ["prc", "mobi"],
    "x-mspublisher": "pub",
    "x-nzb": "nzb",
    "x-tgif": "obj",
    "xaml+xml": "xaml",
    "xml-dtd": "dtd",
    "xproc+xml": "xpl",
    "xslt+xml": "xslt",
    "internet-property-stream": "acx",
    "x-compress": "z",
    "x-compressed": "tgz",
    "x-gzip": "gz"
  },
  audio: {
    flac: "flac",
    midi: ["mid", "midi", "kar", "rmi"],
    mpeg: ["mpga", "mpega", "mp2", "mp3", "m4a", "mp2a", "m2a", "m3a"],
    mpegurl: "m3u",
    ogg: ["oga", "ogg", "spx"],
    "x-aiff": ["aif", "aiff", "aifc"],
    "x-ms-wma": "wma",
    "x-wav": "wav",
    adpcm: "adp",
    mp4: "mp4a",
    webm: "weba",
    "x-aac": "aac",
    "x-caf": "caf",
    "x-matroska": "mka",
    "x-pn-realaudio-plugin": "rmp",
    xm: "xm",
    mid: ["mid", "rmi"]
  },
  image: {
    gif: "gif",
    ief: "ief",
    jpeg: ["jpeg", "jpg", "jpe"],
    pcx: "pcx",
    png: "png",
    "svg+xml": ["svg", "svgz"],
    tiff: ["tiff", "tif"],
    "x-icon": "ico",
    bmp: "bmp",
    webp: "webp",
    "x-pict": ["pic", "pct"],
    "x-tga": "tga",
    "cis-cod": "cod"
  },
  text: {
    "cache-manifest": ["manifest", "appcache"],
    css: "css",
    csv: "csv",
    html: ["html", "htm", "shtml", "stm"],
    mathml: "mml",
    plain: ["txt", "text", "brf", "conf", "def", "list", "log", "in", "bas"],
    richtext: "rtx",
    "tab-separated-values": "tsv",
    "x-bibtex": "bib"
  },
  video: {
    mpeg: ["mpeg", "mpg", "mpe", "m1v", "m2v", "mp2", "mpa", "mpv2"],
    mp4: ["mp4", "mp4v", "mpg4"],
    quicktime: ["qt", "mov"],
    ogg: "ogv",
    "vnd.mpegurl": ["mxu", "m4u"],
    "x-flv": "flv",
    "x-la-asf": ["lsf", "lsx"],
    "x-mng": "mng",
    "x-ms-asf": ["asf", "asx", "asr"],
    "x-ms-wm": "wm",
    "x-ms-wmv": "wmv",
    "x-ms-wmx": "wmx",
    "x-ms-wvx": "wvx",
    "x-msvideo": "avi",
    "x-sgi-movie": "movie",
    "x-matroska": ["mpv", "mkv", "mk3d", "mks"],
    "3gpp2": "3g2",
    h261: "h261",
    h263: "h263",
    h264: "h264",
    jpeg: "jpgv",
    jpm: ["jpm", "jpgm"],
    mj2: ["mj2", "mjp2"],
    "vnd.ms-playready.media.pyv": "pyv",
    "vnd.uvvu.mp4": ["uvu", "uvvu"],
    "vnd.vivo": "viv",
    webm: "webm",
    "x-f4v": "f4v",
    "x-m4v": "m4v",
    "x-ms-vob": "vob",
    "x-smv": "smv"
  }
}, S$ = function() {
  var t, e, n, r, i = {};
  for (t in to)
    if (to.hasOwnProperty(t)) {
      for (e in to[t])
        if (to[t].hasOwnProperty(e))
          if (n = to[t][e], typeof n == "string")
            i[n] = t + "/" + e;
          else
            for (r = 0; r < n.length; r++)
              i[n[r]] = t + "/" + e;
    }
  return i;
}(), x$ = "text/plain";
function C$(t) {
  return t && S$[t.split(".").pop().toLowerCase()] || x$;
}
const xs = { lookup: C$ };
class k$ {
  constructor(e, n) {
    this.settings = {
      replacements: n && n.replacements || "base64",
      archive: n && n.archive,
      resolver: n && n.resolver,
      request: n && n.request
    }, this.process(e);
  }
  /**
   * Process resources
   * @param {Manifest} manifest
   */
  process(e) {
    this.manifest = e, this.resources = Object.keys(e).map(function(n) {
      return e[n];
    }), this.replacementUrls = [], this.html = [], this.assets = [], this.css = [], this.urls = [], this.cssUrls = [], this.split(), this.splitUrls();
  }
  /**
   * Split resources by type
   * @private
   */
  split() {
    this.html = this.resources.filter(function(e) {
      if (e.type === "application/xhtml+xml" || e.type === "text/html")
        return !0;
    }), this.assets = this.resources.filter(function(e) {
      if (e.type !== "application/xhtml+xml" && e.type !== "text/html")
        return !0;
    }), this.css = this.resources.filter(function(e) {
      if (e.type === "text/css")
        return !0;
    });
  }
  /**
   * Convert split resources into Urls
   * @private
   */
  splitUrls() {
    this.urls = this.assets.map(function(e) {
      return e.href;
    }.bind(this)), this.cssUrls = this.css.map(function(e) {
      return e.href;
    });
  }
  /**
   * Create a url to a resource
   * @param {string} url
   * @return {Promise<string>} Promise resolves with url string
   */
  createUrl(e) {
    var n = new fr(e), r = xs.lookup(n.filename);
    return this.settings.archive ? this.settings.archive.createUrl(e, { base64: this.settings.replacements === "base64" }) : this.settings.replacements === "base64" ? this.settings.request(e, "blob").then((i) => hy(i)).then((i) => rd(i, r)) : this.settings.request(e, "blob").then((i) => Nl(i, r));
  }
  /**
   * Create blob urls for all the assets
   * @return {Promise}         returns replacement urls
   */
  replacements() {
    if (this.settings.replacements === "none")
      return new Promise(function(n) {
        n(this.urls);
      }.bind(this));
    var e = this.urls.map((n) => {
      var r = this.settings.resolver(n);
      return this.createUrl(r).catch((i) => (console.error(i), null));
    });
    return Promise.all(e).then((n) => (this.replacementUrls = n.filter((r) => typeof r == "string"), n));
  }
  /**
   * Replace URLs in CSS resources
   * @private
   * @param  {Archive} [archive]
   * @param  {method} [resolver]
   * @return {Promise}
   */
  replaceCss(e, n) {
    var r = [];
    return e = e || this.settings.archive, n = n || this.settings.resolver, this.cssUrls.forEach(function(i) {
      var s = this.createCssFile(i, e, n).then(function(o) {
        var a = this.urls.indexOf(i);
        a > -1 && (this.replacementUrls[a] = o);
      }.bind(this));
      r.push(s);
    }.bind(this)), Promise.all(r);
  }
  /**
   * Create a new CSS file with the replaced URLs
   * @private
   * @param  {string} href the original css file
   * @return {Promise}  returns a BlobUrl to the new CSS file or a data url
   */
  createCssFile(e) {
    var n;
    if (mi.isAbsolute(e))
      return new Promise(function(o) {
        o();
      });
    var r = this.settings.resolver(e), i;
    this.settings.archive ? i = this.settings.archive.getText(r) : i = this.settings.request(r, "text");
    var s = this.urls.map((o) => {
      var a = this.settings.resolver(o), l = new ri(r).relative(a);
      return l;
    });
    return i ? i.then((o) => (o = rv(o, s, this.replacementUrls), this.settings.replacements === "base64" ? n = rd(o, "text/css") : n = Nl(o, "text/css"), n), (o) => new Promise(function(a) {
      a();
    })) : new Promise(function(o) {
      o();
    });
  }
  /**
   * Resolve all resources URLs relative to an absolute URL
   * @param  {string} absolute to be resolved to
   * @param  {resolver} [resolver]
   * @return {string[]} array with relative Urls
   */
  relativeTo(e, n) {
    return n = n || this.settings.resolver, this.urls.map(function(r) {
      var i = n(r), s = new ri(e).relative(i);
      return s;
    }.bind(this));
  }
  /**
   * Get a URL for a resource
   * @param  {string} path
   * @return {string} url
   */
  get(e) {
    var n = this.urls.indexOf(e);
    if (n !== -1)
      return this.replacementUrls.length ? new Promise(function(r, i) {
        r(this.replacementUrls[n]);
      }.bind(this)) : this.createUrl(e);
  }
  /**
   * Substitute urls in content, with replacements,
   * relative to a url if provided
   * @param  {string} content
   * @param  {string} [url]   url to resolve to
   * @return {string}         content with urls substituted
   */
  substitute(e, n) {
    var r;
    return n ? r = this.relativeTo(n) : r = this.urls, rv(e, r, this.replacementUrls);
  }
  destroy() {
    this.settings = void 0, this.manifest = void 0, this.resources = void 0, this.replacementUrls = void 0, this.html = void 0, this.assets = void 0, this.css = void 0, this.urls = void 0, this.cssUrls = void 0;
  }
}
class Hu {
  constructor(e) {
    this.pages = [], this.locations = [], this.epubcfi = new mt(), this.firstPage = 0, this.lastPage = 0, this.totalPages = 0, this.toc = void 0, this.ncx = void 0, e && (this.pageList = this.parse(e)), this.pageList && this.pageList.length && this.process(this.pageList);
  }
  /**
   * Parse PageList Xml
   * @param  {document} xml
   */
  parse(e) {
    var n = Mt(e, "html"), r = Mt(e, "ncx");
    if (n)
      return this.parseNav(e);
    if (r)
      return this.parseNcx(e);
  }
  /**
   * Parse a Nav PageList
   * @private
   * @param  {node} navHtml
   * @return {PageList.item[]} list
   */
  parseNav(e) {
    var n = Il(e, "nav", "page-list"), r = n ? ni(n, "li") : [], i = r.length, s, o = [], a;
    if (!r || i === 0)
      return o;
    for (s = 0; s < i; ++s)
      a = this.item(r[s]), o.push(a);
    return o;
  }
  parseNcx(e) {
    var n = [], r = 0, i, s, o, a = 0;
    if (s = Mt(e, "pageList"), !s || (o = ni(s, "pageTarget"), a = o.length, !o || o.length === 0))
      return n;
    for (r = 0; r < a; ++r)
      i = this.ncxItem(o[r]), n.push(i);
    return n;
  }
  ncxItem(e) {
    var n = Mt(e, "navLabel"), r = Mt(n, "text"), i = r.textContent, s = Mt(e, "content"), o = s.getAttribute("src"), a = parseInt(i, 10);
    return {
      href: o,
      page: a
    };
  }
  /**
   * Page List Item
   * @private
   * @param  {node} item
   * @return {object} pageListItem
   */
  item(e) {
    var n = Mt(e, "a"), r = n.getAttribute("href") || "", i = n.textContent || "", s = parseInt(i), o = r.indexOf("epubcfi"), a, l, u;
    return o != -1 ? (a = r.split("#"), l = a[0], u = a.length > 1 ? a[1] : !1, {
      cfi: u,
      href: r,
      packageUrl: l,
      page: s
    }) : {
      href: r,
      page: s
    };
  }
  /**
   * Process pageList items
   * @private
   * @param  {array} pageList
   */
  process(e) {
    e.forEach(function(n) {
      this.pages.push(n.page), n.cfi && this.locations.push(n.cfi);
    }, this), this.firstPage = parseInt(this.pages[0]), this.lastPage = parseInt(this.pages[this.pages.length - 1]), this.totalPages = this.lastPage - this.firstPage;
  }
  /**
   * Get a PageList result from a EpubCFI
   * @param  {string} cfi EpubCFI String
   * @return {number} page
   */
  pageFromCfi(e) {
    var n = -1;
    if (this.locations.length === 0)
      return -1;
    var r = kl(e, this.locations, this.epubcfi.compare);
    return r != -1 ? n = this.pages[r] : (r = Ms(e, this.locations, this.epubcfi.compare), n = r - 1 >= 0 ? this.pages[r - 1] : this.pages[0], n !== void 0 || (n = -1)), n;
  }
  /**
   * Get an EpubCFI from a Page List Item
   * @param  {string | number} pg
   * @return {string} cfi
   */
  cfiFromPage(e) {
    var n = -1;
    typeof e != "number" && (e = parseInt(e));
    var r = this.pages.indexOf(e);
    return r != -1 && (n = this.locations[r]), n;
  }
  /**
   * Get a Page from Book percentage
   * @param  {number} percent
   * @return {number} page
   */
  pageFromPercentage(e) {
    var n = Math.round(this.totalPages * e);
    return n;
  }
  /**
   * Returns a value between 0 - 1 corresponding to the location of a page
   * @param  {number} pg the page
   * @return {number} percentage
   */
  percentageFromPage(e) {
    var n = (e - this.firstPage) / this.totalPages;
    return Math.round(n * 1e3) / 1e3;
  }
  /**
   * Returns a value between 0 - 1 corresponding to the location of a cfi
   * @param  {string} cfi EpubCFI String
   * @return {number} percentage
   */
  percentageFromCfi(e) {
    var n = this.pageFromCfi(e), r = this.percentageFromPage(n);
    return r;
  }
  /**
   * Destroy
   */
  destroy() {
    this.pages = void 0, this.locations = void 0, this.epubcfi = void 0, this.pageList = void 0, this.toc = void 0, this.ncx = void 0;
  }
}
class yy {
  constructor(e) {
    this.settings = e, this.name = e.layout || "reflowable", this._spread = e.spread !== "none", this._minSpreadWidth = e.minSpreadWidth || 800, this._evenSpreads = e.evenSpreads || !1, e.flow === "scrolled" || e.flow === "scrolled-continuous" || e.flow === "scrolled-doc" ? this._flow = "scrolled" : this._flow = "paginated", this.width = 0, this.height = 0, this.spreadWidth = 0, this.delta = 0, this.columnWidth = 0, this.gap = 0, this.divisor = 1, this.props = {
      name: this.name,
      spread: this._spread,
      flow: this._flow,
      width: 0,
      height: 0,
      spreadWidth: 0,
      delta: 0,
      columnWidth: 0,
      gap: 0,
      divisor: 1
    };
  }
  /**
   * Switch the flow between paginated and scrolled
   * @param  {string} flow paginated | scrolled
   * @return {string} simplified flow
   */
  flow(e) {
    return typeof e < "u" && (e === "scrolled" || e === "scrolled-continuous" || e === "scrolled-doc" ? this._flow = "scrolled" : this._flow = "paginated", this.update({ flow: this._flow })), this._flow;
  }
  /**
   * Switch between using spreads or not, and set the
   * width at which they switch to single.
   * @param  {string} spread "none" | "always" | "auto"
   * @param  {number} min integer in pixels
   * @return {boolean} spread true | false
   */
  spread(e, n) {
    return e && (this._spread = e !== "none", this.update({ spread: this._spread })), n >= 0 && (this._minSpreadWidth = n), this._spread;
  }
  /**
   * Calculate the dimensions of the pagination
   * @param  {number} _width  width of the rendering
   * @param  {number} _height height of the rendering
   * @param  {number} _gap    width of the gap between columns
   */
  calculate(e, n, r) {
    var i = 1, s = r || 0, o = e, a = n, l = Math.floor(o / 12), u, c, d, h;
    this._spread && o >= this._minSpreadWidth ? i = 2 : i = 1, this.name === "reflowable" && this._flow === "paginated" && !(r >= 0) && (s = l % 2 === 0 ? l : l - 1), this.name === "pre-paginated" && (s = 0), i > 1 ? (u = o / i - s, d = u + s) : (u = o, d = o), this.name === "pre-paginated" && i > 1 && (o = u), c = u * i + s, h = o, this.width = o, this.height = a, this.spreadWidth = c, this.pageWidth = d, this.delta = h, this.columnWidth = u, this.gap = s, this.divisor = i, this.update({
      width: o,
      height: a,
      spreadWidth: c,
      pageWidth: d,
      delta: h,
      columnWidth: u,
      gap: s,
      divisor: i
    });
  }
  /**
   * Apply Css to a Document
   * @param  {Contents} contents
   * @return {Promise}
   */
  format(e, n, r) {
    var i;
    return this.name === "pre-paginated" ? i = e.fit(this.columnWidth, this.height, n) : this._flow === "paginated" ? i = e.columns(this.width, this.height, this.columnWidth, this.gap, this.settings.direction) : r && r === "horizontal" ? i = e.size(null, this.height) : i = e.size(this.width, null), i;
  }
  /**
   * Count number of pages
   * @param  {number} totalLength
   * @param  {number} pageLength
   * @return {{spreads: Number, pages: Number}}
   */
  count(e, n) {
    let r, i;
    return this.name === "pre-paginated" ? (r = 1, i = 1) : this._flow === "paginated" ? (n = n || this.delta, r = Math.ceil(e / n), i = r * this.divisor) : (n = n || this.height, r = Math.ceil(e / n), i = r), {
      spreads: r,
      pages: i
    };
  }
  /**
   * Update props that have changed
   * @private
   * @param  {object} props
   */
  update(e) {
    if (Object.keys(e).forEach((n) => {
      this.props[n] === e[n] && delete e[n];
    }), Object.keys(e).length > 0) {
      let n = En(this.props, e);
      this.emit(Re.LAYOUT.UPDATED, n, e);
    }
  }
}
Br(yy.prototype);
class T$ {
  constructor(e) {
    this.rendition = e, this._themes = {
      default: {
        rules: {},
        url: "",
        serialized: ""
      }
    }, this._overrides = {}, this._current = "default", this._injected = [], this.rendition.hooks.content.register(this.inject.bind(this)), this.rendition.hooks.content.register(this.overrides.bind(this));
  }
  /**
   * Add themes to be used by a rendition
   * @param {object | Array<object> | string}
   * @example themes.register("light", "http://example.com/light.css")
   * @example themes.register("light", { "body": { "color": "purple"}})
   * @example themes.register({ "light" : {...}, "dark" : {...}})
   */
  register() {
    if (arguments.length !== 0) {
      if (arguments.length === 1 && typeof arguments[0] == "object")
        return this.registerThemes(arguments[0]);
      if (arguments.length === 1 && typeof arguments[0] == "string")
        return this.default(arguments[0]);
      if (arguments.length === 2 && typeof arguments[1] == "string")
        return this.registerUrl(arguments[0], arguments[1]);
      if (arguments.length === 2 && typeof arguments[1] == "object")
        return this.registerRules(arguments[0], arguments[1]);
    }
  }
  /**
   * Add a default theme to be used by a rendition
   * @param {object | string} theme
   * @example themes.register("http://example.com/default.css")
   * @example themes.register({ "body": { "color": "purple"}})
   */
  default(e) {
    if (e) {
      if (typeof e == "string")
        return this.registerUrl("default", e);
      if (typeof e == "object")
        return this.registerRules("default", e);
    }
  }
  /**
   * Register themes object
   * @param {object} themes
   */
  registerThemes(e) {
    for (var n in e)
      e.hasOwnProperty(n) && (typeof e[n] == "string" ? this.registerUrl(n, e[n]) : this.registerRules(n, e[n]));
  }
  /**
   * Register a theme by passing its css as string
   * @param {string} name 
   * @param {string} css 
   */
  registerCss(e, n) {
    this._themes[e] = { serialized: n }, (this._injected[e] || e == "default") && this.update(e);
  }
  /**
   * Register a url
   * @param {string} name
   * @param {string} input
   */
  registerUrl(e, n) {
    var r = new fr(n);
    this._themes[e] = { url: r.toString() }, (this._injected[e] || e == "default") && this.update(e);
  }
  /**
   * Register rule
   * @param {string} name
   * @param {object} rules
   */
  registerRules(e, n) {
    this._themes[e] = { rules: n }, (this._injected[e] || e == "default") && this.update(e);
  }
  /**
   * Select a theme
   * @param {string} name
   */
  select(e) {
    var n = this._current, r;
    this._current = e, this.update(e), r = this.rendition.getContents(), r.forEach((i) => {
      i.removeClass(n), i.addClass(e);
    });
  }
  /**
   * Update a theme
   * @param {string} name
   */
  update(e) {
    var n = this.rendition.getContents();
    n.forEach((r) => {
      this.add(e, r);
    });
  }
  /**
   * Inject all themes into contents
   * @param {Contents} contents
   */
  inject(e) {
    var n = [], r = this._themes, i;
    for (var s in r)
      r.hasOwnProperty(s) && (s === this._current || s === "default") && (i = r[s], (i.rules && Object.keys(i.rules).length > 0 || i.url && n.indexOf(i.url) === -1) && this.add(s, e), this._injected.push(s));
    this._current != "default" && e.addClass(this._current);
  }
  /**
   * Add Theme to contents
   * @param {string} name
   * @param {Contents} contents
   */
  add(e, n) {
    var r = this._themes[e];
    !r || !n || (r.url ? n.addStylesheet(r.url) : r.serialized ? (n.addStylesheetCss(r.serialized, e), r.injected = !0) : r.rules && (n.addStylesheetRules(r.rules, e), r.injected = !0));
  }
  /**
   * Add override
   * @param {string} name
   * @param {string} value
   * @param {boolean} priority
   */
  override(e, n, r) {
    var i = this.rendition.getContents();
    this._overrides[e] = {
      value: n,
      priority: r === !0
    }, i.forEach((s) => {
      s.css(e, this._overrides[e].value, this._overrides[e].priority);
    });
  }
  removeOverride(e) {
    var n = this.rendition.getContents();
    delete this._overrides[e], n.forEach((r) => {
      r.css(e);
    });
  }
  /**
   * Add all overrides
   * @param {Content} content
   */
  overrides(e) {
    var n = this._overrides;
    for (var r in n)
      n.hasOwnProperty(r) && e.css(r, n[r].value, n[r].priority);
  }
  /**
   * Adjust the font size of a rendition
   * @param {number} size
   */
  fontSize(e) {
    this.override("font-size", e);
  }
  /**
   * Adjust the font-family of a rendition
   * @param {string} f
   */
  font(e) {
    this.override("font-family", e, !0);
  }
  destroy() {
    this.rendition = void 0, this._themes = void 0, this._overrides = void 0, this._current = void 0, this._injected = void 0;
  }
}
class Rl {
  constructor(e, n, r, i = !1) {
    this.layout = e, this.horizontal = r === "horizontal", this.direction = n || "ltr", this._dev = i;
  }
  /**
   * Find CFI pairs for entire section at once
   */
  section(e) {
    var n = this.findRanges(e), r = this.rangeListToCfiList(e.section.cfiBase, n);
    return r;
  }
  /**
   * Find CFI pairs for a page
   * @param {Contents} contents Contents from view
   * @param {string} cfiBase string of the base for a cfi
   * @param {number} start position to start at
   * @param {number} end position to end at
   */
  page(e, n, r, i) {
    var s = e && e.document ? e.document.body : !1, o;
    if (s) {
      if (o = this.rangePairToCfiPair(n, {
        start: this.findStart(s, r, i),
        end: this.findEnd(s, r, i)
      }), this._dev === !0) {
        let a = e.document, l = new mt(o.start).toRange(a), u = new mt(o.end).toRange(a), c = a.defaultView.getSelection(), d = a.createRange();
        c.removeAllRanges(), d.setStart(l.startContainer, l.startOffset), d.setEnd(u.endContainer, u.endOffset), c.addRange(d);
      }
      return o;
    }
  }
  /**
   * Walk a node, preforming a function on each node it finds
   * @private
   * @param {Node} root Node to walkToNode
   * @param {function} func walk function
   * @return {*} returns the result of the walk function
   */
  walk(e, n) {
    if (!(e && e.nodeType === Node.TEXT_NODE)) {
      var r = {
        acceptNode: function(l) {
          return l.data.trim().length > 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
        }
      }, i = r.acceptNode;
      i.acceptNode = r.acceptNode;
      for (var s = document.createTreeWalker(e, NodeFilter.SHOW_TEXT, i, !1), o, a; (o = s.nextNode()) && (a = n(o), !a); )
        ;
      return a;
    }
  }
  findRanges(e) {
    for (var n = [], r = e.contents.scrollWidth(), i = Math.ceil(r / this.layout.spreadWidth), s = i * this.layout.divisor, o = this.layout.columnWidth, a = this.layout.gap, l, u, c = 0; c < s.pages; c++)
      l = (o + a) * c, u = o * (c + 1) + a * c, n.push({
        start: this.findStart(e.document.body, l, u),
        end: this.findEnd(e.document.body, l, u)
      });
    return n;
  }
  /**
   * Find Start Range
   * @private
   * @param {Node} root root node
   * @param {number} start position to start at
   * @param {number} end position to end at
   * @return {Range}
   */
  findStart(e, n, r) {
    for (var i = [e], s, o, a = e; i.length; )
      if (s = i.shift(), o = this.walk(s, (l) => {
        var u, c, d, h, v;
        if (v = nd(l), this.horizontal && this.direction === "ltr") {
          if (u = this.horizontal ? v.left : v.top, c = this.horizontal ? v.right : v.bottom, u >= n && u <= r)
            return l;
          if (c > n)
            return l;
          a = l, i.push(l);
        } else if (this.horizontal && this.direction === "rtl") {
          if (u = v.left, c = v.right, c <= r && c >= n)
            return l;
          if (u < r)
            return l;
          a = l, i.push(l);
        } else {
          if (d = v.top, h = v.bottom, d >= n && d <= r)
            return l;
          if (h > n)
            return l;
          a = l, i.push(l);
        }
      }), o)
        return this.findTextStartRange(o, n, r);
    return this.findTextStartRange(a, n, r);
  }
  /**
   * Find End Range
   * @private
   * @param {Node} root root node
   * @param {number} start position to start at
   * @param {number} end position to end at
   * @return {Range}
   */
  findEnd(e, n, r) {
    for (var i = [e], s, o = e, a; i.length; )
      if (s = i.shift(), a = this.walk(s, (l) => {
        var u, c, d, h, v;
        if (v = nd(l), this.horizontal && this.direction === "ltr") {
          if (u = Math.round(v.left), c = Math.round(v.right), u > r && o)
            return o;
          if (c > r)
            return l;
          o = l, i.push(l);
        } else if (this.horizontal && this.direction === "rtl") {
          if (u = Math.round(this.horizontal ? v.left : v.top), c = Math.round(this.horizontal ? v.right : v.bottom), c < n && o)
            return o;
          if (u < n)
            return l;
          o = l, i.push(l);
        } else {
          if (d = Math.round(v.top), h = Math.round(v.bottom), d > r && o)
            return o;
          if (h > r)
            return l;
          o = l, i.push(l);
        }
      }), a)
        return this.findTextEndRange(a, n, r);
    return this.findTextEndRange(o, n, r);
  }
  /**
   * Find Text Start Range
   * @private
   * @param {Node} root root node
   * @param {number} start position to start at
   * @param {number} end position to end at
   * @return {Range}
   */
  findTextStartRange(e, n, r) {
    for (var i = this.splitTextNodeIntoRanges(e), s, o, a, l, u, c = 0; c < i.length; c++)
      if (s = i[c], o = s.getBoundingClientRect(), this.horizontal && this.direction === "ltr") {
        if (a = o.left, a >= n)
          return s;
      } else if (this.horizontal && this.direction === "rtl") {
        if (u = o.right, u <= r)
          return s;
      } else if (l = o.top, l >= n)
        return s;
    return i[0];
  }
  /**
   * Find Text End Range
   * @private
   * @param {Node} root root node
   * @param {number} start position to start at
   * @param {number} end position to end at
   * @return {Range}
   */
  findTextEndRange(e, n, r) {
    for (var i = this.splitTextNodeIntoRanges(e), s, o, a, l, u, c, d, h = 0; h < i.length; h++) {
      if (o = i[h], a = o.getBoundingClientRect(), this.horizontal && this.direction === "ltr") {
        if (l = a.left, u = a.right, l > r && s)
          return s;
        if (u > r)
          return o;
      } else if (this.horizontal && this.direction === "rtl") {
        if (l = a.left, u = a.right, u < n && s)
          return s;
        if (l < n)
          return o;
      } else {
        if (c = a.top, d = a.bottom, c > r && s)
          return s;
        if (d > r)
          return o;
      }
      s = o;
    }
    return i[i.length - 1];
  }
  /**
   * Split up a text node into ranges for each word
   * @private
   * @param {Node} root root node
   * @param {string} [_splitter] what to split on
   * @return {Range[]}
   */
  splitTextNodeIntoRanges(e, n) {
    var r = [], i = e.textContent || "", s = i.trim(), o, a = e.ownerDocument, l = n || " ", u = s.indexOf(l);
    if (u === -1 || e.nodeType != Node.TEXT_NODE)
      return o = a.createRange(), o.selectNodeContents(e), [o];
    for (o = a.createRange(), o.setStart(e, 0), o.setEnd(e, u), r.push(o), o = !1; u != -1; )
      u = s.indexOf(l, u + 1), u > 0 && (o && (o.setEnd(e, u), r.push(o)), o = a.createRange(), o.setStart(e, u + 1));
    return o && (o.setEnd(e, s.length), r.push(o)), r;
  }
  /**
   * Turn a pair of ranges into a pair of CFIs
   * @private
   * @param {string} cfiBase base string for an EpubCFI
   * @param {object} rangePair { start: Range, end: Range }
   * @return {object} { start: "epubcfi(...)", end: "epubcfi(...)" }
   */
  rangePairToCfiPair(e, n) {
    var r = n.start, i = n.end;
    r.collapse(!0), i.collapse(!1);
    let s = new mt(r, e).toString(), o = new mt(i, e).toString();
    return {
      start: s,
      end: o
    };
  }
  rangeListToCfiList(e, n) {
    for (var r = [], i, s = 0; s < n.length; s++)
      i = this.rangePairToCfiPair(e, n[s]), r.push(i);
    return r;
  }
  /**
   * Set the axis for mapping
   * @param {string} axis horizontal | vertical
   * @return {boolean} is it horizontal?
   */
  axis(e) {
    return e && (this.horizontal = e === "horizontal"), this.horizontal;
  }
}
const by = typeof navigator < "u", O$ = by && /Chrome/.test(navigator.userAgent), sv = by && !O$ && /AppleWebKit/.test(navigator.userAgent), N$ = 1;
class Af {
  constructor(e, n, r, i) {
    this.epubcfi = new mt(), this.document = e, this.documentElement = this.document.documentElement, this.content = n || this.document.body, this.window = this.document.defaultView, this._size = {
      width: 0,
      height: 0
    }, this.sectionIndex = i || 0, this.cfiBase = r || "", this.epubReadingSystem("epub.js", iu), this.called = 0, this.active = !0, this.listeners();
  }
  /**
  	* Get DOM events that are listened for and passed along
  	*/
  static get listenedEvents() {
    return tl;
  }
  /**
  	* Get or Set width
  	* @param {number} [w]
  	* @returns {number} width
  	*/
  width(e) {
    var n = this.content;
    return e && Xt(e) && (e = e + "px"), e && (n.style.width = e), parseInt(this.window.getComputedStyle(n).width);
  }
  /**
  	* Get or Set height
  	* @param {number} [h]
  	* @returns {number} height
  	*/
  height(e) {
    var n = this.content;
    return e && Xt(e) && (e = e + "px"), e && (n.style.height = e), parseInt(this.window.getComputedStyle(n).height);
  }
  /**
  	* Get or Set width of the contents
  	* @param {number} [w]
  	* @returns {number} width
  	*/
  contentWidth(e) {
    var n = this.content || this.document.body;
    return e && Xt(e) && (e = e + "px"), e && (n.style.width = e), parseInt(this.window.getComputedStyle(n).width);
  }
  /**
  	* Get or Set height of the contents
  	* @param {number} [h]
  	* @returns {number} height
  	*/
  contentHeight(e) {
    var n = this.content || this.document.body;
    return e && Xt(e) && (e = e + "px"), e && (n.style.height = e), parseInt(this.window.getComputedStyle(n).height);
  }
  /**
  	* Get the width of the text using Range
  	* @returns {number} width
  	*/
  textWidth() {
    let e, n, r = this.document.createRange(), i = this.content || this.document.body, s = Tl(i);
    return r.selectNodeContents(i), e = r.getBoundingClientRect(), n = e.width, s && s.width && (n += s.width), Math.round(n);
  }
  /**
  	* Get the height of the text using Range
  	* @returns {number} height
  	*/
  textHeight() {
    let e, n, r = this.document.createRange(), i = this.content || this.document.body;
    return r.selectNodeContents(i), e = r.getBoundingClientRect(), n = e.bottom, Math.round(n);
  }
  /**
  	* Get documentElement scrollWidth
  	* @returns {number} width
  	*/
  scrollWidth() {
    var e = this.documentElement.scrollWidth;
    return e;
  }
  /**
  	* Get documentElement scrollHeight
  	* @returns {number} height
  	*/
  scrollHeight() {
    var e = this.documentElement.scrollHeight;
    return e;
  }
  /**
  	* Set overflow css style of the contents
  	* @param {string} [overflow]
  	*/
  overflow(e) {
    return e && (this.documentElement.style.overflow = e), this.window.getComputedStyle(this.documentElement).overflow;
  }
  /**
  	* Set overflowX css style of the documentElement
  	* @param {string} [overflow]
  	*/
  overflowX(e) {
    return e && (this.documentElement.style.overflowX = e), this.window.getComputedStyle(this.documentElement).overflowX;
  }
  /**
  	* Set overflowY css style of the documentElement
  	* @param {string} [overflow]
  	*/
  overflowY(e) {
    return e && (this.documentElement.style.overflowY = e), this.window.getComputedStyle(this.documentElement).overflowY;
  }
  /**
  	* Set Css styles on the contents element (typically Body)
  	* @param {string} property
  	* @param {string} value
  	* @param {boolean} [priority] set as "important"
  	*/
  css(e, n, r) {
    var i = this.content || this.document.body;
    return n ? i.style.setProperty(e, n, r ? "important" : "") : i.style.removeProperty(e), this.window.getComputedStyle(i)[e];
  }
  /**
  	* Get or Set the viewport element
  	* @param {object} [options]
  	* @param {string} [options.width]
  	* @param {string} [options.height]
  	* @param {string} [options.scale]
  	* @param {string} [options.minimum]
  	* @param {string} [options.maximum]
  	* @param {string} [options.scalable]
  	*/
  viewport(e) {
    var n = this.document.querySelector("meta[name='viewport']"), r = {
      width: void 0,
      height: void 0,
      scale: void 0,
      minimum: void 0,
      maximum: void 0,
      scalable: void 0
    }, i = [], s = {};
    if (n && n.hasAttribute("content")) {
      let o = n.getAttribute("content"), a = o.match(/width\s*=\s*([^,]*)/), l = o.match(/height\s*=\s*([^,]*)/), u = o.match(/initial-scale\s*=\s*([^,]*)/), c = o.match(/minimum-scale\s*=\s*([^,]*)/), d = o.match(/maximum-scale\s*=\s*([^,]*)/), h = o.match(/user-scalable\s*=\s*([^,]*)/);
      a && a.length && typeof a[1] < "u" && (r.width = a[1]), l && l.length && typeof l[1] < "u" && (r.height = l[1]), u && u.length && typeof u[1] < "u" && (r.scale = u[1]), c && c.length && typeof c[1] < "u" && (r.minimum = c[1]), d && d.length && typeof d[1] < "u" && (r.maximum = d[1]), h && h.length && typeof h[1] < "u" && (r.scalable = h[1]);
    }
    return s = ay(e || {}, r), e && (s.width && i.push("width=" + s.width), s.height && i.push("height=" + s.height), s.scale && i.push("initial-scale=" + s.scale), s.scalable === "no" ? (i.push("minimum-scale=" + s.scale), i.push("maximum-scale=" + s.scale), i.push("user-scalable=" + s.scalable)) : (s.scalable && i.push("user-scalable=" + s.scalable), s.minimum && i.push("minimum-scale=" + s.minimum), s.maximum && i.push("minimum-scale=" + s.maximum)), n || (n = this.document.createElement("meta"), n.setAttribute("name", "viewport"), this.document.querySelector("head").appendChild(n)), n.setAttribute("content", i.join(", ")), this.window.scrollTo(0, 0)), s;
  }
  /**
   * Event emitter for when the contents has expanded
   * @private
   */
  expand() {
    this.emit(Re.CONTENTS.EXPAND);
  }
  /**
   * Add DOM listeners
   * @private
   */
  listeners() {
    this.imageLoadListeners(), this.mediaQueryListeners(), this.addEventListeners(), this.addSelectionListeners(), typeof ResizeObserver > "u" ? (this.resizeListeners(), this.visibilityListeners()) : this.resizeObservers(), this.linksHandler();
  }
  /**
   * Remove DOM listeners
   * @private
   */
  removeListeners() {
    this.removeEventListeners(), this.removeSelectionListeners(), this.observer && this.observer.disconnect(), clearTimeout(this.expanding);
  }
  /**
   * Check if size of contents has changed and
   * emit 'resize' event if it has.
   * @private
   */
  resizeCheck() {
    let e = this.textWidth(), n = this.textHeight();
    (e != this._size.width || n != this._size.height) && (this._size = {
      width: e,
      height: n
    }, this.onResize && this.onResize(this._size), this.emit(Re.CONTENTS.RESIZE, this._size));
  }
  /**
   * Poll for resize detection
   * @private
   */
  resizeListeners() {
    clearTimeout(this.expanding), requestAnimationFrame(this.resizeCheck.bind(this)), this.expanding = setTimeout(this.resizeListeners.bind(this), 350);
  }
  /**
   * Listen for visibility of tab to change
   * @private
   */
  visibilityListeners() {
    document.addEventListener("visibilitychange", () => {
      document.visibilityState === "visible" && this.active === !1 ? (this.active = !0, this.resizeListeners()) : (this.active = !1, clearTimeout(this.expanding));
    });
  }
  /**
   * Use css transitions to detect resize
   * @private
   */
  transitionListeners() {
    let e = this.content;
    e.style.transitionProperty = "font, font-size, font-size-adjust, font-stretch, font-variation-settings, font-weight, width, height", e.style.transitionDuration = "0.001ms", e.style.transitionTimingFunction = "linear", e.style.transitionDelay = "0", this._resizeCheck = this.resizeCheck.bind(this), this.document.addEventListener("transitionend", this._resizeCheck);
  }
  /**
   * Listen for media query changes and emit 'expand' event
   * Adapted from: https://github.com/tylergaw/media-query-events/blob/master/js/mq-events.js
   * @private
   */
  mediaQueryListeners() {
    for (var e = this.document.styleSheets, n = function(a) {
      a.matches && !this._expanding && setTimeout(this.expand.bind(this), 1);
    }.bind(this), r = 0; r < e.length; r += 1) {
      var i;
      try {
        i = e[r].cssRules;
      } catch {
        return;
      }
      if (!i)
        return;
      for (var s = 0; s < i.length; s += 1)
        if (i[s].media) {
          var o = this.window.matchMedia(i[s].media.mediaText);
          o.addListener(n);
        }
    }
  }
  /**
   * Use ResizeObserver to listen for changes in the DOM and check for resize
   * @private
   */
  resizeObservers() {
    this.observer = new ResizeObserver((e) => {
      requestAnimationFrame(this.resizeCheck.bind(this));
    }), this.observer.observe(this.document.documentElement);
  }
  /**
   * Use MutationObserver to listen for changes in the DOM and check for resize
   * @private
   */
  mutationObservers() {
    this.observer = new MutationObserver((n) => {
      this.resizeCheck();
    });
    let e = { attributes: !0, childList: !0, characterData: !0, subtree: !0 };
    this.observer.observe(this.document, e);
  }
  /**
   * Test if images are loaded or add listener for when they load
   * @private
   */
  imageLoadListeners() {
    for (var e = this.document.querySelectorAll("img"), n, r = 0; r < e.length; r++)
      n = e[r], typeof n.naturalWidth < "u" && n.naturalWidth === 0 && (n.onload = this.expand.bind(this));
  }
  /**
   * Listen for font load and check for resize when loaded
   * @private
   */
  fontLoadListeners() {
    !this.document || !this.document.fonts || this.document.fonts.ready.then(function() {
      this.resizeCheck();
    }.bind(this));
  }
  /**
   * Get the documentElement
   * @returns {element} documentElement
   */
  root() {
    return this.document ? this.document.documentElement : null;
  }
  /**
   * Get the location offset of a EpubCFI or an #id
   * @param {string | EpubCFI} target
   * @param {string} [ignoreClass] for the cfi
   * @returns { {left: Number, top: Number }
   */
  locationOf(e, n) {
    var r, i = { left: 0, top: 0 };
    if (!this.document)
      return i;
    if (this.epubcfi.isCfiString(e)) {
      let s = new mt(e).toRange(this.document, n);
      if (s) {
        try {
          if (!s.endContainer || s.startContainer == s.endContainer && s.startOffset == s.endOffset) {
            let o = s.startContainer.textContent.indexOf(" ", s.startOffset);
            o == -1 && (o = s.startContainer.textContent.length), s.setEnd(s.startContainer, o);
          }
        } catch (o) {
          console.error("setting end offset to start container length failed", o);
        }
        if (s.startContainer.nodeType === Node.ELEMENT_NODE)
          r = s.startContainer.getBoundingClientRect(), i.left = r.left, i.top = r.top;
        else if (sv) {
          let o = s.startContainer, a = new Range();
          try {
            o.nodeType === N$ ? r = o.getBoundingClientRect() : s.startOffset + 2 < o.length ? (a.setStart(o, s.startOffset), a.setEnd(o, s.startOffset + 2), r = a.getBoundingClientRect()) : s.startOffset - 2 > 0 ? (a.setStart(o, s.startOffset - 2), a.setEnd(o, s.startOffset), r = a.getBoundingClientRect()) : r = o.parentNode.getBoundingClientRect();
          } catch (l) {
            console.error(l, l.stack);
          }
        } else
          r = s.getBoundingClientRect();
      }
    } else if (typeof e == "string" && e.indexOf("#") > -1) {
      let s = e.substring(e.indexOf("#") + 1), o = this.document.getElementById(s);
      if (o)
        if (sv) {
          let a = new Range();
          a.selectNode(o), r = a.getBoundingClientRect();
        } else
          r = o.getBoundingClientRect();
    }
    return r && (i.left = r.left, i.top = r.top), i;
  }
  /**
   * Append a stylesheet link to the document head
   * @param {string} src url
   */
  addStylesheet(e) {
    return new Promise(function(n, r) {
      var i, s = !1;
      if (!this.document) {
        n(!1);
        return;
      }
      if (i = this.document.querySelector("link[href='" + e + "']"), i) {
        n(!0);
        return;
      }
      i = this.document.createElement("link"), i.type = "text/css", i.rel = "stylesheet", i.href = e, i.onload = i.onreadystatechange = function() {
        !s && (!this.readyState || this.readyState == "complete") && (s = !0, setTimeout(() => {
          n(!0);
        }, 1));
      }, this.document.head.appendChild(i);
    }.bind(this));
  }
  _getStylesheetNode(e) {
    var n;
    return e = "epubjs-inserted-css-" + (e || ""), this.document ? (n = this.document.getElementById(e), n || (n = this.document.createElement("style"), n.id = e, this.document.head.appendChild(n)), n) : !1;
  }
  /**
   * Append stylesheet css
   * @param {string} serializedCss
   * @param {string} key If the key is the same, the CSS will be replaced instead of inserted
   */
  addStylesheetCss(e, n) {
    if (!this.document || !e)
      return !1;
    var r;
    return r = this._getStylesheetNode(n), r.innerHTML = e, !0;
  }
  /**
   * Append stylesheet rules to a generate stylesheet
   * Array: https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/insertRule
   * Object: https://github.com/desirable-objects/json-to-css
   * @param {array | object} rules
   * @param {string} key If the key is the same, the CSS will be replaced instead of inserted
   */
  addStylesheetRules(e, n) {
    var r;
    if (!(!this.document || !e || e.length === 0))
      if (r = this._getStylesheetNode(n).sheet, Object.prototype.toString.call(e) === "[object Array]")
        for (var i = 0, s = e.length; i < s; i++) {
          var o = 1, a = e[i], l = e[i][0], u = "";
          Object.prototype.toString.call(a[1][0]) === "[object Array]" && (a = a[1], o = 0);
          for (var c = a.length; o < c; o++) {
            var d = a[o];
            u += d[0] + ":" + d[1] + (d[2] ? " !important" : "") + `;
`;
          }
          r.insertRule(l + "{" + u + "}", r.cssRules.length);
        }
      else
        Object.keys(e).forEach((v) => {
          const y = e[v];
          if (Array.isArray(y))
            y.forEach((b) => {
              const f = Object.keys(b).map((m) => `${m}:${b[m]}`).join(";");
              r.insertRule(`${v}{${f}}`, r.cssRules.length);
            });
          else {
            const p = Object.keys(y).map((f) => `${f}:${y[f]}`).join(";");
            r.insertRule(`${v}{${p}}`, r.cssRules.length);
          }
        });
  }
  /**
   * Append a script tag to the document head
   * @param {string} src url
   * @returns {Promise} loaded
   */
  addScript(e) {
    return new Promise(function(n, r) {
      var i, s = !1;
      if (!this.document) {
        n(!1);
        return;
      }
      i = this.document.createElement("script"), i.type = "text/javascript", i.async = !0, i.src = e, i.onload = i.onreadystatechange = function() {
        !s && (!this.readyState || this.readyState == "complete") && (s = !0, setTimeout(function() {
          n(!0);
        }, 1));
      }, this.document.head.appendChild(i);
    }.bind(this));
  }
  /**
   * Add a class to the contents container
   * @param {string} className
   */
  addClass(e) {
    var n;
    this.document && (n = this.content || this.document.body, n && n.classList.add(e));
  }
  /**
   * Remove a class from the contents container
   * @param {string} removeClass
   */
  removeClass(e) {
    var n;
    this.document && (n = this.content || this.document.body, n && n.classList.remove(e));
  }
  /**
   * Add DOM event listeners
   * @private
   */
  addEventListeners() {
    this.document && (this._triggerEvent = this.triggerEvent.bind(this), tl.forEach(function(e) {
      this.document.addEventListener(e, this._triggerEvent, { passive: !0 });
    }, this));
  }
  /**
   * Remove DOM event listeners
   * @private
   */
  removeEventListeners() {
    this.document && (tl.forEach(function(e) {
      this.document.removeEventListener(e, this._triggerEvent, { passive: !0 });
    }, this), this._triggerEvent = void 0);
  }
  /**
   * Emit passed browser events
   * @private
   */
  triggerEvent(e) {
    this.emit(e.type, e);
  }
  /**
   * Add listener for text selection
   * @private
   */
  addSelectionListeners() {
    this.document && (this._onSelectionChange = this.onSelectionChange.bind(this), this.document.addEventListener("selectionchange", this._onSelectionChange, { passive: !0 }));
  }
  /**
   * Remove listener for text selection
   * @private
   */
  removeSelectionListeners() {
    this.document && (this.document.removeEventListener("selectionchange", this._onSelectionChange, { passive: !0 }), this._onSelectionChange = void 0);
  }
  /**
   * Handle getting text on selection
   * @private
   */
  onSelectionChange(e) {
    this.selectionEndTimeout && clearTimeout(this.selectionEndTimeout), this.selectionEndTimeout = setTimeout(function() {
      var n = this.window.getSelection();
      this.triggerSelectedEvent(n);
    }.bind(this), 250);
  }
  /**
   * Emit event on text selection
   * @private
   */
  triggerSelectedEvent(e) {
    var n, r;
    e && e.rangeCount > 0 && (n = e.getRangeAt(0), n.collapsed || (r = new mt(n, this.cfiBase).toString(), this.emit(Re.CONTENTS.SELECTED, r), this.emit(Re.CONTENTS.SELECTED_RANGE, n)));
  }
  /**
   * Get a Dom Range from EpubCFI
   * @param {EpubCFI} _cfi
   * @param {string} [ignoreClass]
   * @returns {Range} range
   */
  range(e, n) {
    var r = new mt(e);
    return r.toRange(this.document, n);
  }
  /**
   * Get an EpubCFI from a Dom Range
   * @param {Range} range
   * @param {string} [ignoreClass]
   * @returns {EpubCFI} cfi
   */
  cfiFromRange(e, n) {
    return new mt(e, this.cfiBase, n).toString();
  }
  /**
   * Get an EpubCFI from a Dom node
   * @param {node} node
   * @param {string} [ignoreClass]
   * @returns {EpubCFI} cfi
   */
  cfiFromNode(e, n) {
    return new mt(e, this.cfiBase, n).toString();
  }
  // TODO: find where this is used - remove?
  map(e) {
    var n = new Rl(e);
    return n.section();
  }
  /**
   * Size the contents to a given width and height
   * @param {number} [width]
   * @param {number} [height]
   */
  size(e, n) {
    var r = { scale: 1, scalable: "no" };
    this.layoutStyle("scrolling"), e >= 0 && (this.width(e), r.width = e, this.css("padding", "0 " + e / 12 + "px")), n >= 0 && (this.height(n), r.height = n), this.css("margin", "0"), this.css("box-sizing", "border-box"), this.viewport(r);
  }
  /**
   * Apply columns to the contents for pagination
   * @param {number} width
   * @param {number} height
   * @param {number} columnWidth
   * @param {number} gap
   */
  columns(e, n, r, i, s) {
    let o = vs("column-axis"), a = vs("column-gap"), l = vs("column-width"), u = vs("column-fill"), d = this.writingMode().indexOf("vertical") === 0 ? "vertical" : "horizontal";
    this.layoutStyle("paginated"), s === "rtl" && d === "horizontal" && this.direction(s), this.width(e), this.height(n), this.viewport({ width: e, height: n, scale: 1, scalable: "no" }), this.css("overflow-y", "hidden"), this.css("margin", "0", !0), d === "vertical" ? (this.css("padding-top", i / 2 + "px", !0), this.css("padding-bottom", i / 2 + "px", !0), this.css("padding-left", "20px"), this.css("padding-right", "20px"), this.css(o, "vertical")) : (this.css("padding-top", "20px"), this.css("padding-bottom", "20px"), this.css("padding-left", i / 2 + "px", !0), this.css("padding-right", i / 2 + "px", !0), this.css(o, "horizontal")), this.css("box-sizing", "border-box"), this.css("max-width", "inherit"), this.css(u, "auto"), this.css(a, i + "px"), this.css(l, r + "px"), this.css("-webkit-line-box-contain", "block glyphs replaced");
  }
  /**
   * Scale contents from center
   * @param {number} scale
   * @param {number} offsetX
   * @param {number} offsetY
   */
  scaler(e, n, r) {
    var i = "scale(" + e + ")", s = "";
    this.css("transform-origin", "top left"), (n >= 0 || r >= 0) && (s = " translate(" + (n || 0) + "px, " + (r || 0) + "px )"), this.css("transform", i + s);
  }
  /**
   * Fit contents into a fixed width and height
   * @param {number} width
   * @param {number} height
   */
  fit(e, n, r) {
    var i = this.viewport(), s = parseInt(i.width), o = parseInt(i.height), a = e / s, l = n / o, u = a < l ? a : l;
    if (this.layoutStyle("paginated"), this.width(s), this.height(o), this.overflow("hidden"), this.scaler(u, 0, 0), this.css("background-size", s * u + "px " + o * u + "px"), this.css("background-color", "transparent"), r && r.properties.includes("page-spread-left")) {
      var c = e - s * u;
      this.css("margin-left", c + "px");
    }
  }
  /**
   * Set the direction of the text
   * @param {string} [dir="ltr"] "rtl" | "ltr"
   */
  direction(e) {
    this.documentElement && (this.documentElement.style.direction = e);
  }
  mapPage(e, n, r, i, s) {
    var o = new Rl(n, s);
    return o.page(this, e, r, i);
  }
  /**
   * Emit event when link in content is clicked
   * @private
   */
  linksHandler() {
    b$(this.content, (e) => {
      this.emit(Re.CONTENTS.LINK_CLICKED, e);
    });
  }
  /**
   * Set the writingMode of the text
   * @param {string} [mode="horizontal-tb"] "horizontal-tb" | "vertical-rl" | "vertical-lr"
   */
  writingMode(e) {
    let n = vs("writing-mode");
    return e && this.documentElement && (this.documentElement.style[n] = e), this.window.getComputedStyle(this.documentElement)[n] || "";
  }
  /**
   * Set the layoutStyle of the content
   * @param {string} [style="paginated"] "scrolling" | "paginated"
   * @private
   */
  layoutStyle(e) {
    return e && (this._layoutStyle = e, navigator.epubReadingSystem.layoutStyle = this._layoutStyle), this._layoutStyle || "paginated";
  }
  /**
   * Add the epubReadingSystem object to the navigator
   * @param {string} name
   * @param {string} version
   * @private
   */
  epubReadingSystem(e, n) {
    return navigator.epubReadingSystem = {
      name: e,
      version: n,
      layoutStyle: this.layoutStyle(),
      hasFeature: function(r) {
        switch (r) {
          case "dom-manipulation":
            return !0;
          case "layout-changes":
            return !0;
          case "touch-events":
            return !0;
          case "mouse-events":
            return !0;
          case "keyboard-events":
            return !0;
          case "spine-scripting":
            return !1;
          default:
            return !1;
        }
      }
    }, navigator.epubReadingSystem;
  }
  destroy() {
    this.removeListeners();
  }
}
Br(Af.prototype);
class A$ {
  constructor(e) {
    this.rendition = e, this.highlights = [], this.underlines = [], this.marks = [], this._annotations = {}, this._annotationsBySectionIndex = {}, this.rendition.hooks.render.register(this.inject.bind(this)), this.rendition.hooks.unloaded.register(this.clear.bind(this));
  }
  /**
   * Add an annotation to store
   * @param {string} type Type of annotation to add: "highlight", "underline", "mark"
   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to
   * @param {object} data Data to assign to annotation
   * @param {function} [cb] Callback after annotation is added
   * @param {string} className CSS class to assign to annotation
   * @param {object} styles CSS styles to assign to annotation
   * @returns {Annotation} annotation
   */
  add(e, n, r, i, s, o) {
    let a = encodeURI(n + e), u = new mt(n).spinePos, c = new wy({
      type: e,
      cfiRange: n,
      data: r,
      sectionIndex: u,
      cb: i,
      className: s,
      styles: o
    });
    return this._annotations[a] = c, u in this._annotationsBySectionIndex ? this._annotationsBySectionIndex[u].push(a) : this._annotationsBySectionIndex[u] = [a], this.rendition.views().forEach((h) => {
      c.sectionIndex === h.index && c.attach(h);
    }), c;
  }
  /**
   * Remove an annotation from store
   * @param {EpubCFI} cfiRange EpubCFI range the annotation is attached to
   * @param {string} type Type of annotation to add: "highlight", "underline", "mark"
   */
  remove(e, n) {
    let r = encodeURI(e + n);
    if (r in this._annotations) {
      let i = this._annotations[r];
      if (n && i.type !== n)
        return;
      this.rendition.views().forEach((o) => {
        this._removeFromAnnotationBySectionIndex(i.sectionIndex, r), i.sectionIndex === o.index && i.detach(o);
      }), delete this._annotations[r];
    }
  }
  /**
   * Remove an annotations by Section Index
   * @private
   */
  _removeFromAnnotationBySectionIndex(e, n) {
    this._annotationsBySectionIndex[e] = this._annotationsAt(e).filter((r) => r !== n);
  }
  /**
   * Get annotations by Section Index
   * @private
   */
  _annotationsAt(e) {
    return this._annotationsBySectionIndex[e];
  }
  /**
   * Add a highlight to the store
   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to
   * @param {object} data Data to assign to annotation
   * @param {function} cb Callback after annotation is clicked
   * @param {string} className CSS class to assign to annotation
   * @param {object} styles CSS styles to assign to annotation
   */
  highlight(e, n, r, i, s) {
    return this.add("highlight", e, n, r, i, s);
  }
  /**
   * Add a underline to the store
   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to
   * @param {object} data Data to assign to annotation
   * @param {function} cb Callback after annotation is clicked
   * @param {string} className CSS class to assign to annotation
   * @param {object} styles CSS styles to assign to annotation
   */
  underline(e, n, r, i, s) {
    return this.add("underline", e, n, r, i, s);
  }
  /**
   * Add a mark to the store
   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to
   * @param {object} data Data to assign to annotation
   * @param {function} cb Callback after annotation is clicked
   */
  mark(e, n, r) {
    return this.add("mark", e, n, r);
  }
  /**
   * iterate over annotations in the store
   */
  each() {
    return this._annotations.forEach.apply(this._annotations, arguments);
  }
  /**
   * Hook for injecting annotation into a view
   * @param {View} view
   * @private
   */
  inject(e) {
    let n = e.index;
    n in this._annotationsBySectionIndex && this._annotationsBySectionIndex[n].forEach((i) => {
      this._annotations[i].attach(e);
    });
  }
  /**
   * Hook for removing annotation from a view
   * @param {View} view
   * @private
   */
  clear(e) {
    let n = e.index;
    n in this._annotationsBySectionIndex && this._annotationsBySectionIndex[n].forEach((i) => {
      this._annotations[i].detach(e);
    });
  }
  /**
   * [Not Implemented] Show annotations
   * @TODO: needs implementation in View
   */
  show() {
  }
  /**
   * [Not Implemented] Hide annotations
   * @TODO: needs implementation in View
   */
  hide() {
  }
}
class wy {
  constructor({
    type: e,
    cfiRange: n,
    data: r,
    sectionIndex: i,
    cb: s,
    className: o,
    styles: a
  }) {
    this.type = e, this.cfiRange = n, this.data = r, this.sectionIndex = i, this.mark = void 0, this.cb = s, this.className = o, this.styles = a;
  }
  /**
   * Update stored data
   * @param {object} data
   */
  update(e) {
    this.data = e;
  }
  /**
   * Add to a view
   * @param {View} view
   */
  attach(e) {
    let { cfiRange: n, data: r, type: i, mark: s, cb: o, className: a, styles: l } = this, u;
    return i === "highlight" ? u = e.highlight(n, r, o, a, l) : i === "underline" ? u = e.underline(n, r, o, a, l) : i === "mark" && (u = e.mark(n, r, o)), this.mark = u, this.emit(Re.ANNOTATION.ATTACH, u), u;
  }
  /**
   * Remove from a view
   * @param {View} view
   */
  detach(e) {
    let { cfiRange: n, type: r } = this, i;
    return e && (r === "highlight" ? i = e.unhighlight(n) : r === "underline" ? i = e.ununderline(n) : r === "mark" && (i = e.unmark(n))), this.mark = void 0, this.emit(Re.ANNOTATION.DETACH, i), i;
  }
  /**
   * [Not Implemented] Get text of an annotation
   * @TODO: needs implementation in contents
   */
  text() {
  }
}
Br(wy.prototype);
var Kr = {}, su = {};
Object.defineProperty(su, "__esModule", {
  value: !0
});
su.createElement = _y;
function _y(t) {
  return document.createElementNS("http://www.w3.org/2000/svg", t);
}
su.default = {
  createElement: _y
};
var ca = {};
Object.defineProperty(ca, "__esModule", {
  value: !0
});
ca.proxyMouse = Ey;
ca.clone = Sy;
ca.default = {
  proxyMouse: Ey
};
function Ey(t, e) {
  function n(o) {
    for (var a = e.length - 1; a >= 0; a--) {
      var l = e[a], u = o.clientX, c = o.clientY;
      if (o.touches && o.touches.length && (u = o.touches[0].clientX, c = o.touches[0].clientY), !!I$(l, t, u, c)) {
        l.dispatchEvent(Sy(o));
        break;
      }
    }
  }
  if (t.nodeName === "iframe" || t.nodeName === "IFRAME")
    try {
      this.target = t.contentDocument;
    } catch {
      this.target = t;
    }
  else
    this.target = t;
  for (var r = ["mouseup", "mousedown", "click", "touchstart"], i = 0; i < r.length; i++) {
    var s = r[i];
    this.target.addEventListener(s, function(o) {
      return n(o);
    }, !1);
  }
}
function Sy(t) {
  var e = Object.assign({}, t, { bubbles: !1 });
  try {
    return new MouseEvent(t.type, e);
  } catch {
    var n = document.createEvent("MouseEvents");
    return n.initMouseEvent(t.type, !1, e.cancelable, e.view, e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget), n;
  }
}
function I$(t, e, n, r) {
  var i = e.getBoundingClientRect();
  function s(c, d, h) {
    var v = c.top - i.top, y = c.left - i.left, b = v + c.height, p = y + c.width;
    return v <= h && y <= d && b > h && p > d;
  }
  var o = t.getBoundingClientRect();
  if (!s(o, n, r))
    return !1;
  for (var a = t.getClientRects(), l = 0, u = a.length; l < u; l++)
    if (s(a[l], n, r))
      return !0;
  return !1;
}
var Ll, If;
Object.defineProperty(Kr, "__esModule", {
  value: !0
});
var xy = Kr.Underline = If = Kr.Highlight = Kr.Mark = Ll = Kr.Pane = void 0, R$ = function t(e, n, r) {
  e === null && (e = Function.prototype);
  var i = Object.getOwnPropertyDescriptor(e, n);
  if (i === void 0) {
    var s = Object.getPrototypeOf(e);
    return s === null ? void 0 : t(s, n, r);
  } else {
    if ("value" in i)
      return i.value;
    var o = i.get;
    return o === void 0 ? void 0 : o.call(r);
  }
}, ou = function() {
  function t(e, n) {
    for (var r = 0; r < n.length; r++) {
      var i = n[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  return function(e, n, r) {
    return n && t(e.prototype, n), r && t(e, r), e;
  };
}(), L$ = su, Vo = Cy(L$), P$ = ca, $$ = Cy(P$);
function Cy(t) {
  return t && t.__esModule ? t : { default: t };
}
function ky(t, e) {
  if (!t)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e && (typeof e == "object" || typeof e == "function") ? e : t;
}
function Ty(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof e);
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
}
function au(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
Ll = Kr.Pane = function() {
  function t(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : document.body;
    au(this, t), this.target = e, this.element = Vo.default.createElement("svg"), this.marks = [], this.element.style.position = "absolute", this.element.setAttribute("pointer-events", "none"), $$.default.proxyMouse(this.target, this.marks), this.container = n, this.container.appendChild(this.element), this.render();
  }
  return ou(t, [{
    key: "addMark",
    value: function(n) {
      var r = Vo.default.createElement("g");
      return this.element.appendChild(r), n.bind(r, this.container), this.marks.push(n), n.render(), n;
    }
  }, {
    key: "removeMark",
    value: function(n) {
      var r = this.marks.indexOf(n);
      if (r !== -1) {
        var i = n.unbind();
        this.element.removeChild(i), this.marks.splice(r, 1);
      }
    }
  }, {
    key: "render",
    value: function() {
      z$(this.element, M$(this.target, this.container));
      var n = !0, r = !1, i = void 0;
      try {
        for (var s = this.marks[Symbol.iterator](), o; !(n = (o = s.next()).done); n = !0) {
          var a = o.value;
          a.render();
        }
      } catch (l) {
        r = !0, i = l;
      } finally {
        try {
          !n && s.return && s.return();
        } finally {
          if (r)
            throw i;
        }
      }
    }
  }]), t;
}();
var D$ = Kr.Mark = function() {
  function t() {
    au(this, t), this.element = null;
  }
  return ou(t, [{
    key: "bind",
    value: function(n, r) {
      this.element = n, this.container = r;
    }
  }, {
    key: "unbind",
    value: function() {
      var n = this.element;
      return this.element = null, n;
    }
  }, {
    key: "render",
    value: function() {
    }
  }, {
    key: "dispatchEvent",
    value: function(n) {
      this.element && this.element.dispatchEvent(n);
    }
  }, {
    key: "getBoundingClientRect",
    value: function() {
      return this.element.getBoundingClientRect();
    }
  }, {
    key: "getClientRects",
    value: function() {
      for (var n = [], r = this.element.firstChild; r; )
        n.push(r.getBoundingClientRect()), r = r.nextSibling;
      return n;
    }
  }, {
    key: "filteredRanges",
    value: function() {
      var n = Array.from(this.range.getClientRects());
      return n.filter(function(r) {
        for (var i = 0; i < n.length; i++) {
          if (n[i] === r)
            return !0;
          var s = F$(n[i], r);
          if (s)
            return !1;
        }
        return !0;
      });
    }
  }]), t;
}(), B$ = If = Kr.Highlight = function(t) {
  Ty(e, t);
  function e(n, r, i, s) {
    au(this, e);
    var o = ky(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
    return o.range = n, o.className = r, o.data = i || {}, o.attributes = s || {}, o;
  }
  return ou(e, [{
    key: "bind",
    value: function(r, i) {
      R$(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "bind", this).call(this, r, i);
      for (var s in this.data)
        this.data.hasOwnProperty(s) && (this.element.dataset[s] = this.data[s]);
      for (var s in this.attributes)
        this.attributes.hasOwnProperty(s) && this.element.setAttribute(s, this.attributes[s]);
      this.className && this.element.classList.add(this.className);
    }
  }, {
    key: "render",
    value: function() {
      for (; this.element.firstChild; )
        this.element.removeChild(this.element.firstChild);
      for (var r = this.element.ownerDocument.createDocumentFragment(), i = this.filteredRanges(), s = this.element.getBoundingClientRect(), o = this.container.getBoundingClientRect(), a = 0, l = i.length; a < l; a++) {
        var u = i[a], c = Vo.default.createElement("rect");
        c.setAttribute("x", u.left - s.left + o.left), c.setAttribute("y", u.top - s.top + o.top), c.setAttribute("height", u.height), c.setAttribute("width", u.width), r.appendChild(c);
      }
      this.element.appendChild(r);
    }
  }]), e;
}(D$);
xy = Kr.Underline = function(t) {
  Ty(e, t);
  function e(n, r, i, s) {
    return au(this, e), ky(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, n, r, i, s));
  }
  return ou(e, [{
    key: "render",
    value: function() {
      for (; this.element.firstChild; )
        this.element.removeChild(this.element.firstChild);
      for (var r = this.element.ownerDocument.createDocumentFragment(), i = this.filteredRanges(), s = this.element.getBoundingClientRect(), o = this.container.getBoundingClientRect(), a = 0, l = i.length; a < l; a++) {
        var u = i[a], c = Vo.default.createElement("rect");
        c.setAttribute("x", u.left - s.left + o.left), c.setAttribute("y", u.top - s.top + o.top), c.setAttribute("height", u.height), c.setAttribute("width", u.width), c.setAttribute("fill", "none");
        var d = Vo.default.createElement("line");
        d.setAttribute("x1", u.left - s.left + o.left), d.setAttribute("x2", u.left - s.left + o.left + u.width), d.setAttribute("y1", u.top - s.top + o.top + u.height - 1), d.setAttribute("y2", u.top - s.top + o.top + u.height - 1), d.setAttribute("stroke-width", 1), d.setAttribute("stroke", "black"), d.setAttribute("stroke-linecap", "square"), r.appendChild(c), r.appendChild(d);
      }
      this.element.appendChild(r);
    }
  }]), e;
}(B$);
function M$(t, e) {
  var n = e.getBoundingClientRect(), r = t.getBoundingClientRect();
  return {
    top: r.top - n.top,
    left: r.left - n.left,
    height: t.scrollHeight,
    width: t.scrollWidth
  };
}
function z$(t, e) {
  t.style.setProperty("top", e.top + "px", "important"), t.style.setProperty("left", e.left + "px", "important"), t.style.setProperty("height", e.height + "px", "important"), t.style.setProperty("width", e.width + "px", "important");
}
function F$(t, e) {
  return e.right <= t.right && e.left >= t.left && e.top >= t.top && e.bottom <= t.bottom;
}
class Oy {
  constructor(e, n) {
    this.settings = En({
      ignoreClass: "",
      axis: void 0,
      //options.layout && options.layout.props.flow === "scrolled" ? "vertical" : "horizontal",
      direction: void 0,
      width: 0,
      height: 0,
      layout: void 0,
      globalLayoutProperties: {},
      method: void 0,
      forceRight: !1,
      allowScriptedContent: !1,
      allowPopups: !1
    }, n || {}), this.id = "epubjs-view-" + ru(), this.section = e, this.index = e.index, this.element = this.container(this.settings.axis), this.added = !1, this.displayed = !1, this.rendered = !1, this.fixedWidth = 0, this.fixedHeight = 0, this.epubcfi = new mt(), this.layout = this.settings.layout, this.pane = void 0, this.highlights = {}, this.underlines = {}, this.marks = {};
  }
  container(e) {
    var n = document.createElement("div");
    return n.classList.add("epub-view"), n.style.height = "0px", n.style.width = "0px", n.style.overflow = "hidden", n.style.position = "relative", n.style.display = "block", e && e == "horizontal" ? n.style.flex = "none" : n.style.flex = "initial", n;
  }
  create() {
    return this.iframe ? this.iframe : (this.element || (this.element = this.createContainer()), this.iframe = document.createElement("iframe"), this.iframe.id = this.id, this.iframe.scrolling = "no", this.iframe.style.overflow = "hidden", this.iframe.seamless = "seamless", this.iframe.style.border = "none", this.iframe.sandbox = "allow-same-origin", this.settings.allowScriptedContent && (this.iframe.sandbox += " allow-scripts"), this.settings.allowPopups && (this.iframe.sandbox += " allow-popups"), this.iframe.setAttribute("enable-annotation", "true"), this.resizing = !0, this.element.style.visibility = "hidden", this.iframe.style.visibility = "hidden", this.iframe.style.width = "0", this.iframe.style.height = "0", this._width = 0, this._height = 0, this.element.setAttribute("ref", this.index), this.added = !0, this.elementBounds = Ja(this.element), "srcdoc" in this.iframe ? this.supportsSrcdoc = !0 : this.supportsSrcdoc = !1, this.settings.method || (this.settings.method = this.supportsSrcdoc ? "srcdoc" : "write"), this.iframe);
  }
  render(e, n) {
    return this.create(), this.size(), this.sectionRender || (this.sectionRender = this.section.render(e)), this.sectionRender.then(function(r) {
      return this.load(r);
    }.bind(this)).then(function() {
      let r = this.contents.writingMode(), i;
      return this.settings.flow === "scrolled" ? i = r.indexOf("vertical") === 0 ? "horizontal" : "vertical" : i = r.indexOf("vertical") === 0 ? "vertical" : "horizontal", r.indexOf("vertical") === 0 && this.settings.flow === "paginated" && (this.layout.delta = this.layout.height), this.setAxis(i), this.emit(Re.VIEWS.AXIS, i), this.setWritingMode(r), this.emit(Re.VIEWS.WRITING_MODE, r), this.layout.format(this.contents, this.section, this.axis), this.addListeners(), new Promise((s, o) => {
        this.expand(), this.settings.forceRight && (this.element.style.marginLeft = this.width() + "px"), s();
      });
    }.bind(this), function(r) {
      return this.emit(Re.VIEWS.LOAD_ERROR, r), new Promise((i, s) => {
        s(r);
      });
    }.bind(this)).then(function() {
      this.emit(Re.VIEWS.RENDERED, this.section);
    }.bind(this));
  }
  reset() {
    this.iframe && (this.iframe.style.width = "0", this.iframe.style.height = "0", this._width = 0, this._height = 0, this._textWidth = void 0, this._contentWidth = void 0, this._textHeight = void 0, this._contentHeight = void 0), this._needsReframe = !0;
  }
  // Determine locks base on settings
  size(e, n) {
    var r = e || this.settings.width, i = n || this.settings.height;
    this.layout.name === "pre-paginated" ? this.lock("both", r, i) : this.settings.axis === "horizontal" ? this.lock("height", r, i) : this.lock("width", r, i), this.settings.width = r, this.settings.height = i;
  }
  // Lock an axis to element dimensions, taking borders into account
  lock(e, n, r) {
    var i = Tl(this.element), s;
    this.iframe ? s = Tl(this.iframe) : s = { width: 0, height: 0 }, e == "width" && Xt(n) && (this.lockedWidth = n - i.width - s.width), e == "height" && Xt(r) && (this.lockedHeight = r - i.height - s.height), e === "both" && Xt(n) && Xt(r) && (this.lockedWidth = n - i.width - s.width, this.lockedHeight = r - i.height - s.height), this.displayed && this.iframe && this.expand();
  }
  // Resize a single axis based on content dimensions
  expand(e) {
    var n = this.lockedWidth, r = this.lockedHeight, i;
    !this.iframe || this._expanding || (this._expanding = !0, this.layout.name === "pre-paginated" ? (n = this.layout.columnWidth, r = this.layout.height) : this.settings.axis === "horizontal" ? (n = this.contents.textWidth(), n % this.layout.pageWidth > 0 && (n = Math.ceil(n / this.layout.pageWidth) * this.layout.pageWidth), this.settings.forceEvenPages && (i = n / this.layout.pageWidth, this.layout.divisor > 1 && this.layout.name === "reflowable" && i % 2 > 0 && (n += this.layout.pageWidth))) : this.settings.axis === "vertical" && (r = this.contents.textHeight(), this.settings.flow === "paginated" && r % this.layout.height > 0 && (r = Math.ceil(r / this.layout.height) * this.layout.height)), (this._needsReframe || n != this._width || r != this._height) && this.reframe(n, r), this._expanding = !1);
  }
  reframe(e, n) {
    var r;
    Xt(e) && (this.element.style.width = e + "px", this.iframe.style.width = e + "px", this._width = e), Xt(n) && (this.element.style.height = n + "px", this.iframe.style.height = n + "px", this._height = n);
    let i = this.prevBounds ? e - this.prevBounds.width : e, s = this.prevBounds ? n - this.prevBounds.height : n;
    r = {
      width: e,
      height: n,
      widthDelta: i,
      heightDelta: s
    }, this.pane && this.pane.render(), requestAnimationFrame(() => {
      let o;
      for (let a in this.marks)
        this.marks.hasOwnProperty(a) && (o = this.marks[a], this.placeMark(o.element, o.range));
    }), this.onResize(this, r), this.emit(Re.VIEWS.RESIZED, r), this.prevBounds = r, this.elementBounds = Ja(this.element);
  }
  load(e) {
    var n = new vt(), r = n.promise;
    if (!this.iframe)
      return n.reject(new Error("No Iframe Available")), r;
    if (this.iframe.onload = function(s) {
      this.onLoad(s, n);
    }.bind(this), this.settings.method === "blobUrl")
      this.blobUrl = Nl(e, "application/xhtml+xml"), this.iframe.src = this.blobUrl, this.element.appendChild(this.iframe);
    else if (this.settings.method === "srcdoc")
      this.iframe.srcdoc = e, this.element.appendChild(this.iframe);
    else {
      if (this.element.appendChild(this.iframe), this.document = this.iframe.contentDocument, !this.document)
        return n.reject(new Error("No Document Available")), r;
      if (this.iframe.contentDocument.open(), window.MSApp && MSApp.execUnsafeLocalFunction) {
        var i = this;
        MSApp.execUnsafeLocalFunction(function() {
          i.iframe.contentDocument.write(e);
        });
      } else
        this.iframe.contentDocument.write(e);
      this.iframe.contentDocument.close();
    }
    return r;
  }
  onLoad(e, n) {
    this.window = this.iframe.contentWindow, this.document = this.iframe.contentDocument, this.contents = new Af(this.document, this.document.body, this.section.cfiBase, this.section.index), this.rendering = !1;
    var r = this.document.querySelector("link[rel='canonical']");
    r ? r.setAttribute("href", this.section.canonical) : (r = this.document.createElement("link"), r.setAttribute("rel", "canonical"), r.setAttribute("href", this.section.canonical), this.document.querySelector("head").appendChild(r)), this.contents.on(Re.CONTENTS.EXPAND, () => {
      this.displayed && this.iframe && (this.expand(), this.contents && this.layout.format(this.contents));
    }), this.contents.on(Re.CONTENTS.RESIZE, (i) => {
      this.displayed && this.iframe && (this.expand(), this.contents && this.layout.format(this.contents));
    }), n.resolve(this.contents);
  }
  setLayout(e) {
    this.layout = e, this.contents && (this.layout.format(this.contents), this.expand());
  }
  setAxis(e) {
    this.settings.axis = e, e == "horizontal" ? this.element.style.flex = "none" : this.element.style.flex = "initial", this.size();
  }
  setWritingMode(e) {
    this.writingMode = e;
  }
  addListeners() {
  }
  removeListeners(e) {
  }
  display(e) {
    var n = new vt();
    return this.displayed ? n.resolve(this) : this.render(e).then(function() {
      this.emit(Re.VIEWS.DISPLAYED, this), this.onDisplayed(this), this.displayed = !0, n.resolve(this);
    }.bind(this), function(r) {
      n.reject(r, this);
    }), n.promise;
  }
  show() {
    this.element.style.visibility = "visible", this.iframe && (this.iframe.style.visibility = "visible", this.iframe.style.transform = "translateZ(0)", this.iframe.offsetWidth, this.iframe.style.transform = null), this.emit(Re.VIEWS.SHOWN, this);
  }
  hide() {
    this.element.style.visibility = "hidden", this.iframe.style.visibility = "hidden", this.stopExpanding = !0, this.emit(Re.VIEWS.HIDDEN, this);
  }
  offset() {
    return {
      top: this.element.offsetTop,
      left: this.element.offsetLeft
    };
  }
  width() {
    return this._width;
  }
  height() {
    return this._height;
  }
  position() {
    return this.element.getBoundingClientRect();
  }
  locationOf(e) {
    this.iframe.getBoundingClientRect();
    var n = this.contents.locationOf(e, this.settings.ignoreClass);
    return {
      left: n.left,
      top: n.top
    };
  }
  onDisplayed(e) {
  }
  onResize(e, n) {
  }
  bounds(e) {
    return (e || !this.elementBounds) && (this.elementBounds = Ja(this.element)), this.elementBounds;
  }
  highlight(e, n = {}, r, i = "epubjs-hl", s = {}) {
    if (!this.contents)
      return;
    const o = Object.assign({ fill: "yellow", "fill-opacity": "0.3", "mix-blend-mode": "multiply" }, s);
    let a = this.contents.range(e), l = () => {
      this.emit(Re.VIEWS.MARK_CLICKED, e, n);
    };
    n.epubcfi = e, this.pane || (this.pane = new Ll(this.iframe, this.element));
    let u = new If(a, i, n, o), c = this.pane.addMark(u);
    return this.highlights[e] = { mark: c, element: c.element, listeners: [l, r] }, c.element.setAttribute("ref", i), c.element.addEventListener("click", l), c.element.addEventListener("touchstart", l), r && (c.element.addEventListener("click", r), c.element.addEventListener("touchstart", r)), c;
  }
  underline(e, n = {}, r, i = "epubjs-ul", s = {}) {
    if (!this.contents)
      return;
    const o = Object.assign({ stroke: "black", "stroke-opacity": "0.3", "mix-blend-mode": "multiply" }, s);
    let a = this.contents.range(e), l = () => {
      this.emit(Re.VIEWS.MARK_CLICKED, e, n);
    };
    n.epubcfi = e, this.pane || (this.pane = new Ll(this.iframe, this.element));
    let u = new xy(a, i, n, o), c = this.pane.addMark(u);
    return this.underlines[e] = { mark: c, element: c.element, listeners: [l, r] }, c.element.setAttribute("ref", i), c.element.addEventListener("click", l), c.element.addEventListener("touchstart", l), r && (c.element.addEventListener("click", r), c.element.addEventListener("touchstart", r)), c;
  }
  mark(e, n = {}, r) {
    if (!this.contents)
      return;
    if (e in this.marks)
      return this.marks[e];
    let i = this.contents.range(e);
    if (!i)
      return;
    let s = i.commonAncestorContainer, o = s.nodeType === 1 ? s : s.parentNode, a = (u) => {
      this.emit(Re.VIEWS.MARK_CLICKED, e, n);
    };
    i.collapsed && s.nodeType === 1 ? (i = new Range(), i.selectNodeContents(s)) : i.collapsed && (i = new Range(), i.selectNodeContents(o));
    let l = this.document.createElement("a");
    return l.setAttribute("ref", "epubjs-mk"), l.style.position = "absolute", l.dataset.epubcfi = e, n && Object.keys(n).forEach((u) => {
      l.dataset[u] = n[u];
    }), r && (l.addEventListener("click", r), l.addEventListener("touchstart", r)), l.addEventListener("click", a), l.addEventListener("touchstart", a), this.placeMark(l, i), this.element.appendChild(l), this.marks[e] = { element: l, range: i, listeners: [a, r] }, o;
  }
  placeMark(e, n) {
    let r, i, s;
    if (this.layout.name === "pre-paginated" || this.settings.axis !== "horizontal") {
      let a = n.getBoundingClientRect();
      r = a.top, i = a.right;
    } else {
      let a = n.getClientRects(), l;
      for (var o = 0; o != a.length; o++)
        l = a[o], (!s || l.left < s) && (s = l.left, i = Math.ceil(s / this.layout.props.pageWidth) * this.layout.props.pageWidth - this.layout.gap / 2, r = l.top);
    }
    e.style.top = `${r}px`, e.style.left = `${i}px`;
  }
  unhighlight(e) {
    let n;
    e in this.highlights && (n = this.highlights[e], this.pane.removeMark(n.mark), n.listeners.forEach((r) => {
      r && (n.element.removeEventListener("click", r), n.element.removeEventListener("touchstart", r));
    }), delete this.highlights[e]);
  }
  ununderline(e) {
    let n;
    e in this.underlines && (n = this.underlines[e], this.pane.removeMark(n.mark), n.listeners.forEach((r) => {
      r && (n.element.removeEventListener("click", r), n.element.removeEventListener("touchstart", r));
    }), delete this.underlines[e]);
  }
  unmark(e) {
    let n;
    e in this.marks && (n = this.marks[e], this.element.removeChild(n.element), n.listeners.forEach((r) => {
      r && (n.element.removeEventListener("click", r), n.element.removeEventListener("touchstart", r));
    }), delete this.marks[e]);
  }
  destroy() {
    for (let e in this.highlights)
      this.unhighlight(e);
    for (let e in this.underlines)
      this.ununderline(e);
    for (let e in this.marks)
      this.unmark(e);
    this.blobUrl && cy(this.blobUrl), this.displayed && (this.displayed = !1, this.removeListeners(), this.contents.destroy(), this.stopExpanding = !0, this.element.removeChild(this.iframe), this.pane && (this.pane.element.remove(), this.pane = void 0), this.iframe = void 0, this.contents = void 0, this._textWidth = null, this._textHeight = null, this._width = null, this._height = null);
  }
}
Br(Oy.prototype);
function j$() {
  var t = "reverse", e = U$();
  return document.body.appendChild(e), e.scrollLeft > 0 ? t = "default" : typeof Element < "u" && Element.prototype.scrollIntoView ? (e.children[0].children[1].scrollIntoView(), e.scrollLeft < 0 && (t = "negative")) : (e.scrollLeft = 1, e.scrollLeft === 0 && (t = "negative")), document.body.removeChild(e), t;
}
function U$() {
  var t = document.createElement("div");
  t.dir = "rtl", t.style.position = "fixed", t.style.width = "1px", t.style.height = "1px", t.style.top = "0px", t.style.left = "0px", t.style.overflow = "hidden";
  var e = document.createElement("div");
  e.style.width = "2px";
  var n = document.createElement("span");
  n.style.width = "1px", n.style.display = "inline-block";
  var r = document.createElement("span");
  return r.style.width = "1px", r.style.display = "inline-block", e.appendChild(n), e.appendChild(r), t.appendChild(e), t;
}
function V$(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var Rf = V$, W$ = typeof gn == "object" && gn && gn.Object === Object && gn, H$ = W$, K$ = H$, q$ = typeof self == "object" && self && self.Object === Object && self, G$ = K$ || q$ || Function("return this")(), Ny = G$, Y$ = Ny, X$ = function() {
  return Y$.Date.now();
}, Z$ = X$, Q$ = /\s/;
function J$(t) {
  for (var e = t.length; e-- && Q$.test(t.charAt(e)); )
    ;
  return e;
}
var e6 = J$, t6 = e6, n6 = /^\s+/;
function r6(t) {
  return t && t.slice(0, t6(t) + 1).replace(n6, "");
}
var i6 = r6, s6 = Ny, o6 = s6.Symbol, Ay = o6, ov = Ay, Iy = Object.prototype, a6 = Iy.hasOwnProperty, l6 = Iy.toString, no = ov ? ov.toStringTag : void 0;
function u6(t) {
  var e = a6.call(t, no), n = t[no];
  try {
    t[no] = void 0;
    var r = !0;
  } catch {
  }
  var i = l6.call(t);
  return r && (e ? t[no] = n : delete t[no]), i;
}
var c6 = u6, d6 = Object.prototype, f6 = d6.toString;
function h6(t) {
  return f6.call(t);
}
var p6 = h6, av = Ay, v6 = c6, m6 = p6, g6 = "[object Null]", y6 = "[object Undefined]", lv = av ? av.toStringTag : void 0;
function b6(t) {
  return t == null ? t === void 0 ? y6 : g6 : lv && lv in Object(t) ? v6(t) : m6(t);
}
var w6 = b6;
function _6(t) {
  return t != null && typeof t == "object";
}
var E6 = _6, S6 = w6, x6 = E6, C6 = "[object Symbol]";
function k6(t) {
  return typeof t == "symbol" || x6(t) && S6(t) == C6;
}
var T6 = k6, O6 = i6, uv = Rf, N6 = T6, cv = 0 / 0, A6 = /^[-+]0x[0-9a-f]+$/i, I6 = /^0b[01]+$/i, R6 = /^0o[0-7]+$/i, L6 = parseInt;
function P6(t) {
  if (typeof t == "number")
    return t;
  if (N6(t))
    return cv;
  if (uv(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = uv(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = O6(t);
  var n = I6.test(t);
  return n || R6.test(t) ? L6(t.slice(2), n ? 2 : 8) : A6.test(t) ? cv : +t;
}
var $6 = P6, D6 = Rf, Ku = Z$, dv = $6, B6 = "Expected a function", M6 = Math.max, z6 = Math.min;
function F6(t, e, n) {
  var r, i, s, o, a, l, u = 0, c = !1, d = !1, h = !0;
  if (typeof t != "function")
    throw new TypeError(B6);
  e = dv(e) || 0, D6(n) && (c = !!n.leading, d = "maxWait" in n, s = d ? M6(dv(n.maxWait) || 0, e) : s, h = "trailing" in n ? !!n.trailing : h);
  function v(E) {
    var C = r, T = i;
    return r = i = void 0, u = E, o = t.apply(T, C), o;
  }
  function y(E) {
    return u = E, a = setTimeout(f, e), c ? v(E) : o;
  }
  function b(E) {
    var C = E - l, T = E - u, k = e - C;
    return d ? z6(k, s - T) : k;
  }
  function p(E) {
    var C = E - l, T = E - u;
    return l === void 0 || C >= e || C < 0 || d && T >= s;
  }
  function f() {
    var E = Ku();
    if (p(E))
      return m(E);
    a = setTimeout(f, b(E));
  }
  function m(E) {
    return a = void 0, h && r ? v(E) : (r = i = void 0, o);
  }
  function g() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = i = a = void 0;
  }
  function w() {
    return a === void 0 ? o : m(Ku());
  }
  function _() {
    var E = Ku(), C = p(E);
    if (r = arguments, i = this, l = E, C) {
      if (a === void 0)
        return y(l);
      if (d)
        return clearTimeout(a), a = setTimeout(f, e), v(l);
    }
    return a === void 0 && (a = setTimeout(f, e)), o;
  }
  return _.cancel = g, _.flush = w, _;
}
var Ry = F6, j6 = Ry, U6 = Rf, V6 = "Expected a function";
function W6(t, e, n) {
  var r = !0, i = !0;
  if (typeof t != "function")
    throw new TypeError(V6);
  return U6(n) && (r = "leading" in n ? !!n.leading : r, i = "trailing" in n ? !!n.trailing : i), j6(t, e, {
    leading: r,
    maxWait: e,
    trailing: i
  });
}
var H6 = W6;
class K6 {
  constructor(e) {
    this.settings = e || {}, this.id = "epubjs-container-" + ru(), this.container = this.create(this.settings), this.settings.hidden && (this.wrapper = this.wrap(this.container));
  }
  /*
  * Creates an element to render to.
  * Resizes to passed width and height or to the elements size
  */
  create(e) {
    let n = e.height, r = e.width, i = e.overflow || !1, s = e.axis || "vertical", o = e.direction;
    En(this.settings, e), e.height && Xt(e.height) && (n = e.height + "px"), e.width && Xt(e.width) && (r = e.width + "px");
    let a = document.createElement("div");
    return a.id = this.id, a.classList.add("epub-container"), a.style.wordSpacing = "0", a.style.lineHeight = "0", a.style.verticalAlign = "top", a.style.position = "relative", s === "horizontal" && (a.style.display = "flex", a.style.flexDirection = "row", a.style.flexWrap = "nowrap"), r && (a.style.width = r), n && (a.style.height = n), i && (i === "scroll" && s === "vertical" ? (a.style["overflow-y"] = i, a.style["overflow-x"] = "hidden") : i === "scroll" && s === "horizontal" ? (a.style["overflow-y"] = "hidden", a.style["overflow-x"] = i) : a.style.overflow = i), o && (a.dir = o, a.style.direction = o), o && this.settings.fullsize && (document.body.style.direction = o), a;
  }
  wrap(e) {
    var n = document.createElement("div");
    return n.style.visibility = "hidden", n.style.overflow = "hidden", n.style.width = "0", n.style.height = "0", n.appendChild(e), n;
  }
  getElement(e) {
    var n;
    if (sy(e) ? n = e : typeof e == "string" && (n = document.getElementById(e)), !n)
      throw new Error("Not an Element");
    return n;
  }
  attachTo(e) {
    var n = this.getElement(e), r;
    if (n)
      return this.settings.hidden ? r = this.wrapper : r = this.container, n.appendChild(r), this.element = n, n;
  }
  getContainer() {
    return this.container;
  }
  onResize(e) {
    (!Xt(this.settings.width) || !Xt(this.settings.height)) && (this.resizeFunc = H6(e, 50), window.addEventListener("resize", this.resizeFunc, !1));
  }
  onOrientationChange(e) {
    this.orientationChangeFunc = e, window.addEventListener("orientationchange", this.orientationChangeFunc, !1);
  }
  size(e, n) {
    var r;
    let i = e || this.settings.width, s = n || this.settings.height;
    e === null ? (r = this.element.getBoundingClientRect(), r.width && (e = Math.floor(r.width), this.container.style.width = e + "px")) : Xt(e) ? this.container.style.width = e + "px" : this.container.style.width = e, n === null ? (r = r || this.element.getBoundingClientRect(), r.height && (n = r.height, this.container.style.height = n + "px")) : Xt(n) ? this.container.style.height = n + "px" : this.container.style.height = n, Xt(e) || (e = this.container.clientWidth), Xt(n) || (n = this.container.clientHeight), this.containerStyles = window.getComputedStyle(this.container), this.containerPadding = {
      left: parseFloat(this.containerStyles["padding-left"]) || 0,
      right: parseFloat(this.containerStyles["padding-right"]) || 0,
      top: parseFloat(this.containerStyles["padding-top"]) || 0,
      bottom: parseFloat(this.containerStyles["padding-bottom"]) || 0
    };
    let o = Ol(), a = window.getComputedStyle(document.body), l = {
      left: parseFloat(a["padding-left"]) || 0,
      right: parseFloat(a["padding-right"]) || 0,
      top: parseFloat(a["padding-top"]) || 0,
      bottom: parseFloat(a["padding-bottom"]) || 0
    };
    return i || (e = o.width - l.left - l.right), (this.settings.fullsize && !s || !s) && (n = o.height - l.top - l.bottom), {
      width: e - this.containerPadding.left - this.containerPadding.right,
      height: n - this.containerPadding.top - this.containerPadding.bottom
    };
  }
  bounds() {
    let e;
    return this.container.style.overflow !== "visible" && (e = this.container && this.container.getBoundingClientRect()), !e || !e.width || !e.height ? Ol() : e;
  }
  getSheet() {
    var e = document.createElement("style");
    return e.appendChild(document.createTextNode("")), document.head.appendChild(e), e.sheet;
  }
  addStyleRules(e, n) {
    var r = "#" + this.id + " ", i = "";
    this.sheet || (this.sheet = this.getSheet()), n.forEach(function(s) {
      for (var o in s)
        s.hasOwnProperty(o) && (i += o + ":" + s[o] + ";");
    }), this.sheet.insertRule(r + e + " {" + i + "}", 0);
  }
  axis(e) {
    e === "horizontal" ? (this.container.style.display = "flex", this.container.style.flexDirection = "row", this.container.style.flexWrap = "nowrap") : this.container.style.display = "block", this.settings.axis = e;
  }
  // orientation(orientation) {
  // 	if (orientation === "landscape") {
  //
  // 	} else {
  //
  // 	}
  //
  // 	this.orientation = orientation;
  // }
  direction(e) {
    this.container && (this.container.dir = e, this.container.style.direction = e), this.settings.fullsize && (document.body.style.direction = e), this.settings.dir = e;
  }
  overflow(e) {
    this.container && (e === "scroll" && this.settings.axis === "vertical" ? (this.container.style["overflow-y"] = e, this.container.style["overflow-x"] = "hidden") : e === "scroll" && this.settings.axis === "horizontal" ? (this.container.style["overflow-y"] = "hidden", this.container.style["overflow-x"] = e) : this.container.style.overflow = e), this.settings.overflow = e;
  }
  destroy() {
    this.element && (this.settings.hidden ? this.wrapper : this.container, this.element.contains(this.container) && this.element.removeChild(this.container), window.removeEventListener("resize", this.resizeFunc), window.removeEventListener("orientationChange", this.orientationChangeFunc));
  }
}
class q6 {
  constructor(e) {
    this.container = e, this._views = [], this.length = 0, this.hidden = !1;
  }
  all() {
    return this._views;
  }
  first() {
    return this._views[0];
  }
  last() {
    return this._views[this._views.length - 1];
  }
  indexOf(e) {
    return this._views.indexOf(e);
  }
  slice() {
    return this._views.slice.apply(this._views, arguments);
  }
  get(e) {
    return this._views[e];
  }
  append(e) {
    return this._views.push(e), this.container && this.container.appendChild(e.element), this.length++, e;
  }
  prepend(e) {
    return this._views.unshift(e), this.container && this.container.insertBefore(e.element, this.container.firstChild), this.length++, e;
  }
  insert(e, n) {
    return this._views.splice(n, 0, e), this.container && (n < this.container.children.length ? this.container.insertBefore(e.element, this.container.children[n]) : this.container.appendChild(e.element)), this.length++, e;
  }
  remove(e) {
    var n = this._views.indexOf(e);
    n > -1 && this._views.splice(n, 1), this.destroy(e), this.length--;
  }
  destroy(e) {
    e.displayed && e.destroy(), this.container && this.container.removeChild(e.element), e = null;
  }
  // Iterators
  forEach() {
    return this._views.forEach.apply(this._views, arguments);
  }
  clear() {
    var e, n = this.length;
    if (this.length) {
      for (var r = 0; r < n; r++)
        e = this._views[r], this.destroy(e);
      this._views = [], this.length = 0;
    }
  }
  find(e) {
    for (var n, r = this.length, i = 0; i < r; i++)
      if (n = this._views[i], n.displayed && n.section.index == e.index)
        return n;
  }
  displayed() {
    for (var e = [], n, r = this.length, i = 0; i < r; i++)
      n = this._views[i], n.displayed && e.push(n);
    return e;
  }
  show() {
    for (var e, n = this.length, r = 0; r < n; r++)
      e = this._views[r], e.displayed && e.show();
    this.hidden = !1;
  }
  hide() {
    for (var e, n = this.length, r = 0; r < n; r++)
      e = this._views[r], e.displayed && e.hide();
    this.hidden = !0;
  }
}
class Pl {
  constructor(e) {
    this.name = "default", this.optsSettings = e.settings, this.View = e.view, this.request = e.request, this.renditionQueue = e.queue, this.q = new Nf(this), this.settings = En(this.settings || {}, {
      infinite: !0,
      hidden: !1,
      width: void 0,
      height: void 0,
      axis: void 0,
      writingMode: void 0,
      flow: "scrolled",
      ignoreClass: "",
      fullsize: void 0,
      allowScriptedContent: !1,
      allowPopups: !1
    }), En(this.settings, e.settings || {}), this.viewSettings = {
      ignoreClass: this.settings.ignoreClass,
      axis: this.settings.axis,
      flow: this.settings.flow,
      layout: this.layout,
      method: this.settings.method,
      // srcdoc, blobUrl, write
      width: 0,
      height: 0,
      forceEvenPages: !0,
      allowScriptedContent: this.settings.allowScriptedContent,
      allowPopups: this.settings.allowPopups
    }, this.rendered = !1;
  }
  render(e, n) {
    let r = e.tagName;
    typeof this.settings.fullsize > "u" && r && (r.toLowerCase() == "body" || r.toLowerCase() == "html") && (this.settings.fullsize = !0), this.settings.fullsize && (this.settings.overflow = "visible", this.overflow = this.settings.overflow), this.settings.size = n, this.settings.rtlScrollType = j$(), this.stage = new K6({
      width: n.width,
      height: n.height,
      overflow: this.overflow,
      hidden: this.settings.hidden,
      axis: this.settings.axis,
      fullsize: this.settings.fullsize,
      direction: this.settings.direction
    }), this.stage.attachTo(e), this.container = this.stage.getContainer(), this.views = new q6(this.container), this._bounds = this.bounds(), this._stageSize = this.stage.size(), this.viewSettings.width = this._stageSize.width, this.viewSettings.height = this._stageSize.height, this.stage.onResize(this.onResized.bind(this)), this.stage.onOrientationChange(this.onOrientationChange.bind(this)), this.addEventListeners(), this.layout && this.updateLayout(), this.rendered = !0;
  }
  addEventListeners() {
    var e;
    window.addEventListener("unload", function(n) {
      this.destroy();
    }.bind(this)), this.settings.fullsize ? e = window : e = this.container, this._onScroll = this.onScroll.bind(this), e.addEventListener("scroll", this._onScroll);
  }
  removeEventListeners() {
    var e;
    this.settings.fullsize ? e = window : e = this.container, e.removeEventListener("scroll", this._onScroll), this._onScroll = void 0;
  }
  destroy() {
    clearTimeout(this.orientationTimeout), clearTimeout(this.resizeTimeout), clearTimeout(this.afterScrolled), this.clear(), this.removeEventListeners(), this.stage.destroy(), this.rendered = !1;
  }
  onOrientationChange(e) {
    let { orientation: n } = window;
    this.optsSettings.resizeOnOrientationChange && this.resize(), clearTimeout(this.orientationTimeout), this.orientationTimeout = setTimeout(function() {
      this.orientationTimeout = void 0, this.optsSettings.resizeOnOrientationChange && this.resize(), this.emit(Re.MANAGERS.ORIENTATION_CHANGE, n);
    }.bind(this), 500);
  }
  onResized(e) {
    this.resize();
  }
  resize(e, n, r) {
    let i = this.stage.size(e, n);
    if (this.winBounds = Ol(), this.orientationTimeout && this.winBounds.width === this.winBounds.height) {
      this._stageSize = void 0;
      return;
    }
    this._stageSize && this._stageSize.width === i.width && this._stageSize.height === i.height || (this._stageSize = i, this._bounds = this.bounds(), this.clear(), this.viewSettings.width = this._stageSize.width, this.viewSettings.height = this._stageSize.height, this.updateLayout(), this.emit(Re.MANAGERS.RESIZED, {
      width: this._stageSize.width,
      height: this._stageSize.height
    }, r));
  }
  createView(e, n) {
    return new this.View(e, En(this.viewSettings, { forceRight: n }));
  }
  handleNextPrePaginated(e, n, r) {
    let i;
    if (this.layout.name === "pre-paginated" && this.layout.divisor > 1) {
      if (e || n.index === 0)
        return;
      if (i = n.next(), i && !i.properties.includes("page-spread-left"))
        return r.call(this, i);
    }
  }
  display(e, n) {
    var r = new vt(), i = r.promise;
    (n === e.href || Xt(n)) && (n = void 0);
    var s = this.views.find(e);
    if (s && e && this.layout.name !== "pre-paginated") {
      let a = s.offset();
      if (this.settings.direction === "ltr")
        this.scrollTo(a.left, a.top, !0);
      else {
        let l = s.width();
        this.scrollTo(a.left + l, a.top, !0);
      }
      if (n) {
        let l = s.locationOf(n), u = s.width();
        this.moveTo(l, u);
      }
      return r.resolve(), i;
    }
    this.clear();
    let o = !1;
    return this.layout.name === "pre-paginated" && this.layout.divisor === 2 && e.properties.includes("page-spread-right") && (o = !0), this.add(e, o).then(function(a) {
      if (n) {
        let l = a.locationOf(n), u = a.width();
        this.moveTo(l, u);
      }
    }.bind(this), (a) => {
      r.reject(a);
    }).then(function() {
      return this.handleNextPrePaginated(o, e, this.add);
    }.bind(this)).then(function() {
      this.views.show(), r.resolve();
    }.bind(this)), i;
  }
  afterDisplayed(e) {
    this.emit(Re.MANAGERS.ADDED, e);
  }
  afterResized(e) {
    this.emit(Re.MANAGERS.RESIZE, e.section);
  }
  moveTo(e, n) {
    var r = 0, i = 0;
    this.isPaginated ? (r = Math.floor(e.left / this.layout.delta) * this.layout.delta, r + this.layout.delta > this.container.scrollWidth && (r = this.container.scrollWidth - this.layout.delta), i = Math.floor(e.top / this.layout.delta) * this.layout.delta, i + this.layout.delta > this.container.scrollHeight && (i = this.container.scrollHeight - this.layout.delta)) : i = e.top, this.settings.direction === "rtl" && (r = r + this.layout.delta, r = r - n), this.scrollTo(r, i, !0);
  }
  add(e, n) {
    var r = this.createView(e, n);
    return this.views.append(r), r.onDisplayed = this.afterDisplayed.bind(this), r.onResize = this.afterResized.bind(this), r.on(Re.VIEWS.AXIS, (i) => {
      this.updateAxis(i);
    }), r.on(Re.VIEWS.WRITING_MODE, (i) => {
      this.updateWritingMode(i);
    }), r.display(this.request);
  }
  append(e, n) {
    var r = this.createView(e, n);
    return this.views.append(r), r.onDisplayed = this.afterDisplayed.bind(this), r.onResize = this.afterResized.bind(this), r.on(Re.VIEWS.AXIS, (i) => {
      this.updateAxis(i);
    }), r.on(Re.VIEWS.WRITING_MODE, (i) => {
      this.updateWritingMode(i);
    }), r.display(this.request);
  }
  prepend(e, n) {
    var r = this.createView(e, n);
    return r.on(Re.VIEWS.RESIZED, (i) => {
      this.counter(i);
    }), this.views.prepend(r), r.onDisplayed = this.afterDisplayed.bind(this), r.onResize = this.afterResized.bind(this), r.on(Re.VIEWS.AXIS, (i) => {
      this.updateAxis(i);
    }), r.on(Re.VIEWS.WRITING_MODE, (i) => {
      this.updateWritingMode(i);
    }), r.display(this.request);
  }
  counter(e) {
    this.settings.axis === "vertical" ? this.scrollBy(0, e.heightDelta, !0) : this.scrollBy(e.widthDelta, 0, !0);
  }
  // resizeView(view) {
  //
  // 	if(this.settings.globalLayoutProperties.layout === "pre-paginated") {
  // 		view.lock("both", this.bounds.width, this.bounds.height);
  // 	} else {
  // 		view.lock("width", this.bounds.width, this.bounds.height);
  // 	}
  //
  // };
  next() {
    var e, n;
    let r = this.settings.direction;
    if (this.views.length && (this.isPaginated && this.settings.axis === "horizontal" && (!r || r === "ltr") ? (this.scrollLeft = this.container.scrollLeft, n = this.container.scrollLeft + this.container.offsetWidth + this.layout.delta, n <= this.container.scrollWidth ? this.scrollBy(this.layout.delta, 0, !0) : e = this.views.last().section.next()) : this.isPaginated && this.settings.axis === "horizontal" && r === "rtl" ? (this.scrollLeft = this.container.scrollLeft, this.settings.rtlScrollType === "default" ? (n = this.container.scrollLeft, n > 0 ? this.scrollBy(this.layout.delta, 0, !0) : e = this.views.last().section.next()) : (n = this.container.scrollLeft + this.layout.delta * -1, n > this.container.scrollWidth * -1 ? this.scrollBy(this.layout.delta, 0, !0) : e = this.views.last().section.next())) : this.isPaginated && this.settings.axis === "vertical" ? (this.scrollTop = this.container.scrollTop, this.container.scrollTop + this.container.offsetHeight < this.container.scrollHeight ? this.scrollBy(0, this.layout.height, !0) : e = this.views.last().section.next()) : e = this.views.last().section.next(), e)) {
      this.clear(), this.updateLayout();
      let i = !1;
      return this.layout.name === "pre-paginated" && this.layout.divisor === 2 && e.properties.includes("page-spread-right") && (i = !0), this.append(e, i).then(function() {
        return this.handleNextPrePaginated(i, e, this.append);
      }.bind(this), (s) => s).then(function() {
        !this.isPaginated && this.settings.axis === "horizontal" && this.settings.direction === "rtl" && this.settings.rtlScrollType === "default" && this.scrollTo(this.container.scrollWidth, 0, !0), this.views.show();
      }.bind(this));
    }
  }
  prev() {
    var e, n;
    let r = this.settings.direction;
    if (this.views.length && (this.isPaginated && this.settings.axis === "horizontal" && (!r || r === "ltr") ? (this.scrollLeft = this.container.scrollLeft, n = this.container.scrollLeft, n > 0 ? this.scrollBy(-this.layout.delta, 0, !0) : e = this.views.first().section.prev()) : this.isPaginated && this.settings.axis === "horizontal" && r === "rtl" ? (this.scrollLeft = this.container.scrollLeft, this.settings.rtlScrollType === "default" ? (n = this.container.scrollLeft + this.container.offsetWidth, n < this.container.scrollWidth ? this.scrollBy(-this.layout.delta, 0, !0) : e = this.views.first().section.prev()) : (n = this.container.scrollLeft, n < 0 ? this.scrollBy(-this.layout.delta, 0, !0) : e = this.views.first().section.prev())) : this.isPaginated && this.settings.axis === "vertical" ? (this.scrollTop = this.container.scrollTop, this.container.scrollTop > 0 ? this.scrollBy(0, -this.layout.height, !0) : e = this.views.first().section.prev()) : e = this.views.first().section.prev(), e)) {
      this.clear(), this.updateLayout();
      let i = !1;
      return this.layout.name === "pre-paginated" && this.layout.divisor === 2 && typeof e.prev() != "object" && (i = !0), this.prepend(e, i).then(function() {
        var s;
        if (this.layout.name === "pre-paginated" && this.layout.divisor > 1 && (s = e.prev(), s))
          return this.prepend(s);
      }.bind(this), (s) => s).then(function() {
        this.isPaginated && this.settings.axis === "horizontal" && (this.settings.direction === "rtl" ? this.settings.rtlScrollType === "default" ? this.scrollTo(0, 0, !0) : this.scrollTo(this.container.scrollWidth * -1 + this.layout.delta, 0, !0) : this.scrollTo(this.container.scrollWidth - this.layout.delta, 0, !0)), this.views.show();
      }.bind(this));
    }
  }
  current() {
    var e = this.visible();
    return e.length ? e[e.length - 1] : null;
  }
  clear() {
    this.views && (this.views.hide(), this.scrollTo(0, 0, !0), this.views.clear());
  }
  currentLocation() {
    return this.updateLayout(), this.isPaginated && this.settings.axis === "horizontal" ? this.location = this.paginatedLocation() : this.location = this.scrolledLocation(), this.location;
  }
  scrolledLocation() {
    let e = this.visible(), n = this.container.getBoundingClientRect(), r = n.height < window.innerHeight ? n.height : window.innerHeight, i = n.width < window.innerWidth ? n.width : window.innerWidth, s = this.settings.axis === "vertical";
    this.settings.direction;
    let o = 0, a = 0;
    return this.settings.fullsize && (o = s ? window.scrollY : window.scrollX), e.map((u) => {
      let { index: c, href: d } = u.section, h = u.position(), v = u.width(), y = u.height(), b, p, f, m;
      s ? (b = o + n.top - h.top + a, p = b + r - a, m = this.layout.count(y, r).pages, f = r) : (b = o + n.left - h.left + a, p = b + i - a, m = this.layout.count(v, i).pages, f = i);
      let g = Math.ceil(b / f), w = [], _ = Math.ceil(p / f);
      if (this.settings.direction === "rtl" && !s) {
        let T = g;
        g = m - _, _ = m - T;
      }
      w = [];
      for (var E = g; E <= _; E++) {
        let T = E + 1;
        w.push(T);
      }
      let C = this.mapping.page(u.contents, u.section.cfiBase, b, p);
      return {
        index: c,
        href: d,
        pages: w,
        totalPages: m,
        mapping: C
      };
    });
  }
  paginatedLocation() {
    let e = this.visible(), n = this.container.getBoundingClientRect(), r = 0, i = 0;
    return this.settings.fullsize && (r = window.scrollX), e.map((o) => {
      let { index: a, href: l } = o.section, u, c = o.position(), d = o.width(), h, v, y;
      this.settings.direction === "rtl" ? (u = n.right - r, y = Math.min(Math.abs(u - c.left), this.layout.width) - i, v = c.width - (c.right - u) - i, h = v - y) : (u = n.left + r, y = Math.min(c.right - u, this.layout.width) - i, h = u - c.left + i, v = h + y), i += y;
      let b = this.mapping.page(o.contents, o.section.cfiBase, h, v), p = this.layout.count(d).pages, f = Math.floor(h / this.layout.pageWidth), m = [], g = Math.floor(v / this.layout.pageWidth);
      if (f < 0 && (f = 0, g = g + 1), this.settings.direction === "rtl") {
        let _ = f;
        f = p - g, g = p - _;
      }
      for (var w = f + 1; w <= g; w++) {
        let _ = w;
        m.push(_);
      }
      return {
        index: a,
        href: l,
        pages: m,
        totalPages: p,
        mapping: b
      };
    });
  }
  isVisible(e, n, r, i) {
    var s = e.position(), o = i || this.bounds();
    return this.settings.axis === "horizontal" && s.right > o.left - n && s.left < o.right + r ? !0 : this.settings.axis === "vertical" && s.bottom > o.top - n && s.top < o.bottom + r;
  }
  visible() {
    for (var e = this.bounds(), n = this.views.displayed(), r = n.length, i = [], s, o, a = 0; a < r; a++)
      o = n[a], s = this.isVisible(o, 0, 0, e), s === !0 && i.push(o);
    return i;
  }
  scrollBy(e, n, r) {
    let i = this.settings.direction === "rtl" ? -1 : 1;
    r && (this.ignore = !0), this.settings.fullsize ? window.scrollBy(e * i, n * i) : (e && (this.container.scrollLeft += e * i), n && (this.container.scrollTop += n)), this.scrolled = !0;
  }
  scrollTo(e, n, r) {
    r && (this.ignore = !0), this.settings.fullsize ? window.scrollTo(e, n) : (this.container.scrollLeft = e, this.container.scrollTop = n), this.scrolled = !0;
  }
  onScroll() {
    let e, n;
    this.settings.fullsize ? (e = window.scrollY, n = window.scrollX) : (e = this.container.scrollTop, n = this.container.scrollLeft), this.scrollTop = e, this.scrollLeft = n, this.ignore ? this.ignore = !1 : (this.emit(Re.MANAGERS.SCROLL, {
      top: e,
      left: n
    }), clearTimeout(this.afterScrolled), this.afterScrolled = setTimeout(function() {
      this.emit(Re.MANAGERS.SCROLLED, {
        top: this.scrollTop,
        left: this.scrollLeft
      });
    }.bind(this), 20));
  }
  bounds() {
    var e;
    return e = this.stage.bounds(), e;
  }
  applyLayout(e) {
    this.layout = e, this.updateLayout(), this.views && this.views.length > 0 && this.layout.name === "pre-paginated" && this.display(this.views.first().section);
  }
  updateLayout() {
    this.stage && (this._stageSize = this.stage.size(), this.isPaginated ? (this.layout.calculate(
      this._stageSize.width,
      this._stageSize.height,
      this.settings.gap
    ), this.settings.offset = this.layout.delta / this.layout.divisor) : this.layout.calculate(this._stageSize.width, this._stageSize.height), this.viewSettings.width = this.layout.width, this.viewSettings.height = this.layout.height, this.setLayout(this.layout));
  }
  setLayout(e) {
    this.viewSettings.layout = e, this.mapping = new Rl(e.props, this.settings.direction, this.settings.axis), this.views && this.views.forEach(function(n) {
      n && n.setLayout(e);
    });
  }
  updateWritingMode(e) {
    this.writingMode = e;
  }
  updateAxis(e, n) {
    !n && e === this.settings.axis || (this.settings.axis = e, this.stage && this.stage.axis(e), this.viewSettings.axis = e, this.mapping && (this.mapping = new Rl(this.layout.props, this.settings.direction, this.settings.axis)), this.layout && (e === "vertical" ? this.layout.spread("none") : this.layout.spread(this.layout.settings.spread)));
  }
  updateFlow(e, n = "auto") {
    let r = e === "paginated" || e === "auto";
    this.isPaginated = r, e === "scrolled-doc" || e === "scrolled-continuous" || e === "scrolled" ? this.updateAxis("vertical") : this.updateAxis("horizontal"), this.viewSettings.flow = e, this.settings.overflow ? this.overflow = this.settings.overflow : this.overflow = r ? "hidden" : n, this.stage && this.stage.overflow(this.overflow), this.updateLayout();
  }
  getContents() {
    var e = [];
    return this.views && this.views.forEach(function(n) {
      const r = n && n.contents;
      r && e.push(r);
    }), e;
  }
  direction(e = "ltr") {
    this.settings.direction = e, this.stage && this.stage.direction(e), this.viewSettings.direction = e, this.updateLayout();
  }
  isRendered() {
    return this.rendered;
  }
}
Br(Pl.prototype);
const G6 = Math.PI / 2, Y6 = {
  easeOutSine: function(t) {
    return Math.sin(t * G6);
  },
  easeInOutSine: function(t) {
    return -0.5 * (Math.cos(Math.PI * t) - 1);
  },
  easeInOutQuint: function(t) {
    return (t /= 0.5) < 1 ? 0.5 * Math.pow(t, 5) : 0.5 * (Math.pow(t - 2, 5) + 2);
  },
  easeInCubic: function(t) {
    return Math.pow(t, 3);
  }
};
class od {
  constructor(e, n) {
    this.settings = En({
      duration: 80,
      minVelocity: 0.2,
      minDistance: 10,
      easing: Y6.easeInCubic
    }, n || {}), this.supportsTouch = this.supportsTouch(), this.supportsTouch && this.setup(e);
  }
  setup(e) {
    this.manager = e, this.layout = this.manager.layout, this.fullsize = this.manager.settings.fullsize, this.fullsize ? (this.element = this.manager.stage.element, this.scroller = window, this.disableScroll()) : (this.element = this.manager.stage.container, this.scroller = this.element, this.element.style.WebkitOverflowScrolling = "touch"), this.manager.settings.offset = this.layout.width, this.manager.settings.afterScrolledTimeout = this.settings.duration * 2, this.isVertical = this.manager.settings.axis === "vertical", !(!this.manager.isPaginated || this.isVertical) && (this.touchCanceler = !1, this.resizeCanceler = !1, this.snapping = !1, this.scrollLeft, this.scrollTop, this.startTouchX = void 0, this.startTouchY = void 0, this.startTime = void 0, this.endTouchX = void 0, this.endTouchY = void 0, this.endTime = void 0, this.addListeners());
  }
  supportsTouch() {
    return !!("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch);
  }
  disableScroll() {
    this.element.style.overflow = "hidden";
  }
  enableScroll() {
    this.element.style.overflow = "";
  }
  addListeners() {
    this._onResize = this.onResize.bind(this), window.addEventListener("resize", this._onResize), this._onScroll = this.onScroll.bind(this), this.scroller.addEventListener("scroll", this._onScroll), this._onTouchStart = this.onTouchStart.bind(this), this.scroller.addEventListener("touchstart", this._onTouchStart, { passive: !0 }), this.on("touchstart", this._onTouchStart), this._onTouchMove = this.onTouchMove.bind(this), this.scroller.addEventListener("touchmove", this._onTouchMove, { passive: !0 }), this.on("touchmove", this._onTouchMove), this._onTouchEnd = this.onTouchEnd.bind(this), this.scroller.addEventListener("touchend", this._onTouchEnd, { passive: !0 }), this.on("touchend", this._onTouchEnd), this._afterDisplayed = this.afterDisplayed.bind(this), this.manager.on(Re.MANAGERS.ADDED, this._afterDisplayed);
  }
  removeListeners() {
    window.removeEventListener("resize", this._onResize), this._onResize = void 0, this.scroller.removeEventListener("scroll", this._onScroll), this._onScroll = void 0, this.scroller.removeEventListener("touchstart", this._onTouchStart, { passive: !0 }), this.off("touchstart", this._onTouchStart), this._onTouchStart = void 0, this.scroller.removeEventListener("touchmove", this._onTouchMove, { passive: !0 }), this.off("touchmove", this._onTouchMove), this._onTouchMove = void 0, this.scroller.removeEventListener("touchend", this._onTouchEnd, { passive: !0 }), this.off("touchend", this._onTouchEnd), this._onTouchEnd = void 0, this.manager.off(Re.MANAGERS.ADDED, this._afterDisplayed), this._afterDisplayed = void 0;
  }
  afterDisplayed(e) {
    let n = e.contents;
    ["touchstart", "touchmove", "touchend"].forEach((r) => {
      n.on(r, (i) => this.triggerViewEvent(i, n));
    });
  }
  triggerViewEvent(e, n) {
    this.emit(e.type, e, n);
  }
  onScroll(e) {
    this.scrollLeft = this.fullsize ? window.scrollX : this.scroller.scrollLeft, this.scrollTop = this.fullsize ? window.scrollY : this.scroller.scrollTop;
  }
  onResize(e) {
    this.resizeCanceler = !0;
  }
  onTouchStart(e) {
    let { screenX: n, screenY: r } = e.touches[0];
    this.fullsize && this.enableScroll(), this.touchCanceler = !0, this.startTouchX || (this.startTouchX = n, this.startTouchY = r, this.startTime = this.now()), this.endTouchX = n, this.endTouchY = r, this.endTime = this.now();
  }
  onTouchMove(e) {
    let { screenX: n, screenY: r } = e.touches[0], i = Math.abs(r - this.endTouchY);
    this.touchCanceler = !0, !this.fullsize && i < 10 && (this.element.scrollLeft -= n - this.endTouchX), this.endTouchX = n, this.endTouchY = r, this.endTime = this.now();
  }
  onTouchEnd(e) {
    this.fullsize && this.disableScroll(), this.touchCanceler = !1;
    let n = this.wasSwiped();
    n !== 0 ? this.snap(n) : this.snap(), this.startTouchX = void 0, this.startTouchY = void 0, this.startTime = void 0, this.endTouchX = void 0, this.endTouchY = void 0, this.endTime = void 0;
  }
  wasSwiped() {
    let e = this.layout.pageWidth * this.layout.divisor, n = this.endTouchX - this.startTouchX, r = Math.abs(n), i = this.endTime - this.startTime, s = n / i, o = this.settings.minVelocity;
    if (r <= this.settings.minDistance || r >= e)
      return 0;
    if (s > o)
      return -1;
    if (s < -o)
      return 1;
  }
  needsSnap() {
    let e = this.scrollLeft, n = this.layout.pageWidth * this.layout.divisor;
    return e % n !== 0;
  }
  snap(e = 0) {
    let n = this.scrollLeft, r = this.layout.pageWidth * this.layout.divisor, i = Math.round(n / r) * r;
    return e && (i += e * r), this.smoothScrollTo(i);
  }
  smoothScrollTo(e) {
    const n = new vt(), r = this.scrollLeft, i = this.now(), s = this.settings.duration, o = this.settings.easing;
    this.snapping = !0;
    function a() {
      const l = this.now(), u = Math.min(1, (l - i) / s);
      if (o(u), this.touchCanceler || this.resizeCanceler) {
        this.resizeCanceler = !1, this.snapping = !1, n.resolve();
        return;
      }
      u < 1 ? (window.requestAnimationFrame(a.bind(this)), this.scrollTo(r + (e - r) * u, 0)) : (this.scrollTo(e, 0), this.snapping = !1, n.resolve());
    }
    return a.call(this), n.promise;
  }
  scrollTo(e = 0, n = 0) {
    this.fullsize ? window.scroll(e, n) : (this.scroller.scrollLeft = e, this.scroller.scrollTop = n);
  }
  now() {
    return "now" in window.performance ? performance.now() : (/* @__PURE__ */ new Date()).getTime();
  }
  destroy() {
    this.scroller && (this.fullsize && this.enableScroll(), this.removeListeners(), this.scroller = void 0);
  }
}
Br(od.prototype);
class X6 extends Pl {
  constructor(e) {
    super(e), this.name = "continuous", this.settings = En(this.settings || {}, {
      infinite: !0,
      overflow: void 0,
      axis: void 0,
      writingMode: void 0,
      flow: "scrolled",
      offset: 500,
      offsetDelta: 250,
      width: void 0,
      height: void 0,
      snap: !1,
      afterScrolledTimeout: 10,
      allowScriptedContent: !1,
      allowPopups: !1
    }), En(this.settings, e.settings || {}), e.settings.gap != "undefined" && e.settings.gap === 0 && (this.settings.gap = e.settings.gap), this.viewSettings = {
      ignoreClass: this.settings.ignoreClass,
      axis: this.settings.axis,
      flow: this.settings.flow,
      layout: this.layout,
      width: 0,
      height: 0,
      forceEvenPages: !1,
      allowScriptedContent: this.settings.allowScriptedContent,
      allowPopups: this.settings.allowPopups
    }, this.scrollTop = 0, this.scrollLeft = 0;
  }
  display(e, n) {
    return Pl.prototype.display.call(this, e, n).then(function() {
      return this.fill();
    }.bind(this));
  }
  fill(e) {
    var n = e || new vt();
    return this.q.enqueue(() => this.check()).then((r) => {
      r ? this.fill(n) : n.resolve();
    }), n.promise;
  }
  moveTo(e) {
    var n = 0, r = 0;
    this.isPaginated ? (n = Math.floor(e.left / this.layout.delta) * this.layout.delta, n + this.settings.offsetDelta) : (r = e.top, e.top + this.settings.offsetDelta), (n > 0 || r > 0) && this.scrollBy(n, r, !0);
  }
  afterResized(e) {
    this.emit(Re.MANAGERS.RESIZE, e.section);
  }
  // Remove Previous Listeners if present
  removeShownListeners(e) {
    e.onDisplayed = function() {
    };
  }
  add(e) {
    var n = this.createView(e);
    return this.views.append(n), n.on(Re.VIEWS.RESIZED, (r) => {
      n.expanded = !0;
    }), n.on(Re.VIEWS.AXIS, (r) => {
      this.updateAxis(r);
    }), n.on(Re.VIEWS.WRITING_MODE, (r) => {
      this.updateWritingMode(r);
    }), n.onDisplayed = this.afterDisplayed.bind(this), n.onResize = this.afterResized.bind(this), n.display(this.request);
  }
  append(e) {
    var n = this.createView(e);
    return n.on(Re.VIEWS.RESIZED, (r) => {
      n.expanded = !0;
    }), n.on(Re.VIEWS.AXIS, (r) => {
      this.updateAxis(r);
    }), n.on(Re.VIEWS.WRITING_MODE, (r) => {
      this.updateWritingMode(r);
    }), this.views.append(n), n.onDisplayed = this.afterDisplayed.bind(this), n;
  }
  prepend(e) {
    var n = this.createView(e);
    return n.on(Re.VIEWS.RESIZED, (r) => {
      this.counter(r), n.expanded = !0;
    }), n.on(Re.VIEWS.AXIS, (r) => {
      this.updateAxis(r);
    }), n.on(Re.VIEWS.WRITING_MODE, (r) => {
      this.updateWritingMode(r);
    }), this.views.prepend(n), n.onDisplayed = this.afterDisplayed.bind(this), n;
  }
  counter(e) {
    this.settings.axis === "vertical" ? this.scrollBy(0, e.heightDelta, !0) : this.scrollBy(e.widthDelta, 0, !0);
  }
  update(e) {
    for (var n = this.bounds(), r = this.views.all(), i = r.length, s = typeof e < "u" ? e : this.settings.offset || 0, o, a, l = new vt(), u = [], c = 0; c < i; c++)
      if (a = r[c], o = this.isVisible(a, s, s, n), o === !0)
        if (a.displayed)
          a.show();
        else {
          let d = a.display(this.request).then(function(h) {
            h.show();
          }, (h) => {
            a.hide();
          });
          u.push(d);
        }
      else
        this.q.enqueue(a.destroy.bind(a)), clearTimeout(this.trimTimeout), this.trimTimeout = setTimeout(function() {
          this.q.enqueue(this.trim.bind(this));
        }.bind(this), 250);
    return u.length ? Promise.all(u).catch((d) => {
      l.reject(d);
    }) : (l.resolve(), l.promise);
  }
  check(e, n) {
    var r = new vt(), i = [], s = this.settings.axis === "horizontal", o = this.settings.offset || 0;
    e && s && (o = e), n && !s && (o = n);
    var a = this._bounds;
    let l = s ? this.scrollLeft : this.scrollTop, u = s ? Math.floor(a.width) : a.height, c = s ? this.container.scrollWidth : this.container.scrollHeight, d = this.writingMode && this.writingMode.indexOf("vertical") === 0 ? "vertical" : "horizontal", h = this.settings.rtlScrollType, v = this.settings.direction === "rtl";
    this.settings.fullsize ? (s && v && h === "negative" || !s && v && h === "default") && (l = l * -1) : (v && h === "default" && d === "horizontal" && (l = c - u - l), v && h === "negative" && d === "horizontal" && (l = l * -1));
    let y = () => {
      let g = this.views.first(), w = g && g.section.prev();
      w && i.push(this.prepend(w));
    }, b = () => {
      let g = this.views.last(), w = g && g.section.next();
      w && i.push(this.append(w));
    }, p = l + u + o, f = l - o;
    p >= c && b(), f < 0 && y();
    let m = i.map((g) => g.display(this.request));
    return i.length ? Promise.all(m).then(() => this.check()).then(() => this.update(o), (g) => g) : (this.q.enqueue(function() {
      this.update();
    }.bind(this)), r.resolve(!1), r.promise);
  }
  trim() {
    for (var e = new vt(), n = this.views.displayed(), r = n[0], i = n[n.length - 1], s = this.views.indexOf(r), o = this.views.indexOf(i), a = this.views.slice(0, s), l = this.views.slice(o + 1), u = 0; u < a.length - 1; u++)
      this.erase(a[u], a);
    for (var c = 1; c < l.length; c++)
      this.erase(l[c]);
    return e.resolve(), e.promise;
  }
  erase(e, n) {
    var r, i;
    this.settings.fullsize ? (r = window.scrollY, i = window.scrollX) : (r = this.container.scrollTop, i = this.container.scrollLeft);
    var s = e.bounds();
    this.views.remove(e), n && (this.settings.axis === "vertical" ? this.scrollTo(0, r - s.height, !0) : this.settings.direction === "rtl" ? this.settings.fullsize ? this.scrollTo(i + Math.floor(s.width), 0, !0) : this.scrollTo(i, 0, !0) : this.scrollTo(i - Math.floor(s.width), 0, !0));
  }
  addEventListeners(e) {
    window.addEventListener("unload", function(n) {
      this.ignore = !0, this.destroy();
    }.bind(this)), this.addScrollListeners(), this.isPaginated && this.settings.snap && (this.snapper = new od(this, this.settings.snap && typeof this.settings.snap == "object" && this.settings.snap));
  }
  addScrollListeners() {
    var e;
    this.tick = kf;
    let n = this.settings.direction === "rtl" && this.settings.rtlScrollType === "default" ? -1 : 1;
    this.scrollDeltaVert = 0, this.scrollDeltaHorz = 0, this.settings.fullsize ? (e = window, this.scrollTop = window.scrollY * n, this.scrollLeft = window.scrollX * n) : (e = this.container, this.scrollTop = this.container.scrollTop, this.scrollLeft = this.container.scrollLeft), this._onScroll = this.onScroll.bind(this), e.addEventListener("scroll", this._onScroll), this._scrolled = Ry(this.scrolled.bind(this), 30), this.didScroll = !1;
  }
  removeEventListeners() {
    var e;
    this.settings.fullsize ? e = window : e = this.container, e.removeEventListener("scroll", this._onScroll), this._onScroll = void 0;
  }
  onScroll() {
    let e, n, r = this.settings.direction === "rtl" && this.settings.rtlScrollType === "default" ? -1 : 1;
    this.settings.fullsize ? (e = window.scrollY * r, n = window.scrollX * r) : (e = this.container.scrollTop, n = this.container.scrollLeft), this.scrollTop = e, this.scrollLeft = n, this.ignore ? this.ignore = !1 : this._scrolled(), this.scrollDeltaVert += Math.abs(e - this.prevScrollTop), this.scrollDeltaHorz += Math.abs(n - this.prevScrollLeft), this.prevScrollTop = e, this.prevScrollLeft = n, clearTimeout(this.scrollTimeout), this.scrollTimeout = setTimeout(function() {
      this.scrollDeltaVert = 0, this.scrollDeltaHorz = 0;
    }.bind(this), 150), clearTimeout(this.afterScrolled), this.didScroll = !1;
  }
  scrolled() {
    this.q.enqueue(function() {
      return this.check();
    }.bind(this)), this.emit(Re.MANAGERS.SCROLL, {
      top: this.scrollTop,
      left: this.scrollLeft
    }), clearTimeout(this.afterScrolled), this.afterScrolled = setTimeout(function() {
      this.snapper && this.snapper.supportsTouch && this.snapper.needsSnap() || this.emit(Re.MANAGERS.SCROLLED, {
        top: this.scrollTop,
        left: this.scrollLeft
      });
    }.bind(this), this.settings.afterScrolledTimeout);
  }
  next() {
    let e = this.layout.props.name === "pre-paginated" && this.layout.props.spread ? this.layout.props.delta * 2 : this.layout.props.delta;
    this.views.length && (this.isPaginated && this.settings.axis === "horizontal" ? this.scrollBy(e, 0, !0) : this.scrollBy(0, this.layout.height, !0), this.q.enqueue(function() {
      return this.check();
    }.bind(this)));
  }
  prev() {
    let e = this.layout.props.name === "pre-paginated" && this.layout.props.spread ? this.layout.props.delta * 2 : this.layout.props.delta;
    this.views.length && (this.isPaginated && this.settings.axis === "horizontal" ? this.scrollBy(-e, 0, !0) : this.scrollBy(0, -this.layout.height, !0), this.q.enqueue(function() {
      return this.check();
    }.bind(this)));
  }
  updateFlow(e) {
    this.rendered && this.snapper && (this.snapper.destroy(), this.snapper = void 0), super.updateFlow(e, "scroll"), this.rendered && this.isPaginated && this.settings.snap && (this.snapper = new od(this, this.settings.snap && typeof this.settings.snap == "object" && this.settings.snap));
  }
  destroy() {
    super.destroy(), this.snapper && this.snapper.destroy();
  }
}
class Lf {
  constructor(e, n) {
    this.settings = En(this.settings || {}, {
      width: null,
      height: null,
      ignoreClass: "",
      manager: "default",
      view: "iframe",
      flow: null,
      layout: null,
      spread: null,
      minSpreadWidth: 800,
      stylesheet: null,
      resizeOnOrientationChange: !0,
      script: null,
      snap: !1,
      defaultDirection: "ltr",
      allowScriptedContent: !1,
      allowPopups: !1
    }), En(this.settings, n), typeof this.settings.manager == "object" && (this.manager = this.settings.manager), this.book = e, this.hooks = {}, this.hooks.display = new hr(this), this.hooks.serialize = new hr(this), this.hooks.content = new hr(this), this.hooks.unloaded = new hr(this), this.hooks.layout = new hr(this), this.hooks.render = new hr(this), this.hooks.show = new hr(this), this.hooks.content.register(this.handleLinks.bind(this)), this.hooks.content.register(this.passEvents.bind(this)), this.hooks.content.register(this.adjustImages.bind(this)), this.book.spine.hooks.content.register(this.injectIdentifier.bind(this)), this.settings.stylesheet && this.book.spine.hooks.content.register(this.injectStylesheet.bind(this)), this.settings.script && this.book.spine.hooks.content.register(this.injectScript.bind(this)), this.themes = new T$(this), this.annotations = new A$(this), this.epubcfi = new mt(), this.q = new Nf(this), this.location = void 0, this.q.enqueue(this.book.opened), this.starting = new vt(), this.started = this.starting.promise, this.q.enqueue(this.start);
  }
  /**
   * Set the manager function
   * @param {function} manager
   */
  setManager(e) {
    this.manager = e;
  }
  /**
   * Require the manager from passed string, or as a class function
   * @param  {string|object} manager [description]
   * @return {method}
   */
  requireManager(e) {
    var n;
    return typeof e == "string" && e === "default" ? n = Pl : typeof e == "string" && e === "continuous" ? n = X6 : n = e, n;
  }
  /**
   * Require the view from passed string, or as a class function
   * @param  {string|object} view
   * @return {view}
   */
  requireView(e) {
    var n;
    return typeof e == "string" && e === "iframe" ? n = Oy : n = e, n;
  }
  /**
   * Start the rendering
   * @return {Promise} rendering has started
   */
  start() {
    switch (!this.settings.layout && (this.book.package.metadata.layout === "pre-paginated" || this.book.displayOptions.fixedLayout === "true") && (this.settings.layout = "pre-paginated"), this.book.package.metadata.spread) {
      case "none":
        this.settings.spread = "none";
        break;
      case "both":
        this.settings.spread = !0;
        break;
    }
    this.manager || (this.ViewManager = this.requireManager(this.settings.manager), this.View = this.requireView(this.settings.view), this.manager = new this.ViewManager({
      view: this.View,
      queue: this.q,
      request: this.book.load.bind(this.book),
      settings: this.settings
    })), this.direction(this.book.package.metadata.direction || this.settings.defaultDirection), this.settings.globalLayoutProperties = this.determineLayoutProperties(this.book.package.metadata), this.flow(this.settings.globalLayoutProperties.flow), this.layout(this.settings.globalLayoutProperties), this.manager.on(Re.MANAGERS.ADDED, this.afterDisplayed.bind(this)), this.manager.on(Re.MANAGERS.REMOVED, this.afterRemoved.bind(this)), this.manager.on(Re.MANAGERS.RESIZED, this.onResized.bind(this)), this.manager.on(Re.MANAGERS.ORIENTATION_CHANGE, this.onOrientationChange.bind(this)), this.manager.on(Re.MANAGERS.SCROLLED, this.reportLocation.bind(this)), this.emit(Re.RENDITION.STARTED), this.starting.resolve();
  }
  /**
   * Call to attach the container to an element in the dom
   * Container must be attached before rendering can begin
   * @param  {element} element to attach to
   * @return {Promise}
   */
  attachTo(e) {
    return this.q.enqueue(function() {
      this.manager.render(e, {
        width: this.settings.width,
        height: this.settings.height
      }), this.emit(Re.RENDITION.ATTACHED);
    }.bind(this));
  }
  /**
   * Display a point in the book
   * The request will be added to the rendering Queue,
   * so it will wait until book is opened, rendering started
   * and all other rendering tasks have finished to be called.
   * @param  {string} target Url or EpubCFI
   * @return {Promise}
   */
  display(e) {
    return this.displaying && this.displaying.resolve(), this.q.enqueue(this._display, e);
  }
  /**
   * Tells the manager what to display immediately
   * @private
   * @param  {string} target Url or EpubCFI
   * @return {Promise}
   */
  _display(e) {
    if (this.book) {
      this.epubcfi.isCfiString(e);
      var n = new vt(), r = n.promise, i;
      return this.displaying = n, this.book.locations.length() && oy(e) && (e = this.book.locations.cfiFromPercentage(parseFloat(e))), i = this.book.spine.get(e), i ? (this.manager.display(i, e).then(() => {
        n.resolve(i), this.displaying = void 0, this.emit(Re.RENDITION.DISPLAYED, i), this.reportLocation();
      }, (s) => {
        this.emit(Re.RENDITION.DISPLAY_ERROR, s);
      }), r) : (n.reject(new Error("No Section Found")), r);
    }
  }
  /*
  	render(view, show) {
  
  		// view.onLayout = this.layout.format.bind(this.layout);
  		view.create();
  
  		// Fit to size of the container, apply padding
  		this.manager.resizeView(view);
  
  		// Render Chain
  		return view.section.render(this.book.request)
  			.then(function(contents){
  				return view.load(contents);
  			}.bind(this))
  			.then(function(doc){
  				return this.hooks.content.trigger(view, this);
  			}.bind(this))
  			.then(function(){
  				this.layout.format(view.contents);
  				return this.hooks.layout.trigger(view, this);
  			}.bind(this))
  			.then(function(){
  				return view.display();
  			}.bind(this))
  			.then(function(){
  				return this.hooks.render.trigger(view, this);
  			}.bind(this))
  			.then(function(){
  				if(show !== false) {
  					this.q.enqueue(function(view){
  						view.show();
  					}, view);
  				}
  				// this.map = new Map(view, this.layout);
  				this.hooks.show.trigger(view, this);
  				this.trigger("rendered", view.section);
  
  			}.bind(this))
  			.catch(function(e){
  				this.trigger("loaderror", e);
  			}.bind(this));
  
  	}
  	*/
  /**
   * Report what section has been displayed
   * @private
   * @param  {*} view
   */
  afterDisplayed(e) {
    e.on(Re.VIEWS.MARK_CLICKED, (n, r) => this.triggerMarkEvent(n, r, e.contents)), this.hooks.render.trigger(e, this).then(() => {
      e.contents ? this.hooks.content.trigger(e.contents, this).then(() => {
        this.emit(Re.RENDITION.RENDERED, e.section, e);
      }) : this.emit(Re.RENDITION.RENDERED, e.section, e);
    });
  }
  /**
   * Report what has been removed
   * @private
   * @param  {*} view
   */
  afterRemoved(e) {
    this.hooks.unloaded.trigger(e, this).then(() => {
      this.emit(Re.RENDITION.REMOVED, e.section, e);
    });
  }
  /**
   * Report resize events and display the last seen location
   * @private
   */
  onResized(e, n) {
    this.emit(Re.RENDITION.RESIZED, {
      width: e.width,
      height: e.height
    }, n), this.location && this.location.start && this.display(n || this.location.start.cfi);
  }
  /**
   * Report orientation events and display the last seen location
   * @private
   */
  onOrientationChange(e) {
    this.emit(Re.RENDITION.ORIENTATION_CHANGE, e);
  }
  /**
   * Move the Rendition to a specific offset
   * Usually you would be better off calling display()
   * @param {object} offset
   */
  moveTo(e) {
    this.manager.moveTo(e);
  }
  /**
   * Trigger a resize of the views
   * @param {number} [width]
   * @param {number} [height]
   * @param {string} [epubcfi] (optional)
   */
  resize(e, n, r) {
    e && (this.settings.width = e), n && (this.settings.height = n), this.manager.resize(e, n, r);
  }
  /**
   * Clear all rendered views
   */
  clear() {
    this.manager.clear();
  }
  /**
   * Go to the next "page" in the rendition
   * @return {Promise}
   */
  next() {
    return this.q.enqueue(this.manager.next.bind(this.manager)).then(this.reportLocation.bind(this));
  }
  /**
   * Go to the previous "page" in the rendition
   * @return {Promise}
   */
  prev() {
    return this.q.enqueue(this.manager.prev.bind(this.manager)).then(this.reportLocation.bind(this));
  }
  //-- http://www.idpf.org/epub/301/spec/epub-publications.html#meta-properties-rendering
  /**
   * Determine the Layout properties from metadata and settings
   * @private
   * @param  {object} metadata
   * @return {object} properties
   */
  determineLayoutProperties(e) {
    var n, r = this.settings.layout || e.layout || "reflowable", i = this.settings.spread || e.spread || "auto", s = this.settings.orientation || e.orientation || "auto", o = this.settings.flow || e.flow || "auto", a = e.viewport || "", l = this.settings.minSpreadWidth || e.minSpreadWidth || 800, u = this.settings.direction || e.direction || "ltr";
    return (this.settings.width === 0 || this.settings.width > 0) && (this.settings.height === 0 || this.settings.height > 0), n = {
      layout: r,
      spread: i,
      orientation: s,
      flow: o,
      viewport: a,
      minSpreadWidth: l,
      direction: u
    }, n;
  }
  /**
   * Adjust the flow of the rendition to paginated or scrolled
   * (scrolled-continuous vs scrolled-doc are handled by different view managers)
   * @param  {string} flow
   */
  flow(e) {
    var n = e;
    (e === "scrolled" || e === "scrolled-doc" || e === "scrolled-continuous") && (n = "scrolled"), (e === "auto" || e === "paginated") && (n = "paginated"), this.settings.flow = e, this._layout && this._layout.flow(n), this.manager && this._layout && this.manager.applyLayout(this._layout), this.manager && this.manager.updateFlow(n), this.manager && this.manager.isRendered() && this.location && (this.manager.clear(), this.display(this.location.start.cfi));
  }
  /**
   * Adjust the layout of the rendition to reflowable or pre-paginated
   * @param  {object} settings
   */
  layout(e) {
    return e && (this._layout = new yy(e), this._layout.spread(e.spread, this.settings.minSpreadWidth), this._layout.on(Re.LAYOUT.UPDATED, (n, r) => {
      this.emit(Re.RENDITION.LAYOUT, n, r);
    })), this.manager && this._layout && this.manager.applyLayout(this._layout), this._layout;
  }
  /**
   * Adjust if the rendition uses spreads
   * @param  {string} spread none | auto (TODO: implement landscape, portrait, both)
   * @param  {int} [min] min width to use spreads at
   */
  spread(e, n) {
    this.settings.spread = e, n && (this.settings.minSpreadWidth = n), this._layout && this._layout.spread(e, n), this.manager && this.manager.isRendered() && this.manager.updateLayout();
  }
  /**
   * Adjust the direction of the rendition
   * @param  {string} dir
   */
  direction(e) {
    this.settings.direction = e || "ltr", this.manager && this.manager.direction(this.settings.direction), this.manager && this.manager.isRendered() && this.location && (this.manager.clear(), this.display(this.location.start.cfi));
  }
  /**
   * Report the current location
   * @fires relocated
   * @fires locationChanged
   */
  reportLocation() {
    return this.q.enqueue(function() {
      requestAnimationFrame(function() {
        var r = this.manager.currentLocation();
        if (r && r.then && typeof r.then == "function")
          r.then(function(i) {
            let s = this.located(i);
            !s || !s.start || !s.end || (this.location = s, this.emit(Re.RENDITION.LOCATION_CHANGED, {
              index: this.location.start.index,
              href: this.location.start.href,
              start: this.location.start.cfi,
              end: this.location.end.cfi,
              percentage: this.location.start.percentage
            }), this.emit(Re.RENDITION.RELOCATED, this.location));
          }.bind(this));
        else if (r) {
          let i = this.located(r);
          if (!i || !i.start || !i.end)
            return;
          this.location = i, this.emit(Re.RENDITION.LOCATION_CHANGED, {
            index: this.location.start.index,
            href: this.location.start.href,
            start: this.location.start.cfi,
            end: this.location.end.cfi,
            percentage: this.location.start.percentage
          }), this.emit(Re.RENDITION.RELOCATED, this.location);
        }
      }.bind(this));
    }.bind(this));
  }
  /**
   * Get the Current Location object
   * @return {displayedLocation | promise} location (may be a promise)
   */
  currentLocation() {
    var e = this.manager.currentLocation();
    if (e && e.then && typeof e.then == "function")
      e.then(function(n) {
        return this.located(n);
      }.bind(this));
    else if (e)
      return this.located(e);
  }
  /**
   * Creates a Rendition#locationRange from location
   * passed by the Manager
   * @returns {displayedLocation}
   * @private
   */
  located(e) {
    if (!e.length)
      return {};
    let n = e[0], r = e[e.length - 1], i = {
      start: {
        index: n.index,
        href: n.href,
        cfi: n.mapping.start,
        displayed: {
          page: n.pages[0] || 1,
          total: n.totalPages
        }
      },
      end: {
        index: r.index,
        href: r.href,
        cfi: r.mapping.end,
        displayed: {
          page: r.pages[r.pages.length - 1] || 1,
          total: r.totalPages
        }
      }
    }, s = this.book.locations.locationFromCfi(n.mapping.start), o = this.book.locations.locationFromCfi(r.mapping.end);
    s != null && (i.start.location = s, i.start.percentage = this.book.locations.percentageFromLocation(s)), o != null && (i.end.location = o, i.end.percentage = this.book.locations.percentageFromLocation(o));
    let a = this.book.pageList.pageFromCfi(n.mapping.start), l = this.book.pageList.pageFromCfi(r.mapping.end);
    return a != -1 && (i.start.page = a), l != -1 && (i.end.page = l), r.index === this.book.spine.last().index && i.end.displayed.page >= i.end.displayed.total && (i.atEnd = !0), n.index === this.book.spine.first().index && i.start.displayed.page === 1 && (i.atStart = !0), i;
  }
  /**
   * Remove and Clean Up the Rendition
   */
  destroy() {
    this.manager && this.manager.destroy(), this.book = void 0;
  }
  /**
   * Pass the events from a view's Contents
   * @private
   * @param  {Contents} view contents
   */
  passEvents(e) {
    tl.forEach((n) => {
      e.on(n, (r) => this.triggerViewEvent(r, e));
    }), e.on(Re.CONTENTS.SELECTED, (n) => this.triggerSelectedEvent(n, e));
  }
  /**
   * Emit events passed by a view
   * @private
   * @param  {event} e
   */
  triggerViewEvent(e, n) {
    this.emit(e.type, e, n);
  }
  /**
   * Emit a selection event's CFI Range passed from a a view
   * @private
   * @param  {string} cfirange
   */
  triggerSelectedEvent(e, n) {
    this.emit(Re.RENDITION.SELECTED, e, n);
  }
  /**
   * Emit a markClicked event with the cfiRange and data from a mark
   * @private
   * @param  {EpubCFI} cfirange
   */
  triggerMarkEvent(e, n, r) {
    this.emit(Re.RENDITION.MARK_CLICKED, e, n, r);
  }
  /**
   * Get a Range from a Visible CFI
   * @param  {string} cfi EpubCfi String
   * @param  {string} ignoreClass
   * @return {range}
   */
  getRange(e, n) {
    var r = new mt(e), i = this.manager.visible().filter(function(s) {
      if (r.spinePos === s.index)
        return !0;
    });
    if (i.length)
      return i[0].contents.range(r, n);
  }
  /**
   * Hook to adjust images to fit in columns
   * @param  {Contents} contents
   * @private
   */
  adjustImages(e) {
    if (this._layout.name === "pre-paginated")
      return new Promise(function(s) {
        s();
      });
    let n = e.window.getComputedStyle(e.content, null), r = (e.content.offsetHeight - (parseFloat(n.paddingTop) + parseFloat(n.paddingBottom))) * 0.95, i = parseFloat(n.paddingLeft) + parseFloat(n.paddingRight);
    return e.addStylesheetRules({
      img: {
        "max-width": (this._layout.columnWidth ? this._layout.columnWidth - i + "px" : "100%") + "!important",
        "max-height": r + "px!important",
        "object-fit": "contain",
        "page-break-inside": "avoid",
        "break-inside": "avoid",
        "box-sizing": "border-box"
      },
      svg: {
        "max-width": (this._layout.columnWidth ? this._layout.columnWidth - i + "px" : "100%") + "!important",
        "max-height": r + "px!important",
        "page-break-inside": "avoid",
        "break-inside": "avoid"
      }
    }), new Promise(function(s, o) {
      setTimeout(function() {
        s();
      }, 1);
    });
  }
  /**
   * Get the Contents object of each rendered view
   * @returns {Contents[]}
   */
  getContents() {
    return this.manager ? this.manager.getContents() : [];
  }
  /**
   * Get the views member from the manager
   * @returns {Views}
   */
  views() {
    return (this.manager ? this.manager.views : void 0) || [];
  }
  /**
   * Hook to handle link clicks in rendered content
   * @param  {Contents} contents
   * @private
   */
  handleLinks(e) {
    e && e.on(Re.CONTENTS.LINK_CLICKED, (n) => {
      let r = this.book.path.relative(n);
      this.display(r);
    });
  }
  /**
   * Hook to handle injecting stylesheet before
   * a Section is serialized
   * @param  {document} doc
   * @param  {Section} section
   * @private
   */
  injectStylesheet(e, n) {
    let r = e.createElement("link");
    r.setAttribute("type", "text/css"), r.setAttribute("rel", "stylesheet"), r.setAttribute("href", this.settings.stylesheet), e.getElementsByTagName("head")[0].appendChild(r);
  }
  /**
   * Hook to handle injecting scripts before
   * a Section is serialized
   * @param  {document} doc
   * @param  {Section} section
   * @private
   */
  injectScript(e, n) {
    let r = e.createElement("script");
    r.setAttribute("type", "text/javascript"), r.setAttribute("src", this.settings.script), r.textContent = " ", e.getElementsByTagName("head")[0].appendChild(r);
  }
  /**
   * Hook to handle the document identifier before
   * a Section is serialized
   * @param  {document} doc
   * @param  {Section} section
   * @private
   */
  injectIdentifier(e, n) {
    let r = this.book.packaging.metadata.identifier, i = e.createElement("meta");
    i.setAttribute("name", "dc.relation.ispartof"), r && i.setAttribute("content", r), e.getElementsByTagName("head")[0].appendChild(i);
  }
}
Br(Lf.prototype);
function gi(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var ad = {}, Z6 = {
  get exports() {
    return ad;
  },
  set exports(t) {
    ad = t;
  }
};
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(t, e) {
  (function(n) {
    t.exports = n();
  })(function() {
    return function n(r, i, s) {
      function o(u, c) {
        if (!i[u]) {
          if (!r[u]) {
            var d = typeof gi == "function" && gi;
            if (!c && d)
              return d(u, !0);
            if (a)
              return a(u, !0);
            var h = new Error("Cannot find module '" + u + "'");
            throw h.code = "MODULE_NOT_FOUND", h;
          }
          var v = i[u] = { exports: {} };
          r[u][0].call(v.exports, function(y) {
            var b = r[u][1][y];
            return o(b || y);
          }, v, v.exports, n, r, i, s);
        }
        return i[u].exports;
      }
      for (var a = typeof gi == "function" && gi, l = 0; l < s.length; l++)
        o(s[l]);
      return o;
    }({ 1: [function(n, r, i) {
      var s = n("./utils"), o = n("./support"), a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      i.encode = function(l) {
        for (var u = [], c, d, h, v, y, b, p, f = 0, m = l.length, g = m, w = s.getTypeOf(l) !== "string"; f < l.length; )
          g = m - f, w ? (c = l[f++], d = f < m ? l[f++] : 0, h = f < m ? l[f++] : 0) : (c = l.charCodeAt(f++), d = f < m ? l.charCodeAt(f++) : 0, h = f < m ? l.charCodeAt(f++) : 0), v = c >> 2, y = (c & 3) << 4 | d >> 4, b = g > 1 ? (d & 15) << 2 | h >> 6 : 64, p = g > 2 ? h & 63 : 64, u.push(a.charAt(v) + a.charAt(y) + a.charAt(b) + a.charAt(p));
        return u.join("");
      }, i.decode = function(l) {
        var u, c, d, h, v, y, b, p = 0, f = 0, m = "data:";
        if (l.substr(0, m.length) === m)
          throw new Error("Invalid base64 input, it looks like a data url.");
        l = l.replace(/[^A-Za-z0-9+/=]/g, "");
        var g = l.length * 3 / 4;
        if (l.charAt(l.length - 1) === a.charAt(64) && g--, l.charAt(l.length - 2) === a.charAt(64) && g--, g % 1 !== 0)
          throw new Error("Invalid base64 input, bad content length.");
        var w;
        for (o.uint8array ? w = new Uint8Array(g | 0) : w = new Array(g | 0); p < l.length; )
          h = a.indexOf(l.charAt(p++)), v = a.indexOf(l.charAt(p++)), y = a.indexOf(l.charAt(p++)), b = a.indexOf(l.charAt(p++)), u = h << 2 | v >> 4, c = (v & 15) << 4 | y >> 2, d = (y & 3) << 6 | b, w[f++] = u, y !== 64 && (w[f++] = c), b !== 64 && (w[f++] = d);
        return w;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(n, r, i) {
      var s = n("./external"), o = n("./stream/DataWorker"), a = n("./stream/Crc32Probe"), l = n("./stream/DataLengthProbe");
      function u(c, d, h, v, y) {
        this.compressedSize = c, this.uncompressedSize = d, this.crc32 = h, this.compression = v, this.compressedContent = y;
      }
      u.prototype = {
        /**
         * Create a worker to get the uncompressed content.
         * @return {GenericWorker} the worker.
         */
        getContentWorker: function() {
          var c = new o(s.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new l("data_length")), d = this;
          return c.on("end", function() {
            if (this.streamInfo.data_length !== d.uncompressedSize)
              throw new Error("Bug : uncompressed data size mismatch");
          }), c;
        },
        /**
         * Create a worker to get the compressed content.
         * @return {GenericWorker} the worker.
         */
        getCompressedWorker: function() {
          return new o(s.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        }
      }, u.createWorkerFrom = function(c, d, h) {
        return c.pipe(new a()).pipe(new l("uncompressedSize")).pipe(d.compressWorker(h)).pipe(new l("compressedSize")).withStreamInfo("compression", d);
      }, r.exports = u;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(n, r, i) {
      var s = n("./stream/GenericWorker");
      i.STORE = {
        magic: "\0\0",
        compressWorker: function() {
          return new s("STORE compression");
        },
        uncompressWorker: function() {
          return new s("STORE decompression");
        }
      }, i.DEFLATE = n("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(n, r, i) {
      var s = n("./utils");
      function o() {
        for (var c, d = [], h = 0; h < 256; h++) {
          c = h;
          for (var v = 0; v < 8; v++)
            c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
          d[h] = c;
        }
        return d;
      }
      var a = o();
      function l(c, d, h, v) {
        var y = a, b = v + h;
        c = c ^ -1;
        for (var p = v; p < b; p++)
          c = c >>> 8 ^ y[(c ^ d[p]) & 255];
        return c ^ -1;
      }
      function u(c, d, h, v) {
        var y = a, b = v + h;
        c = c ^ -1;
        for (var p = v; p < b; p++)
          c = c >>> 8 ^ y[(c ^ d.charCodeAt(p)) & 255];
        return c ^ -1;
      }
      r.exports = function(d, h) {
        if (typeof d > "u" || !d.length)
          return 0;
        var v = s.getTypeOf(d) !== "string";
        return v ? l(h | 0, d, d.length, 0) : u(h | 0, d, d.length, 0);
      };
    }, { "./utils": 32 }], 5: [function(n, r, i) {
      i.base64 = !1, i.binary = !1, i.dir = !1, i.createFolders = !0, i.date = null, i.compression = null, i.compressionOptions = null, i.comment = null, i.unixPermissions = null, i.dosPermissions = null;
    }, {}], 6: [function(n, r, i) {
      var s = null;
      typeof Promise < "u" ? s = Promise : s = n("lie"), r.exports = {
        Promise: s
      };
    }, { lie: 37 }], 7: [function(n, r, i) {
      var s = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", o = n("pako"), a = n("./utils"), l = n("./stream/GenericWorker"), u = s ? "uint8array" : "array";
      i.magic = "\b\0";
      function c(d, h) {
        l.call(this, "FlateWorker/" + d), this._pako = null, this._pakoAction = d, this._pakoOptions = h, this.meta = {};
      }
      a.inherits(c, l), c.prototype.processChunk = function(d) {
        this.meta = d.meta, this._pako === null && this._createPako(), this._pako.push(a.transformTo(u, d.data), !1);
      }, c.prototype.flush = function() {
        l.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, c.prototype.cleanUp = function() {
        l.prototype.cleanUp.call(this), this._pako = null;
      }, c.prototype._createPako = function() {
        this._pako = new o[this._pakoAction]({
          raw: !0,
          level: this._pakoOptions.level || -1
          // default compression
        });
        var d = this;
        this._pako.onData = function(h) {
          d.push({
            data: h,
            meta: d.meta
          });
        };
      }, i.compressWorker = function(d) {
        return new c("Deflate", d);
      }, i.uncompressWorker = function() {
        return new c("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(n, r, i) {
      var s = n("../utils"), o = n("../stream/GenericWorker"), a = n("../utf8"), l = n("../crc32"), u = n("../signature"), c = function(f, m) {
        var g = "", w;
        for (w = 0; w < m; w++)
          g += String.fromCharCode(f & 255), f = f >>> 8;
        return g;
      }, d = function(f, m) {
        var g = f;
        return f || (g = m ? 16893 : 33204), (g & 65535) << 16;
      }, h = function(f) {
        return (f || 0) & 63;
      }, v = function(f, m, g, w, _, E) {
        var C = f.file, T = f.compression, k = E !== a.utf8encode, N = s.transformTo("string", E(C.name)), I = s.transformTo("string", a.utf8encode(C.name)), P = C.comment, D = s.transformTo("string", E(P)), z = s.transformTo("string", a.utf8encode(P)), G = I.length !== C.name.length, J = z.length !== P.length, M, U, j = "", re = "", fe = "", Y = C.dir, le = C.date, ce = {
          crc32: 0,
          compressedSize: 0,
          uncompressedSize: 0
        };
        (!m || g) && (ce.crc32 = f.crc32, ce.compressedSize = f.compressedSize, ce.uncompressedSize = f.uncompressedSize);
        var me = 0;
        m && (me |= 8), !k && (G || J) && (me |= 2048);
        var _e = 0, ze = 0;
        Y && (_e |= 16), _ === "UNIX" ? (ze = 798, _e |= d(C.unixPermissions, Y)) : (ze = 20, _e |= h(C.dosPermissions)), M = le.getUTCHours(), M = M << 6, M = M | le.getUTCMinutes(), M = M << 5, M = M | le.getUTCSeconds() / 2, U = le.getUTCFullYear() - 1980, U = U << 4, U = U | le.getUTCMonth() + 1, U = U << 5, U = U | le.getUTCDate(), G && (re = // Version
        c(1, 1) + // NameCRC32
        c(l(N), 4) + // UnicodeName
        I, j += // Info-ZIP Unicode Path Extra Field
        "up" + // size
        c(re.length, 2) + // content
        re), J && (fe = // Version
        c(1, 1) + // CommentCRC32
        c(l(D), 4) + // UnicodeName
        z, j += // Info-ZIP Unicode Path Extra Field
        "uc" + // size
        c(fe.length, 2) + // content
        fe);
        var Oe = "";
        Oe += `
\0`, Oe += c(me, 2), Oe += T.magic, Oe += c(M, 2), Oe += c(U, 2), Oe += c(ce.crc32, 4), Oe += c(ce.compressedSize, 4), Oe += c(ce.uncompressedSize, 4), Oe += c(N.length, 2), Oe += c(j.length, 2);
        var Qe = u.LOCAL_FILE_HEADER + Oe + N + j, Be = u.CENTRAL_FILE_HEADER + // version made by (00: DOS)
        c(ze, 2) + // file header (common to file and central directory)
        Oe + // file comment length
        c(D.length, 2) + // disk number start
        "\0\0\0\0" + // external file attributes
        c(_e, 4) + // relative offset of local header
        c(w, 4) + // file name
        N + // extra field
        j + // file comment
        D;
        return {
          fileRecord: Qe,
          dirRecord: Be
        };
      }, y = function(f, m, g, w, _) {
        var E = "", C = s.transformTo("string", _(w));
        return E = u.CENTRAL_DIRECTORY_END + // number of this disk
        "\0\0\0\0" + // total number of entries in the central directory on this disk
        c(f, 2) + // total number of entries in the central directory
        c(f, 2) + // size of the central directory   4 bytes
        c(m, 4) + // offset of start of central directory with respect to the starting disk number
        c(g, 4) + // .ZIP file comment length
        c(C.length, 2) + // .ZIP file comment
        C, E;
      }, b = function(f) {
        var m = "";
        return m = u.DATA_DESCRIPTOR + // crc-32                          4 bytes
        c(f.crc32, 4) + // compressed size                 4 bytes
        c(f.compressedSize, 4) + // uncompressed size               4 bytes
        c(f.uncompressedSize, 4), m;
      };
      function p(f, m, g, w) {
        o.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = m, this.zipPlatform = g, this.encodeFileName = w, this.streamFiles = f, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      s.inherits(p, o), p.prototype.push = function(f) {
        var m = f.meta.percent || 0, g = this.entriesCount, w = this._sources.length;
        this.accumulate ? this.contentBuffer.push(f) : (this.bytesWritten += f.data.length, o.prototype.push.call(this, {
          data: f.data,
          meta: {
            currentFile: this.currentFile,
            percent: g ? (m + 100 * (g - w - 1)) / g : 100
          }
        }));
      }, p.prototype.openedSource = function(f) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = f.file.name;
        var m = this.streamFiles && !f.file.dir;
        if (m) {
          var g = v(f, m, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({
            data: g.fileRecord,
            meta: { percent: 0 }
          });
        } else
          this.accumulate = !0;
      }, p.prototype.closedSource = function(f) {
        this.accumulate = !1;
        var m = this.streamFiles && !f.file.dir, g = v(f, m, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(g.dirRecord), m)
          this.push({
            data: b(f),
            meta: { percent: 100 }
          });
        else
          for (this.push({
            data: g.fileRecord,
            meta: { percent: 0 }
          }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, p.prototype.flush = function() {
        for (var f = this.bytesWritten, m = 0; m < this.dirRecords.length; m++)
          this.push({
            data: this.dirRecords[m],
            meta: { percent: 100 }
          });
        var g = this.bytesWritten - f, w = y(this.dirRecords.length, g, f, this.zipComment, this.encodeFileName);
        this.push({
          data: w,
          meta: { percent: 100 }
        });
      }, p.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, p.prototype.registerPrevious = function(f) {
        this._sources.push(f);
        var m = this;
        return f.on("data", function(g) {
          m.processChunk(g);
        }), f.on("end", function() {
          m.closedSource(m.previous.streamInfo), m._sources.length ? m.prepareNextSource() : m.end();
        }), f.on("error", function(g) {
          m.error(g);
        }), this;
      }, p.prototype.resume = function() {
        if (!o.prototype.resume.call(this))
          return !1;
        if (!this.previous && this._sources.length)
          return this.prepareNextSource(), !0;
        if (!this.previous && !this._sources.length && !this.generatedError)
          return this.end(), !0;
      }, p.prototype.error = function(f) {
        var m = this._sources;
        if (!o.prototype.error.call(this, f))
          return !1;
        for (var g = 0; g < m.length; g++)
          try {
            m[g].error(f);
          } catch {
          }
        return !0;
      }, p.prototype.lock = function() {
        o.prototype.lock.call(this);
        for (var f = this._sources, m = 0; m < f.length; m++)
          f[m].lock();
      }, r.exports = p;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(n, r, i) {
      var s = n("../compressions"), o = n("./ZipFileWorker"), a = function(l, u) {
        var c = l || u, d = s[c];
        if (!d)
          throw new Error(c + " is not a valid compression method !");
        return d;
      };
      i.generateWorker = function(l, u, c) {
        var d = new o(u.streamFiles, c, u.platform, u.encodeFileName), h = 0;
        try {
          l.forEach(function(v, y) {
            h++;
            var b = a(y.options.compression, u.compression), p = y.options.compressionOptions || u.compressionOptions || {}, f = y.dir, m = y.date;
            y._compressWorker(b, p).withStreamInfo("file", {
              name: v,
              dir: f,
              date: m,
              comment: y.comment || "",
              unixPermissions: y.unixPermissions,
              dosPermissions: y.dosPermissions
            }).pipe(d);
          }), d.entriesCount = h;
        } catch (v) {
          d.error(v);
        }
        return d;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(n, r, i) {
      function s() {
        if (!(this instanceof s))
          return new s();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var o = new s();
          for (var a in this)
            typeof this[a] != "function" && (o[a] = this[a]);
          return o;
        };
      }
      s.prototype = n("./object"), s.prototype.loadAsync = n("./load"), s.support = n("./support"), s.defaults = n("./defaults"), s.version = "3.10.1", s.loadAsync = function(o, a) {
        return new s().loadAsync(o, a);
      }, s.external = n("./external"), r.exports = s;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(n, r, i) {
      var s = n("./utils"), o = n("./external"), a = n("./utf8"), l = n("./zipEntries"), u = n("./stream/Crc32Probe"), c = n("./nodejsUtils");
      function d(h) {
        return new o.Promise(function(v, y) {
          var b = h.decompressed.getContentWorker().pipe(new u());
          b.on("error", function(p) {
            y(p);
          }).on("end", function() {
            b.streamInfo.crc32 !== h.decompressed.crc32 ? y(new Error("Corrupted zip : CRC32 mismatch")) : v();
          }).resume();
        });
      }
      r.exports = function(h, v) {
        var y = this;
        return v = s.extend(v || {}, {
          base64: !1,
          checkCRC32: !1,
          optimizedBinaryString: !1,
          createFolders: !1,
          decodeFileName: a.utf8decode
        }), c.isNode && c.isStream(h) ? o.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : s.prepareContent("the loaded zip file", h, !0, v.optimizedBinaryString, v.base64).then(function(b) {
          var p = new l(v);
          return p.load(b), p;
        }).then(function(p) {
          var f = [o.Promise.resolve(p)], m = p.files;
          if (v.checkCRC32)
            for (var g = 0; g < m.length; g++)
              f.push(d(m[g]));
          return o.Promise.all(f);
        }).then(function(p) {
          for (var f = p.shift(), m = f.files, g = 0; g < m.length; g++) {
            var w = m[g], _ = w.fileNameStr, E = s.resolve(w.fileNameStr);
            y.file(E, w.decompressed, {
              binary: !0,
              optimizedBinaryString: !0,
              date: w.date,
              dir: w.dir,
              comment: w.fileCommentStr.length ? w.fileCommentStr : null,
              unixPermissions: w.unixPermissions,
              dosPermissions: w.dosPermissions,
              createFolders: v.createFolders
            }), w.dir || (y.file(E).unsafeOriginalName = _);
          }
          return f.zipComment.length && (y.comment = f.zipComment), y;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(n, r, i) {
      var s = n("../utils"), o = n("../stream/GenericWorker");
      function a(l, u) {
        o.call(this, "Nodejs stream input adapter for " + l), this._upstreamEnded = !1, this._bindStream(u);
      }
      s.inherits(a, o), a.prototype._bindStream = function(l) {
        var u = this;
        this._stream = l, l.pause(), l.on("data", function(c) {
          u.push({
            data: c,
            meta: {
              percent: 0
            }
          });
        }).on("error", function(c) {
          u.isPaused ? this.generatedError = c : u.error(c);
        }).on("end", function() {
          u.isPaused ? u._upstreamEnded = !0 : u.end();
        });
      }, a.prototype.pause = function() {
        return o.prototype.pause.call(this) ? (this._stream.pause(), !0) : !1;
      }, a.prototype.resume = function() {
        return o.prototype.resume.call(this) ? (this._upstreamEnded ? this.end() : this._stream.resume(), !0) : !1;
      }, r.exports = a;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(n, r, i) {
      var s = n("readable-stream").Readable, o = n("../utils");
      o.inherits(a, s);
      function a(l, u, c) {
        s.call(this, u), this._helper = l;
        var d = this;
        l.on("data", function(h, v) {
          d.push(h) || d._helper.pause(), c && c(v);
        }).on("error", function(h) {
          d.emit("error", h);
        }).on("end", function() {
          d.push(null);
        });
      }
      a.prototype._read = function() {
        this._helper.resume();
      }, r.exports = a;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(n, r, i) {
      r.exports = {
        /**
         * True if this is running in Nodejs, will be undefined in a browser.
         * In a browser, browserify won't include this file and the whole module
         * will be resolved an empty object.
         */
        isNode: typeof Buffer < "u",
        /**
         * Create a new nodejs Buffer from an existing content.
         * @param {Object} data the data to pass to the constructor.
         * @param {String} encoding the encoding to use.
         * @return {Buffer} a new Buffer.
         */
        newBufferFrom: function(s, o) {
          if (Buffer.from && Buffer.from !== Uint8Array.from)
            return Buffer.from(s, o);
          if (typeof s == "number")
            throw new Error('The "data" argument must not be a number');
          return new Buffer(s, o);
        },
        /**
         * Create a new nodejs Buffer with the specified size.
         * @param {Integer} size the size of the buffer.
         * @return {Buffer} a new Buffer.
         */
        allocBuffer: function(s) {
          if (Buffer.alloc)
            return Buffer.alloc(s);
          var o = new Buffer(s);
          return o.fill(0), o;
        },
        /**
         * Find out if an object is a Buffer.
         * @param {Object} b the object to test.
         * @return {Boolean} true if the object is a Buffer, false otherwise.
         */
        isBuffer: function(s) {
          return Buffer.isBuffer(s);
        },
        isStream: function(s) {
          return s && typeof s.on == "function" && typeof s.pause == "function" && typeof s.resume == "function";
        }
      };
    }, {}], 15: [function(n, r, i) {
      var s = n("./utf8"), o = n("./utils"), a = n("./stream/GenericWorker"), l = n("./stream/StreamHelper"), u = n("./defaults"), c = n("./compressedObject"), d = n("./zipObject"), h = n("./generate"), v = n("./nodejsUtils"), y = n("./nodejs/NodejsStreamInputAdapter"), b = function(_, E, C) {
        var T = o.getTypeOf(E), k, N = o.extend(C || {}, u);
        N.date = N.date || /* @__PURE__ */ new Date(), N.compression !== null && (N.compression = N.compression.toUpperCase()), typeof N.unixPermissions == "string" && (N.unixPermissions = parseInt(N.unixPermissions, 8)), N.unixPermissions && N.unixPermissions & 16384 && (N.dir = !0), N.dosPermissions && N.dosPermissions & 16 && (N.dir = !0), N.dir && (_ = f(_)), N.createFolders && (k = p(_)) && m.call(this, k, !0);
        var I = T === "string" && N.binary === !1 && N.base64 === !1;
        (!C || typeof C.binary > "u") && (N.binary = !I);
        var P = E instanceof c && E.uncompressedSize === 0;
        (P || N.dir || !E || E.length === 0) && (N.base64 = !1, N.binary = !0, E = "", N.compression = "STORE", T = "string");
        var D = null;
        E instanceof c || E instanceof a ? D = E : v.isNode && v.isStream(E) ? D = new y(_, E) : D = o.prepareContent(_, E, N.binary, N.optimizedBinaryString, N.base64);
        var z = new d(_, D, N);
        this.files[_] = z;
      }, p = function(_) {
        _.slice(-1) === "/" && (_ = _.substring(0, _.length - 1));
        var E = _.lastIndexOf("/");
        return E > 0 ? _.substring(0, E) : "";
      }, f = function(_) {
        return _.slice(-1) !== "/" && (_ += "/"), _;
      }, m = function(_, E) {
        return E = typeof E < "u" ? E : u.createFolders, _ = f(_), this.files[_] || b.call(this, _, null, {
          dir: !0,
          createFolders: E
        }), this.files[_];
      };
      function g(_) {
        return Object.prototype.toString.call(_) === "[object RegExp]";
      }
      var w = {
        /**
         * @see loadAsync
         */
        load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        },
        /**
         * Call a callback function for each entry at this folder level.
         * @param {Function} cb the callback function:
         * function (relativePath, file) {...}
         * It takes 2 arguments : the relative path and the file.
         */
        forEach: function(_) {
          var E, C, T;
          for (E in this.files)
            T = this.files[E], C = E.slice(this.root.length, E.length), C && E.slice(0, this.root.length) === this.root && _(C, T);
        },
        /**
         * Filter nested files/folders with the specified function.
         * @param {Function} search the predicate to use :
         * function (relativePath, file) {...}
         * It takes 2 arguments : the relative path and the file.
         * @return {Array} An array of matching elements.
         */
        filter: function(_) {
          var E = [];
          return this.forEach(function(C, T) {
            _(C, T) && E.push(T);
          }), E;
        },
        /**
         * Add a file to the zip file, or search a file.
         * @param   {string|RegExp} name The name of the file to add (if data is defined),
         * the name of the file to find (if no data) or a regex to match files.
         * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
         * @param   {Object} o     File options
         * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
         * a file (when searching by string) or an array of files (when searching by regex).
         */
        file: function(_, E, C) {
          if (arguments.length === 1)
            if (g(_)) {
              var T = _;
              return this.filter(function(N, I) {
                return !I.dir && T.test(N);
              });
            } else {
              var k = this.files[this.root + _];
              return k && !k.dir ? k : null;
            }
          else
            _ = this.root + _, b.call(this, _, E, C);
          return this;
        },
        /**
         * Add a directory to the zip file, or search.
         * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
         * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
         */
        folder: function(_) {
          if (!_)
            return this;
          if (g(_))
            return this.filter(function(k, N) {
              return N.dir && _.test(k);
            });
          var E = this.root + _, C = m.call(this, E), T = this.clone();
          return T.root = C.name, T;
        },
        /**
         * Delete a file, or a directory and all sub-files, from the zip
         * @param {string} name the name of the file to delete
         * @return {JSZip} this JSZip object
         */
        remove: function(_) {
          _ = this.root + _;
          var E = this.files[_];
          if (E || (_.slice(-1) !== "/" && (_ += "/"), E = this.files[_]), E && !E.dir)
            delete this.files[_];
          else
            for (var C = this.filter(function(k, N) {
              return N.name.slice(0, _.length) === _;
            }), T = 0; T < C.length; T++)
              delete this.files[C[T].name];
          return this;
        },
        /**
         * @deprecated This method has been removed in JSZip 3.0, please check the upgrade guide.
         */
        generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        },
        /**
         * Generate the complete zip file as an internal stream.
         * @param {Object} options the options to generate the zip file :
         * - compression, "STORE" by default.
         * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
         * @return {StreamHelper} the streamed zip file.
         */
        generateInternalStream: function(_) {
          var E, C = {};
          try {
            if (C = o.extend(_ || {}, {
              streamFiles: !1,
              compression: "STORE",
              compressionOptions: null,
              type: "",
              platform: "DOS",
              comment: null,
              mimeType: "application/zip",
              encodeFileName: s.utf8encode
            }), C.type = C.type.toLowerCase(), C.compression = C.compression.toUpperCase(), C.type === "binarystring" && (C.type = "string"), !C.type)
              throw new Error("No output type specified.");
            o.checkSupport(C.type), (C.platform === "darwin" || C.platform === "freebsd" || C.platform === "linux" || C.platform === "sunos") && (C.platform = "UNIX"), C.platform === "win32" && (C.platform = "DOS");
            var T = C.comment || this.comment || "";
            E = h.generateWorker(this, C, T);
          } catch (k) {
            E = new a("error"), E.error(k);
          }
          return new l(E, C.type || "string", C.mimeType);
        },
        /**
         * Generate the complete zip file asynchronously.
         * @see generateInternalStream
         */
        generateAsync: function(_, E) {
          return this.generateInternalStream(_).accumulate(E);
        },
        /**
         * Generate the complete zip file asynchronously.
         * @see generateInternalStream
         */
        generateNodeStream: function(_, E) {
          return _ = _ || {}, _.type || (_.type = "nodebuffer"), this.generateInternalStream(_).toNodejsStream(E);
        }
      };
      r.exports = w;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(n, r, i) {
      r.exports = n("stream");
    }, { stream: void 0 }], 17: [function(n, r, i) {
      var s = n("./DataReader"), o = n("../utils");
      function a(l) {
        s.call(this, l);
        for (var u = 0; u < this.data.length; u++)
          l[u] = l[u] & 255;
      }
      o.inherits(a, s), a.prototype.byteAt = function(l) {
        return this.data[this.zero + l];
      }, a.prototype.lastIndexOfSignature = function(l) {
        for (var u = l.charCodeAt(0), c = l.charCodeAt(1), d = l.charCodeAt(2), h = l.charCodeAt(3), v = this.length - 4; v >= 0; --v)
          if (this.data[v] === u && this.data[v + 1] === c && this.data[v + 2] === d && this.data[v + 3] === h)
            return v - this.zero;
        return -1;
      }, a.prototype.readAndCheckSignature = function(l) {
        var u = l.charCodeAt(0), c = l.charCodeAt(1), d = l.charCodeAt(2), h = l.charCodeAt(3), v = this.readData(4);
        return u === v[0] && c === v[1] && d === v[2] && h === v[3];
      }, a.prototype.readData = function(l) {
        if (this.checkOffset(l), l === 0)
          return [];
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, u;
      }, r.exports = a;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(n, r, i) {
      var s = n("../utils");
      function o(a) {
        this.data = a, this.length = a.length, this.index = 0, this.zero = 0;
      }
      o.prototype = {
        /**
         * Check that the offset will not go too far.
         * @param {string} offset the additional offset to check.
         * @throws {Error} an Error if the offset is out of bounds.
         */
        checkOffset: function(a) {
          this.checkIndex(this.index + a);
        },
        /**
         * Check that the specified index will not be too far.
         * @param {string} newIndex the index to check.
         * @throws {Error} an Error if the index is out of bounds.
         */
        checkIndex: function(a) {
          if (this.length < this.zero + a || a < 0)
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + a + "). Corrupted zip ?");
        },
        /**
         * Change the index.
         * @param {number} newIndex The new index.
         * @throws {Error} if the new index is out of the data.
         */
        setIndex: function(a) {
          this.checkIndex(a), this.index = a;
        },
        /**
         * Skip the next n bytes.
         * @param {number} n the number of bytes to skip.
         * @throws {Error} if the new index is out of the data.
         */
        skip: function(a) {
          this.setIndex(this.index + a);
        },
        /**
         * Get the byte at the specified index.
         * @param {number} i the index to use.
         * @return {number} a byte.
         */
        byteAt: function() {
        },
        /**
         * Get the next number with a given byte size.
         * @param {number} size the number of bytes to read.
         * @return {number} the corresponding number.
         */
        readInt: function(a) {
          var l = 0, u;
          for (this.checkOffset(a), u = this.index + a - 1; u >= this.index; u--)
            l = (l << 8) + this.byteAt(u);
          return this.index += a, l;
        },
        /**
         * Get the next string with a given byte size.
         * @param {number} size the number of bytes to read.
         * @return {string} the corresponding string.
         */
        readString: function(a) {
          return s.transformTo("string", this.readData(a));
        },
        /**
         * Get raw data without conversion, <size> bytes.
         * @param {number} size the number of bytes to read.
         * @return {Object} the raw data, implementation specific.
         */
        readData: function() {
        },
        /**
         * Find the last occurrence of a zip signature (4 bytes).
         * @param {string} sig the signature to find.
         * @return {number} the index of the last occurrence, -1 if not found.
         */
        lastIndexOfSignature: function() {
        },
        /**
         * Read the signature (4 bytes) at the current position and compare it with sig.
         * @param {string} sig the expected signature
         * @return {boolean} true if the signature matches, false otherwise.
         */
        readAndCheckSignature: function() {
        },
        /**
         * Get the next date.
         * @return {Date} the date.
         */
        readDate: function() {
          var a = this.readInt(4);
          return new Date(Date.UTC(
            (a >> 25 & 127) + 1980,
            // year
            (a >> 21 & 15) - 1,
            // month
            a >> 16 & 31,
            // day
            a >> 11 & 31,
            // hour
            a >> 5 & 63,
            // minute
            (a & 31) << 1
          ));
        }
      }, r.exports = o;
    }, { "../utils": 32 }], 19: [function(n, r, i) {
      var s = n("./Uint8ArrayReader"), o = n("../utils");
      function a(l) {
        s.call(this, l);
      }
      o.inherits(a, s), a.prototype.readData = function(l) {
        this.checkOffset(l);
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, u;
      }, r.exports = a;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(n, r, i) {
      var s = n("./DataReader"), o = n("../utils");
      function a(l) {
        s.call(this, l);
      }
      o.inherits(a, s), a.prototype.byteAt = function(l) {
        return this.data.charCodeAt(this.zero + l);
      }, a.prototype.lastIndexOfSignature = function(l) {
        return this.data.lastIndexOf(l) - this.zero;
      }, a.prototype.readAndCheckSignature = function(l) {
        var u = this.readData(4);
        return l === u;
      }, a.prototype.readData = function(l) {
        this.checkOffset(l);
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, u;
      }, r.exports = a;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(n, r, i) {
      var s = n("./ArrayReader"), o = n("../utils");
      function a(l) {
        s.call(this, l);
      }
      o.inherits(a, s), a.prototype.readData = function(l) {
        if (this.checkOffset(l), l === 0)
          return new Uint8Array(0);
        var u = this.data.subarray(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, u;
      }, r.exports = a;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(n, r, i) {
      var s = n("../utils"), o = n("../support"), a = n("./ArrayReader"), l = n("./StringReader"), u = n("./NodeBufferReader"), c = n("./Uint8ArrayReader");
      r.exports = function(d) {
        var h = s.getTypeOf(d);
        return s.checkSupport(h), h === "string" && !o.uint8array ? new l(d) : h === "nodebuffer" ? new u(d) : o.uint8array ? new c(s.transformTo("uint8array", d)) : new a(s.transformTo("array", d));
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(n, r, i) {
      i.LOCAL_FILE_HEADER = "PK", i.CENTRAL_FILE_HEADER = "PK", i.CENTRAL_DIRECTORY_END = "PK", i.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", i.ZIP64_CENTRAL_DIRECTORY_END = "PK", i.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(n, r, i) {
      var s = n("./GenericWorker"), o = n("../utils");
      function a(l) {
        s.call(this, "ConvertWorker to " + l), this.destType = l;
      }
      o.inherits(a, s), a.prototype.processChunk = function(l) {
        this.push({
          data: o.transformTo(this.destType, l.data),
          meta: l.meta
        });
      }, r.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(n, r, i) {
      var s = n("./GenericWorker"), o = n("../crc32"), a = n("../utils");
      function l() {
        s.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      a.inherits(l, s), l.prototype.processChunk = function(u) {
        this.streamInfo.crc32 = o(u.data, this.streamInfo.crc32 || 0), this.push(u);
      }, r.exports = l;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(n, r, i) {
      var s = n("../utils"), o = n("./GenericWorker");
      function a(l) {
        o.call(this, "DataLengthProbe for " + l), this.propName = l, this.withStreamInfo(l, 0);
      }
      s.inherits(a, o), a.prototype.processChunk = function(l) {
        if (l) {
          var u = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = u + l.data.length;
        }
        o.prototype.processChunk.call(this, l);
      }, r.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(n, r, i) {
      var s = n("../utils"), o = n("./GenericWorker"), a = 16 * 1024;
      function l(u) {
        o.call(this, "DataWorker");
        var c = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, u.then(function(d) {
          c.dataIsReady = !0, c.data = d, c.max = d && d.length || 0, c.type = s.getTypeOf(d), c.isPaused || c._tickAndRepeat();
        }, function(d) {
          c.error(d);
        });
      }
      s.inherits(l, o), l.prototype.cleanUp = function() {
        o.prototype.cleanUp.call(this), this.data = null;
      }, l.prototype.resume = function() {
        return o.prototype.resume.call(this) ? (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, s.delay(this._tickAndRepeat, [], this)), !0) : !1;
      }, l.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, !(this.isPaused || this.isFinished) && (this._tick(), this.isFinished || (s.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, l.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return !1;
        var u = a, c = null, d = Math.min(this.max, this.index + u);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            c = this.data.substring(this.index, d);
            break;
          case "uint8array":
            c = this.data.subarray(this.index, d);
            break;
          case "array":
          case "nodebuffer":
            c = this.data.slice(this.index, d);
            break;
        }
        return this.index = d, this.push({
          data: c,
          meta: {
            percent: this.max ? this.index / this.max * 100 : 0
          }
        });
      }, r.exports = l;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(n, r, i) {
      function s(o) {
        this.name = o || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = {
          data: [],
          end: [],
          error: []
        }, this.previous = null;
      }
      s.prototype = {
        /**
         * Push a chunk to the next workers.
         * @param {Object} chunk the chunk to push
         */
        push: function(o) {
          this.emit("data", o);
        },
        /**
         * End the stream.
         * @return {Boolean} true if this call ended the worker, false otherwise.
         */
        end: function() {
          if (this.isFinished)
            return !1;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = !0;
          } catch (o) {
            this.emit("error", o);
          }
          return !0;
        },
        /**
         * End the stream with an error.
         * @param {Error} e the error which caused the premature end.
         * @return {Boolean} true if this call ended the worker with an error, false otherwise.
         */
        error: function(o) {
          return this.isFinished ? !1 : (this.isPaused ? this.generatedError = o : (this.isFinished = !0, this.emit("error", o), this.previous && this.previous.error(o), this.cleanUp()), !0);
        },
        /**
         * Add a callback on an event.
         * @param {String} name the name of the event (data, end, error)
         * @param {Function} listener the function to call when the event is triggered
         * @return {GenericWorker} the current object for chainability
         */
        on: function(o, a) {
          return this._listeners[o].push(a), this;
        },
        /**
         * Clean any references when a worker is ending.
         */
        cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        },
        /**
         * Trigger an event. This will call registered callback with the provided arg.
         * @param {String} name the name of the event (data, end, error)
         * @param {Object} arg the argument to call the callback with.
         */
        emit: function(o, a) {
          if (this._listeners[o])
            for (var l = 0; l < this._listeners[o].length; l++)
              this._listeners[o][l].call(this, a);
        },
        /**
         * Chain a worker with an other.
         * @param {Worker} next the worker receiving events from the current one.
         * @return {worker} the next worker for chainability
         */
        pipe: function(o) {
          return o.registerPrevious(this);
        },
        /**
         * Same as `pipe` in the other direction.
         * Using an API with `pipe(next)` is very easy.
         * Implementing the API with the point of view of the next one registering
         * a source is easier, see the ZipFileWorker.
         * @param {Worker} previous the previous worker, sending events to this one
         * @return {Worker} the current worker for chainability
         */
        registerPrevious: function(o) {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = o.streamInfo, this.mergeStreamInfo(), this.previous = o;
          var a = this;
          return o.on("data", function(l) {
            a.processChunk(l);
          }), o.on("end", function() {
            a.end();
          }), o.on("error", function(l) {
            a.error(l);
          }), this;
        },
        /**
         * Pause the stream so it doesn't send events anymore.
         * @return {Boolean} true if this call paused the worker, false otherwise.
         */
        pause: function() {
          return this.isPaused || this.isFinished ? !1 : (this.isPaused = !0, this.previous && this.previous.pause(), !0);
        },
        /**
         * Resume a paused stream.
         * @return {Boolean} true if this call resumed the worker, false otherwise.
         */
        resume: function() {
          if (!this.isPaused || this.isFinished)
            return !1;
          this.isPaused = !1;
          var o = !1;
          return this.generatedError && (this.error(this.generatedError), o = !0), this.previous && this.previous.resume(), !o;
        },
        /**
         * Flush any remaining bytes as the stream is ending.
         */
        flush: function() {
        },
        /**
         * Process a chunk. This is usually the method overridden.
         * @param {Object} chunk the chunk to process.
         */
        processChunk: function(o) {
          this.push(o);
        },
        /**
         * Add a key/value to be added in the workers chain streamInfo once activated.
         * @param {String} key the key to use
         * @param {Object} value the associated value
         * @return {Worker} the current worker for chainability
         */
        withStreamInfo: function(o, a) {
          return this.extraStreamInfo[o] = a, this.mergeStreamInfo(), this;
        },
        /**
         * Merge this worker's streamInfo into the chain's streamInfo.
         */
        mergeStreamInfo: function() {
          for (var o in this.extraStreamInfo)
            Object.prototype.hasOwnProperty.call(this.extraStreamInfo, o) && (this.streamInfo[o] = this.extraStreamInfo[o]);
        },
        /**
         * Lock the stream to prevent further updates on the workers chain.
         * After calling this method, all calls to pipe will fail.
         */
        lock: function() {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = !0, this.previous && this.previous.lock();
        },
        /**
         *
         * Pretty print the workers chain.
         */
        toString: function() {
          var o = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + o : o;
        }
      }, r.exports = s;
    }, {}], 29: [function(n, r, i) {
      var s = n("../utils"), o = n("./ConvertWorker"), a = n("./GenericWorker"), l = n("../base64"), u = n("../support"), c = n("../external"), d = null;
      if (u.nodestream)
        try {
          d = n("../nodejs/NodejsStreamOutputAdapter");
        } catch {
        }
      function h(p, f, m) {
        switch (p) {
          case "blob":
            return s.newBlob(s.transformTo("arraybuffer", f), m);
          case "base64":
            return l.encode(f);
          default:
            return s.transformTo(p, f);
        }
      }
      function v(p, f) {
        var m, g = 0, w = null, _ = 0;
        for (m = 0; m < f.length; m++)
          _ += f[m].length;
        switch (p) {
          case "string":
            return f.join("");
          case "array":
            return Array.prototype.concat.apply([], f);
          case "uint8array":
            for (w = new Uint8Array(_), m = 0; m < f.length; m++)
              w.set(f[m], g), g += f[m].length;
            return w;
          case "nodebuffer":
            return Buffer.concat(f);
          default:
            throw new Error("concat : unsupported type '" + p + "'");
        }
      }
      function y(p, f) {
        return new c.Promise(function(m, g) {
          var w = [], _ = p._internalType, E = p._outputType, C = p._mimeType;
          p.on("data", function(T, k) {
            w.push(T), f && f(k);
          }).on("error", function(T) {
            w = [], g(T);
          }).on("end", function() {
            try {
              var T = h(E, v(_, w), C);
              m(T);
            } catch (k) {
              g(k);
            }
            w = [];
          }).resume();
        });
      }
      function b(p, f, m) {
        var g = f;
        switch (f) {
          case "blob":
          case "arraybuffer":
            g = "uint8array";
            break;
          case "base64":
            g = "string";
            break;
        }
        try {
          this._internalType = g, this._outputType = f, this._mimeType = m, s.checkSupport(g), this._worker = p.pipe(new o(g)), p.lock();
        } catch (w) {
          this._worker = new a("error"), this._worker.error(w);
        }
      }
      b.prototype = {
        /**
         * Listen a StreamHelper, accumulate its content and concatenate it into a
         * complete block.
         * @param {Function} updateCb the update callback.
         * @return Promise the promise for the accumulation.
         */
        accumulate: function(p) {
          return y(this, p);
        },
        /**
         * Add a listener on an event triggered on a stream.
         * @param {String} evt the name of the event
         * @param {Function} fn the listener
         * @return {StreamHelper} the current helper.
         */
        on: function(p, f) {
          var m = this;
          return p === "data" ? this._worker.on(p, function(g) {
            f.call(m, g.data, g.meta);
          }) : this._worker.on(p, function() {
            s.delay(f, arguments, m);
          }), this;
        },
        /**
         * Resume the flow of chunks.
         * @return {StreamHelper} the current helper.
         */
        resume: function() {
          return s.delay(this._worker.resume, [], this._worker), this;
        },
        /**
         * Pause the flow of chunks.
         * @return {StreamHelper} the current helper.
         */
        pause: function() {
          return this._worker.pause(), this;
        },
        /**
         * Return a nodejs stream for this helper.
         * @param {Function} updateCb the update callback.
         * @return {NodejsStreamOutputAdapter} the nodejs stream.
         */
        toNodejsStream: function(p) {
          if (s.checkSupport("nodestream"), this._outputType !== "nodebuffer")
            throw new Error(this._outputType + " is not supported by this method");
          return new d(this, {
            objectMode: this._outputType !== "nodebuffer"
          }, p);
        }
      }, r.exports = b;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(n, r, i) {
      if (i.base64 = !0, i.array = !0, i.string = !0, i.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", i.nodebuffer = typeof Buffer < "u", i.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u")
        i.blob = !1;
      else {
        var s = new ArrayBuffer(0);
        try {
          i.blob = new Blob([s], {
            type: "application/zip"
          }).size === 0;
        } catch {
          try {
            var o = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder, a = new o();
            a.append(s), i.blob = a.getBlob("application/zip").size === 0;
          } catch {
            i.blob = !1;
          }
        }
      }
      try {
        i.nodestream = !!n("readable-stream").Readable;
      } catch {
        i.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(n, r, i) {
      for (var s = n("./utils"), o = n("./support"), a = n("./nodejsUtils"), l = n("./stream/GenericWorker"), u = new Array(256), c = 0; c < 256; c++)
        u[c] = c >= 252 ? 6 : c >= 248 ? 5 : c >= 240 ? 4 : c >= 224 ? 3 : c >= 192 ? 2 : 1;
      u[254] = u[254] = 1;
      var d = function(p) {
        var f, m, g, w, _, E = p.length, C = 0;
        for (w = 0; w < E; w++)
          m = p.charCodeAt(w), (m & 64512) === 55296 && w + 1 < E && (g = p.charCodeAt(w + 1), (g & 64512) === 56320 && (m = 65536 + (m - 55296 << 10) + (g - 56320), w++)), C += m < 128 ? 1 : m < 2048 ? 2 : m < 65536 ? 3 : 4;
        for (o.uint8array ? f = new Uint8Array(C) : f = new Array(C), _ = 0, w = 0; _ < C; w++)
          m = p.charCodeAt(w), (m & 64512) === 55296 && w + 1 < E && (g = p.charCodeAt(w + 1), (g & 64512) === 56320 && (m = 65536 + (m - 55296 << 10) + (g - 56320), w++)), m < 128 ? f[_++] = m : m < 2048 ? (f[_++] = 192 | m >>> 6, f[_++] = 128 | m & 63) : m < 65536 ? (f[_++] = 224 | m >>> 12, f[_++] = 128 | m >>> 6 & 63, f[_++] = 128 | m & 63) : (f[_++] = 240 | m >>> 18, f[_++] = 128 | m >>> 12 & 63, f[_++] = 128 | m >>> 6 & 63, f[_++] = 128 | m & 63);
        return f;
      }, h = function(p, f) {
        var m;
        for (f = f || p.length, f > p.length && (f = p.length), m = f - 1; m >= 0 && (p[m] & 192) === 128; )
          m--;
        return m < 0 || m === 0 ? f : m + u[p[m]] > f ? m : f;
      }, v = function(p) {
        var f, m, g, w, _ = p.length, E = new Array(_ * 2);
        for (m = 0, f = 0; f < _; ) {
          if (g = p[f++], g < 128) {
            E[m++] = g;
            continue;
          }
          if (w = u[g], w > 4) {
            E[m++] = 65533, f += w - 1;
            continue;
          }
          for (g &= w === 2 ? 31 : w === 3 ? 15 : 7; w > 1 && f < _; )
            g = g << 6 | p[f++] & 63, w--;
          if (w > 1) {
            E[m++] = 65533;
            continue;
          }
          g < 65536 ? E[m++] = g : (g -= 65536, E[m++] = 55296 | g >> 10 & 1023, E[m++] = 56320 | g & 1023);
        }
        return E.length !== m && (E.subarray ? E = E.subarray(0, m) : E.length = m), s.applyFromCharCode(E);
      };
      i.utf8encode = function(f) {
        return o.nodebuffer ? a.newBufferFrom(f, "utf-8") : d(f);
      }, i.utf8decode = function(f) {
        return o.nodebuffer ? s.transformTo("nodebuffer", f).toString("utf-8") : (f = s.transformTo(o.uint8array ? "uint8array" : "array", f), v(f));
      };
      function y() {
        l.call(this, "utf-8 decode"), this.leftOver = null;
      }
      s.inherits(y, l), y.prototype.processChunk = function(p) {
        var f = s.transformTo(o.uint8array ? "uint8array" : "array", p.data);
        if (this.leftOver && this.leftOver.length) {
          if (o.uint8array) {
            var m = f;
            f = new Uint8Array(m.length + this.leftOver.length), f.set(this.leftOver, 0), f.set(m, this.leftOver.length);
          } else
            f = this.leftOver.concat(f);
          this.leftOver = null;
        }
        var g = h(f), w = f;
        g !== f.length && (o.uint8array ? (w = f.subarray(0, g), this.leftOver = f.subarray(g, f.length)) : (w = f.slice(0, g), this.leftOver = f.slice(g, f.length))), this.push({
          data: i.utf8decode(w),
          meta: p.meta
        });
      }, y.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({
          data: i.utf8decode(this.leftOver),
          meta: {}
        }), this.leftOver = null);
      }, i.Utf8DecodeWorker = y;
      function b() {
        l.call(this, "utf-8 encode");
      }
      s.inherits(b, l), b.prototype.processChunk = function(p) {
        this.push({
          data: i.utf8encode(p.data),
          meta: p.meta
        });
      }, i.Utf8EncodeWorker = b;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(n, r, i) {
      var s = n("./support"), o = n("./base64"), a = n("./nodejsUtils"), l = n("./external");
      n("setimmediate");
      function u(p) {
        var f = null;
        return s.uint8array ? f = new Uint8Array(p.length) : f = new Array(p.length), d(p, f);
      }
      i.newBlob = function(p, f) {
        i.checkSupport("blob");
        try {
          return new Blob([p], {
            type: f
          });
        } catch {
          try {
            var m = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder, g = new m();
            return g.append(p), g.getBlob(f);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      function c(p) {
        return p;
      }
      function d(p, f) {
        for (var m = 0; m < p.length; ++m)
          f[m] = p.charCodeAt(m) & 255;
        return f;
      }
      var h = {
        /**
         * Transform an array of int into a string, chunk by chunk.
         * See the performances notes on arrayLikeToString.
         * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
         * @param {String} type the type of the array.
         * @param {Integer} chunk the chunk size.
         * @return {String} the resulting string.
         * @throws Error if the chunk is too big for the stack.
         */
        stringifyByChunk: function(p, f, m) {
          var g = [], w = 0, _ = p.length;
          if (_ <= m)
            return String.fromCharCode.apply(null, p);
          for (; w < _; )
            f === "array" || f === "nodebuffer" ? g.push(String.fromCharCode.apply(null, p.slice(w, Math.min(w + m, _)))) : g.push(String.fromCharCode.apply(null, p.subarray(w, Math.min(w + m, _)))), w += m;
          return g.join("");
        },
        /**
         * Call String.fromCharCode on every item in the array.
         * This is the naive implementation, which generate A LOT of intermediate string.
         * This should be used when everything else fail.
         * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
         * @return {String} the result.
         */
        stringifyByChar: function(p) {
          for (var f = "", m = 0; m < p.length; m++)
            f += String.fromCharCode(p[m]);
          return f;
        },
        applyCanBeUsed: {
          /**
           * true if the browser accepts to use String.fromCharCode on Uint8Array
           */
          uint8array: function() {
            try {
              return s.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
            } catch {
              return !1;
            }
          }(),
          /**
           * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
           */
          nodebuffer: function() {
            try {
              return s.nodebuffer && String.fromCharCode.apply(null, a.allocBuffer(1)).length === 1;
            } catch {
              return !1;
            }
          }()
        }
      };
      function v(p) {
        var f = 65536, m = i.getTypeOf(p), g = !0;
        if (m === "uint8array" ? g = h.applyCanBeUsed.uint8array : m === "nodebuffer" && (g = h.applyCanBeUsed.nodebuffer), g)
          for (; f > 1; )
            try {
              return h.stringifyByChunk(p, m, f);
            } catch {
              f = Math.floor(f / 2);
            }
        return h.stringifyByChar(p);
      }
      i.applyFromCharCode = v;
      function y(p, f) {
        for (var m = 0; m < p.length; m++)
          f[m] = p[m];
        return f;
      }
      var b = {};
      b.string = {
        string: c,
        array: function(p) {
          return d(p, new Array(p.length));
        },
        arraybuffer: function(p) {
          return b.string.uint8array(p).buffer;
        },
        uint8array: function(p) {
          return d(p, new Uint8Array(p.length));
        },
        nodebuffer: function(p) {
          return d(p, a.allocBuffer(p.length));
        }
      }, b.array = {
        string: v,
        array: c,
        arraybuffer: function(p) {
          return new Uint8Array(p).buffer;
        },
        uint8array: function(p) {
          return new Uint8Array(p);
        },
        nodebuffer: function(p) {
          return a.newBufferFrom(p);
        }
      }, b.arraybuffer = {
        string: function(p) {
          return v(new Uint8Array(p));
        },
        array: function(p) {
          return y(new Uint8Array(p), new Array(p.byteLength));
        },
        arraybuffer: c,
        uint8array: function(p) {
          return new Uint8Array(p);
        },
        nodebuffer: function(p) {
          return a.newBufferFrom(new Uint8Array(p));
        }
      }, b.uint8array = {
        string: v,
        array: function(p) {
          return y(p, new Array(p.length));
        },
        arraybuffer: function(p) {
          return p.buffer;
        },
        uint8array: c,
        nodebuffer: function(p) {
          return a.newBufferFrom(p);
        }
      }, b.nodebuffer = {
        string: v,
        array: function(p) {
          return y(p, new Array(p.length));
        },
        arraybuffer: function(p) {
          return b.nodebuffer.uint8array(p).buffer;
        },
        uint8array: function(p) {
          return y(p, new Uint8Array(p.length));
        },
        nodebuffer: c
      }, i.transformTo = function(p, f) {
        if (f || (f = ""), !p)
          return f;
        i.checkSupport(p);
        var m = i.getTypeOf(f), g = b[m][p](f);
        return g;
      }, i.resolve = function(p) {
        for (var f = p.split("/"), m = [], g = 0; g < f.length; g++) {
          var w = f[g];
          w === "." || w === "" && g !== 0 && g !== f.length - 1 || (w === ".." ? m.pop() : m.push(w));
        }
        return m.join("/");
      }, i.getTypeOf = function(p) {
        if (typeof p == "string")
          return "string";
        if (Object.prototype.toString.call(p) === "[object Array]")
          return "array";
        if (s.nodebuffer && a.isBuffer(p))
          return "nodebuffer";
        if (s.uint8array && p instanceof Uint8Array)
          return "uint8array";
        if (s.arraybuffer && p instanceof ArrayBuffer)
          return "arraybuffer";
      }, i.checkSupport = function(p) {
        var f = s[p.toLowerCase()];
        if (!f)
          throw new Error(p + " is not supported by this platform");
      }, i.MAX_VALUE_16BITS = 65535, i.MAX_VALUE_32BITS = -1, i.pretty = function(p) {
        var f = "", m, g;
        for (g = 0; g < (p || "").length; g++)
          m = p.charCodeAt(g), f += "\\x" + (m < 16 ? "0" : "") + m.toString(16).toUpperCase();
        return f;
      }, i.delay = function(p, f, m) {
        setImmediate(function() {
          p.apply(m || null, f || []);
        });
      }, i.inherits = function(p, f) {
        var m = function() {
        };
        m.prototype = f.prototype, p.prototype = new m();
      }, i.extend = function() {
        var p = {}, f, m;
        for (f = 0; f < arguments.length; f++)
          for (m in arguments[f])
            Object.prototype.hasOwnProperty.call(arguments[f], m) && typeof p[m] > "u" && (p[m] = arguments[f][m]);
        return p;
      }, i.prepareContent = function(p, f, m, g, w) {
        var _ = l.Promise.resolve(f).then(function(E) {
          var C = s.blob && (E instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(E)) !== -1);
          return C && typeof FileReader < "u" ? new l.Promise(function(T, k) {
            var N = new FileReader();
            N.onload = function(I) {
              T(I.target.result);
            }, N.onerror = function(I) {
              k(I.target.error);
            }, N.readAsArrayBuffer(E);
          }) : E;
        });
        return _.then(function(E) {
          var C = i.getTypeOf(E);
          return C ? (C === "arraybuffer" ? E = i.transformTo("uint8array", E) : C === "string" && (w ? E = o.decode(E) : m && g !== !0 && (E = u(E))), E) : l.Promise.reject(
            new Error("Can't read the data of '" + p + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")
          );
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(n, r, i) {
      var s = n("./reader/readerFor"), o = n("./utils"), a = n("./signature"), l = n("./zipEntry"), u = n("./support");
      function c(d) {
        this.files = [], this.loadOptions = d;
      }
      c.prototype = {
        /**
         * Check that the reader is on the specified signature.
         * @param {string} expectedSignature the expected signature.
         * @throws {Error} if it is an other signature.
         */
        checkSignature: function(d) {
          if (!this.reader.readAndCheckSignature(d)) {
            this.reader.index -= 4;
            var h = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + o.pretty(h) + ", expected " + o.pretty(d) + ")");
          }
        },
        /**
         * Check if the given signature is at the given index.
         * @param {number} askedIndex the index to check.
         * @param {string} expectedSignature the signature to expect.
         * @return {boolean} true if the signature is here, false otherwise.
         */
        isSignature: function(d, h) {
          var v = this.reader.index;
          this.reader.setIndex(d);
          var y = this.reader.readString(4), b = y === h;
          return this.reader.setIndex(v), b;
        },
        /**
         * Read the end of the central directory.
         */
        readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var d = this.reader.readData(this.zipCommentLength), h = u.uint8array ? "uint8array" : "array", v = o.transformTo(h, d);
          this.zipComment = this.loadOptions.decodeFileName(v);
        },
        /**
         * Read the end of the Zip 64 central directory.
         * Not merged with the method readEndOfCentral :
         * The end of central can coexist with its Zip64 brother,
         * I don't want to read the wrong number of bytes !
         */
        readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var d = this.zip64EndOfCentralSize - 44, h = 0, v, y, b; h < d; )
            v = this.reader.readInt(2), y = this.reader.readInt(4), b = this.reader.readData(y), this.zip64ExtensibleData[v] = {
              id: v,
              length: y,
              value: b
            };
        },
        /**
         * Read the end of the Zip 64 central directory locator.
         */
        readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), this.disksCount > 1)
            throw new Error("Multi-volumes zip are not supported");
        },
        /**
         * Read the local files, based on the offset read in the central part.
         */
        readLocalFiles: function() {
          var d, h;
          for (d = 0; d < this.files.length; d++)
            h = this.files[d], this.reader.setIndex(h.localHeaderOffset), this.checkSignature(a.LOCAL_FILE_HEADER), h.readLocalPart(this.reader), h.handleUTF8(), h.processAttributes();
        },
        /**
         * Read the central directory.
         */
        readCentralDir: function() {
          var d;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(a.CENTRAL_FILE_HEADER); )
            d = new l({
              zip64: this.zip64
            }, this.loadOptions), d.readCentralPart(this.reader), this.files.push(d);
          if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        },
        /**
         * Read the end of central directory.
         */
        readEndOfCentral: function() {
          var d = this.reader.lastIndexOfSignature(a.CENTRAL_DIRECTORY_END);
          if (d < 0) {
            var h = !this.isSignature(0, a.LOCAL_FILE_HEADER);
            throw h ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
          }
          this.reader.setIndex(d);
          var v = d;
          if (this.checkSignature(a.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === o.MAX_VALUE_16BITS || this.diskWithCentralDirStart === o.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === o.MAX_VALUE_16BITS || this.centralDirRecords === o.MAX_VALUE_16BITS || this.centralDirSize === o.MAX_VALUE_32BITS || this.centralDirOffset === o.MAX_VALUE_32BITS) {
            if (this.zip64 = !0, d = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR), d < 0)
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(d), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, a.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var y = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (y += 20, y += 12 + this.zip64EndOfCentralSize);
          var b = v - y;
          if (b > 0)
            this.isSignature(v, a.CENTRAL_FILE_HEADER) || (this.reader.zero = b);
          else if (b < 0)
            throw new Error("Corrupted zip: missing " + Math.abs(b) + " bytes.");
        },
        prepareReader: function(d) {
          this.reader = s(d);
        },
        /**
         * Read a zip file and create ZipEntries.
         * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
         */
        load: function(d) {
          this.prepareReader(d), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        }
      }, r.exports = c;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(n, r, i) {
      var s = n("./reader/readerFor"), o = n("./utils"), a = n("./compressedObject"), l = n("./crc32"), u = n("./utf8"), c = n("./compressions"), d = n("./support"), h = 0, v = 3, y = function(p) {
        for (var f in c)
          if (Object.prototype.hasOwnProperty.call(c, f) && c[f].magic === p)
            return c[f];
        return null;
      };
      function b(p, f) {
        this.options = p, this.loadOptions = f;
      }
      b.prototype = {
        /**
         * say if the file is encrypted.
         * @return {boolean} true if the file is encrypted, false otherwise.
         */
        isEncrypted: function() {
          return (this.bitFlag & 1) === 1;
        },
        /**
         * say if the file has utf-8 filename/comment.
         * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
         */
        useUTF8: function() {
          return (this.bitFlag & 2048) === 2048;
        },
        /**
         * Read the local part of a zip file and add the info in this object.
         * @param {DataReader} reader the reader to use.
         */
        readLocalPart: function(p) {
          var f, m;
          if (p.skip(22), this.fileNameLength = p.readInt(2), m = p.readInt(2), this.fileName = p.readData(this.fileNameLength), p.skip(m), this.compressedSize === -1 || this.uncompressedSize === -1)
            throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if (f = y(this.compressionMethod), f === null)
            throw new Error("Corrupted zip : compression " + o.pretty(this.compressionMethod) + " unknown (inner file : " + o.transformTo("string", this.fileName) + ")");
          this.decompressed = new a(this.compressedSize, this.uncompressedSize, this.crc32, f, p.readData(this.compressedSize));
        },
        /**
         * Read the central part of a zip file and add the info in this object.
         * @param {DataReader} reader the reader to use.
         */
        readCentralPart: function(p) {
          this.versionMadeBy = p.readInt(2), p.skip(2), this.bitFlag = p.readInt(2), this.compressionMethod = p.readString(2), this.date = p.readDate(), this.crc32 = p.readInt(4), this.compressedSize = p.readInt(4), this.uncompressedSize = p.readInt(4);
          var f = p.readInt(2);
          if (this.extraFieldsLength = p.readInt(2), this.fileCommentLength = p.readInt(2), this.diskNumberStart = p.readInt(2), this.internalFileAttributes = p.readInt(2), this.externalFileAttributes = p.readInt(4), this.localHeaderOffset = p.readInt(4), this.isEncrypted())
            throw new Error("Encrypted zip are not supported");
          p.skip(f), this.readExtraFields(p), this.parseZIP64ExtraField(p), this.fileComment = p.readData(this.fileCommentLength);
        },
        /**
         * Parse the external file attributes and get the unix/dos permissions.
         */
        processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var p = this.versionMadeBy >> 8;
          this.dir = !!(this.externalFileAttributes & 16), p === h && (this.dosPermissions = this.externalFileAttributes & 63), p === v && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), !this.dir && this.fileNameStr.slice(-1) === "/" && (this.dir = !0);
        },
        /**
         * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
         * @param {DataReader} reader the reader to use.
         */
        parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var p = s(this.extraFields[1].value);
            this.uncompressedSize === o.MAX_VALUE_32BITS && (this.uncompressedSize = p.readInt(8)), this.compressedSize === o.MAX_VALUE_32BITS && (this.compressedSize = p.readInt(8)), this.localHeaderOffset === o.MAX_VALUE_32BITS && (this.localHeaderOffset = p.readInt(8)), this.diskNumberStart === o.MAX_VALUE_32BITS && (this.diskNumberStart = p.readInt(4));
          }
        },
        /**
         * Read the central part of a zip file and add the info in this object.
         * @param {DataReader} reader the reader to use.
         */
        readExtraFields: function(p) {
          var f = p.index + this.extraFieldsLength, m, g, w;
          for (this.extraFields || (this.extraFields = {}); p.index + 4 < f; )
            m = p.readInt(2), g = p.readInt(2), w = p.readData(g), this.extraFields[m] = {
              id: m,
              length: g,
              value: w
            };
          p.setIndex(f);
        },
        /**
         * Apply an UTF8 transformation if needed.
         */
        handleUTF8: function() {
          var p = d.uint8array ? "uint8array" : "array";
          if (this.useUTF8())
            this.fileNameStr = u.utf8decode(this.fileName), this.fileCommentStr = u.utf8decode(this.fileComment);
          else {
            var f = this.findExtraFieldUnicodePath();
            if (f !== null)
              this.fileNameStr = f;
            else {
              var m = o.transformTo(p, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(m);
            }
            var g = this.findExtraFieldUnicodeComment();
            if (g !== null)
              this.fileCommentStr = g;
            else {
              var w = o.transformTo(p, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(w);
            }
          }
        },
        /**
         * Find the unicode path declared in the extra field, if any.
         * @return {String} the unicode path, null otherwise.
         */
        findExtraFieldUnicodePath: function() {
          var p = this.extraFields[28789];
          if (p) {
            var f = s(p.value);
            return f.readInt(1) !== 1 || l(this.fileName) !== f.readInt(4) ? null : u.utf8decode(f.readData(p.length - 5));
          }
          return null;
        },
        /**
         * Find the unicode comment declared in the extra field, if any.
         * @return {String} the unicode comment, null otherwise.
         */
        findExtraFieldUnicodeComment: function() {
          var p = this.extraFields[25461];
          if (p) {
            var f = s(p.value);
            return f.readInt(1) !== 1 || l(this.fileComment) !== f.readInt(4) ? null : u.utf8decode(f.readData(p.length - 5));
          }
          return null;
        }
      }, r.exports = b;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(n, r, i) {
      var s = n("./stream/StreamHelper"), o = n("./stream/DataWorker"), a = n("./utf8"), l = n("./compressedObject"), u = n("./stream/GenericWorker"), c = function(y, b, p) {
        this.name = y, this.dir = p.dir, this.date = p.date, this.comment = p.comment, this.unixPermissions = p.unixPermissions, this.dosPermissions = p.dosPermissions, this._data = b, this._dataBinary = p.binary, this.options = {
          compression: p.compression,
          compressionOptions: p.compressionOptions
        };
      };
      c.prototype = {
        /**
         * Create an internal stream for the content of this object.
         * @param {String} type the type of each chunk.
         * @return StreamHelper the stream.
         */
        internalStream: function(y) {
          var b = null, p = "string";
          try {
            if (!y)
              throw new Error("No output type specified.");
            p = y.toLowerCase();
            var f = p === "string" || p === "text";
            (p === "binarystring" || p === "text") && (p = "string"), b = this._decompressWorker();
            var m = !this._dataBinary;
            m && !f && (b = b.pipe(new a.Utf8EncodeWorker())), !m && f && (b = b.pipe(new a.Utf8DecodeWorker()));
          } catch (g) {
            b = new u("error"), b.error(g);
          }
          return new s(b, p, "");
        },
        /**
         * Prepare the content in the asked type.
         * @param {String} type the type of the result.
         * @param {Function} onUpdate a function to call on each internal update.
         * @return Promise the promise of the result.
         */
        async: function(y, b) {
          return this.internalStream(y).accumulate(b);
        },
        /**
         * Prepare the content as a nodejs stream.
         * @param {String} type the type of each chunk.
         * @param {Function} onUpdate a function to call on each internal update.
         * @return Stream the stream.
         */
        nodeStream: function(y, b) {
          return this.internalStream(y || "nodebuffer").toNodejsStream(b);
        },
        /**
         * Return a worker for the compressed content.
         * @private
         * @param {Object} compression the compression object to use.
         * @param {Object} compressionOptions the options to use when compressing.
         * @return Worker the worker.
         */
        _compressWorker: function(y, b) {
          if (this._data instanceof l && this._data.compression.magic === y.magic)
            return this._data.getCompressedWorker();
          var p = this._decompressWorker();
          return this._dataBinary || (p = p.pipe(new a.Utf8EncodeWorker())), l.createWorkerFrom(p, y, b);
        },
        /**
         * Return a worker for the decompressed content.
         * @private
         * @return Worker the worker.
         */
        _decompressWorker: function() {
          return this._data instanceof l ? this._data.getContentWorker() : this._data instanceof u ? this._data : new o(this._data);
        }
      };
      for (var d = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], h = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, v = 0; v < d.length; v++)
        c.prototype[d[v]] = h;
      r.exports = c;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(n, r, i) {
      (function(s) {
        var o = s.MutationObserver || s.WebKitMutationObserver, a;
        if (o) {
          var l = 0, u = new o(y), c = s.document.createTextNode("");
          u.observe(c, {
            characterData: !0
          }), a = function() {
            c.data = l = ++l % 2;
          };
        } else if (!s.setImmediate && typeof s.MessageChannel < "u") {
          var d = new s.MessageChannel();
          d.port1.onmessage = y, a = function() {
            d.port2.postMessage(0);
          };
        } else
          "document" in s && "onreadystatechange" in s.document.createElement("script") ? a = function() {
            var p = s.document.createElement("script");
            p.onreadystatechange = function() {
              y(), p.onreadystatechange = null, p.parentNode.removeChild(p), p = null;
            }, s.document.documentElement.appendChild(p);
          } : a = function() {
            setTimeout(y, 0);
          };
        var h, v = [];
        function y() {
          h = !0;
          for (var p, f, m = v.length; m; ) {
            for (f = v, v = [], p = -1; ++p < m; )
              f[p]();
            m = v.length;
          }
          h = !1;
        }
        r.exports = b;
        function b(p) {
          v.push(p) === 1 && !h && a();
        }
      }).call(this, typeof gn < "u" ? gn : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(n, r, i) {
      var s = n("immediate");
      function o() {
      }
      var a = {}, l = ["REJECTED"], u = ["FULFILLED"], c = ["PENDING"];
      r.exports = d;
      function d(_) {
        if (typeof _ != "function")
          throw new TypeError("resolver must be a function");
        this.state = c, this.queue = [], this.outcome = void 0, _ !== o && b(this, _);
      }
      d.prototype.finally = function(_) {
        if (typeof _ != "function")
          return this;
        var E = this.constructor;
        return this.then(C, T);
        function C(k) {
          function N() {
            return k;
          }
          return E.resolve(_()).then(N);
        }
        function T(k) {
          function N() {
            throw k;
          }
          return E.resolve(_()).then(N);
        }
      }, d.prototype.catch = function(_) {
        return this.then(null, _);
      }, d.prototype.then = function(_, E) {
        if (typeof _ != "function" && this.state === u || typeof E != "function" && this.state === l)
          return this;
        var C = new this.constructor(o);
        if (this.state !== c) {
          var T = this.state === u ? _ : E;
          v(C, T, this.outcome);
        } else
          this.queue.push(new h(C, _, E));
        return C;
      };
      function h(_, E, C) {
        this.promise = _, typeof E == "function" && (this.onFulfilled = E, this.callFulfilled = this.otherCallFulfilled), typeof C == "function" && (this.onRejected = C, this.callRejected = this.otherCallRejected);
      }
      h.prototype.callFulfilled = function(_) {
        a.resolve(this.promise, _);
      }, h.prototype.otherCallFulfilled = function(_) {
        v(this.promise, this.onFulfilled, _);
      }, h.prototype.callRejected = function(_) {
        a.reject(this.promise, _);
      }, h.prototype.otherCallRejected = function(_) {
        v(this.promise, this.onRejected, _);
      };
      function v(_, E, C) {
        s(function() {
          var T;
          try {
            T = E(C);
          } catch (k) {
            return a.reject(_, k);
          }
          T === _ ? a.reject(_, new TypeError("Cannot resolve promise with itself")) : a.resolve(_, T);
        });
      }
      a.resolve = function(_, E) {
        var C = p(y, E);
        if (C.status === "error")
          return a.reject(_, C.value);
        var T = C.value;
        if (T)
          b(_, T);
        else {
          _.state = u, _.outcome = E;
          for (var k = -1, N = _.queue.length; ++k < N; )
            _.queue[k].callFulfilled(E);
        }
        return _;
      }, a.reject = function(_, E) {
        _.state = l, _.outcome = E;
        for (var C = -1, T = _.queue.length; ++C < T; )
          _.queue[C].callRejected(E);
        return _;
      };
      function y(_) {
        var E = _ && _.then;
        if (_ && (typeof _ == "object" || typeof _ == "function") && typeof E == "function")
          return function() {
            E.apply(_, arguments);
          };
      }
      function b(_, E) {
        var C = !1;
        function T(P) {
          C || (C = !0, a.reject(_, P));
        }
        function k(P) {
          C || (C = !0, a.resolve(_, P));
        }
        function N() {
          E(k, T);
        }
        var I = p(N);
        I.status === "error" && T(I.value);
      }
      function p(_, E) {
        var C = {};
        try {
          C.value = _(E), C.status = "success";
        } catch (T) {
          C.status = "error", C.value = T;
        }
        return C;
      }
      d.resolve = f;
      function f(_) {
        return _ instanceof this ? _ : a.resolve(new this(o), _);
      }
      d.reject = m;
      function m(_) {
        var E = new this(o);
        return a.reject(E, _);
      }
      d.all = g;
      function g(_) {
        var E = this;
        if (Object.prototype.toString.call(_) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var C = _.length, T = !1;
        if (!C)
          return this.resolve([]);
        for (var k = new Array(C), N = 0, I = -1, P = new this(o); ++I < C; )
          D(_[I], I);
        return P;
        function D(z, G) {
          E.resolve(z).then(J, function(M) {
            T || (T = !0, a.reject(P, M));
          });
          function J(M) {
            k[G] = M, ++N === C && !T && (T = !0, a.resolve(P, k));
          }
        }
      }
      d.race = w;
      function w(_) {
        var E = this;
        if (Object.prototype.toString.call(_) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var C = _.length, T = !1;
        if (!C)
          return this.resolve([]);
        for (var k = -1, N = new this(o); ++k < C; )
          I(_[k]);
        return N;
        function I(P) {
          E.resolve(P).then(function(D) {
            T || (T = !0, a.resolve(N, D));
          }, function(D) {
            T || (T = !0, a.reject(N, D));
          });
        }
      }
    }, { immediate: 36 }], 38: [function(n, r, i) {
      var s = n("./lib/utils/common").assign, o = n("./lib/deflate"), a = n("./lib/inflate"), l = n("./lib/zlib/constants"), u = {};
      s(u, o, a, l), r.exports = u;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(n, r, i) {
      var s = n("./zlib/deflate"), o = n("./utils/common"), a = n("./utils/strings"), l = n("./zlib/messages"), u = n("./zlib/zstream"), c = Object.prototype.toString, d = 0, h = 4, v = 0, y = 1, b = 2, p = -1, f = 0, m = 8;
      function g(C) {
        if (!(this instanceof g))
          return new g(C);
        this.options = o.assign({
          level: p,
          method: m,
          chunkSize: 16384,
          windowBits: 15,
          memLevel: 8,
          strategy: f,
          to: ""
        }, C || {});
        var T = this.options;
        T.raw && T.windowBits > 0 ? T.windowBits = -T.windowBits : T.gzip && T.windowBits > 0 && T.windowBits < 16 && (T.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new u(), this.strm.avail_out = 0;
        var k = s.deflateInit2(
          this.strm,
          T.level,
          T.method,
          T.windowBits,
          T.memLevel,
          T.strategy
        );
        if (k !== v)
          throw new Error(l[k]);
        if (T.header && s.deflateSetHeader(this.strm, T.header), T.dictionary) {
          var N;
          if (typeof T.dictionary == "string" ? N = a.string2buf(T.dictionary) : c.call(T.dictionary) === "[object ArrayBuffer]" ? N = new Uint8Array(T.dictionary) : N = T.dictionary, k = s.deflateSetDictionary(this.strm, N), k !== v)
            throw new Error(l[k]);
          this._dict_set = !0;
        }
      }
      g.prototype.push = function(C, T) {
        var k = this.strm, N = this.options.chunkSize, I, P;
        if (this.ended)
          return !1;
        P = T === ~~T ? T : T === !0 ? h : d, typeof C == "string" ? k.input = a.string2buf(C) : c.call(C) === "[object ArrayBuffer]" ? k.input = new Uint8Array(C) : k.input = C, k.next_in = 0, k.avail_in = k.input.length;
        do {
          if (k.avail_out === 0 && (k.output = new o.Buf8(N), k.next_out = 0, k.avail_out = N), I = s.deflate(k, P), I !== y && I !== v)
            return this.onEnd(I), this.ended = !0, !1;
          (k.avail_out === 0 || k.avail_in === 0 && (P === h || P === b)) && (this.options.to === "string" ? this.onData(a.buf2binstring(o.shrinkBuf(k.output, k.next_out))) : this.onData(o.shrinkBuf(k.output, k.next_out)));
        } while ((k.avail_in > 0 || k.avail_out === 0) && I !== y);
        return P === h ? (I = s.deflateEnd(this.strm), this.onEnd(I), this.ended = !0, I === v) : (P === b && (this.onEnd(v), k.avail_out = 0), !0);
      }, g.prototype.onData = function(C) {
        this.chunks.push(C);
      }, g.prototype.onEnd = function(C) {
        C === v && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = C, this.msg = this.strm.msg;
      };
      function w(C, T) {
        var k = new g(T);
        if (k.push(C, !0), k.err)
          throw k.msg || l[k.err];
        return k.result;
      }
      function _(C, T) {
        return T = T || {}, T.raw = !0, w(C, T);
      }
      function E(C, T) {
        return T = T || {}, T.gzip = !0, w(C, T);
      }
      i.Deflate = g, i.deflate = w, i.deflateRaw = _, i.gzip = E;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(n, r, i) {
      var s = n("./zlib/inflate"), o = n("./utils/common"), a = n("./utils/strings"), l = n("./zlib/constants"), u = n("./zlib/messages"), c = n("./zlib/zstream"), d = n("./zlib/gzheader"), h = Object.prototype.toString;
      function v(p) {
        if (!(this instanceof v))
          return new v(p);
        this.options = o.assign({
          chunkSize: 16384,
          windowBits: 0,
          to: ""
        }, p || {});
        var f = this.options;
        f.raw && f.windowBits >= 0 && f.windowBits < 16 && (f.windowBits = -f.windowBits, f.windowBits === 0 && (f.windowBits = -15)), f.windowBits >= 0 && f.windowBits < 16 && !(p && p.windowBits) && (f.windowBits += 32), f.windowBits > 15 && f.windowBits < 48 && (f.windowBits & 15 || (f.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new c(), this.strm.avail_out = 0;
        var m = s.inflateInit2(
          this.strm,
          f.windowBits
        );
        if (m !== l.Z_OK)
          throw new Error(u[m]);
        this.header = new d(), s.inflateGetHeader(this.strm, this.header);
      }
      v.prototype.push = function(p, f) {
        var m = this.strm, g = this.options.chunkSize, w = this.options.dictionary, _, E, C, T, k, N, I = !1;
        if (this.ended)
          return !1;
        E = f === ~~f ? f : f === !0 ? l.Z_FINISH : l.Z_NO_FLUSH, typeof p == "string" ? m.input = a.binstring2buf(p) : h.call(p) === "[object ArrayBuffer]" ? m.input = new Uint8Array(p) : m.input = p, m.next_in = 0, m.avail_in = m.input.length;
        do {
          if (m.avail_out === 0 && (m.output = new o.Buf8(g), m.next_out = 0, m.avail_out = g), _ = s.inflate(m, l.Z_NO_FLUSH), _ === l.Z_NEED_DICT && w && (typeof w == "string" ? N = a.string2buf(w) : h.call(w) === "[object ArrayBuffer]" ? N = new Uint8Array(w) : N = w, _ = s.inflateSetDictionary(this.strm, N)), _ === l.Z_BUF_ERROR && I === !0 && (_ = l.Z_OK, I = !1), _ !== l.Z_STREAM_END && _ !== l.Z_OK)
            return this.onEnd(_), this.ended = !0, !1;
          m.next_out && (m.avail_out === 0 || _ === l.Z_STREAM_END || m.avail_in === 0 && (E === l.Z_FINISH || E === l.Z_SYNC_FLUSH)) && (this.options.to === "string" ? (C = a.utf8border(m.output, m.next_out), T = m.next_out - C, k = a.buf2string(m.output, C), m.next_out = T, m.avail_out = g - T, T && o.arraySet(m.output, m.output, C, T, 0), this.onData(k)) : this.onData(o.shrinkBuf(m.output, m.next_out))), m.avail_in === 0 && m.avail_out === 0 && (I = !0);
        } while ((m.avail_in > 0 || m.avail_out === 0) && _ !== l.Z_STREAM_END);
        return _ === l.Z_STREAM_END && (E = l.Z_FINISH), E === l.Z_FINISH ? (_ = s.inflateEnd(this.strm), this.onEnd(_), this.ended = !0, _ === l.Z_OK) : (E === l.Z_SYNC_FLUSH && (this.onEnd(l.Z_OK), m.avail_out = 0), !0);
      }, v.prototype.onData = function(p) {
        this.chunks.push(p);
      }, v.prototype.onEnd = function(p) {
        p === l.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = p, this.msg = this.strm.msg;
      };
      function y(p, f) {
        var m = new v(f);
        if (m.push(p, !0), m.err)
          throw m.msg || u[m.err];
        return m.result;
      }
      function b(p, f) {
        return f = f || {}, f.raw = !0, y(p, f);
      }
      i.Inflate = v, i.inflate = y, i.inflateRaw = b, i.ungzip = y;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(n, r, i) {
      var s = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      i.assign = function(l) {
        for (var u = Array.prototype.slice.call(arguments, 1); u.length; ) {
          var c = u.shift();
          if (c) {
            if (typeof c != "object")
              throw new TypeError(c + "must be non-object");
            for (var d in c)
              c.hasOwnProperty(d) && (l[d] = c[d]);
          }
        }
        return l;
      }, i.shrinkBuf = function(l, u) {
        return l.length === u ? l : l.subarray ? l.subarray(0, u) : (l.length = u, l);
      };
      var o = {
        arraySet: function(l, u, c, d, h) {
          if (u.subarray && l.subarray) {
            l.set(u.subarray(c, c + d), h);
            return;
          }
          for (var v = 0; v < d; v++)
            l[h + v] = u[c + v];
        },
        // Join array of chunks to single array.
        flattenChunks: function(l) {
          var u, c, d, h, v, y;
          for (d = 0, u = 0, c = l.length; u < c; u++)
            d += l[u].length;
          for (y = new Uint8Array(d), h = 0, u = 0, c = l.length; u < c; u++)
            v = l[u], y.set(v, h), h += v.length;
          return y;
        }
      }, a = {
        arraySet: function(l, u, c, d, h) {
          for (var v = 0; v < d; v++)
            l[h + v] = u[c + v];
        },
        // Join array of chunks to single array.
        flattenChunks: function(l) {
          return [].concat.apply([], l);
        }
      };
      i.setTyped = function(l) {
        l ? (i.Buf8 = Uint8Array, i.Buf16 = Uint16Array, i.Buf32 = Int32Array, i.assign(i, o)) : (i.Buf8 = Array, i.Buf16 = Array, i.Buf32 = Array, i.assign(i, a));
      }, i.setTyped(s);
    }, {}], 42: [function(n, r, i) {
      var s = n("./common"), o = !0, a = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        o = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        a = !1;
      }
      for (var l = new s.Buf8(256), u = 0; u < 256; u++)
        l[u] = u >= 252 ? 6 : u >= 248 ? 5 : u >= 240 ? 4 : u >= 224 ? 3 : u >= 192 ? 2 : 1;
      l[254] = l[254] = 1, i.string2buf = function(d) {
        var h, v, y, b, p, f = d.length, m = 0;
        for (b = 0; b < f; b++)
          v = d.charCodeAt(b), (v & 64512) === 55296 && b + 1 < f && (y = d.charCodeAt(b + 1), (y & 64512) === 56320 && (v = 65536 + (v - 55296 << 10) + (y - 56320), b++)), m += v < 128 ? 1 : v < 2048 ? 2 : v < 65536 ? 3 : 4;
        for (h = new s.Buf8(m), p = 0, b = 0; p < m; b++)
          v = d.charCodeAt(b), (v & 64512) === 55296 && b + 1 < f && (y = d.charCodeAt(b + 1), (y & 64512) === 56320 && (v = 65536 + (v - 55296 << 10) + (y - 56320), b++)), v < 128 ? h[p++] = v : v < 2048 ? (h[p++] = 192 | v >>> 6, h[p++] = 128 | v & 63) : v < 65536 ? (h[p++] = 224 | v >>> 12, h[p++] = 128 | v >>> 6 & 63, h[p++] = 128 | v & 63) : (h[p++] = 240 | v >>> 18, h[p++] = 128 | v >>> 12 & 63, h[p++] = 128 | v >>> 6 & 63, h[p++] = 128 | v & 63);
        return h;
      };
      function c(d, h) {
        if (h < 65537 && (d.subarray && a || !d.subarray && o))
          return String.fromCharCode.apply(null, s.shrinkBuf(d, h));
        for (var v = "", y = 0; y < h; y++)
          v += String.fromCharCode(d[y]);
        return v;
      }
      i.buf2binstring = function(d) {
        return c(d, d.length);
      }, i.binstring2buf = function(d) {
        for (var h = new s.Buf8(d.length), v = 0, y = h.length; v < y; v++)
          h[v] = d.charCodeAt(v);
        return h;
      }, i.buf2string = function(d, h) {
        var v, y, b, p, f = h || d.length, m = new Array(f * 2);
        for (y = 0, v = 0; v < f; ) {
          if (b = d[v++], b < 128) {
            m[y++] = b;
            continue;
          }
          if (p = l[b], p > 4) {
            m[y++] = 65533, v += p - 1;
            continue;
          }
          for (b &= p === 2 ? 31 : p === 3 ? 15 : 7; p > 1 && v < f; )
            b = b << 6 | d[v++] & 63, p--;
          if (p > 1) {
            m[y++] = 65533;
            continue;
          }
          b < 65536 ? m[y++] = b : (b -= 65536, m[y++] = 55296 | b >> 10 & 1023, m[y++] = 56320 | b & 1023);
        }
        return c(m, y);
      }, i.utf8border = function(d, h) {
        var v;
        for (h = h || d.length, h > d.length && (h = d.length), v = h - 1; v >= 0 && (d[v] & 192) === 128; )
          v--;
        return v < 0 || v === 0 ? h : v + l[d[v]] > h ? v : h;
      };
    }, { "./common": 41 }], 43: [function(n, r, i) {
      function s(o, a, l, u) {
        for (var c = o & 65535 | 0, d = o >>> 16 & 65535 | 0, h = 0; l !== 0; ) {
          h = l > 2e3 ? 2e3 : l, l -= h;
          do
            c = c + a[u++] | 0, d = d + c | 0;
          while (--h);
          c %= 65521, d %= 65521;
        }
        return c | d << 16 | 0;
      }
      r.exports = s;
    }, {}], 44: [function(n, r, i) {
      r.exports = {
        /* Allowed flush values; see deflate() and inflate() below for details */
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        /* Return codes for the compression/decompression functions. Negative values
        * are errors, positive values are used for special but normal events.
        */
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        //Z_MEM_ERROR:     -4,
        Z_BUF_ERROR: -5,
        //Z_VERSION_ERROR: -6,
        /* compression levels */
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        /* Possible values of the data_type field (though see inflate()) */
        Z_BINARY: 0,
        Z_TEXT: 1,
        //Z_ASCII:                1, // = Z_TEXT (deprecated)
        Z_UNKNOWN: 2,
        /* The deflate compression method */
        Z_DEFLATED: 8
        //Z_NULL:                 null // Use -1 or null inline, depending on var type
      };
    }, {}], 45: [function(n, r, i) {
      function s() {
        for (var l, u = [], c = 0; c < 256; c++) {
          l = c;
          for (var d = 0; d < 8; d++)
            l = l & 1 ? 3988292384 ^ l >>> 1 : l >>> 1;
          u[c] = l;
        }
        return u;
      }
      var o = s();
      function a(l, u, c, d) {
        var h = o, v = d + c;
        l ^= -1;
        for (var y = d; y < v; y++)
          l = l >>> 8 ^ h[(l ^ u[y]) & 255];
        return l ^ -1;
      }
      r.exports = a;
    }, {}], 46: [function(n, r, i) {
      var s = n("../utils/common"), o = n("./trees"), a = n("./adler32"), l = n("./crc32"), u = n("./messages"), c = 0, d = 1, h = 3, v = 4, y = 5, b = 0, p = 1, f = -2, m = -3, g = -5, w = -1, _ = 1, E = 2, C = 3, T = 4, k = 0, N = 2, I = 8, P = 9, D = 15, z = 8, G = 29, J = 256, M = J + 1 + G, U = 30, j = 19, re = 2 * M + 1, fe = 15, Y = 3, le = 258, ce = le + Y + 1, me = 32, _e = 42, ze = 69, Oe = 73, Qe = 91, Be = 103, He = 113, ct = 666, nt = 1, St = 2, yt = 3, It = 4, ot = 3;
      function bt(S, Z) {
        return S.msg = u[Z], Z;
      }
      function Kt(S) {
        return (S << 1) - (S > 4 ? 9 : 0);
      }
      function wt(S) {
        for (var Z = S.length; --Z >= 0; )
          S[Z] = 0;
      }
      function xt(S) {
        var Z = S.state, ie = Z.pending;
        ie > S.avail_out && (ie = S.avail_out), ie !== 0 && (s.arraySet(S.output, Z.pending_buf, Z.pending_out, ie, S.next_out), S.next_out += ie, Z.pending_out += ie, S.total_out += ie, S.avail_out -= ie, Z.pending -= ie, Z.pending === 0 && (Z.pending_out = 0));
      }
      function lt(S, Z) {
        o._tr_flush_block(S, S.block_start >= 0 ? S.block_start : -1, S.strstart - S.block_start, Z), S.block_start = S.strstart, xt(S.strm);
      }
      function Ge(S, Z) {
        S.pending_buf[S.pending++] = Z;
      }
      function Rt(S, Z) {
        S.pending_buf[S.pending++] = Z >>> 8 & 255, S.pending_buf[S.pending++] = Z & 255;
      }
      function we(S, Z, ie, A) {
        var W = S.avail_in;
        return W > A && (W = A), W === 0 ? 0 : (S.avail_in -= W, s.arraySet(Z, S.input, S.next_in, W, ie), S.state.wrap === 1 ? S.adler = a(S.adler, Z, W, ie) : S.state.wrap === 2 && (S.adler = l(S.adler, Z, W, ie)), S.next_in += W, S.total_in += W, W);
      }
      function Ue(S, Z) {
        var ie = S.max_chain_length, A = S.strstart, W, ne, Le = S.prev_length, Ne = S.nice_match, $e = S.strstart > S.w_size - ce ? S.strstart - (S.w_size - ce) : 0, Xe = S.window, ln = S.w_mask, Wt = S.prev, pt = S.strstart + le, Qt = Xe[A + Le - 1], fn = Xe[A + Le];
        S.prev_length >= S.good_match && (ie >>= 2), Ne > S.lookahead && (Ne = S.lookahead);
        do
          if (W = Z, !(Xe[W + Le] !== fn || Xe[W + Le - 1] !== Qt || Xe[W] !== Xe[A] || Xe[++W] !== Xe[A + 1])) {
            A += 2, W++;
            do
              ;
            while (Xe[++A] === Xe[++W] && Xe[++A] === Xe[++W] && Xe[++A] === Xe[++W] && Xe[++A] === Xe[++W] && Xe[++A] === Xe[++W] && Xe[++A] === Xe[++W] && Xe[++A] === Xe[++W] && Xe[++A] === Xe[++W] && A < pt);
            if (ne = le - (pt - A), A = pt - le, ne > Le) {
              if (S.match_start = Z, Le = ne, ne >= Ne)
                break;
              Qt = Xe[A + Le - 1], fn = Xe[A + Le];
            }
          }
        while ((Z = Wt[Z & ln]) > $e && --ie !== 0);
        return Le <= S.lookahead ? Le : S.lookahead;
      }
      function at(S) {
        var Z = S.w_size, ie, A, W, ne, Le;
        do {
          if (ne = S.window_size - S.lookahead - S.strstart, S.strstart >= Z + (Z - ce)) {
            s.arraySet(S.window, S.window, Z, Z, 0), S.match_start -= Z, S.strstart -= Z, S.block_start -= Z, A = S.hash_size, ie = A;
            do
              W = S.head[--ie], S.head[ie] = W >= Z ? W - Z : 0;
            while (--A);
            A = Z, ie = A;
            do
              W = S.prev[--ie], S.prev[ie] = W >= Z ? W - Z : 0;
            while (--A);
            ne += Z;
          }
          if (S.strm.avail_in === 0)
            break;
          if (A = we(S.strm, S.window, S.strstart + S.lookahead, ne), S.lookahead += A, S.lookahead + S.insert >= Y)
            for (Le = S.strstart - S.insert, S.ins_h = S.window[Le], S.ins_h = (S.ins_h << S.hash_shift ^ S.window[Le + 1]) & S.hash_mask; S.insert && (S.ins_h = (S.ins_h << S.hash_shift ^ S.window[Le + Y - 1]) & S.hash_mask, S.prev[Le & S.w_mask] = S.head[S.ins_h], S.head[S.ins_h] = Le, Le++, S.insert--, !(S.lookahead + S.insert < Y)); )
              ;
        } while (S.lookahead < ce && S.strm.avail_in !== 0);
      }
      function Lt(S, Z) {
        var ie = 65535;
        for (ie > S.pending_buf_size - 5 && (ie = S.pending_buf_size - 5); ; ) {
          if (S.lookahead <= 1) {
            if (at(S), S.lookahead === 0 && Z === c)
              return nt;
            if (S.lookahead === 0)
              break;
          }
          S.strstart += S.lookahead, S.lookahead = 0;
          var A = S.block_start + ie;
          if ((S.strstart === 0 || S.strstart >= A) && (S.lookahead = S.strstart - A, S.strstart = A, lt(S, !1), S.strm.avail_out === 0) || S.strstart - S.block_start >= S.w_size - ce && (lt(S, !1), S.strm.avail_out === 0))
            return nt;
        }
        return S.insert = 0, Z === v ? (lt(S, !0), S.strm.avail_out === 0 ? yt : It) : (S.strstart > S.block_start && (lt(S, !1), S.strm.avail_out === 0), nt);
      }
      function Zt(S, Z) {
        for (var ie, A; ; ) {
          if (S.lookahead < ce) {
            if (at(S), S.lookahead < ce && Z === c)
              return nt;
            if (S.lookahead === 0)
              break;
          }
          if (ie = 0, S.lookahead >= Y && (S.ins_h = (S.ins_h << S.hash_shift ^ S.window[S.strstart + Y - 1]) & S.hash_mask, ie = S.prev[S.strstart & S.w_mask] = S.head[S.ins_h], S.head[S.ins_h] = S.strstart), ie !== 0 && S.strstart - ie <= S.w_size - ce && (S.match_length = Ue(S, ie)), S.match_length >= Y)
            if (A = o._tr_tally(S, S.strstart - S.match_start, S.match_length - Y), S.lookahead -= S.match_length, S.match_length <= S.max_lazy_match && S.lookahead >= Y) {
              S.match_length--;
              do
                S.strstart++, S.ins_h = (S.ins_h << S.hash_shift ^ S.window[S.strstart + Y - 1]) & S.hash_mask, ie = S.prev[S.strstart & S.w_mask] = S.head[S.ins_h], S.head[S.ins_h] = S.strstart;
              while (--S.match_length !== 0);
              S.strstart++;
            } else
              S.strstart += S.match_length, S.match_length = 0, S.ins_h = S.window[S.strstart], S.ins_h = (S.ins_h << S.hash_shift ^ S.window[S.strstart + 1]) & S.hash_mask;
          else
            A = o._tr_tally(S, 0, S.window[S.strstart]), S.lookahead--, S.strstart++;
          if (A && (lt(S, !1), S.strm.avail_out === 0))
            return nt;
        }
        return S.insert = S.strstart < Y - 1 ? S.strstart : Y - 1, Z === v ? (lt(S, !0), S.strm.avail_out === 0 ? yt : It) : S.last_lit && (lt(S, !1), S.strm.avail_out === 0) ? nt : St;
      }
      function Ae(S, Z) {
        for (var ie, A, W; ; ) {
          if (S.lookahead < ce) {
            if (at(S), S.lookahead < ce && Z === c)
              return nt;
            if (S.lookahead === 0)
              break;
          }
          if (ie = 0, S.lookahead >= Y && (S.ins_h = (S.ins_h << S.hash_shift ^ S.window[S.strstart + Y - 1]) & S.hash_mask, ie = S.prev[S.strstart & S.w_mask] = S.head[S.ins_h], S.head[S.ins_h] = S.strstart), S.prev_length = S.match_length, S.prev_match = S.match_start, S.match_length = Y - 1, ie !== 0 && S.prev_length < S.max_lazy_match && S.strstart - ie <= S.w_size - ce && (S.match_length = Ue(S, ie), S.match_length <= 5 && (S.strategy === _ || S.match_length === Y && S.strstart - S.match_start > 4096) && (S.match_length = Y - 1)), S.prev_length >= Y && S.match_length <= S.prev_length) {
            W = S.strstart + S.lookahead - Y, A = o._tr_tally(S, S.strstart - 1 - S.prev_match, S.prev_length - Y), S.lookahead -= S.prev_length - 1, S.prev_length -= 2;
            do
              ++S.strstart <= W && (S.ins_h = (S.ins_h << S.hash_shift ^ S.window[S.strstart + Y - 1]) & S.hash_mask, ie = S.prev[S.strstart & S.w_mask] = S.head[S.ins_h], S.head[S.ins_h] = S.strstart);
            while (--S.prev_length !== 0);
            if (S.match_available = 0, S.match_length = Y - 1, S.strstart++, A && (lt(S, !1), S.strm.avail_out === 0))
              return nt;
          } else if (S.match_available) {
            if (A = o._tr_tally(S, 0, S.window[S.strstart - 1]), A && lt(S, !1), S.strstart++, S.lookahead--, S.strm.avail_out === 0)
              return nt;
          } else
            S.match_available = 1, S.strstart++, S.lookahead--;
        }
        return S.match_available && (A = o._tr_tally(S, 0, S.window[S.strstart - 1]), S.match_available = 0), S.insert = S.strstart < Y - 1 ? S.strstart : Y - 1, Z === v ? (lt(S, !0), S.strm.avail_out === 0 ? yt : It) : S.last_lit && (lt(S, !1), S.strm.avail_out === 0) ? nt : St;
      }
      function Ve(S, Z) {
        for (var ie, A, W, ne, Le = S.window; ; ) {
          if (S.lookahead <= le) {
            if (at(S), S.lookahead <= le && Z === c)
              return nt;
            if (S.lookahead === 0)
              break;
          }
          if (S.match_length = 0, S.lookahead >= Y && S.strstart > 0 && (W = S.strstart - 1, A = Le[W], A === Le[++W] && A === Le[++W] && A === Le[++W])) {
            ne = S.strstart + le;
            do
              ;
            while (A === Le[++W] && A === Le[++W] && A === Le[++W] && A === Le[++W] && A === Le[++W] && A === Le[++W] && A === Le[++W] && A === Le[++W] && W < ne);
            S.match_length = le - (ne - W), S.match_length > S.lookahead && (S.match_length = S.lookahead);
          }
          if (S.match_length >= Y ? (ie = o._tr_tally(S, 1, S.match_length - Y), S.lookahead -= S.match_length, S.strstart += S.match_length, S.match_length = 0) : (ie = o._tr_tally(S, 0, S.window[S.strstart]), S.lookahead--, S.strstart++), ie && (lt(S, !1), S.strm.avail_out === 0))
            return nt;
        }
        return S.insert = 0, Z === v ? (lt(S, !0), S.strm.avail_out === 0 ? yt : It) : S.last_lit && (lt(S, !1), S.strm.avail_out === 0) ? nt : St;
      }
      function Ye(S, Z) {
        for (var ie; ; ) {
          if (S.lookahead === 0 && (at(S), S.lookahead === 0)) {
            if (Z === c)
              return nt;
            break;
          }
          if (S.match_length = 0, ie = o._tr_tally(S, 0, S.window[S.strstart]), S.lookahead--, S.strstart++, ie && (lt(S, !1), S.strm.avail_out === 0))
            return nt;
        }
        return S.insert = 0, Z === v ? (lt(S, !0), S.strm.avail_out === 0 ? yt : It) : S.last_lit && (lt(S, !1), S.strm.avail_out === 0) ? nt : St;
      }
      function je(S, Z, ie, A, W) {
        this.good_length = S, this.max_lazy = Z, this.nice_length = ie, this.max_chain = A, this.func = W;
      }
      var Ze;
      Ze = [
        /*      good lazy nice chain */
        new je(0, 0, 0, 0, Lt),
        /* 0 store only */
        new je(4, 4, 8, 4, Zt),
        /* 1 max speed, no lazy matches */
        new je(4, 5, 16, 8, Zt),
        /* 2 */
        new je(4, 6, 32, 32, Zt),
        /* 3 */
        new je(4, 4, 16, 16, Ae),
        /* 4 lazy matches */
        new je(8, 16, 32, 32, Ae),
        /* 5 */
        new je(8, 16, 128, 128, Ae),
        /* 6 */
        new je(8, 32, 128, 256, Ae),
        /* 7 */
        new je(32, 128, 258, 1024, Ae),
        /* 8 */
        new je(32, 258, 258, 4096, Ae)
        /* 9 max compression */
      ];
      function Ct(S) {
        S.window_size = 2 * S.w_size, wt(S.head), S.max_lazy_match = Ze[S.level].max_lazy, S.good_match = Ze[S.level].good_length, S.nice_match = Ze[S.level].nice_length, S.max_chain_length = Ze[S.level].max_chain, S.strstart = 0, S.block_start = 0, S.lookahead = 0, S.insert = 0, S.match_length = S.prev_length = Y - 1, S.match_available = 0, S.ins_h = 0;
      }
      function L() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = I, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new s.Buf16(re * 2), this.dyn_dtree = new s.Buf16((2 * U + 1) * 2), this.bl_tree = new s.Buf16((2 * j + 1) * 2), wt(this.dyn_ltree), wt(this.dyn_dtree), wt(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new s.Buf16(fe + 1), this.heap = new s.Buf16(2 * M + 1), wt(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new s.Buf16(2 * M + 1), wt(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function he(S) {
        var Z;
        return !S || !S.state ? bt(S, f) : (S.total_in = S.total_out = 0, S.data_type = N, Z = S.state, Z.pending = 0, Z.pending_out = 0, Z.wrap < 0 && (Z.wrap = -Z.wrap), Z.status = Z.wrap ? _e : He, S.adler = Z.wrap === 2 ? 0 : 1, Z.last_flush = c, o._tr_init(Z), b);
      }
      function ge(S) {
        var Z = he(S);
        return Z === b && Ct(S.state), Z;
      }
      function Ie(S, Z) {
        return !S || !S.state || S.state.wrap !== 2 ? f : (S.state.gzhead = Z, b);
      }
      function q(S, Z, ie, A, W, ne) {
        if (!S)
          return f;
        var Le = 1;
        if (Z === w && (Z = 6), A < 0 ? (Le = 0, A = -A) : A > 15 && (Le = 2, A -= 16), W < 1 || W > P || ie !== I || A < 8 || A > 15 || Z < 0 || Z > 9 || ne < 0 || ne > T)
          return bt(S, f);
        A === 8 && (A = 9);
        var Ne = new L();
        return S.state = Ne, Ne.strm = S, Ne.wrap = Le, Ne.gzhead = null, Ne.w_bits = A, Ne.w_size = 1 << Ne.w_bits, Ne.w_mask = Ne.w_size - 1, Ne.hash_bits = W + 7, Ne.hash_size = 1 << Ne.hash_bits, Ne.hash_mask = Ne.hash_size - 1, Ne.hash_shift = ~~((Ne.hash_bits + Y - 1) / Y), Ne.window = new s.Buf8(Ne.w_size * 2), Ne.head = new s.Buf16(Ne.hash_size), Ne.prev = new s.Buf16(Ne.w_size), Ne.lit_bufsize = 1 << W + 6, Ne.pending_buf_size = Ne.lit_bufsize * 4, Ne.pending_buf = new s.Buf8(Ne.pending_buf_size), Ne.d_buf = 1 * Ne.lit_bufsize, Ne.l_buf = (1 + 2) * Ne.lit_bufsize, Ne.level = Z, Ne.strategy = ne, Ne.method = ie, ge(S);
      }
      function ue(S, Z) {
        return q(S, Z, I, D, z, k);
      }
      function O(S, Z) {
        var ie, A, W, ne;
        if (!S || !S.state || Z > y || Z < 0)
          return S ? bt(S, f) : f;
        if (A = S.state, !S.output || !S.input && S.avail_in !== 0 || A.status === ct && Z !== v)
          return bt(S, S.avail_out === 0 ? g : f);
        if (A.strm = S, ie = A.last_flush, A.last_flush = Z, A.status === _e)
          if (A.wrap === 2)
            S.adler = 0, Ge(A, 31), Ge(A, 139), Ge(A, 8), A.gzhead ? (Ge(
              A,
              (A.gzhead.text ? 1 : 0) + (A.gzhead.hcrc ? 2 : 0) + (A.gzhead.extra ? 4 : 0) + (A.gzhead.name ? 8 : 0) + (A.gzhead.comment ? 16 : 0)
            ), Ge(A, A.gzhead.time & 255), Ge(A, A.gzhead.time >> 8 & 255), Ge(A, A.gzhead.time >> 16 & 255), Ge(A, A.gzhead.time >> 24 & 255), Ge(A, A.level === 9 ? 2 : A.strategy >= E || A.level < 2 ? 4 : 0), Ge(A, A.gzhead.os & 255), A.gzhead.extra && A.gzhead.extra.length && (Ge(A, A.gzhead.extra.length & 255), Ge(A, A.gzhead.extra.length >> 8 & 255)), A.gzhead.hcrc && (S.adler = l(S.adler, A.pending_buf, A.pending, 0)), A.gzindex = 0, A.status = ze) : (Ge(A, 0), Ge(A, 0), Ge(A, 0), Ge(A, 0), Ge(A, 0), Ge(A, A.level === 9 ? 2 : A.strategy >= E || A.level < 2 ? 4 : 0), Ge(A, ot), A.status = He);
          else {
            var Le = I + (A.w_bits - 8 << 4) << 8, Ne = -1;
            A.strategy >= E || A.level < 2 ? Ne = 0 : A.level < 6 ? Ne = 1 : A.level === 6 ? Ne = 2 : Ne = 3, Le |= Ne << 6, A.strstart !== 0 && (Le |= me), Le += 31 - Le % 31, A.status = He, Rt(A, Le), A.strstart !== 0 && (Rt(A, S.adler >>> 16), Rt(A, S.adler & 65535)), S.adler = 1;
          }
        if (A.status === ze)
          if (A.gzhead.extra) {
            for (W = A.pending; A.gzindex < (A.gzhead.extra.length & 65535) && !(A.pending === A.pending_buf_size && (A.gzhead.hcrc && A.pending > W && (S.adler = l(S.adler, A.pending_buf, A.pending - W, W)), xt(S), W = A.pending, A.pending === A.pending_buf_size)); )
              Ge(A, A.gzhead.extra[A.gzindex] & 255), A.gzindex++;
            A.gzhead.hcrc && A.pending > W && (S.adler = l(S.adler, A.pending_buf, A.pending - W, W)), A.gzindex === A.gzhead.extra.length && (A.gzindex = 0, A.status = Oe);
          } else
            A.status = Oe;
        if (A.status === Oe)
          if (A.gzhead.name) {
            W = A.pending;
            do {
              if (A.pending === A.pending_buf_size && (A.gzhead.hcrc && A.pending > W && (S.adler = l(S.adler, A.pending_buf, A.pending - W, W)), xt(S), W = A.pending, A.pending === A.pending_buf_size)) {
                ne = 1;
                break;
              }
              A.gzindex < A.gzhead.name.length ? ne = A.gzhead.name.charCodeAt(A.gzindex++) & 255 : ne = 0, Ge(A, ne);
            } while (ne !== 0);
            A.gzhead.hcrc && A.pending > W && (S.adler = l(S.adler, A.pending_buf, A.pending - W, W)), ne === 0 && (A.gzindex = 0, A.status = Qe);
          } else
            A.status = Qe;
        if (A.status === Qe)
          if (A.gzhead.comment) {
            W = A.pending;
            do {
              if (A.pending === A.pending_buf_size && (A.gzhead.hcrc && A.pending > W && (S.adler = l(S.adler, A.pending_buf, A.pending - W, W)), xt(S), W = A.pending, A.pending === A.pending_buf_size)) {
                ne = 1;
                break;
              }
              A.gzindex < A.gzhead.comment.length ? ne = A.gzhead.comment.charCodeAt(A.gzindex++) & 255 : ne = 0, Ge(A, ne);
            } while (ne !== 0);
            A.gzhead.hcrc && A.pending > W && (S.adler = l(S.adler, A.pending_buf, A.pending - W, W)), ne === 0 && (A.status = Be);
          } else
            A.status = Be;
        if (A.status === Be && (A.gzhead.hcrc ? (A.pending + 2 > A.pending_buf_size && xt(S), A.pending + 2 <= A.pending_buf_size && (Ge(A, S.adler & 255), Ge(A, S.adler >> 8 & 255), S.adler = 0, A.status = He)) : A.status = He), A.pending !== 0) {
          if (xt(S), S.avail_out === 0)
            return A.last_flush = -1, b;
        } else if (S.avail_in === 0 && Kt(Z) <= Kt(ie) && Z !== v)
          return bt(S, g);
        if (A.status === ct && S.avail_in !== 0)
          return bt(S, g);
        if (S.avail_in !== 0 || A.lookahead !== 0 || Z !== c && A.status !== ct) {
          var $e = A.strategy === E ? Ye(A, Z) : A.strategy === C ? Ve(A, Z) : Ze[A.level].func(A, Z);
          if (($e === yt || $e === It) && (A.status = ct), $e === nt || $e === yt)
            return S.avail_out === 0 && (A.last_flush = -1), b;
          if ($e === St && (Z === d ? o._tr_align(A) : Z !== y && (o._tr_stored_block(A, 0, 0, !1), Z === h && (wt(A.head), A.lookahead === 0 && (A.strstart = 0, A.block_start = 0, A.insert = 0))), xt(S), S.avail_out === 0))
            return A.last_flush = -1, b;
        }
        return Z !== v ? b : A.wrap <= 0 ? p : (A.wrap === 2 ? (Ge(A, S.adler & 255), Ge(A, S.adler >> 8 & 255), Ge(A, S.adler >> 16 & 255), Ge(A, S.adler >> 24 & 255), Ge(A, S.total_in & 255), Ge(A, S.total_in >> 8 & 255), Ge(A, S.total_in >> 16 & 255), Ge(A, S.total_in >> 24 & 255)) : (Rt(A, S.adler >>> 16), Rt(A, S.adler & 65535)), xt(S), A.wrap > 0 && (A.wrap = -A.wrap), A.pending !== 0 ? b : p);
      }
      function B(S) {
        var Z;
        return !S || !S.state ? f : (Z = S.state.status, Z !== _e && Z !== ze && Z !== Oe && Z !== Qe && Z !== Be && Z !== He && Z !== ct ? bt(S, f) : (S.state = null, Z === He ? bt(S, m) : b));
      }
      function oe(S, Z) {
        var ie = Z.length, A, W, ne, Le, Ne, $e, Xe, ln;
        if (!S || !S.state || (A = S.state, Le = A.wrap, Le === 2 || Le === 1 && A.status !== _e || A.lookahead))
          return f;
        for (Le === 1 && (S.adler = a(S.adler, Z, ie, 0)), A.wrap = 0, ie >= A.w_size && (Le === 0 && (wt(A.head), A.strstart = 0, A.block_start = 0, A.insert = 0), ln = new s.Buf8(A.w_size), s.arraySet(ln, Z, ie - A.w_size, A.w_size, 0), Z = ln, ie = A.w_size), Ne = S.avail_in, $e = S.next_in, Xe = S.input, S.avail_in = ie, S.next_in = 0, S.input = Z, at(A); A.lookahead >= Y; ) {
          W = A.strstart, ne = A.lookahead - (Y - 1);
          do
            A.ins_h = (A.ins_h << A.hash_shift ^ A.window[W + Y - 1]) & A.hash_mask, A.prev[W & A.w_mask] = A.head[A.ins_h], A.head[A.ins_h] = W, W++;
          while (--ne);
          A.strstart = W, A.lookahead = Y - 1, at(A);
        }
        return A.strstart += A.lookahead, A.block_start = A.strstart, A.insert = A.lookahead, A.lookahead = 0, A.match_length = A.prev_length = Y - 1, A.match_available = 0, S.next_in = $e, S.input = Xe, S.avail_in = Ne, A.wrap = Le, b;
      }
      i.deflateInit = ue, i.deflateInit2 = q, i.deflateReset = ge, i.deflateResetKeep = he, i.deflateSetHeader = Ie, i.deflate = O, i.deflateEnd = B, i.deflateSetDictionary = oe, i.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(n, r, i) {
      function s() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      }
      r.exports = s;
    }, {}], 48: [function(n, r, i) {
      var s = 30, o = 12;
      r.exports = function(l, u) {
        var c, d, h, v, y, b, p, f, m, g, w, _, E, C, T, k, N, I, P, D, z, G, J, M, U;
        c = l.state, d = l.next_in, M = l.input, h = d + (l.avail_in - 5), v = l.next_out, U = l.output, y = v - (u - l.avail_out), b = v + (l.avail_out - 257), p = c.dmax, f = c.wsize, m = c.whave, g = c.wnext, w = c.window, _ = c.hold, E = c.bits, C = c.lencode, T = c.distcode, k = (1 << c.lenbits) - 1, N = (1 << c.distbits) - 1;
        e:
          do {
            E < 15 && (_ += M[d++] << E, E += 8, _ += M[d++] << E, E += 8), I = C[_ & k];
            t:
              for (; ; ) {
                if (P = I >>> 24, _ >>>= P, E -= P, P = I >>> 16 & 255, P === 0)
                  U[v++] = I & 65535;
                else if (P & 16) {
                  D = I & 65535, P &= 15, P && (E < P && (_ += M[d++] << E, E += 8), D += _ & (1 << P) - 1, _ >>>= P, E -= P), E < 15 && (_ += M[d++] << E, E += 8, _ += M[d++] << E, E += 8), I = T[_ & N];
                  n:
                    for (; ; ) {
                      if (P = I >>> 24, _ >>>= P, E -= P, P = I >>> 16 & 255, P & 16) {
                        if (z = I & 65535, P &= 15, E < P && (_ += M[d++] << E, E += 8, E < P && (_ += M[d++] << E, E += 8)), z += _ & (1 << P) - 1, z > p) {
                          l.msg = "invalid distance too far back", c.mode = s;
                          break e;
                        }
                        if (_ >>>= P, E -= P, P = v - y, z > P) {
                          if (P = z - P, P > m && c.sane) {
                            l.msg = "invalid distance too far back", c.mode = s;
                            break e;
                          }
                          if (G = 0, J = w, g === 0) {
                            if (G += f - P, P < D) {
                              D -= P;
                              do
                                U[v++] = w[G++];
                              while (--P);
                              G = v - z, J = U;
                            }
                          } else if (g < P) {
                            if (G += f + g - P, P -= g, P < D) {
                              D -= P;
                              do
                                U[v++] = w[G++];
                              while (--P);
                              if (G = 0, g < D) {
                                P = g, D -= P;
                                do
                                  U[v++] = w[G++];
                                while (--P);
                                G = v - z, J = U;
                              }
                            }
                          } else if (G += g - P, P < D) {
                            D -= P;
                            do
                              U[v++] = w[G++];
                            while (--P);
                            G = v - z, J = U;
                          }
                          for (; D > 2; )
                            U[v++] = J[G++], U[v++] = J[G++], U[v++] = J[G++], D -= 3;
                          D && (U[v++] = J[G++], D > 1 && (U[v++] = J[G++]));
                        } else {
                          G = v - z;
                          do
                            U[v++] = U[G++], U[v++] = U[G++], U[v++] = U[G++], D -= 3;
                          while (D > 2);
                          D && (U[v++] = U[G++], D > 1 && (U[v++] = U[G++]));
                        }
                      } else if (P & 64) {
                        l.msg = "invalid distance code", c.mode = s;
                        break e;
                      } else {
                        I = T[(I & 65535) + (_ & (1 << P) - 1)];
                        continue n;
                      }
                      break;
                    }
                } else if (P & 64)
                  if (P & 32) {
                    c.mode = o;
                    break e;
                  } else {
                    l.msg = "invalid literal/length code", c.mode = s;
                    break e;
                  }
                else {
                  I = C[(I & 65535) + (_ & (1 << P) - 1)];
                  continue t;
                }
                break;
              }
          } while (d < h && v < b);
        D = E >> 3, d -= D, E -= D << 3, _ &= (1 << E) - 1, l.next_in = d, l.next_out = v, l.avail_in = d < h ? 5 + (h - d) : 5 - (d - h), l.avail_out = v < b ? 257 + (b - v) : 257 - (v - b), c.hold = _, c.bits = E;
      };
    }, {}], 49: [function(n, r, i) {
      var s = n("../utils/common"), o = n("./adler32"), a = n("./crc32"), l = n("./inffast"), u = n("./inftrees"), c = 0, d = 1, h = 2, v = 4, y = 5, b = 6, p = 0, f = 1, m = 2, g = -2, w = -3, _ = -4, E = -5, C = 8, T = 1, k = 2, N = 3, I = 4, P = 5, D = 6, z = 7, G = 8, J = 9, M = 10, U = 11, j = 12, re = 13, fe = 14, Y = 15, le = 16, ce = 17, me = 18, _e = 19, ze = 20, Oe = 21, Qe = 22, Be = 23, He = 24, ct = 25, nt = 26, St = 27, yt = 28, It = 29, ot = 30, bt = 31, Kt = 32, wt = 852, xt = 592, lt = 15, Ge = lt;
      function Rt(q) {
        return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
      }
      function we() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new s.Buf16(320), this.work = new s.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function Ue(q) {
        var ue;
        return !q || !q.state ? g : (ue = q.state, q.total_in = q.total_out = ue.total = 0, q.msg = "", ue.wrap && (q.adler = ue.wrap & 1), ue.mode = T, ue.last = 0, ue.havedict = 0, ue.dmax = 32768, ue.head = null, ue.hold = 0, ue.bits = 0, ue.lencode = ue.lendyn = new s.Buf32(wt), ue.distcode = ue.distdyn = new s.Buf32(xt), ue.sane = 1, ue.back = -1, p);
      }
      function at(q) {
        var ue;
        return !q || !q.state ? g : (ue = q.state, ue.wsize = 0, ue.whave = 0, ue.wnext = 0, Ue(q));
      }
      function Lt(q, ue) {
        var O, B;
        return !q || !q.state || (B = q.state, ue < 0 ? (O = 0, ue = -ue) : (O = (ue >> 4) + 1, ue < 48 && (ue &= 15)), ue && (ue < 8 || ue > 15)) ? g : (B.window !== null && B.wbits !== ue && (B.window = null), B.wrap = O, B.wbits = ue, at(q));
      }
      function Zt(q, ue) {
        var O, B;
        return q ? (B = new we(), q.state = B, B.window = null, O = Lt(q, ue), O !== p && (q.state = null), O) : g;
      }
      function Ae(q) {
        return Zt(q, Ge);
      }
      var Ve = !0, Ye, je;
      function Ze(q) {
        if (Ve) {
          var ue;
          for (Ye = new s.Buf32(512), je = new s.Buf32(32), ue = 0; ue < 144; )
            q.lens[ue++] = 8;
          for (; ue < 256; )
            q.lens[ue++] = 9;
          for (; ue < 280; )
            q.lens[ue++] = 7;
          for (; ue < 288; )
            q.lens[ue++] = 8;
          for (u(d, q.lens, 0, 288, Ye, 0, q.work, { bits: 9 }), ue = 0; ue < 32; )
            q.lens[ue++] = 5;
          u(h, q.lens, 0, 32, je, 0, q.work, { bits: 5 }), Ve = !1;
        }
        q.lencode = Ye, q.lenbits = 9, q.distcode = je, q.distbits = 5;
      }
      function Ct(q, ue, O, B) {
        var oe, S = q.state;
        return S.window === null && (S.wsize = 1 << S.wbits, S.wnext = 0, S.whave = 0, S.window = new s.Buf8(S.wsize)), B >= S.wsize ? (s.arraySet(S.window, ue, O - S.wsize, S.wsize, 0), S.wnext = 0, S.whave = S.wsize) : (oe = S.wsize - S.wnext, oe > B && (oe = B), s.arraySet(S.window, ue, O - B, oe, S.wnext), B -= oe, B ? (s.arraySet(S.window, ue, O - B, B, 0), S.wnext = B, S.whave = S.wsize) : (S.wnext += oe, S.wnext === S.wsize && (S.wnext = 0), S.whave < S.wsize && (S.whave += oe))), 0;
      }
      function L(q, ue) {
        var O, B, oe, S, Z, ie, A, W, ne, Le, Ne, $e, Xe, ln, Wt = 0, pt, Qt, fn, xn, es, ts, Yt, $n, un = new s.Buf8(4), ar, Zn, da = (
          /* permutation of code lengths */
          [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
        );
        if (!q || !q.state || !q.output || !q.input && q.avail_in !== 0)
          return g;
        O = q.state, O.mode === j && (O.mode = re), Z = q.next_out, oe = q.output, A = q.avail_out, S = q.next_in, B = q.input, ie = q.avail_in, W = O.hold, ne = O.bits, Le = ie, Ne = A, $n = p;
        e:
          for (; ; )
            switch (O.mode) {
              case T:
                if (O.wrap === 0) {
                  O.mode = re;
                  break;
                }
                for (; ne < 16; ) {
                  if (ie === 0)
                    break e;
                  ie--, W += B[S++] << ne, ne += 8;
                }
                if (O.wrap & 2 && W === 35615) {
                  O.check = 0, un[0] = W & 255, un[1] = W >>> 8 & 255, O.check = a(O.check, un, 2, 0), W = 0, ne = 0, O.mode = k;
                  break;
                }
                if (O.flags = 0, O.head && (O.head.done = !1), !(O.wrap & 1) || /* check if zlib header allowed */
                (((W & 255) << 8) + (W >> 8)) % 31) {
                  q.msg = "incorrect header check", O.mode = ot;
                  break;
                }
                if ((W & 15) !== C) {
                  q.msg = "unknown compression method", O.mode = ot;
                  break;
                }
                if (W >>>= 4, ne -= 4, Yt = (W & 15) + 8, O.wbits === 0)
                  O.wbits = Yt;
                else if (Yt > O.wbits) {
                  q.msg = "invalid window size", O.mode = ot;
                  break;
                }
                O.dmax = 1 << Yt, q.adler = O.check = 1, O.mode = W & 512 ? M : j, W = 0, ne = 0;
                break;
              case k:
                for (; ne < 16; ) {
                  if (ie === 0)
                    break e;
                  ie--, W += B[S++] << ne, ne += 8;
                }
                if (O.flags = W, (O.flags & 255) !== C) {
                  q.msg = "unknown compression method", O.mode = ot;
                  break;
                }
                if (O.flags & 57344) {
                  q.msg = "unknown header flags set", O.mode = ot;
                  break;
                }
                O.head && (O.head.text = W >> 8 & 1), O.flags & 512 && (un[0] = W & 255, un[1] = W >>> 8 & 255, O.check = a(O.check, un, 2, 0)), W = 0, ne = 0, O.mode = N;
              case N:
                for (; ne < 32; ) {
                  if (ie === 0)
                    break e;
                  ie--, W += B[S++] << ne, ne += 8;
                }
                O.head && (O.head.time = W), O.flags & 512 && (un[0] = W & 255, un[1] = W >>> 8 & 255, un[2] = W >>> 16 & 255, un[3] = W >>> 24 & 255, O.check = a(O.check, un, 4, 0)), W = 0, ne = 0, O.mode = I;
              case I:
                for (; ne < 16; ) {
                  if (ie === 0)
                    break e;
                  ie--, W += B[S++] << ne, ne += 8;
                }
                O.head && (O.head.xflags = W & 255, O.head.os = W >> 8), O.flags & 512 && (un[0] = W & 255, un[1] = W >>> 8 & 255, O.check = a(O.check, un, 2, 0)), W = 0, ne = 0, O.mode = P;
              case P:
                if (O.flags & 1024) {
                  for (; ne < 16; ) {
                    if (ie === 0)
                      break e;
                    ie--, W += B[S++] << ne, ne += 8;
                  }
                  O.length = W, O.head && (O.head.extra_len = W), O.flags & 512 && (un[0] = W & 255, un[1] = W >>> 8 & 255, O.check = a(O.check, un, 2, 0)), W = 0, ne = 0;
                } else
                  O.head && (O.head.extra = null);
                O.mode = D;
              case D:
                if (O.flags & 1024 && ($e = O.length, $e > ie && ($e = ie), $e && (O.head && (Yt = O.head.extra_len - O.length, O.head.extra || (O.head.extra = new Array(O.head.extra_len)), s.arraySet(
                  O.head.extra,
                  B,
                  S,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  $e,
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  Yt
                )), O.flags & 512 && (O.check = a(O.check, B, $e, S)), ie -= $e, S += $e, O.length -= $e), O.length))
                  break e;
                O.length = 0, O.mode = z;
              case z:
                if (O.flags & 2048) {
                  if (ie === 0)
                    break e;
                  $e = 0;
                  do
                    Yt = B[S + $e++], O.head && Yt && O.length < 65536 && (O.head.name += String.fromCharCode(Yt));
                  while (Yt && $e < ie);
                  if (O.flags & 512 && (O.check = a(O.check, B, $e, S)), ie -= $e, S += $e, Yt)
                    break e;
                } else
                  O.head && (O.head.name = null);
                O.length = 0, O.mode = G;
              case G:
                if (O.flags & 4096) {
                  if (ie === 0)
                    break e;
                  $e = 0;
                  do
                    Yt = B[S + $e++], O.head && Yt && O.length < 65536 && (O.head.comment += String.fromCharCode(Yt));
                  while (Yt && $e < ie);
                  if (O.flags & 512 && (O.check = a(O.check, B, $e, S)), ie -= $e, S += $e, Yt)
                    break e;
                } else
                  O.head && (O.head.comment = null);
                O.mode = J;
              case J:
                if (O.flags & 512) {
                  for (; ne < 16; ) {
                    if (ie === 0)
                      break e;
                    ie--, W += B[S++] << ne, ne += 8;
                  }
                  if (W !== (O.check & 65535)) {
                    q.msg = "header crc mismatch", O.mode = ot;
                    break;
                  }
                  W = 0, ne = 0;
                }
                O.head && (O.head.hcrc = O.flags >> 9 & 1, O.head.done = !0), q.adler = O.check = 0, O.mode = j;
                break;
              case M:
                for (; ne < 32; ) {
                  if (ie === 0)
                    break e;
                  ie--, W += B[S++] << ne, ne += 8;
                }
                q.adler = O.check = Rt(W), W = 0, ne = 0, O.mode = U;
              case U:
                if (O.havedict === 0)
                  return q.next_out = Z, q.avail_out = A, q.next_in = S, q.avail_in = ie, O.hold = W, O.bits = ne, m;
                q.adler = O.check = 1, O.mode = j;
              case j:
                if (ue === y || ue === b)
                  break e;
              case re:
                if (O.last) {
                  W >>>= ne & 7, ne -= ne & 7, O.mode = St;
                  break;
                }
                for (; ne < 3; ) {
                  if (ie === 0)
                    break e;
                  ie--, W += B[S++] << ne, ne += 8;
                }
                switch (O.last = W & 1, W >>>= 1, ne -= 1, W & 3) {
                  case 0:
                    O.mode = fe;
                    break;
                  case 1:
                    if (Ze(O), O.mode = ze, ue === b) {
                      W >>>= 2, ne -= 2;
                      break e;
                    }
                    break;
                  case 2:
                    O.mode = ce;
                    break;
                  case 3:
                    q.msg = "invalid block type", O.mode = ot;
                }
                W >>>= 2, ne -= 2;
                break;
              case fe:
                for (W >>>= ne & 7, ne -= ne & 7; ne < 32; ) {
                  if (ie === 0)
                    break e;
                  ie--, W += B[S++] << ne, ne += 8;
                }
                if ((W & 65535) !== (W >>> 16 ^ 65535)) {
                  q.msg = "invalid stored block lengths", O.mode = ot;
                  break;
                }
                if (O.length = W & 65535, W = 0, ne = 0, O.mode = Y, ue === b)
                  break e;
              case Y:
                O.mode = le;
              case le:
                if ($e = O.length, $e) {
                  if ($e > ie && ($e = ie), $e > A && ($e = A), $e === 0)
                    break e;
                  s.arraySet(oe, B, S, $e, Z), ie -= $e, S += $e, A -= $e, Z += $e, O.length -= $e;
                  break;
                }
                O.mode = j;
                break;
              case ce:
                for (; ne < 14; ) {
                  if (ie === 0)
                    break e;
                  ie--, W += B[S++] << ne, ne += 8;
                }
                if (O.nlen = (W & 31) + 257, W >>>= 5, ne -= 5, O.ndist = (W & 31) + 1, W >>>= 5, ne -= 5, O.ncode = (W & 15) + 4, W >>>= 4, ne -= 4, O.nlen > 286 || O.ndist > 30) {
                  q.msg = "too many length or distance symbols", O.mode = ot;
                  break;
                }
                O.have = 0, O.mode = me;
              case me:
                for (; O.have < O.ncode; ) {
                  for (; ne < 3; ) {
                    if (ie === 0)
                      break e;
                    ie--, W += B[S++] << ne, ne += 8;
                  }
                  O.lens[da[O.have++]] = W & 7, W >>>= 3, ne -= 3;
                }
                for (; O.have < 19; )
                  O.lens[da[O.have++]] = 0;
                if (O.lencode = O.lendyn, O.lenbits = 7, ar = { bits: O.lenbits }, $n = u(c, O.lens, 0, 19, O.lencode, 0, O.work, ar), O.lenbits = ar.bits, $n) {
                  q.msg = "invalid code lengths set", O.mode = ot;
                  break;
                }
                O.have = 0, O.mode = _e;
              case _e:
                for (; O.have < O.nlen + O.ndist; ) {
                  for (; Wt = O.lencode[W & (1 << O.lenbits) - 1], pt = Wt >>> 24, Qt = Wt >>> 16 & 255, fn = Wt & 65535, !(pt <= ne); ) {
                    if (ie === 0)
                      break e;
                    ie--, W += B[S++] << ne, ne += 8;
                  }
                  if (fn < 16)
                    W >>>= pt, ne -= pt, O.lens[O.have++] = fn;
                  else {
                    if (fn === 16) {
                      for (Zn = pt + 2; ne < Zn; ) {
                        if (ie === 0)
                          break e;
                        ie--, W += B[S++] << ne, ne += 8;
                      }
                      if (W >>>= pt, ne -= pt, O.have === 0) {
                        q.msg = "invalid bit length repeat", O.mode = ot;
                        break;
                      }
                      Yt = O.lens[O.have - 1], $e = 3 + (W & 3), W >>>= 2, ne -= 2;
                    } else if (fn === 17) {
                      for (Zn = pt + 3; ne < Zn; ) {
                        if (ie === 0)
                          break e;
                        ie--, W += B[S++] << ne, ne += 8;
                      }
                      W >>>= pt, ne -= pt, Yt = 0, $e = 3 + (W & 7), W >>>= 3, ne -= 3;
                    } else {
                      for (Zn = pt + 7; ne < Zn; ) {
                        if (ie === 0)
                          break e;
                        ie--, W += B[S++] << ne, ne += 8;
                      }
                      W >>>= pt, ne -= pt, Yt = 0, $e = 11 + (W & 127), W >>>= 7, ne -= 7;
                    }
                    if (O.have + $e > O.nlen + O.ndist) {
                      q.msg = "invalid bit length repeat", O.mode = ot;
                      break;
                    }
                    for (; $e--; )
                      O.lens[O.have++] = Yt;
                  }
                }
                if (O.mode === ot)
                  break;
                if (O.lens[256] === 0) {
                  q.msg = "invalid code -- missing end-of-block", O.mode = ot;
                  break;
                }
                if (O.lenbits = 9, ar = { bits: O.lenbits }, $n = u(d, O.lens, 0, O.nlen, O.lencode, 0, O.work, ar), O.lenbits = ar.bits, $n) {
                  q.msg = "invalid literal/lengths set", O.mode = ot;
                  break;
                }
                if (O.distbits = 6, O.distcode = O.distdyn, ar = { bits: O.distbits }, $n = u(h, O.lens, O.nlen, O.ndist, O.distcode, 0, O.work, ar), O.distbits = ar.bits, $n) {
                  q.msg = "invalid distances set", O.mode = ot;
                  break;
                }
                if (O.mode = ze, ue === b)
                  break e;
              case ze:
                O.mode = Oe;
              case Oe:
                if (ie >= 6 && A >= 258) {
                  q.next_out = Z, q.avail_out = A, q.next_in = S, q.avail_in = ie, O.hold = W, O.bits = ne, l(q, Ne), Z = q.next_out, oe = q.output, A = q.avail_out, S = q.next_in, B = q.input, ie = q.avail_in, W = O.hold, ne = O.bits, O.mode === j && (O.back = -1);
                  break;
                }
                for (O.back = 0; Wt = O.lencode[W & (1 << O.lenbits) - 1], pt = Wt >>> 24, Qt = Wt >>> 16 & 255, fn = Wt & 65535, !(pt <= ne); ) {
                  if (ie === 0)
                    break e;
                  ie--, W += B[S++] << ne, ne += 8;
                }
                if (Qt && !(Qt & 240)) {
                  for (xn = pt, es = Qt, ts = fn; Wt = O.lencode[ts + ((W & (1 << xn + es) - 1) >> xn)], pt = Wt >>> 24, Qt = Wt >>> 16 & 255, fn = Wt & 65535, !(xn + pt <= ne); ) {
                    if (ie === 0)
                      break e;
                    ie--, W += B[S++] << ne, ne += 8;
                  }
                  W >>>= xn, ne -= xn, O.back += xn;
                }
                if (W >>>= pt, ne -= pt, O.back += pt, O.length = fn, Qt === 0) {
                  O.mode = nt;
                  break;
                }
                if (Qt & 32) {
                  O.back = -1, O.mode = j;
                  break;
                }
                if (Qt & 64) {
                  q.msg = "invalid literal/length code", O.mode = ot;
                  break;
                }
                O.extra = Qt & 15, O.mode = Qe;
              case Qe:
                if (O.extra) {
                  for (Zn = O.extra; ne < Zn; ) {
                    if (ie === 0)
                      break e;
                    ie--, W += B[S++] << ne, ne += 8;
                  }
                  O.length += W & (1 << O.extra) - 1, W >>>= O.extra, ne -= O.extra, O.back += O.extra;
                }
                O.was = O.length, O.mode = Be;
              case Be:
                for (; Wt = O.distcode[W & (1 << O.distbits) - 1], pt = Wt >>> 24, Qt = Wt >>> 16 & 255, fn = Wt & 65535, !(pt <= ne); ) {
                  if (ie === 0)
                    break e;
                  ie--, W += B[S++] << ne, ne += 8;
                }
                if (!(Qt & 240)) {
                  for (xn = pt, es = Qt, ts = fn; Wt = O.distcode[ts + ((W & (1 << xn + es) - 1) >> xn)], pt = Wt >>> 24, Qt = Wt >>> 16 & 255, fn = Wt & 65535, !(xn + pt <= ne); ) {
                    if (ie === 0)
                      break e;
                    ie--, W += B[S++] << ne, ne += 8;
                  }
                  W >>>= xn, ne -= xn, O.back += xn;
                }
                if (W >>>= pt, ne -= pt, O.back += pt, Qt & 64) {
                  q.msg = "invalid distance code", O.mode = ot;
                  break;
                }
                O.offset = fn, O.extra = Qt & 15, O.mode = He;
              case He:
                if (O.extra) {
                  for (Zn = O.extra; ne < Zn; ) {
                    if (ie === 0)
                      break e;
                    ie--, W += B[S++] << ne, ne += 8;
                  }
                  O.offset += W & (1 << O.extra) - 1, W >>>= O.extra, ne -= O.extra, O.back += O.extra;
                }
                if (O.offset > O.dmax) {
                  q.msg = "invalid distance too far back", O.mode = ot;
                  break;
                }
                O.mode = ct;
              case ct:
                if (A === 0)
                  break e;
                if ($e = Ne - A, O.offset > $e) {
                  if ($e = O.offset - $e, $e > O.whave && O.sane) {
                    q.msg = "invalid distance too far back", O.mode = ot;
                    break;
                  }
                  $e > O.wnext ? ($e -= O.wnext, Xe = O.wsize - $e) : Xe = O.wnext - $e, $e > O.length && ($e = O.length), ln = O.window;
                } else
                  ln = oe, Xe = Z - O.offset, $e = O.length;
                $e > A && ($e = A), A -= $e, O.length -= $e;
                do
                  oe[Z++] = ln[Xe++];
                while (--$e);
                O.length === 0 && (O.mode = Oe);
                break;
              case nt:
                if (A === 0)
                  break e;
                oe[Z++] = O.length, A--, O.mode = Oe;
                break;
              case St:
                if (O.wrap) {
                  for (; ne < 32; ) {
                    if (ie === 0)
                      break e;
                    ie--, W |= B[S++] << ne, ne += 8;
                  }
                  if (Ne -= A, q.total_out += Ne, O.total += Ne, Ne && (q.adler = O.check = /*UPDATE(state.check, put - _out, _out);*/
                  O.flags ? a(O.check, oe, Ne, Z - Ne) : o(O.check, oe, Ne, Z - Ne)), Ne = A, (O.flags ? W : Rt(W)) !== O.check) {
                    q.msg = "incorrect data check", O.mode = ot;
                    break;
                  }
                  W = 0, ne = 0;
                }
                O.mode = yt;
              case yt:
                if (O.wrap && O.flags) {
                  for (; ne < 32; ) {
                    if (ie === 0)
                      break e;
                    ie--, W += B[S++] << ne, ne += 8;
                  }
                  if (W !== (O.total & 4294967295)) {
                    q.msg = "incorrect length check", O.mode = ot;
                    break;
                  }
                  W = 0, ne = 0;
                }
                O.mode = It;
              case It:
                $n = f;
                break e;
              case ot:
                $n = w;
                break e;
              case bt:
                return _;
              case Kt:
              default:
                return g;
            }
        return q.next_out = Z, q.avail_out = A, q.next_in = S, q.avail_in = ie, O.hold = W, O.bits = ne, (O.wsize || Ne !== q.avail_out && O.mode < ot && (O.mode < St || ue !== v)) && Ct(q, q.output, q.next_out, Ne - q.avail_out), Le -= q.avail_in, Ne -= q.avail_out, q.total_in += Le, q.total_out += Ne, O.total += Ne, O.wrap && Ne && (q.adler = O.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        O.flags ? a(O.check, oe, Ne, q.next_out - Ne) : o(O.check, oe, Ne, q.next_out - Ne)), q.data_type = O.bits + (O.last ? 64 : 0) + (O.mode === j ? 128 : 0) + (O.mode === ze || O.mode === Y ? 256 : 0), (Le === 0 && Ne === 0 || ue === v) && $n === p && ($n = E), $n;
      }
      function he(q) {
        if (!q || !q.state)
          return g;
        var ue = q.state;
        return ue.window && (ue.window = null), q.state = null, p;
      }
      function ge(q, ue) {
        var O;
        return !q || !q.state || (O = q.state, !(O.wrap & 2)) ? g : (O.head = ue, ue.done = !1, p);
      }
      function Ie(q, ue) {
        var O = ue.length, B, oe, S;
        return !q || !q.state || (B = q.state, B.wrap !== 0 && B.mode !== U) ? g : B.mode === U && (oe = 1, oe = o(oe, ue, O, 0), oe !== B.check) ? w : (S = Ct(q, ue, O, O), S ? (B.mode = bt, _) : (B.havedict = 1, p));
      }
      i.inflateReset = at, i.inflateReset2 = Lt, i.inflateResetKeep = Ue, i.inflateInit = Ae, i.inflateInit2 = Zt, i.inflate = L, i.inflateEnd = he, i.inflateGetHeader = ge, i.inflateSetDictionary = Ie, i.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(n, r, i) {
      var s = n("../utils/common"), o = 15, a = 852, l = 592, u = 0, c = 1, d = 2, h = [
        /* Length codes 257..285 base */
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        13,
        15,
        17,
        19,
        23,
        27,
        31,
        35,
        43,
        51,
        59,
        67,
        83,
        99,
        115,
        131,
        163,
        195,
        227,
        258,
        0,
        0
      ], v = [
        /* Length codes 257..285 extra */
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        17,
        17,
        17,
        17,
        18,
        18,
        18,
        18,
        19,
        19,
        19,
        19,
        20,
        20,
        20,
        20,
        21,
        21,
        21,
        21,
        16,
        72,
        78
      ], y = [
        /* Distance codes 0..29 base */
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        13,
        17,
        25,
        33,
        49,
        65,
        97,
        129,
        193,
        257,
        385,
        513,
        769,
        1025,
        1537,
        2049,
        3073,
        4097,
        6145,
        8193,
        12289,
        16385,
        24577,
        0,
        0
      ], b = [
        /* Distance codes 0..29 extra */
        16,
        16,
        16,
        16,
        17,
        17,
        18,
        18,
        19,
        19,
        20,
        20,
        21,
        21,
        22,
        22,
        23,
        23,
        24,
        24,
        25,
        25,
        26,
        26,
        27,
        27,
        28,
        28,
        29,
        29,
        64,
        64
      ];
      r.exports = function(f, m, g, w, _, E, C, T) {
        var k = T.bits, N = 0, I = 0, P = 0, D = 0, z = 0, G = 0, J = 0, M = 0, U = 0, j = 0, re, fe, Y, le, ce, me = null, _e = 0, ze, Oe = new s.Buf16(o + 1), Qe = new s.Buf16(o + 1), Be = null, He = 0, ct, nt, St;
        for (N = 0; N <= o; N++)
          Oe[N] = 0;
        for (I = 0; I < w; I++)
          Oe[m[g + I]]++;
        for (z = k, D = o; D >= 1 && Oe[D] === 0; D--)
          ;
        if (z > D && (z = D), D === 0)
          return _[E++] = 1 << 24 | 64 << 16 | 0, _[E++] = 1 << 24 | 64 << 16 | 0, T.bits = 1, 0;
        for (P = 1; P < D && Oe[P] === 0; P++)
          ;
        for (z < P && (z = P), M = 1, N = 1; N <= o; N++)
          if (M <<= 1, M -= Oe[N], M < 0)
            return -1;
        if (M > 0 && (f === u || D !== 1))
          return -1;
        for (Qe[1] = 0, N = 1; N < o; N++)
          Qe[N + 1] = Qe[N] + Oe[N];
        for (I = 0; I < w; I++)
          m[g + I] !== 0 && (C[Qe[m[g + I]]++] = I);
        if (f === u ? (me = Be = C, ze = 19) : f === c ? (me = h, _e -= 257, Be = v, He -= 257, ze = 256) : (me = y, Be = b, ze = -1), j = 0, I = 0, N = P, ce = E, G = z, J = 0, Y = -1, U = 1 << z, le = U - 1, f === c && U > a || f === d && U > l)
          return 1;
        for (; ; ) {
          ct = N - J, C[I] < ze ? (nt = 0, St = C[I]) : C[I] > ze ? (nt = Be[He + C[I]], St = me[_e + C[I]]) : (nt = 32 + 64, St = 0), re = 1 << N - J, fe = 1 << G, P = fe;
          do
            fe -= re, _[ce + (j >> J) + fe] = ct << 24 | nt << 16 | St | 0;
          while (fe !== 0);
          for (re = 1 << N - 1; j & re; )
            re >>= 1;
          if (re !== 0 ? (j &= re - 1, j += re) : j = 0, I++, --Oe[N] === 0) {
            if (N === D)
              break;
            N = m[g + C[I]];
          }
          if (N > z && (j & le) !== Y) {
            for (J === 0 && (J = z), ce += P, G = N - J, M = 1 << G; G + J < D && (M -= Oe[G + J], !(M <= 0)); )
              G++, M <<= 1;
            if (U += 1 << G, f === c && U > a || f === d && U > l)
              return 1;
            Y = j & le, _[Y] = z << 24 | G << 16 | ce - E | 0;
          }
        }
        return j !== 0 && (_[ce + j] = N - J << 24 | 64 << 16 | 0), T.bits = z, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(n, r, i) {
      r.exports = {
        2: "need dictionary",
        /* Z_NEED_DICT       2  */
        1: "stream end",
        /* Z_STREAM_END      1  */
        0: "",
        /* Z_OK              0  */
        "-1": "file error",
        /* Z_ERRNO         (-1) */
        "-2": "stream error",
        /* Z_STREAM_ERROR  (-2) */
        "-3": "data error",
        /* Z_DATA_ERROR    (-3) */
        "-4": "insufficient memory",
        /* Z_MEM_ERROR     (-4) */
        "-5": "buffer error",
        /* Z_BUF_ERROR     (-5) */
        "-6": "incompatible version"
        /* Z_VERSION_ERROR (-6) */
      };
    }, {}], 52: [function(n, r, i) {
      var s = n("../utils/common"), o = 4, a = 0, l = 1, u = 2;
      function c(L) {
        for (var he = L.length; --he >= 0; )
          L[he] = 0;
      }
      var d = 0, h = 1, v = 2, y = 3, b = 258, p = 29, f = 256, m = f + 1 + p, g = 30, w = 19, _ = 2 * m + 1, E = 15, C = 16, T = 7, k = 256, N = 16, I = 17, P = 18, D = (
        /* extra bits for each length code */
        [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
      ), z = (
        /* extra bits for each distance code */
        [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
      ), G = (
        /* extra bits for each bit length code */
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
      ), J = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], M = 512, U = new Array((m + 2) * 2);
      c(U);
      var j = new Array(g * 2);
      c(j);
      var re = new Array(M);
      c(re);
      var fe = new Array(b - y + 1);
      c(fe);
      var Y = new Array(p);
      c(Y);
      var le = new Array(g);
      c(le);
      function ce(L, he, ge, Ie, q) {
        this.static_tree = L, this.extra_bits = he, this.extra_base = ge, this.elems = Ie, this.max_length = q, this.has_stree = L && L.length;
      }
      var me, _e, ze;
      function Oe(L, he) {
        this.dyn_tree = L, this.max_code = 0, this.stat_desc = he;
      }
      function Qe(L) {
        return L < 256 ? re[L] : re[256 + (L >>> 7)];
      }
      function Be(L, he) {
        L.pending_buf[L.pending++] = he & 255, L.pending_buf[L.pending++] = he >>> 8 & 255;
      }
      function He(L, he, ge) {
        L.bi_valid > C - ge ? (L.bi_buf |= he << L.bi_valid & 65535, Be(L, L.bi_buf), L.bi_buf = he >> C - L.bi_valid, L.bi_valid += ge - C) : (L.bi_buf |= he << L.bi_valid & 65535, L.bi_valid += ge);
      }
      function ct(L, he, ge) {
        He(
          L,
          ge[he * 2],
          ge[he * 2 + 1]
          /*.Len*/
        );
      }
      function nt(L, he) {
        var ge = 0;
        do
          ge |= L & 1, L >>>= 1, ge <<= 1;
        while (--he > 0);
        return ge >>> 1;
      }
      function St(L) {
        L.bi_valid === 16 ? (Be(L, L.bi_buf), L.bi_buf = 0, L.bi_valid = 0) : L.bi_valid >= 8 && (L.pending_buf[L.pending++] = L.bi_buf & 255, L.bi_buf >>= 8, L.bi_valid -= 8);
      }
      function yt(L, he) {
        var ge = he.dyn_tree, Ie = he.max_code, q = he.stat_desc.static_tree, ue = he.stat_desc.has_stree, O = he.stat_desc.extra_bits, B = he.stat_desc.extra_base, oe = he.stat_desc.max_length, S, Z, ie, A, W, ne, Le = 0;
        for (A = 0; A <= E; A++)
          L.bl_count[A] = 0;
        for (ge[L.heap[L.heap_max] * 2 + 1] = 0, S = L.heap_max + 1; S < _; S++)
          Z = L.heap[S], A = ge[ge[Z * 2 + 1] * 2 + 1] + 1, A > oe && (A = oe, Le++), ge[Z * 2 + 1] = A, !(Z > Ie) && (L.bl_count[A]++, W = 0, Z >= B && (W = O[Z - B]), ne = ge[Z * 2], L.opt_len += ne * (A + W), ue && (L.static_len += ne * (q[Z * 2 + 1] + W)));
        if (Le !== 0) {
          do {
            for (A = oe - 1; L.bl_count[A] === 0; )
              A--;
            L.bl_count[A]--, L.bl_count[A + 1] += 2, L.bl_count[oe]--, Le -= 2;
          } while (Le > 0);
          for (A = oe; A !== 0; A--)
            for (Z = L.bl_count[A]; Z !== 0; )
              ie = L.heap[--S], !(ie > Ie) && (ge[ie * 2 + 1] !== A && (L.opt_len += (A - ge[ie * 2 + 1]) * ge[ie * 2], ge[ie * 2 + 1] = A), Z--);
        }
      }
      function It(L, he, ge) {
        var Ie = new Array(E + 1), q = 0, ue, O;
        for (ue = 1; ue <= E; ue++)
          Ie[ue] = q = q + ge[ue - 1] << 1;
        for (O = 0; O <= he; O++) {
          var B = L[O * 2 + 1];
          B !== 0 && (L[O * 2] = nt(Ie[B]++, B));
        }
      }
      function ot() {
        var L, he, ge, Ie, q, ue = new Array(E + 1);
        for (ge = 0, Ie = 0; Ie < p - 1; Ie++)
          for (Y[Ie] = ge, L = 0; L < 1 << D[Ie]; L++)
            fe[ge++] = Ie;
        for (fe[ge - 1] = Ie, q = 0, Ie = 0; Ie < 16; Ie++)
          for (le[Ie] = q, L = 0; L < 1 << z[Ie]; L++)
            re[q++] = Ie;
        for (q >>= 7; Ie < g; Ie++)
          for (le[Ie] = q << 7, L = 0; L < 1 << z[Ie] - 7; L++)
            re[256 + q++] = Ie;
        for (he = 0; he <= E; he++)
          ue[he] = 0;
        for (L = 0; L <= 143; )
          U[L * 2 + 1] = 8, L++, ue[8]++;
        for (; L <= 255; )
          U[L * 2 + 1] = 9, L++, ue[9]++;
        for (; L <= 279; )
          U[L * 2 + 1] = 7, L++, ue[7]++;
        for (; L <= 287; )
          U[L * 2 + 1] = 8, L++, ue[8]++;
        for (It(U, m + 1, ue), L = 0; L < g; L++)
          j[L * 2 + 1] = 5, j[L * 2] = nt(L, 5);
        me = new ce(U, D, f + 1, m, E), _e = new ce(j, z, 0, g, E), ze = new ce(new Array(0), G, 0, w, T);
      }
      function bt(L) {
        var he;
        for (he = 0; he < m; he++)
          L.dyn_ltree[he * 2] = 0;
        for (he = 0; he < g; he++)
          L.dyn_dtree[he * 2] = 0;
        for (he = 0; he < w; he++)
          L.bl_tree[he * 2] = 0;
        L.dyn_ltree[k * 2] = 1, L.opt_len = L.static_len = 0, L.last_lit = L.matches = 0;
      }
      function Kt(L) {
        L.bi_valid > 8 ? Be(L, L.bi_buf) : L.bi_valid > 0 && (L.pending_buf[L.pending++] = L.bi_buf), L.bi_buf = 0, L.bi_valid = 0;
      }
      function wt(L, he, ge, Ie) {
        Kt(L), Ie && (Be(L, ge), Be(L, ~ge)), s.arraySet(L.pending_buf, L.window, he, ge, L.pending), L.pending += ge;
      }
      function xt(L, he, ge, Ie) {
        var q = he * 2, ue = ge * 2;
        return L[q] < L[ue] || L[q] === L[ue] && Ie[he] <= Ie[ge];
      }
      function lt(L, he, ge) {
        for (var Ie = L.heap[ge], q = ge << 1; q <= L.heap_len && (q < L.heap_len && xt(he, L.heap[q + 1], L.heap[q], L.depth) && q++, !xt(he, Ie, L.heap[q], L.depth)); )
          L.heap[ge] = L.heap[q], ge = q, q <<= 1;
        L.heap[ge] = Ie;
      }
      function Ge(L, he, ge) {
        var Ie, q, ue = 0, O, B;
        if (L.last_lit !== 0)
          do
            Ie = L.pending_buf[L.d_buf + ue * 2] << 8 | L.pending_buf[L.d_buf + ue * 2 + 1], q = L.pending_buf[L.l_buf + ue], ue++, Ie === 0 ? ct(L, q, he) : (O = fe[q], ct(L, O + f + 1, he), B = D[O], B !== 0 && (q -= Y[O], He(L, q, B)), Ie--, O = Qe(Ie), ct(L, O, ge), B = z[O], B !== 0 && (Ie -= le[O], He(L, Ie, B)));
          while (ue < L.last_lit);
        ct(L, k, he);
      }
      function Rt(L, he) {
        var ge = he.dyn_tree, Ie = he.stat_desc.static_tree, q = he.stat_desc.has_stree, ue = he.stat_desc.elems, O, B, oe = -1, S;
        for (L.heap_len = 0, L.heap_max = _, O = 0; O < ue; O++)
          ge[O * 2] !== 0 ? (L.heap[++L.heap_len] = oe = O, L.depth[O] = 0) : ge[O * 2 + 1] = 0;
        for (; L.heap_len < 2; )
          S = L.heap[++L.heap_len] = oe < 2 ? ++oe : 0, ge[S * 2] = 1, L.depth[S] = 0, L.opt_len--, q && (L.static_len -= Ie[S * 2 + 1]);
        for (he.max_code = oe, O = L.heap_len >> 1; O >= 1; O--)
          lt(L, ge, O);
        S = ue;
        do
          O = L.heap[
            1
            /*SMALLEST*/
          ], L.heap[
            1
            /*SMALLEST*/
          ] = L.heap[L.heap_len--], lt(
            L,
            ge,
            1
            /*SMALLEST*/
          ), B = L.heap[
            1
            /*SMALLEST*/
          ], L.heap[--L.heap_max] = O, L.heap[--L.heap_max] = B, ge[S * 2] = ge[O * 2] + ge[B * 2], L.depth[S] = (L.depth[O] >= L.depth[B] ? L.depth[O] : L.depth[B]) + 1, ge[O * 2 + 1] = ge[B * 2 + 1] = S, L.heap[
            1
            /*SMALLEST*/
          ] = S++, lt(
            L,
            ge,
            1
            /*SMALLEST*/
          );
        while (L.heap_len >= 2);
        L.heap[--L.heap_max] = L.heap[
          1
          /*SMALLEST*/
        ], yt(L, he), It(ge, oe, L.bl_count);
      }
      function we(L, he, ge) {
        var Ie, q = -1, ue, O = he[0 * 2 + 1], B = 0, oe = 7, S = 4;
        for (O === 0 && (oe = 138, S = 3), he[(ge + 1) * 2 + 1] = 65535, Ie = 0; Ie <= ge; Ie++)
          ue = O, O = he[(Ie + 1) * 2 + 1], !(++B < oe && ue === O) && (B < S ? L.bl_tree[ue * 2] += B : ue !== 0 ? (ue !== q && L.bl_tree[ue * 2]++, L.bl_tree[N * 2]++) : B <= 10 ? L.bl_tree[I * 2]++ : L.bl_tree[P * 2]++, B = 0, q = ue, O === 0 ? (oe = 138, S = 3) : ue === O ? (oe = 6, S = 3) : (oe = 7, S = 4));
      }
      function Ue(L, he, ge) {
        var Ie, q = -1, ue, O = he[0 * 2 + 1], B = 0, oe = 7, S = 4;
        for (O === 0 && (oe = 138, S = 3), Ie = 0; Ie <= ge; Ie++)
          if (ue = O, O = he[(Ie + 1) * 2 + 1], !(++B < oe && ue === O)) {
            if (B < S)
              do
                ct(L, ue, L.bl_tree);
              while (--B !== 0);
            else
              ue !== 0 ? (ue !== q && (ct(L, ue, L.bl_tree), B--), ct(L, N, L.bl_tree), He(L, B - 3, 2)) : B <= 10 ? (ct(L, I, L.bl_tree), He(L, B - 3, 3)) : (ct(L, P, L.bl_tree), He(L, B - 11, 7));
            B = 0, q = ue, O === 0 ? (oe = 138, S = 3) : ue === O ? (oe = 6, S = 3) : (oe = 7, S = 4);
          }
      }
      function at(L) {
        var he;
        for (we(L, L.dyn_ltree, L.l_desc.max_code), we(L, L.dyn_dtree, L.d_desc.max_code), Rt(L, L.bl_desc), he = w - 1; he >= 3 && L.bl_tree[J[he] * 2 + 1] === 0; he--)
          ;
        return L.opt_len += 3 * (he + 1) + 5 + 5 + 4, he;
      }
      function Lt(L, he, ge, Ie) {
        var q;
        for (He(L, he - 257, 5), He(L, ge - 1, 5), He(L, Ie - 4, 4), q = 0; q < Ie; q++)
          He(L, L.bl_tree[J[q] * 2 + 1], 3);
        Ue(L, L.dyn_ltree, he - 1), Ue(L, L.dyn_dtree, ge - 1);
      }
      function Zt(L) {
        var he = 4093624447, ge;
        for (ge = 0; ge <= 31; ge++, he >>>= 1)
          if (he & 1 && L.dyn_ltree[ge * 2] !== 0)
            return a;
        if (L.dyn_ltree[9 * 2] !== 0 || L.dyn_ltree[10 * 2] !== 0 || L.dyn_ltree[13 * 2] !== 0)
          return l;
        for (ge = 32; ge < f; ge++)
          if (L.dyn_ltree[ge * 2] !== 0)
            return l;
        return a;
      }
      var Ae = !1;
      function Ve(L) {
        Ae || (ot(), Ae = !0), L.l_desc = new Oe(L.dyn_ltree, me), L.d_desc = new Oe(L.dyn_dtree, _e), L.bl_desc = new Oe(L.bl_tree, ze), L.bi_buf = 0, L.bi_valid = 0, bt(L);
      }
      function Ye(L, he, ge, Ie) {
        He(L, (d << 1) + (Ie ? 1 : 0), 3), wt(L, he, ge, !0);
      }
      function je(L) {
        He(L, h << 1, 3), ct(L, k, U), St(L);
      }
      function Ze(L, he, ge, Ie) {
        var q, ue, O = 0;
        L.level > 0 ? (L.strm.data_type === u && (L.strm.data_type = Zt(L)), Rt(L, L.l_desc), Rt(L, L.d_desc), O = at(L), q = L.opt_len + 3 + 7 >>> 3, ue = L.static_len + 3 + 7 >>> 3, ue <= q && (q = ue)) : q = ue = ge + 5, ge + 4 <= q && he !== -1 ? Ye(L, he, ge, Ie) : L.strategy === o || ue === q ? (He(L, (h << 1) + (Ie ? 1 : 0), 3), Ge(L, U, j)) : (He(L, (v << 1) + (Ie ? 1 : 0), 3), Lt(L, L.l_desc.max_code + 1, L.d_desc.max_code + 1, O + 1), Ge(L, L.dyn_ltree, L.dyn_dtree)), bt(L), Ie && Kt(L);
      }
      function Ct(L, he, ge) {
        return L.pending_buf[L.d_buf + L.last_lit * 2] = he >>> 8 & 255, L.pending_buf[L.d_buf + L.last_lit * 2 + 1] = he & 255, L.pending_buf[L.l_buf + L.last_lit] = ge & 255, L.last_lit++, he === 0 ? L.dyn_ltree[ge * 2]++ : (L.matches++, he--, L.dyn_ltree[(fe[ge] + f + 1) * 2]++, L.dyn_dtree[Qe(he) * 2]++), L.last_lit === L.lit_bufsize - 1;
      }
      i._tr_init = Ve, i._tr_stored_block = Ye, i._tr_flush_block = Ze, i._tr_tally = Ct, i._tr_align = je;
    }, { "../utils/common": 41 }], 53: [function(n, r, i) {
      function s() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      }
      r.exports = s;
    }, {}], 54: [function(n, r, i) {
      (function(s) {
        (function(o, a) {
          if (o.setImmediate)
            return;
          var l = 1, u = {}, c = !1, d = o.document, h;
          function v(T) {
            typeof T != "function" && (T = new Function("" + T));
            for (var k = new Array(arguments.length - 1), N = 0; N < k.length; N++)
              k[N] = arguments[N + 1];
            var I = { callback: T, args: k };
            return u[l] = I, h(l), l++;
          }
          function y(T) {
            delete u[T];
          }
          function b(T) {
            var k = T.callback, N = T.args;
            switch (N.length) {
              case 0:
                k();
                break;
              case 1:
                k(N[0]);
                break;
              case 2:
                k(N[0], N[1]);
                break;
              case 3:
                k(N[0], N[1], N[2]);
                break;
              default:
                k.apply(a, N);
                break;
            }
          }
          function p(T) {
            if (c)
              setTimeout(p, 0, T);
            else {
              var k = u[T];
              if (k) {
                c = !0;
                try {
                  b(k);
                } finally {
                  y(T), c = !1;
                }
              }
            }
          }
          function f() {
            h = function(T) {
              process.nextTick(function() {
                p(T);
              });
            };
          }
          function m() {
            if (o.postMessage && !o.importScripts) {
              var T = !0, k = o.onmessage;
              return o.onmessage = function() {
                T = !1;
              }, o.postMessage("", "*"), o.onmessage = k, T;
            }
          }
          function g() {
            var T = "setImmediate$" + Math.random() + "$", k = function(N) {
              N.source === o && typeof N.data == "string" && N.data.indexOf(T) === 0 && p(+N.data.slice(T.length));
            };
            o.addEventListener ? o.addEventListener("message", k, !1) : o.attachEvent("onmessage", k), h = function(N) {
              o.postMessage(T + N, "*");
            };
          }
          function w() {
            var T = new MessageChannel();
            T.port1.onmessage = function(k) {
              var N = k.data;
              p(N);
            }, h = function(k) {
              T.port2.postMessage(k);
            };
          }
          function _() {
            var T = d.documentElement;
            h = function(k) {
              var N = d.createElement("script");
              N.onreadystatechange = function() {
                p(k), N.onreadystatechange = null, T.removeChild(N), N = null;
              }, T.appendChild(N);
            };
          }
          function E() {
            h = function(T) {
              setTimeout(p, 0, T);
            };
          }
          var C = Object.getPrototypeOf && Object.getPrototypeOf(o);
          C = C && C.setTimeout ? C : o, {}.toString.call(o.process) === "[object process]" ? f() : m() ? g() : o.MessageChannel ? w() : d && "onreadystatechange" in d.createElement("script") ? _() : E(), C.setImmediate = v, C.clearImmediate = y;
        })(typeof self > "u" ? typeof s > "u" ? this : s : self);
      }).call(this, typeof gn < "u" ? gn : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(Z6);
class Q6 {
  constructor() {
    this.zip = void 0, this.urlCache = {}, this.checkRequirements();
  }
  /**
   * Checks to see if JSZip exists in global namspace,
   * Requires JSZip if it isn't there
   * @private
   */
  checkRequirements() {
    try {
      this.zip = new ad();
    } catch {
      throw new Error("JSZip lib not loaded");
    }
  }
  /**
   * Open an archive
   * @param  {binary} input
   * @param  {boolean} [isBase64] tells JSZip if the input data is base64 encoded
   * @return {Promise} zipfile
   */
  open(e, n) {
    return this.zip.loadAsync(e, { base64: n });
  }
  /**
   * Load and Open an archive
   * @param  {string} zipUrl
   * @param  {boolean} [isBase64] tells JSZip if the input data is base64 encoded
   * @return {Promise} zipfile
   */
  openUrl(e, n) {
    return Uo(e, "binary").then(function(r) {
      return this.zip.loadAsync(r, { base64: n });
    }.bind(this));
  }
  /**
   * Request a url from the archive
   * @param  {string} url  a url to request from the archive
   * @param  {string} [type] specify the type of the returned result
   * @return {Promise<Blob | string | JSON | Document | XMLDocument>}
   */
  request(e, n) {
    var r = new vt(), i, s = new ri(e);
    return n || (n = s.extension), n == "blob" ? i = this.getBlob(e) : i = this.getText(e), i ? i.then(function(o) {
      let a = this.handleResponse(o, n);
      r.resolve(a);
    }.bind(this)) : r.reject({
      message: "File not found in the epub: " + e,
      stack: new Error().stack
    }), r.promise;
  }
  /**
   * Handle the response from request
   * @private
   * @param  {any} response
   * @param  {string} [type]
   * @return {any} the parsed result
   */
  handleResponse(e, n) {
    var r;
    return n == "json" ? r = JSON.parse(e) : jo(n) ? r = Tr(e, "text/xml") : n == "xhtml" ? r = Tr(e, "application/xhtml+xml") : n == "html" || n == "htm" ? r = Tr(e, "text/html") : r = e, r;
  }
  /**
   * Get a Blob from Archive by Url
   * @param  {string} url
   * @param  {string} [mimeType]
   * @return {Blob}
   */
  getBlob(e, n) {
    var r = window.decodeURIComponent(e.substr(1)), i = this.zip.file(r);
    if (i)
      return n = n || xs.lookup(i.name), i.async("uint8array").then(function(s) {
        return new Blob([s], { type: n });
      });
  }
  /**
   * Get Text from Archive by Url
   * @param  {string} url
   * @param  {string} [encoding]
   * @return {string}
   */
  getText(e, n) {
    var r = window.decodeURIComponent(e.substr(1)), i = this.zip.file(r);
    if (i)
      return i.async("string").then(function(s) {
        return s;
      });
  }
  /**
   * Get a base64 encoded result from Archive by Url
   * @param  {string} url
   * @param  {string} [mimeType]
   * @return {string} base64 encoded
   */
  getBase64(e, n) {
    var r = window.decodeURIComponent(e.substr(1)), i = this.zip.file(r);
    if (i)
      return n = n || xs.lookup(i.name), i.async("base64").then(function(s) {
        return "data:" + n + ";base64," + s;
      });
  }
  /**
   * Create a Url from an unarchived item
   * @param  {string} url
   * @param  {object} [options.base64] use base64 encoding or blob url
   * @return {Promise} url promise with Url string
   */
  createUrl(e, n) {
    var r = new vt(), i = window.URL || window.webkitURL || window.mozURL, s, o, a = n && n.base64;
    return e in this.urlCache ? (r.resolve(this.urlCache[e]), r.promise) : (a ? (o = this.getBase64(e), o && o.then(function(l) {
      this.urlCache[e] = l, r.resolve(l);
    }.bind(this))) : (o = this.getBlob(e), o && o.then(function(l) {
      s = i.createObjectURL(l), this.urlCache[e] = s, r.resolve(s);
    }.bind(this))), o || r.reject({
      message: "File not found in the epub: " + e,
      stack: new Error().stack
    }), r.promise);
  }
  /**
   * Revoke Temp Url for a archive item
   * @param  {string} url url of the item in the archive
   */
  revokeUrl(e) {
    var n = window.URL || window.webkitURL || window.mozURL, r = this.urlCache[e];
    r && n.revokeObjectURL(r);
  }
  destroy() {
    var e = window.URL || window.webkitURL || window.mozURL;
    for (let n in this.urlCache)
      e.revokeObjectURL(n);
    this.zip = void 0, this.urlCache = {};
  }
}
var $l = {}, J6 = {
  get exports() {
    return $l;
  },
  set exports(t) {
    $l = t;
  }
};
/*!
    localForage -- Offline Storage, Improved
    Version 1.10.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
(function(t, e) {
  (function(n) {
    t.exports = n();
  })(function() {
    return function n(r, i, s) {
      function o(u, c) {
        if (!i[u]) {
          if (!r[u]) {
            var d = typeof gi == "function" && gi;
            if (!c && d)
              return d(u, !0);
            if (a)
              return a(u, !0);
            var h = new Error("Cannot find module '" + u + "'");
            throw h.code = "MODULE_NOT_FOUND", h;
          }
          var v = i[u] = { exports: {} };
          r[u][0].call(v.exports, function(y) {
            var b = r[u][1][y];
            return o(b || y);
          }, v, v.exports, n, r, i, s);
        }
        return i[u].exports;
      }
      for (var a = typeof gi == "function" && gi, l = 0; l < s.length; l++)
        o(s[l]);
      return o;
    }({ 1: [function(n, r, i) {
      (function(s) {
        var o = s.MutationObserver || s.WebKitMutationObserver, a;
        if (o) {
          var l = 0, u = new o(y), c = s.document.createTextNode("");
          u.observe(c, {
            characterData: !0
          }), a = function() {
            c.data = l = ++l % 2;
          };
        } else if (!s.setImmediate && typeof s.MessageChannel < "u") {
          var d = new s.MessageChannel();
          d.port1.onmessage = y, a = function() {
            d.port2.postMessage(0);
          };
        } else
          "document" in s && "onreadystatechange" in s.document.createElement("script") ? a = function() {
            var p = s.document.createElement("script");
            p.onreadystatechange = function() {
              y(), p.onreadystatechange = null, p.parentNode.removeChild(p), p = null;
            }, s.document.documentElement.appendChild(p);
          } : a = function() {
            setTimeout(y, 0);
          };
        var h, v = [];
        function y() {
          h = !0;
          for (var p, f, m = v.length; m; ) {
            for (f = v, v = [], p = -1; ++p < m; )
              f[p]();
            m = v.length;
          }
          h = !1;
        }
        r.exports = b;
        function b(p) {
          v.push(p) === 1 && !h && a();
        }
      }).call(this, typeof gn < "u" ? gn : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 2: [function(n, r, i) {
      var s = n(1);
      function o() {
      }
      var a = {}, l = ["REJECTED"], u = ["FULFILLED"], c = ["PENDING"];
      r.exports = d;
      function d(_) {
        if (typeof _ != "function")
          throw new TypeError("resolver must be a function");
        this.state = c, this.queue = [], this.outcome = void 0, _ !== o && b(this, _);
      }
      d.prototype.catch = function(_) {
        return this.then(null, _);
      }, d.prototype.then = function(_, E) {
        if (typeof _ != "function" && this.state === u || typeof E != "function" && this.state === l)
          return this;
        var C = new this.constructor(o);
        if (this.state !== c) {
          var T = this.state === u ? _ : E;
          v(C, T, this.outcome);
        } else
          this.queue.push(new h(C, _, E));
        return C;
      };
      function h(_, E, C) {
        this.promise = _, typeof E == "function" && (this.onFulfilled = E, this.callFulfilled = this.otherCallFulfilled), typeof C == "function" && (this.onRejected = C, this.callRejected = this.otherCallRejected);
      }
      h.prototype.callFulfilled = function(_) {
        a.resolve(this.promise, _);
      }, h.prototype.otherCallFulfilled = function(_) {
        v(this.promise, this.onFulfilled, _);
      }, h.prototype.callRejected = function(_) {
        a.reject(this.promise, _);
      }, h.prototype.otherCallRejected = function(_) {
        v(this.promise, this.onRejected, _);
      };
      function v(_, E, C) {
        s(function() {
          var T;
          try {
            T = E(C);
          } catch (k) {
            return a.reject(_, k);
          }
          T === _ ? a.reject(_, new TypeError("Cannot resolve promise with itself")) : a.resolve(_, T);
        });
      }
      a.resolve = function(_, E) {
        var C = p(y, E);
        if (C.status === "error")
          return a.reject(_, C.value);
        var T = C.value;
        if (T)
          b(_, T);
        else {
          _.state = u, _.outcome = E;
          for (var k = -1, N = _.queue.length; ++k < N; )
            _.queue[k].callFulfilled(E);
        }
        return _;
      }, a.reject = function(_, E) {
        _.state = l, _.outcome = E;
        for (var C = -1, T = _.queue.length; ++C < T; )
          _.queue[C].callRejected(E);
        return _;
      };
      function y(_) {
        var E = _ && _.then;
        if (_ && (typeof _ == "object" || typeof _ == "function") && typeof E == "function")
          return function() {
            E.apply(_, arguments);
          };
      }
      function b(_, E) {
        var C = !1;
        function T(P) {
          C || (C = !0, a.reject(_, P));
        }
        function k(P) {
          C || (C = !0, a.resolve(_, P));
        }
        function N() {
          E(k, T);
        }
        var I = p(N);
        I.status === "error" && T(I.value);
      }
      function p(_, E) {
        var C = {};
        try {
          C.value = _(E), C.status = "success";
        } catch (T) {
          C.status = "error", C.value = T;
        }
        return C;
      }
      d.resolve = f;
      function f(_) {
        return _ instanceof this ? _ : a.resolve(new this(o), _);
      }
      d.reject = m;
      function m(_) {
        var E = new this(o);
        return a.reject(E, _);
      }
      d.all = g;
      function g(_) {
        var E = this;
        if (Object.prototype.toString.call(_) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var C = _.length, T = !1;
        if (!C)
          return this.resolve([]);
        for (var k = new Array(C), N = 0, I = -1, P = new this(o); ++I < C; )
          D(_[I], I);
        return P;
        function D(z, G) {
          E.resolve(z).then(J, function(M) {
            T || (T = !0, a.reject(P, M));
          });
          function J(M) {
            k[G] = M, ++N === C && !T && (T = !0, a.resolve(P, k));
          }
        }
      }
      d.race = w;
      function w(_) {
        var E = this;
        if (Object.prototype.toString.call(_) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var C = _.length, T = !1;
        if (!C)
          return this.resolve([]);
        for (var k = -1, N = new this(o); ++k < C; )
          I(_[k]);
        return N;
        function I(P) {
          E.resolve(P).then(function(D) {
            T || (T = !0, a.resolve(N, D));
          }, function(D) {
            T || (T = !0, a.reject(N, D));
          });
        }
      }
    }, { 1: 1 }], 3: [function(n, r, i) {
      (function(s) {
        typeof s.Promise != "function" && (s.Promise = n(2));
      }).call(this, typeof gn < "u" ? gn : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { 2: 2 }], 4: [function(n, r, i) {
      var s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(R) {
        return typeof R;
      } : function(R) {
        return R && typeof Symbol == "function" && R.constructor === Symbol && R !== Symbol.prototype ? "symbol" : typeof R;
      };
      function o(R, H) {
        if (!(R instanceof H))
          throw new TypeError("Cannot call a class as a function");
      }
      function a() {
        try {
          if (typeof indexedDB < "u")
            return indexedDB;
          if (typeof webkitIndexedDB < "u")
            return webkitIndexedDB;
          if (typeof mozIndexedDB < "u")
            return mozIndexedDB;
          if (typeof OIndexedDB < "u")
            return OIndexedDB;
          if (typeof msIndexedDB < "u")
            return msIndexedDB;
        } catch {
          return;
        }
      }
      var l = a();
      function u() {
        try {
          if (!l || !l.open)
            return !1;
          var R = typeof openDatabase < "u" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform), H = typeof fetch == "function" && fetch.toString().indexOf("[native code") !== -1;
          return (!R || H) && typeof indexedDB < "u" && // some outdated implementations of IDB that appear on Samsung
          // and HTC Android devices <4.4 are missing IDBKeyRange
          // See: https://github.com/mozilla/localForage/issues/128
          // See: https://github.com/mozilla/localForage/issues/272
          typeof IDBKeyRange < "u";
        } catch {
          return !1;
        }
      }
      function c(R, H) {
        R = R || [], H = H || {};
        try {
          return new Blob(R, H);
        } catch (X) {
          if (X.name !== "TypeError")
            throw X;
          for (var $ = typeof BlobBuilder < "u" ? BlobBuilder : typeof MSBlobBuilder < "u" ? MSBlobBuilder : typeof MozBlobBuilder < "u" ? MozBlobBuilder : WebKitBlobBuilder, Q = new $(), te = 0; te < R.length; te += 1)
            Q.append(R[te]);
          return Q.getBlob(H.type);
        }
      }
      typeof Promise > "u" && n(3);
      var d = Promise;
      function h(R, H) {
        H && R.then(function($) {
          H(null, $);
        }, function($) {
          H($);
        });
      }
      function v(R, H, $) {
        typeof H == "function" && R.then(H), typeof $ == "function" && R.catch($);
      }
      function y(R) {
        return typeof R != "string" && (console.warn(R + " used as a key, but it is not a string."), R = String(R)), R;
      }
      function b() {
        if (arguments.length && typeof arguments[arguments.length - 1] == "function")
          return arguments[arguments.length - 1];
      }
      var p = "local-forage-detect-blob-support", f = void 0, m = {}, g = Object.prototype.toString, w = "readonly", _ = "readwrite";
      function E(R) {
        for (var H = R.length, $ = new ArrayBuffer(H), Q = new Uint8Array($), te = 0; te < H; te++)
          Q[te] = R.charCodeAt(te);
        return $;
      }
      function C(R) {
        return new d(function(H) {
          var $ = R.transaction(p, _), Q = c([""]);
          $.objectStore(p).put(Q, "key"), $.onabort = function(te) {
            te.preventDefault(), te.stopPropagation(), H(!1);
          }, $.oncomplete = function() {
            var te = navigator.userAgent.match(/Chrome\/(\d+)/), X = navigator.userAgent.match(/Edge\//);
            H(X || !te || parseInt(te[1], 10) >= 43);
          };
        }).catch(function() {
          return !1;
        });
      }
      function T(R) {
        return typeof f == "boolean" ? d.resolve(f) : C(R).then(function(H) {
          return f = H, f;
        });
      }
      function k(R) {
        var H = m[R.name], $ = {};
        $.promise = new d(function(Q, te) {
          $.resolve = Q, $.reject = te;
        }), H.deferredOperations.push($), H.dbReady ? H.dbReady = H.dbReady.then(function() {
          return $.promise;
        }) : H.dbReady = $.promise;
      }
      function N(R) {
        var H = m[R.name], $ = H.deferredOperations.pop();
        if ($)
          return $.resolve(), $.promise;
      }
      function I(R, H) {
        var $ = m[R.name], Q = $.deferredOperations.pop();
        if (Q)
          return Q.reject(H), Q.promise;
      }
      function P(R, H) {
        return new d(function($, Q) {
          if (m[R.name] = m[R.name] || Y(), R.db)
            if (H)
              k(R), R.db.close();
            else
              return $(R.db);
          var te = [R.name];
          H && te.push(R.version);
          var X = l.open.apply(l, te);
          H && (X.onupgradeneeded = function(pe) {
            var Ee = X.result;
            try {
              Ee.createObjectStore(R.storeName), pe.oldVersion <= 1 && Ee.createObjectStore(p);
            } catch (Se) {
              if (Se.name === "ConstraintError")
                console.warn('The database "' + R.name + '" has been upgraded from version ' + pe.oldVersion + " to version " + pe.newVersion + ', but the storage "' + R.storeName + '" already exists.');
              else
                throw Se;
            }
          }), X.onerror = function(pe) {
            pe.preventDefault(), Q(X.error);
          }, X.onsuccess = function() {
            var pe = X.result;
            pe.onversionchange = function(Ee) {
              Ee.target.close();
            }, $(pe), N(R);
          };
        });
      }
      function D(R) {
        return P(R, !1);
      }
      function z(R) {
        return P(R, !0);
      }
      function G(R, H) {
        if (!R.db)
          return !0;
        var $ = !R.db.objectStoreNames.contains(R.storeName), Q = R.version < R.db.version, te = R.version > R.db.version;
        if (Q && (R.version !== H && console.warn('The database "' + R.name + `" can't be downgraded from version ` + R.db.version + " to version " + R.version + "."), R.version = R.db.version), te || $) {
          if ($) {
            var X = R.db.version + 1;
            X > R.version && (R.version = X);
          }
          return !0;
        }
        return !1;
      }
      function J(R) {
        return new d(function(H, $) {
          var Q = new FileReader();
          Q.onerror = $, Q.onloadend = function(te) {
            var X = btoa(te.target.result || "");
            H({
              __local_forage_encoded_blob: !0,
              data: X,
              type: R.type
            });
          }, Q.readAsBinaryString(R);
        });
      }
      function M(R) {
        var H = E(atob(R.data));
        return c([H], { type: R.type });
      }
      function U(R) {
        return R && R.__local_forage_encoded_blob;
      }
      function j(R) {
        var H = this, $ = H._initReady().then(function() {
          var Q = m[H._dbInfo.name];
          if (Q && Q.dbReady)
            return Q.dbReady;
        });
        return v($, R, R), $;
      }
      function re(R) {
        k(R);
        for (var H = m[R.name], $ = H.forages, Q = 0; Q < $.length; Q++) {
          var te = $[Q];
          te._dbInfo.db && (te._dbInfo.db.close(), te._dbInfo.db = null);
        }
        return R.db = null, D(R).then(function(X) {
          return R.db = X, G(R) ? z(R) : X;
        }).then(function(X) {
          R.db = H.db = X;
          for (var pe = 0; pe < $.length; pe++)
            $[pe]._dbInfo.db = X;
        }).catch(function(X) {
          throw I(R, X), X;
        });
      }
      function fe(R, H, $, Q) {
        Q === void 0 && (Q = 1);
        try {
          var te = R.db.transaction(R.storeName, H);
          $(null, te);
        } catch (X) {
          if (Q > 0 && (!R.db || X.name === "InvalidStateError" || X.name === "NotFoundError"))
            return d.resolve().then(function() {
              if (!R.db || X.name === "NotFoundError" && !R.db.objectStoreNames.contains(R.storeName) && R.version <= R.db.version)
                return R.db && (R.version = R.db.version + 1), z(R);
            }).then(function() {
              return re(R).then(function() {
                fe(R, H, $, Q - 1);
              });
            }).catch($);
          $(X);
        }
      }
      function Y() {
        return {
          // Running localForages sharing a database.
          forages: [],
          // Shared database.
          db: null,
          // Database readiness (promise).
          dbReady: null,
          // Deferred operations on the database.
          deferredOperations: []
        };
      }
      function le(R) {
        var H = this, $ = {
          db: null
        };
        if (R)
          for (var Q in R)
            $[Q] = R[Q];
        var te = m[$.name];
        te || (te = Y(), m[$.name] = te), te.forages.push(H), H._initReady || (H._initReady = H.ready, H.ready = j);
        var X = [];
        function pe() {
          return d.resolve();
        }
        for (var Ee = 0; Ee < te.forages.length; Ee++) {
          var Se = te.forages[Ee];
          Se !== H && X.push(Se._initReady().catch(pe));
        }
        var xe = te.forages.slice(0);
        return d.all(X).then(function() {
          return $.db = te.db, D($);
        }).then(function(Te) {
          return $.db = Te, G($, H._defaultConfig.version) ? z($) : Te;
        }).then(function(Te) {
          $.db = te.db = Te, H._dbInfo = $;
          for (var We = 0; We < xe.length; We++) {
            var dt = xe[We];
            dt !== H && (dt._dbInfo.db = $.db, dt._dbInfo.version = $.version);
          }
        });
      }
      function ce(R, H) {
        var $ = this;
        R = y(R);
        var Q = new d(function(te, X) {
          $.ready().then(function() {
            fe($._dbInfo, w, function(pe, Ee) {
              if (pe)
                return X(pe);
              try {
                var Se = Ee.objectStore($._dbInfo.storeName), xe = Se.get(R);
                xe.onsuccess = function() {
                  var Te = xe.result;
                  Te === void 0 && (Te = null), U(Te) && (Te = M(Te)), te(Te);
                }, xe.onerror = function() {
                  X(xe.error);
                };
              } catch (Te) {
                X(Te);
              }
            });
          }).catch(X);
        });
        return h(Q, H), Q;
      }
      function me(R, H) {
        var $ = this, Q = new d(function(te, X) {
          $.ready().then(function() {
            fe($._dbInfo, w, function(pe, Ee) {
              if (pe)
                return X(pe);
              try {
                var Se = Ee.objectStore($._dbInfo.storeName), xe = Se.openCursor(), Te = 1;
                xe.onsuccess = function() {
                  var We = xe.result;
                  if (We) {
                    var dt = We.value;
                    U(dt) && (dt = M(dt));
                    var kt = R(dt, We.key, Te++);
                    kt !== void 0 ? te(kt) : We.continue();
                  } else
                    te();
                }, xe.onerror = function() {
                  X(xe.error);
                };
              } catch (We) {
                X(We);
              }
            });
          }).catch(X);
        });
        return h(Q, H), Q;
      }
      function _e(R, H, $) {
        var Q = this;
        R = y(R);
        var te = new d(function(X, pe) {
          var Ee;
          Q.ready().then(function() {
            return Ee = Q._dbInfo, g.call(H) === "[object Blob]" ? T(Ee.db).then(function(Se) {
              return Se ? H : J(H);
            }) : H;
          }).then(function(Se) {
            fe(Q._dbInfo, _, function(xe, Te) {
              if (xe)
                return pe(xe);
              try {
                var We = Te.objectStore(Q._dbInfo.storeName);
                Se === null && (Se = void 0);
                var dt = We.put(Se, R);
                Te.oncomplete = function() {
                  Se === void 0 && (Se = null), X(Se);
                }, Te.onabort = Te.onerror = function() {
                  var kt = dt.error ? dt.error : dt.transaction.error;
                  pe(kt);
                };
              } catch (kt) {
                pe(kt);
              }
            });
          }).catch(pe);
        });
        return h(te, $), te;
      }
      function ze(R, H) {
        var $ = this;
        R = y(R);
        var Q = new d(function(te, X) {
          $.ready().then(function() {
            fe($._dbInfo, _, function(pe, Ee) {
              if (pe)
                return X(pe);
              try {
                var Se = Ee.objectStore($._dbInfo.storeName), xe = Se.delete(R);
                Ee.oncomplete = function() {
                  te();
                }, Ee.onerror = function() {
                  X(xe.error);
                }, Ee.onabort = function() {
                  var Te = xe.error ? xe.error : xe.transaction.error;
                  X(Te);
                };
              } catch (Te) {
                X(Te);
              }
            });
          }).catch(X);
        });
        return h(Q, H), Q;
      }
      function Oe(R) {
        var H = this, $ = new d(function(Q, te) {
          H.ready().then(function() {
            fe(H._dbInfo, _, function(X, pe) {
              if (X)
                return te(X);
              try {
                var Ee = pe.objectStore(H._dbInfo.storeName), Se = Ee.clear();
                pe.oncomplete = function() {
                  Q();
                }, pe.onabort = pe.onerror = function() {
                  var xe = Se.error ? Se.error : Se.transaction.error;
                  te(xe);
                };
              } catch (xe) {
                te(xe);
              }
            });
          }).catch(te);
        });
        return h($, R), $;
      }
      function Qe(R) {
        var H = this, $ = new d(function(Q, te) {
          H.ready().then(function() {
            fe(H._dbInfo, w, function(X, pe) {
              if (X)
                return te(X);
              try {
                var Ee = pe.objectStore(H._dbInfo.storeName), Se = Ee.count();
                Se.onsuccess = function() {
                  Q(Se.result);
                }, Se.onerror = function() {
                  te(Se.error);
                };
              } catch (xe) {
                te(xe);
              }
            });
          }).catch(te);
        });
        return h($, R), $;
      }
      function Be(R, H) {
        var $ = this, Q = new d(function(te, X) {
          if (R < 0) {
            te(null);
            return;
          }
          $.ready().then(function() {
            fe($._dbInfo, w, function(pe, Ee) {
              if (pe)
                return X(pe);
              try {
                var Se = Ee.objectStore($._dbInfo.storeName), xe = !1, Te = Se.openKeyCursor();
                Te.onsuccess = function() {
                  var We = Te.result;
                  if (!We) {
                    te(null);
                    return;
                  }
                  R === 0 || xe ? te(We.key) : (xe = !0, We.advance(R));
                }, Te.onerror = function() {
                  X(Te.error);
                };
              } catch (We) {
                X(We);
              }
            });
          }).catch(X);
        });
        return h(Q, H), Q;
      }
      function He(R) {
        var H = this, $ = new d(function(Q, te) {
          H.ready().then(function() {
            fe(H._dbInfo, w, function(X, pe) {
              if (X)
                return te(X);
              try {
                var Ee = pe.objectStore(H._dbInfo.storeName), Se = Ee.openKeyCursor(), xe = [];
                Se.onsuccess = function() {
                  var Te = Se.result;
                  if (!Te) {
                    Q(xe);
                    return;
                  }
                  xe.push(Te.key), Te.continue();
                }, Se.onerror = function() {
                  te(Se.error);
                };
              } catch (Te) {
                te(Te);
              }
            });
          }).catch(te);
        });
        return h($, R), $;
      }
      function ct(R, H) {
        H = b.apply(this, arguments);
        var $ = this.config();
        R = typeof R != "function" && R || {}, R.name || (R.name = R.name || $.name, R.storeName = R.storeName || $.storeName);
        var Q = this, te;
        if (!R.name)
          te = d.reject("Invalid arguments");
        else {
          var X = R.name === $.name && Q._dbInfo.db, pe = X ? d.resolve(Q._dbInfo.db) : D(R).then(function(Ee) {
            var Se = m[R.name], xe = Se.forages;
            Se.db = Ee;
            for (var Te = 0; Te < xe.length; Te++)
              xe[Te]._dbInfo.db = Ee;
            return Ee;
          });
          R.storeName ? te = pe.then(function(Ee) {
            if (Ee.objectStoreNames.contains(R.storeName)) {
              var Se = Ee.version + 1;
              k(R);
              var xe = m[R.name], Te = xe.forages;
              Ee.close();
              for (var We = 0; We < Te.length; We++) {
                var dt = Te[We];
                dt._dbInfo.db = null, dt._dbInfo.version = Se;
              }
              var kt = new d(function(Nt, rn) {
                var Jt = l.open(R.name, Se);
                Jt.onerror = function(Qn) {
                  var qs = Jt.result;
                  qs.close(), rn(Qn);
                }, Jt.onupgradeneeded = function() {
                  var Qn = Jt.result;
                  Qn.deleteObjectStore(R.storeName);
                }, Jt.onsuccess = function() {
                  var Qn = Jt.result;
                  Qn.close(), Nt(Qn);
                };
              });
              return kt.then(function(Nt) {
                xe.db = Nt;
                for (var rn = 0; rn < Te.length; rn++) {
                  var Jt = Te[rn];
                  Jt._dbInfo.db = Nt, N(Jt._dbInfo);
                }
              }).catch(function(Nt) {
                throw (I(R, Nt) || d.resolve()).catch(function() {
                }), Nt;
              });
            }
          }) : te = pe.then(function(Ee) {
            k(R);
            var Se = m[R.name], xe = Se.forages;
            Ee.close();
            for (var Te = 0; Te < xe.length; Te++) {
              var We = xe[Te];
              We._dbInfo.db = null;
            }
            var dt = new d(function(kt, Nt) {
              var rn = l.deleteDatabase(R.name);
              rn.onerror = function() {
                var Jt = rn.result;
                Jt && Jt.close(), Nt(rn.error);
              }, rn.onblocked = function() {
                console.warn('dropInstance blocked for database "' + R.name + '" until all open connections are closed');
              }, rn.onsuccess = function() {
                var Jt = rn.result;
                Jt && Jt.close(), kt(Jt);
              };
            });
            return dt.then(function(kt) {
              Se.db = kt;
              for (var Nt = 0; Nt < xe.length; Nt++) {
                var rn = xe[Nt];
                N(rn._dbInfo);
              }
            }).catch(function(kt) {
              throw (I(R, kt) || d.resolve()).catch(function() {
              }), kt;
            });
          });
        }
        return h(te, H), te;
      }
      var nt = {
        _driver: "asyncStorage",
        _initStorage: le,
        _support: u(),
        iterate: me,
        getItem: ce,
        setItem: _e,
        removeItem: ze,
        clear: Oe,
        length: Qe,
        key: Be,
        keys: He,
        dropInstance: ct
      };
      function St() {
        return typeof openDatabase == "function";
      }
      var yt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", It = "~~local_forage_type~", ot = /^~~local_forage_type~([^~]+)~/, bt = "__lfsc__:", Kt = bt.length, wt = "arbf", xt = "blob", lt = "si08", Ge = "ui08", Rt = "uic8", we = "si16", Ue = "si32", at = "ur16", Lt = "ui32", Zt = "fl32", Ae = "fl64", Ve = Kt + wt.length, Ye = Object.prototype.toString;
      function je(R) {
        var H = R.length * 0.75, $ = R.length, Q, te = 0, X, pe, Ee, Se;
        R[R.length - 1] === "=" && (H--, R[R.length - 2] === "=" && H--);
        var xe = new ArrayBuffer(H), Te = new Uint8Array(xe);
        for (Q = 0; Q < $; Q += 4)
          X = yt.indexOf(R[Q]), pe = yt.indexOf(R[Q + 1]), Ee = yt.indexOf(R[Q + 2]), Se = yt.indexOf(R[Q + 3]), Te[te++] = X << 2 | pe >> 4, Te[te++] = (pe & 15) << 4 | Ee >> 2, Te[te++] = (Ee & 3) << 6 | Se & 63;
        return xe;
      }
      function Ze(R) {
        var H = new Uint8Array(R), $ = "", Q;
        for (Q = 0; Q < H.length; Q += 3)
          $ += yt[H[Q] >> 2], $ += yt[(H[Q] & 3) << 4 | H[Q + 1] >> 4], $ += yt[(H[Q + 1] & 15) << 2 | H[Q + 2] >> 6], $ += yt[H[Q + 2] & 63];
        return H.length % 3 === 2 ? $ = $.substring(0, $.length - 1) + "=" : H.length % 3 === 1 && ($ = $.substring(0, $.length - 2) + "=="), $;
      }
      function Ct(R, H) {
        var $ = "";
        if (R && ($ = Ye.call(R)), R && ($ === "[object ArrayBuffer]" || R.buffer && Ye.call(R.buffer) === "[object ArrayBuffer]")) {
          var Q, te = bt;
          R instanceof ArrayBuffer ? (Q = R, te += wt) : (Q = R.buffer, $ === "[object Int8Array]" ? te += lt : $ === "[object Uint8Array]" ? te += Ge : $ === "[object Uint8ClampedArray]" ? te += Rt : $ === "[object Int16Array]" ? te += we : $ === "[object Uint16Array]" ? te += at : $ === "[object Int32Array]" ? te += Ue : $ === "[object Uint32Array]" ? te += Lt : $ === "[object Float32Array]" ? te += Zt : $ === "[object Float64Array]" ? te += Ae : H(new Error("Failed to get type for BinaryArray"))), H(te + Ze(Q));
        } else if ($ === "[object Blob]") {
          var X = new FileReader();
          X.onload = function() {
            var pe = It + R.type + "~" + Ze(this.result);
            H(bt + xt + pe);
          }, X.readAsArrayBuffer(R);
        } else
          try {
            H(JSON.stringify(R));
          } catch (pe) {
            console.error("Couldn't convert value into a JSON string: ", R), H(null, pe);
          }
      }
      function L(R) {
        if (R.substring(0, Kt) !== bt)
          return JSON.parse(R);
        var H = R.substring(Ve), $ = R.substring(Kt, Ve), Q;
        if ($ === xt && ot.test(H)) {
          var te = H.match(ot);
          Q = te[1], H = H.substring(te[0].length);
        }
        var X = je(H);
        switch ($) {
          case wt:
            return X;
          case xt:
            return c([X], { type: Q });
          case lt:
            return new Int8Array(X);
          case Ge:
            return new Uint8Array(X);
          case Rt:
            return new Uint8ClampedArray(X);
          case we:
            return new Int16Array(X);
          case at:
            return new Uint16Array(X);
          case Ue:
            return new Int32Array(X);
          case Lt:
            return new Uint32Array(X);
          case Zt:
            return new Float32Array(X);
          case Ae:
            return new Float64Array(X);
          default:
            throw new Error("Unkown type: " + $);
        }
      }
      var he = {
        serialize: Ct,
        deserialize: L,
        stringToBuffer: je,
        bufferToString: Ze
      };
      function ge(R, H, $, Q) {
        R.executeSql("CREATE TABLE IF NOT EXISTS " + H.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], $, Q);
      }
      function Ie(R) {
        var H = this, $ = {
          db: null
        };
        if (R)
          for (var Q in R)
            $[Q] = typeof R[Q] != "string" ? R[Q].toString() : R[Q];
        var te = new d(function(X, pe) {
          try {
            $.db = openDatabase($.name, String($.version), $.description, $.size);
          } catch (Ee) {
            return pe(Ee);
          }
          $.db.transaction(function(Ee) {
            ge(Ee, $, function() {
              H._dbInfo = $, X();
            }, function(Se, xe) {
              pe(xe);
            });
          }, pe);
        });
        return $.serializer = he, te;
      }
      function q(R, H, $, Q, te, X) {
        R.executeSql($, Q, te, function(pe, Ee) {
          Ee.code === Ee.SYNTAX_ERR ? pe.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [H.storeName], function(Se, xe) {
            xe.rows.length ? X(Se, Ee) : ge(Se, H, function() {
              Se.executeSql($, Q, te, X);
            }, X);
          }, X) : X(pe, Ee);
        }, X);
      }
      function ue(R, H) {
        var $ = this;
        R = y(R);
        var Q = new d(function(te, X) {
          $.ready().then(function() {
            var pe = $._dbInfo;
            pe.db.transaction(function(Ee) {
              q(Ee, pe, "SELECT * FROM " + pe.storeName + " WHERE key = ? LIMIT 1", [R], function(Se, xe) {
                var Te = xe.rows.length ? xe.rows.item(0).value : null;
                Te && (Te = pe.serializer.deserialize(Te)), te(Te);
              }, function(Se, xe) {
                X(xe);
              });
            });
          }).catch(X);
        });
        return h(Q, H), Q;
      }
      function O(R, H) {
        var $ = this, Q = new d(function(te, X) {
          $.ready().then(function() {
            var pe = $._dbInfo;
            pe.db.transaction(function(Ee) {
              q(Ee, pe, "SELECT * FROM " + pe.storeName, [], function(Se, xe) {
                for (var Te = xe.rows, We = Te.length, dt = 0; dt < We; dt++) {
                  var kt = Te.item(dt), Nt = kt.value;
                  if (Nt && (Nt = pe.serializer.deserialize(Nt)), Nt = R(Nt, kt.key, dt + 1), Nt !== void 0) {
                    te(Nt);
                    return;
                  }
                }
                te();
              }, function(Se, xe) {
                X(xe);
              });
            });
          }).catch(X);
        });
        return h(Q, H), Q;
      }
      function B(R, H, $, Q) {
        var te = this;
        R = y(R);
        var X = new d(function(pe, Ee) {
          te.ready().then(function() {
            H === void 0 && (H = null);
            var Se = H, xe = te._dbInfo;
            xe.serializer.serialize(H, function(Te, We) {
              We ? Ee(We) : xe.db.transaction(function(dt) {
                q(dt, xe, "INSERT OR REPLACE INTO " + xe.storeName + " (key, value) VALUES (?, ?)", [R, Te], function() {
                  pe(Se);
                }, function(kt, Nt) {
                  Ee(Nt);
                });
              }, function(dt) {
                if (dt.code === dt.QUOTA_ERR) {
                  if (Q > 0) {
                    pe(B.apply(te, [R, Se, $, Q - 1]));
                    return;
                  }
                  Ee(dt);
                }
              });
            });
          }).catch(Ee);
        });
        return h(X, $), X;
      }
      function oe(R, H, $) {
        return B.apply(this, [R, H, $, 1]);
      }
      function S(R, H) {
        var $ = this;
        R = y(R);
        var Q = new d(function(te, X) {
          $.ready().then(function() {
            var pe = $._dbInfo;
            pe.db.transaction(function(Ee) {
              q(Ee, pe, "DELETE FROM " + pe.storeName + " WHERE key = ?", [R], function() {
                te();
              }, function(Se, xe) {
                X(xe);
              });
            });
          }).catch(X);
        });
        return h(Q, H), Q;
      }
      function Z(R) {
        var H = this, $ = new d(function(Q, te) {
          H.ready().then(function() {
            var X = H._dbInfo;
            X.db.transaction(function(pe) {
              q(pe, X, "DELETE FROM " + X.storeName, [], function() {
                Q();
              }, function(Ee, Se) {
                te(Se);
              });
            });
          }).catch(te);
        });
        return h($, R), $;
      }
      function ie(R) {
        var H = this, $ = new d(function(Q, te) {
          H.ready().then(function() {
            var X = H._dbInfo;
            X.db.transaction(function(pe) {
              q(pe, X, "SELECT COUNT(key) as c FROM " + X.storeName, [], function(Ee, Se) {
                var xe = Se.rows.item(0).c;
                Q(xe);
              }, function(Ee, Se) {
                te(Se);
              });
            });
          }).catch(te);
        });
        return h($, R), $;
      }
      function A(R, H) {
        var $ = this, Q = new d(function(te, X) {
          $.ready().then(function() {
            var pe = $._dbInfo;
            pe.db.transaction(function(Ee) {
              q(Ee, pe, "SELECT key FROM " + pe.storeName + " WHERE id = ? LIMIT 1", [R + 1], function(Se, xe) {
                var Te = xe.rows.length ? xe.rows.item(0).key : null;
                te(Te);
              }, function(Se, xe) {
                X(xe);
              });
            });
          }).catch(X);
        });
        return h(Q, H), Q;
      }
      function W(R) {
        var H = this, $ = new d(function(Q, te) {
          H.ready().then(function() {
            var X = H._dbInfo;
            X.db.transaction(function(pe) {
              q(pe, X, "SELECT key FROM " + X.storeName, [], function(Ee, Se) {
                for (var xe = [], Te = 0; Te < Se.rows.length; Te++)
                  xe.push(Se.rows.item(Te).key);
                Q(xe);
              }, function(Ee, Se) {
                te(Se);
              });
            });
          }).catch(te);
        });
        return h($, R), $;
      }
      function ne(R) {
        return new d(function(H, $) {
          R.transaction(function(Q) {
            Q.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(te, X) {
              for (var pe = [], Ee = 0; Ee < X.rows.length; Ee++)
                pe.push(X.rows.item(Ee).name);
              H({
                db: R,
                storeNames: pe
              });
            }, function(te, X) {
              $(X);
            });
          }, function(Q) {
            $(Q);
          });
        });
      }
      function Le(R, H) {
        H = b.apply(this, arguments);
        var $ = this.config();
        R = typeof R != "function" && R || {}, R.name || (R.name = R.name || $.name, R.storeName = R.storeName || $.storeName);
        var Q = this, te;
        return R.name ? te = new d(function(X) {
          var pe;
          R.name === $.name ? pe = Q._dbInfo.db : pe = openDatabase(R.name, "", "", 0), R.storeName ? X({
            db: pe,
            storeNames: [R.storeName]
          }) : X(ne(pe));
        }).then(function(X) {
          return new d(function(pe, Ee) {
            X.db.transaction(function(Se) {
              function xe(kt) {
                return new d(function(Nt, rn) {
                  Se.executeSql("DROP TABLE IF EXISTS " + kt, [], function() {
                    Nt();
                  }, function(Jt, Qn) {
                    rn(Qn);
                  });
                });
              }
              for (var Te = [], We = 0, dt = X.storeNames.length; We < dt; We++)
                Te.push(xe(X.storeNames[We]));
              d.all(Te).then(function() {
                pe();
              }).catch(function(kt) {
                Ee(kt);
              });
            }, function(Se) {
              Ee(Se);
            });
          });
        }) : te = d.reject("Invalid arguments"), h(te, H), te;
      }
      var Ne = {
        _driver: "webSQLStorage",
        _initStorage: Ie,
        _support: St(),
        iterate: O,
        getItem: ue,
        setItem: oe,
        removeItem: S,
        clear: Z,
        length: ie,
        key: A,
        keys: W,
        dropInstance: Le
      };
      function $e() {
        try {
          return typeof localStorage < "u" && "setItem" in localStorage && // in IE8 typeof localStorage.setItem === 'object'
          !!localStorage.setItem;
        } catch {
          return !1;
        }
      }
      function Xe(R, H) {
        var $ = R.name + "/";
        return R.storeName !== H.storeName && ($ += R.storeName + "/"), $;
      }
      function ln() {
        var R = "_localforage_support_test";
        try {
          return localStorage.setItem(R, !0), localStorage.removeItem(R), !1;
        } catch {
          return !0;
        }
      }
      function Wt() {
        return !ln() || localStorage.length > 0;
      }
      function pt(R) {
        var H = this, $ = {};
        if (R)
          for (var Q in R)
            $[Q] = R[Q];
        return $.keyPrefix = Xe(R, H._defaultConfig), Wt() ? (H._dbInfo = $, $.serializer = he, d.resolve()) : d.reject();
      }
      function Qt(R) {
        var H = this, $ = H.ready().then(function() {
          for (var Q = H._dbInfo.keyPrefix, te = localStorage.length - 1; te >= 0; te--) {
            var X = localStorage.key(te);
            X.indexOf(Q) === 0 && localStorage.removeItem(X);
          }
        });
        return h($, R), $;
      }
      function fn(R, H) {
        var $ = this;
        R = y(R);
        var Q = $.ready().then(function() {
          var te = $._dbInfo, X = localStorage.getItem(te.keyPrefix + R);
          return X && (X = te.serializer.deserialize(X)), X;
        });
        return h(Q, H), Q;
      }
      function xn(R, H) {
        var $ = this, Q = $.ready().then(function() {
          for (var te = $._dbInfo, X = te.keyPrefix, pe = X.length, Ee = localStorage.length, Se = 1, xe = 0; xe < Ee; xe++) {
            var Te = localStorage.key(xe);
            if (Te.indexOf(X) === 0) {
              var We = localStorage.getItem(Te);
              if (We && (We = te.serializer.deserialize(We)), We = R(We, Te.substring(pe), Se++), We !== void 0)
                return We;
            }
          }
        });
        return h(Q, H), Q;
      }
      function es(R, H) {
        var $ = this, Q = $.ready().then(function() {
          var te = $._dbInfo, X;
          try {
            X = localStorage.key(R);
          } catch {
            X = null;
          }
          return X && (X = X.substring(te.keyPrefix.length)), X;
        });
        return h(Q, H), Q;
      }
      function ts(R) {
        var H = this, $ = H.ready().then(function() {
          for (var Q = H._dbInfo, te = localStorage.length, X = [], pe = 0; pe < te; pe++) {
            var Ee = localStorage.key(pe);
            Ee.indexOf(Q.keyPrefix) === 0 && X.push(Ee.substring(Q.keyPrefix.length));
          }
          return X;
        });
        return h($, R), $;
      }
      function Yt(R) {
        var H = this, $ = H.keys().then(function(Q) {
          return Q.length;
        });
        return h($, R), $;
      }
      function $n(R, H) {
        var $ = this;
        R = y(R);
        var Q = $.ready().then(function() {
          var te = $._dbInfo;
          localStorage.removeItem(te.keyPrefix + R);
        });
        return h(Q, H), Q;
      }
      function un(R, H, $) {
        var Q = this;
        R = y(R);
        var te = Q.ready().then(function() {
          H === void 0 && (H = null);
          var X = H;
          return new d(function(pe, Ee) {
            var Se = Q._dbInfo;
            Se.serializer.serialize(H, function(xe, Te) {
              if (Te)
                Ee(Te);
              else
                try {
                  localStorage.setItem(Se.keyPrefix + R, xe), pe(X);
                } catch (We) {
                  (We.name === "QuotaExceededError" || We.name === "NS_ERROR_DOM_QUOTA_REACHED") && Ee(We), Ee(We);
                }
            });
          });
        });
        return h(te, $), te;
      }
      function ar(R, H) {
        if (H = b.apply(this, arguments), R = typeof R != "function" && R || {}, !R.name) {
          var $ = this.config();
          R.name = R.name || $.name, R.storeName = R.storeName || $.storeName;
        }
        var Q = this, te;
        return R.name ? te = new d(function(X) {
          R.storeName ? X(Xe(R, Q._defaultConfig)) : X(R.name + "/");
        }).then(function(X) {
          for (var pe = localStorage.length - 1; pe >= 0; pe--) {
            var Ee = localStorage.key(pe);
            Ee.indexOf(X) === 0 && localStorage.removeItem(Ee);
          }
        }) : te = d.reject("Invalid arguments"), h(te, H), te;
      }
      var Zn = {
        _driver: "localStorageWrapper",
        _initStorage: pt,
        _support: $e(),
        iterate: xn,
        getItem: fn,
        setItem: un,
        removeItem: $n,
        clear: Qt,
        length: Yt,
        key: es,
        keys: ts,
        dropInstance: ar
      }, da = function(H, $) {
        return H === $ || typeof H == "number" && typeof $ == "number" && isNaN(H) && isNaN($);
      }, Dy = function(H, $) {
        for (var Q = H.length, te = 0; te < Q; ) {
          if (da(H[te], $))
            return !0;
          te++;
        }
        return !1;
      }, $f = Array.isArray || function(R) {
        return Object.prototype.toString.call(R) === "[object Array]";
      }, Ks = {}, Df = {}, ns = {
        INDEXEDDB: nt,
        WEBSQL: Ne,
        LOCALSTORAGE: Zn
      }, By = [ns.INDEXEDDB._driver, ns.WEBSQL._driver, ns.LOCALSTORAGE._driver], fa = ["dropInstance"], lu = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(fa), My = {
        description: "",
        driver: By.slice(),
        name: "localforage",
        // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
        // we can use without a prompt.
        size: 4980736,
        storeName: "keyvaluepairs",
        version: 1
      };
      function zy(R, H) {
        R[H] = function() {
          var $ = arguments;
          return R.ready().then(function() {
            return R[H].apply(R, $);
          });
        };
      }
      function uu() {
        for (var R = 1; R < arguments.length; R++) {
          var H = arguments[R];
          if (H)
            for (var $ in H)
              H.hasOwnProperty($) && ($f(H[$]) ? arguments[0][$] = H[$].slice() : arguments[0][$] = H[$]);
        }
        return arguments[0];
      }
      var Fy = function() {
        function R(H) {
          o(this, R);
          for (var $ in ns)
            if (ns.hasOwnProperty($)) {
              var Q = ns[$], te = Q._driver;
              this[$] = te, Ks[te] || this.defineDriver(Q);
            }
          this._defaultConfig = uu({}, My), this._config = uu({}, this._defaultConfig, H), this._driverSet = null, this._initDriver = null, this._ready = !1, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch(function() {
          });
        }
        return R.prototype.config = function($) {
          if ((typeof $ > "u" ? "undefined" : s($)) === "object") {
            if (this._ready)
              return new Error("Can't call config() after localforage has been used.");
            for (var Q in $) {
              if (Q === "storeName" && ($[Q] = $[Q].replace(/\W/g, "_")), Q === "version" && typeof $[Q] != "number")
                return new Error("Database version must be a number.");
              this._config[Q] = $[Q];
            }
            return "driver" in $ && $.driver ? this.setDriver(this._config.driver) : !0;
          } else
            return typeof $ == "string" ? this._config[$] : this._config;
        }, R.prototype.defineDriver = function($, Q, te) {
          var X = new d(function(pe, Ee) {
            try {
              var Se = $._driver, xe = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
              if (!$._driver) {
                Ee(xe);
                return;
              }
              for (var Te = lu.concat("_initStorage"), We = 0, dt = Te.length; We < dt; We++) {
                var kt = Te[We], Nt = !Dy(fa, kt);
                if ((Nt || $[kt]) && typeof $[kt] != "function") {
                  Ee(xe);
                  return;
                }
              }
              var rn = function() {
                for (var qs = function(Vy) {
                  return function() {
                    var Wy = new Error("Method " + Vy + " is not implemented by the current driver"), Bf = d.reject(Wy);
                    return h(Bf, arguments[arguments.length - 1]), Bf;
                  };
                }, cu = 0, Uy = fa.length; cu < Uy; cu++) {
                  var du = fa[cu];
                  $[du] || ($[du] = qs(du));
                }
              };
              rn();
              var Jt = function(qs) {
                Ks[Se] && console.info("Redefining LocalForage driver: " + Se), Ks[Se] = $, Df[Se] = qs, pe();
              };
              "_support" in $ ? $._support && typeof $._support == "function" ? $._support().then(Jt, Ee) : Jt(!!$._support) : Jt(!0);
            } catch (Qn) {
              Ee(Qn);
            }
          });
          return v(X, Q, te), X;
        }, R.prototype.driver = function() {
          return this._driver || null;
        }, R.prototype.getDriver = function($, Q, te) {
          var X = Ks[$] ? d.resolve(Ks[$]) : d.reject(new Error("Driver not found."));
          return v(X, Q, te), X;
        }, R.prototype.getSerializer = function($) {
          var Q = d.resolve(he);
          return v(Q, $), Q;
        }, R.prototype.ready = function($) {
          var Q = this, te = Q._driverSet.then(function() {
            return Q._ready === null && (Q._ready = Q._initDriver()), Q._ready;
          });
          return v(te, $, $), te;
        }, R.prototype.setDriver = function($, Q, te) {
          var X = this;
          $f($) || ($ = [$]);
          var pe = this._getSupportedDrivers($);
          function Ee() {
            X._config.driver = X.driver();
          }
          function Se(We) {
            return X._extend(We), Ee(), X._ready = X._initStorage(X._config), X._ready;
          }
          function xe(We) {
            return function() {
              var dt = 0;
              function kt() {
                for (; dt < We.length; ) {
                  var Nt = We[dt];
                  return dt++, X._dbInfo = null, X._ready = null, X.getDriver(Nt).then(Se).catch(kt);
                }
                Ee();
                var rn = new Error("No available storage method found.");
                return X._driverSet = d.reject(rn), X._driverSet;
              }
              return kt();
            };
          }
          var Te = this._driverSet !== null ? this._driverSet.catch(function() {
            return d.resolve();
          }) : d.resolve();
          return this._driverSet = Te.then(function() {
            var We = pe[0];
            return X._dbInfo = null, X._ready = null, X.getDriver(We).then(function(dt) {
              X._driver = dt._driver, Ee(), X._wrapLibraryMethodsWithReady(), X._initDriver = xe(pe);
            });
          }).catch(function() {
            Ee();
            var We = new Error("No available storage method found.");
            return X._driverSet = d.reject(We), X._driverSet;
          }), v(this._driverSet, Q, te), this._driverSet;
        }, R.prototype.supports = function($) {
          return !!Df[$];
        }, R.prototype._extend = function($) {
          uu(this, $);
        }, R.prototype._getSupportedDrivers = function($) {
          for (var Q = [], te = 0, X = $.length; te < X; te++) {
            var pe = $[te];
            this.supports(pe) && Q.push(pe);
          }
          return Q;
        }, R.prototype._wrapLibraryMethodsWithReady = function() {
          for (var $ = 0, Q = lu.length; $ < Q; $++)
            zy(this, lu[$]);
        }, R.prototype.createInstance = function($) {
          return new R($);
        }, R;
      }(), jy = new Fy();
      r.exports = jy;
    }, { 3: 3 }] }, {}, [4])(4);
  });
})(J6);
class Ly {
  constructor(e, n, r) {
    this.urlCache = {}, this.storage = void 0, this.name = e, this.requester = n || Uo, this.resolver = r, this.online = !0, this.checkRequirements(), this.addListeners();
  }
  /**
   * Checks to see if localForage exists in global namspace,
   * Requires localForage if it isn't there
   * @private
   */
  checkRequirements() {
    try {
      let e;
      typeof $l > "u" && (e = $l), this.storage = e.createInstance({
        name: this.name
      });
    } catch {
      throw new Error("localForage lib not loaded");
    }
  }
  /**
   * Add online and offline event listeners
   * @private
   */
  addListeners() {
    this._status = this.status.bind(this), window.addEventListener("online", this._status), window.addEventListener("offline", this._status);
  }
  /**
   * Remove online and offline event listeners
   * @private
   */
  removeListeners() {
    window.removeEventListener("online", this._status), window.removeEventListener("offline", this._status), this._status = void 0;
  }
  /**
   * Update the online / offline status
   * @private
   */
  status(e) {
    let n = navigator.onLine;
    this.online = n, n ? this.emit("online", this) : this.emit("offline", this);
  }
  /**
   * Add all of a book resources to the store
   * @param  {Resources} resources  book resources
   * @param  {boolean} [force] force resaving resources
   * @return {Promise<object>} store objects
   */
  add(e, n) {
    let r = e.resources.map((i) => {
      let { href: s } = i, o = this.resolver(s), a = window.encodeURIComponent(o);
      return this.storage.getItem(a).then((l) => !l || n ? this.requester(o, "binary").then((u) => this.storage.setItem(a, u)) : l);
    });
    return Promise.all(r);
  }
  /**
   * Put binary data from a url to storage
   * @param  {string} url  a url to request from storage
   * @param  {boolean} [withCredentials]
   * @param  {object} [headers]
   * @return {Promise<Blob>}
   */
  put(e, n, r) {
    let i = window.encodeURIComponent(e);
    return this.storage.getItem(i).then((s) => s || this.requester(e, "binary", n, r).then((o) => this.storage.setItem(i, o)));
  }
  /**
   * Request a url
   * @param  {string} url  a url to request from storage
   * @param  {string} [type] specify the type of the returned result
   * @param  {boolean} [withCredentials]
   * @param  {object} [headers]
   * @return {Promise<Blob | string | JSON | Document | XMLDocument>}
   */
  request(e, n, r, i) {
    return this.online ? this.requester(e, n, r, i).then((s) => (this.put(e), s)) : this.retrieve(e, n);
  }
  /**
   * Request a url from storage
   * @param  {string} url  a url to request from storage
   * @param  {string} [type] specify the type of the returned result
   * @return {Promise<Blob | string | JSON | Document | XMLDocument>}
   */
  retrieve(e, n) {
    new vt();
    var r, i = new ri(e);
    return n || (n = i.extension), n == "blob" ? r = this.getBlob(e) : r = this.getText(e), r.then((s) => {
      var o = new vt(), a;
      return s ? (a = this.handleResponse(s, n), o.resolve(a)) : o.reject({
        message: "File not found in storage: " + e,
        stack: new Error().stack
      }), o.promise;
    });
  }
  /**
   * Handle the response from request
   * @private
   * @param  {any} response
   * @param  {string} [type]
   * @return {any} the parsed result
   */
  handleResponse(e, n) {
    var r;
    return n == "json" ? r = JSON.parse(e) : jo(n) ? r = Tr(e, "text/xml") : n == "xhtml" ? r = Tr(e, "application/xhtml+xml") : n == "html" || n == "htm" ? r = Tr(e, "text/html") : r = e, r;
  }
  /**
   * Get a Blob from Storage by Url
   * @param  {string} url
   * @param  {string} [mimeType]
   * @return {Blob}
   */
  getBlob(e, n) {
    let r = window.encodeURIComponent(e);
    return this.storage.getItem(r).then(function(i) {
      if (i)
        return n = n || xs.lookup(e), new Blob([i], { type: n });
    });
  }
  /**
   * Get Text from Storage by Url
   * @param  {string} url
   * @param  {string} [mimeType]
   * @return {string}
   */
  getText(e, n) {
    let r = window.encodeURIComponent(e);
    return n = n || xs.lookup(e), this.storage.getItem(r).then(function(i) {
      var s = new vt(), o = new FileReader(), a;
      if (i)
        return a = new Blob([i], { type: n }), o.addEventListener("loadend", () => {
          s.resolve(o.result);
        }), o.readAsText(a, n), s.promise;
    });
  }
  /**
   * Get a base64 encoded result from Storage by Url
   * @param  {string} url
   * @param  {string} [mimeType]
   * @return {string} base64 encoded
   */
  getBase64(e, n) {
    let r = window.encodeURIComponent(e);
    return n = n || xs.lookup(e), this.storage.getItem(r).then((i) => {
      var s = new vt(), o = new FileReader(), a;
      if (i)
        return a = new Blob([i], { type: n }), o.addEventListener("loadend", () => {
          s.resolve(o.result);
        }), o.readAsDataURL(a, n), s.promise;
    });
  }
  /**
   * Create a Url from a stored item
   * @param  {string} url
   * @param  {object} [options.base64] use base64 encoding or blob url
   * @return {Promise} url promise with Url string
   */
  createUrl(e, n) {
    var r = new vt(), i = window.URL || window.webkitURL || window.mozURL, s, o, a = n && n.base64;
    return e in this.urlCache ? (r.resolve(this.urlCache[e]), r.promise) : (a ? (o = this.getBase64(e), o && o.then(function(l) {
      this.urlCache[e] = l, r.resolve(l);
    }.bind(this))) : (o = this.getBlob(e), o && o.then(function(l) {
      s = i.createObjectURL(l), this.urlCache[e] = s, r.resolve(s);
    }.bind(this))), o || r.reject({
      message: "File not found in storage: " + e,
      stack: new Error().stack
    }), r.promise);
  }
  /**
   * Revoke Temp Url for a archive item
   * @param  {string} url url of the item in the store
   */
  revokeUrl(e) {
    var n = window.URL || window.webkitURL || window.mozURL, r = this.urlCache[e];
    r && n.revokeObjectURL(r);
  }
  destroy() {
    var e = window.URL || window.webkitURL || window.mozURL;
    for (let n in this.urlCache)
      e.revokeObjectURL(n);
    this.urlCache = {}, this.removeListeners();
  }
}
Br(Ly.prototype);
class qu {
  constructor(e) {
    this.interactive = "", this.fixedLayout = "", this.openToSpread = "", this.orientationLock = "", e && this.parse(e);
  }
  /**
   * Parse XML
   * @param  {document} displayOptionsDocument XML
   * @return {DisplayOptions} self
   */
  parse(e) {
    if (!e)
      return this;
    const n = Mt(e, "display_options");
    return n ? (ni(n, "option").forEach((i) => {
      let s = "";
      switch (i.childNodes.length && (s = i.childNodes[0].nodeValue), i.attributes.name.value) {
        case "interactive":
          this.interactive = s;
          break;
        case "fixed-layout":
          this.fixedLayout = s;
          break;
        case "open-to-spread":
          this.openToSpread = s;
          break;
        case "orientation-lock":
          this.orientationLock = s;
          break;
      }
    }), this) : this;
  }
  destroy() {
    this.interactive = void 0, this.fixedLayout = void 0, this.openToSpread = void 0, this.orientationLock = void 0;
  }
}
const fv = "META-INF/container.xml", eD = "META-INF/com.apple.ibooks.display-options.xml", ur = {
  BINARY: "binary",
  BASE64: "base64",
  EPUB: "epub",
  OPF: "opf",
  MANIFEST: "json",
  DIRECTORY: "directory"
};
class Pf {
  constructor(e, n) {
    typeof n > "u" && typeof e != "string" && !(e instanceof Blob) && !(e instanceof ArrayBuffer) && (n = e, e = void 0), this.settings = En(this.settings || {}, {
      requestMethod: void 0,
      requestCredentials: void 0,
      requestHeaders: void 0,
      encoding: void 0,
      replacements: void 0,
      canonical: void 0,
      openAs: void 0,
      store: void 0
    }), En(this.settings, n), this.opening = new vt(), this.opened = this.opening.promise, this.isOpen = !1, this.loading = {
      manifest: new vt(),
      spine: new vt(),
      metadata: new vt(),
      cover: new vt(),
      navigation: new vt(),
      pageList: new vt(),
      resources: new vt(),
      displayOptions: new vt()
    }, this.loaded = {
      manifest: this.loading.manifest.promise,
      spine: this.loading.spine.promise,
      metadata: this.loading.metadata.promise,
      cover: this.loading.cover.promise,
      navigation: this.loading.navigation.promise,
      pageList: this.loading.pageList.promise,
      resources: this.loading.resources.promise,
      displayOptions: this.loading.displayOptions.promise
    }, this.ready = Promise.all([
      this.loaded.manifest,
      this.loaded.spine,
      this.loaded.metadata,
      this.loaded.cover,
      this.loaded.navigation,
      this.loaded.resources,
      this.loaded.displayOptions
    ]), this.isRendered = !1, this.request = this.settings.requestMethod || Uo, this.spine = new _$(), this.locations = new gy(this.spine, this.load.bind(this)), this.navigation = void 0, this.pageList = void 0, this.url = void 0, this.path = void 0, this.archived = !1, this.archive = void 0, this.storage = void 0, this.resources = void 0, this.rendition = void 0, this.container = void 0, this.packaging = void 0, this.displayOptions = void 0, this.settings.store && this.store(this.settings.store), e && this.open(e, this.settings.openAs).catch((r) => {
      var i = new Error("Cannot load book at " + e);
      this.emit(Re.BOOK.OPEN_FAILED, i);
    });
  }
  /**
   * Open a epub or url
   * @param {string | ArrayBuffer} input Url, Path or ArrayBuffer
   * @param {string} [what="binary", "base64", "epub", "opf", "json", "directory"] force opening as a certain type
   * @returns {Promise} of when the book has been loaded
   * @example book.open("/path/to/book.epub")
   */
  open(e, n) {
    var r, i = n || this.determineType(e);
    return i === ur.BINARY ? (this.archived = !0, this.url = new fr("/", ""), r = this.openEpub(e)) : i === ur.BASE64 ? (this.archived = !0, this.url = new fr("/", ""), r = this.openEpub(e, i)) : i === ur.EPUB ? (this.archived = !0, this.url = new fr("/", ""), r = this.request(e, "binary", this.settings.requestCredentials, this.settings.requestHeaders).then(this.openEpub.bind(this))) : i == ur.OPF ? (this.url = new fr(e), r = this.openPackaging(this.url.Path.toString())) : i == ur.MANIFEST ? (this.url = new fr(e), r = this.openManifest(this.url.Path.toString())) : (this.url = new fr(e), r = this.openContainer(fv).then(this.openPackaging.bind(this))), r;
  }
  /**
   * Open an archived epub
   * @private
   * @param  {binary} data
   * @param  {string} [encoding]
   * @return {Promise}
   */
  openEpub(e, n) {
    return this.unarchive(e, n || this.settings.encoding).then(() => this.openContainer(fv)).then((r) => this.openPackaging(r));
  }
  /**
   * Open the epub container
   * @private
   * @param  {string} url
   * @return {string} packagePath
   */
  openContainer(e) {
    return this.load(e).then((n) => (this.container = new E$(n), this.resolve(this.container.packagePath)));
  }
  /**
   * Open the Open Packaging Format Xml
   * @private
   * @param  {string} url
   * @return {Promise}
   */
  openPackaging(e) {
    return this.path = new ri(e), this.load(e).then((n) => (this.packaging = new iv(n), this.unpack(this.packaging)));
  }
  /**
   * Open the manifest JSON
   * @private
   * @param  {string} url
   * @return {Promise}
   */
  openManifest(e) {
    return this.path = new ri(e), this.load(e).then((n) => (this.packaging = new iv(), this.packaging.load(n), this.unpack(this.packaging)));
  }
  /**
   * Load a resource from the Book
   * @param  {string} path path to the resource to load
   * @return {Promise}     returns a promise with the requested resource
   */
  load(e) {
    var n = this.resolve(e);
    return this.archived ? this.archive.request(n) : this.request(n, null, this.settings.requestCredentials, this.settings.requestHeaders);
  }
  /**
   * Resolve a path to it's absolute position in the Book
   * @param  {string} path
   * @param  {boolean} [absolute] force resolving the full URL
   * @return {string}          the resolved path string
   */
  resolve(e, n) {
    if (e) {
      var r = e, i = e.indexOf("://") > -1;
      return i ? e : (this.path && (r = this.path.resolve(e)), n != !1 && this.url && (r = this.url.resolve(r)), r);
    }
  }
  /**
   * Get a canonical link to a path
   * @param  {string} path
   * @return {string} the canonical path string
   */
  canonical(e) {
    var n = e;
    return e ? (this.settings.canonical ? n = this.settings.canonical(e) : n = this.resolve(e, !0), n) : "";
  }
  /**
   * Determine the type of they input passed to open
   * @private
   * @param  {string} input
   * @return {string}  binary | directory | epub | opf
   */
  determineType(e) {
    var n, r, i;
    if (this.settings.encoding === "base64")
      return ur.BASE64;
    if (typeof e != "string")
      return ur.BINARY;
    if (n = new fr(e), r = n.path(), i = r.extension, i && (i = i.replace(/\?.*$/, "")), !i)
      return ur.DIRECTORY;
    if (i === "epub")
      return ur.EPUB;
    if (i === "opf")
      return ur.OPF;
    if (i === "json")
      return ur.MANIFEST;
  }
  /**
   * unpack the contents of the Books packaging
   * @private
   * @param {Packaging} packaging object
   */
  unpack(e) {
    this.package = e, this.packaging.metadata.layout === "" ? this.load(this.url.resolve(eD)).then((n) => {
      this.displayOptions = new qu(n), this.loading.displayOptions.resolve(this.displayOptions);
    }).catch((n) => {
      this.displayOptions = new qu(), this.loading.displayOptions.resolve(this.displayOptions);
    }) : (this.displayOptions = new qu(), this.loading.displayOptions.resolve(this.displayOptions)), this.spine.unpack(this.packaging, this.resolve.bind(this), this.canonical.bind(this)), this.resources = new k$(this.packaging.manifest, {
      archive: this.archive,
      resolver: this.resolve.bind(this),
      request: this.request.bind(this),
      replacements: this.settings.replacements || (this.archived ? "blobUrl" : "base64")
    }), this.loadNavigation(this.packaging).then(() => {
      this.loading.navigation.resolve(this.navigation);
    }), this.packaging.coverPath && (this.cover = this.resolve(this.packaging.coverPath)), this.loading.manifest.resolve(this.packaging.manifest), this.loading.metadata.resolve(this.packaging.metadata), this.loading.spine.resolve(this.spine), this.loading.cover.resolve(this.cover), this.loading.resources.resolve(this.resources), this.loading.pageList.resolve(this.pageList), this.isOpen = !0, this.archived || this.settings.replacements && this.settings.replacements != "none" ? this.replacements().then(() => {
      this.loaded.displayOptions.then(() => {
        this.opening.resolve(this);
      });
    }).catch((n) => {
      console.error(n);
    }) : this.loaded.displayOptions.then(() => {
      this.opening.resolve(this);
    });
  }
  /**
   * Load Navigation and PageList from package
   * @private
   * @param {Packaging} packaging
   */
  loadNavigation(e) {
    let n = e.navPath || e.ncxPath, r = e.toc;
    return r ? new Promise((i, s) => {
      this.navigation = new Wu(r), e.pageList && (this.pageList = new Hu(e.pageList)), i(this.navigation);
    }) : n ? this.load(n, "xml").then((i) => (this.navigation = new Wu(i), this.pageList = new Hu(i), this.navigation)) : new Promise((i, s) => {
      this.navigation = new Wu(), this.pageList = new Hu(), i(this.navigation);
    });
  }
  /**
   * Gets a Section of the Book from the Spine
   * Alias for `book.spine.get`
   * @param {string} target
   * @return {Section}
   */
  section(e) {
    return this.spine.get(e);
  }
  /**
   * Sugar to render a book to an element
   * @param  {element | string} element element or string to add a rendition to
   * @param  {object} [options]
   * @return {Rendition}
   */
  renderTo(e, n) {
    return this.rendition = new Lf(this, n), this.rendition.attachTo(e), this.rendition;
  }
  /**
   * Set if request should use withCredentials
   * @param {boolean} credentials
   */
  setRequestCredentials(e) {
    this.settings.requestCredentials = e;
  }
  /**
   * Set headers request should use
   * @param {object} headers
   */
  setRequestHeaders(e) {
    this.settings.requestHeaders = e;
  }
  /**
   * Unarchive a zipped epub
   * @private
   * @param  {binary} input epub data
   * @param  {string} [encoding]
   * @return {Archive}
   */
  unarchive(e, n) {
    return this.archive = new Q6(), this.archive.open(e, n);
  }
  /**
   * Store the epubs contents
   * @private
   * @param  {binary} input epub data
   * @param  {string} [encoding]
   * @return {Store}
   */
  store(e) {
    let n = this.settings.replacements && this.settings.replacements !== "none", r = this.url, i = this.settings.requestMethod || Uo.bind(this);
    return this.storage = new Ly(e, i, this.resolve.bind(this)), this.request = this.storage.request.bind(this.storage), this.opened.then(() => {
      this.archived && (this.storage.requester = this.archive.request.bind(this.archive));
      let s = (o, a) => {
        a.output = this.resources.substitute(o, a.url);
      };
      this.resources.settings.replacements = n || "blobUrl", this.resources.replacements().then(() => this.resources.replaceCss()), this.storage.on("offline", () => {
        this.url = new fr("/", ""), this.spine.hooks.serialize.register(s);
      }), this.storage.on("online", () => {
        this.url = r, this.spine.hooks.serialize.deregister(s);
      });
    }), this.storage;
  }
  /**
   * Get the cover url
   * @return {Promise<?string>} coverUrl
   */
  coverUrl() {
    return this.loaded.cover.then(() => this.cover ? this.archived ? this.archive.createUrl(this.cover) : this.cover : null);
  }
  /**
   * Load replacement urls
   * @private
   * @return {Promise} completed loading urls
   */
  replacements() {
    return this.spine.hooks.serialize.register((e, n) => {
      n.output = this.resources.substitute(e, n.url);
    }), this.resources.replacements().then(() => this.resources.replaceCss());
  }
  /**
   * Find a DOM Range for a given CFI Range
   * @param  {EpubCFI} cfiRange a epub cfi range
   * @return {Promise}
   */
  getRange(e) {
    var n = new mt(e), r = this.spine.get(n.spinePos), i = this.load.bind(this);
    return r ? r.load(i).then(function(s) {
      var o = n.toRange(r.document);
      return o;
    }) : new Promise((s, o) => {
      o("CFI could not be found");
    });
  }
  /**
   * Generates the Book Key using the identifier in the manifest or other string provided
   * @param  {string} [identifier] to use instead of metadata identifier
   * @return {string} key
   */
  key(e) {
    var n = e || this.packaging.metadata.identifier || this.url.filename;
    return `epubjs:${iu}:${n}`;
  }
  /**
   * Destroy the Book and all associated objects
   */
  destroy() {
    this.opened = void 0, this.loading = void 0, this.loaded = void 0, this.ready = void 0, this.isOpen = !1, this.isRendered = !1, this.spine && this.spine.destroy(), this.locations && this.locations.destroy(), this.pageList && this.pageList.destroy(), this.archive && this.archive.destroy(), this.resources && this.resources.destroy(), this.container && this.container.destroy(), this.packaging && this.packaging.destroy(), this.rendition && this.rendition.destroy(), this.displayOptions && this.displayOptions.destroy(), this.spine = void 0, this.locations = void 0, this.pageList = void 0, this.archive = void 0, this.resources = void 0, this.container = void 0, this.packaging = void 0, this.rendition = void 0, this.navigation = void 0, this.url = void 0, this.path = void 0, this.archived = !1;
  }
}
Br(Pf.prototype);
function Ji(t, e) {
  return new Pf(t, e);
}
Ji.VERSION = iu;
typeof global < "u" && (global.EPUBJS_VERSION = iu);
Ji.Book = Pf;
Ji.Rendition = Lf;
Ji.Contents = Af;
Ji.CFI = mt;
Ji.utils = p$;
function tD(t, e) {
  t.addEventListener(
    "keyup",
    (n) => {
      n.key === "ArrowUp" || n.key === "ArrowRight" ? e("next") : (n.key === "ArrowDown" || n.key === "ArrowLeft") && e("prev");
    },
    !1
  );
}
function nD(t, e) {
  let i = 0, s;
  t.addEventListener("wheel", (o) => {
    o.ignore || (o.ignore = !0, clearTimeout(s), i += o.deltaY, s = setTimeout(() => {
      if (Math.abs(i) >= 750) {
        let a = Math.sign(i) > 0 ? "next" : "prev";
        e(a), i = 0;
      }
      i = 0;
    }, 50));
  });
}
function rD(t, e) {
  let s, o, a;
  t.addEventListener(
    "touchstart",
    (l) => {
      l.ignore || (l.ignore = !0, s = l.changedTouches[0].pageX, o = l.changedTouches[0].pageY, a = Date.now());
    },
    !1
  ), t.addEventListener(
    "touchend",
    (l) => {
      var h, v;
      if (l.ignore)
        return;
      l.ignore = !0;
      const u = l.changedTouches[0].pageX - s, c = l.changedTouches[0].pageY - o;
      Date.now() - a <= 500 && (Math.abs(u) >= 50 && Math.abs(c) <= 200 ? e(u < 0 ? "prev" : "next") : Math.abs(c) >= 50 && Math.abs(u) <= 200 ? e(c < 0 ? "up" : "down") : ((v = (h = t == null ? void 0 : t.defaultView) == null ? void 0 : h.getSelection()) == null || v.removeAllRanges(), t.dispatchEvent(
        new MouseEvent("click", {
          clientX: s,
          clientY: o
        })
      ), l.preventDefault()));
    },
    !1
  );
}
function iD(t, e, n) {
  t.addEventListener("mousedown", () => {
    t.getSelection().removeAllRanges(), n("cleared");
  }), t.addEventListener("mouseup", (r) => {
    if (r.ignore)
      return;
    r.ignore = !0;
    const i = t.getSelection(), s = i.toString();
    if (s === "")
      return;
    const o = i.getRangeAt(0), [a] = e.getContents(), l = a.cfiFromRange(o), u = o.getBoundingClientRect(), c = e.manager.container.getBoundingClientRect();
    let d = {
      left: `${c.x + u.x - (e.manager.scrollLeft || 0)}px`,
      top: `${c.y + u.y}px`,
      width: `${u.width}px`,
      height: `${u.height}px`
    };
    n("selected", d, s, l);
  });
}
const Py = be({
  name: "EpubView",
  model: {
    prop: "location",
    event: "update:location"
  },
  emits: {
    "update:location"(t) {
      return !0;
    },
    select(t, e) {
      return !0;
    },
    keyup(t) {
      return !0;
    }
  },
  props: {
    url: {
      required: !0
      // type: Object as PropType<Props['url']>,
    },
    location: {
      // type: [Number, String],
    },
    tocChanged: {
      type: Function
    },
    getRendition: {
      type: Function
    },
    epubInitOptions: {
      type: Object,
      default: () => ({})
    },
    epubOptions: {
      type: Object,
      default: () => ({})
    }
  },
  setup(t, e) {
    const { emit: n, slots: r, expose: i } = e, s = ht(), o = et.bind(s), { url: a, location: l } = hn(t), { tocChanged: u, getRendition: c, epubInitOptions: d, epubOptions: h } = t, v = K(null), y = K([]), b = K(!1);
    let p = null, f = null;
    const m = async () => {
      p && p.destroy(), a.value && (p = Ji(a.value, d), p.loaded.navigation.then(({ toc: I }) => {
        b.value = !0, y.value = I, u && u(I), g();
      }));
    }, g = () => {
      var P, D;
      const I = v.value || ((P = s == null ? void 0 : s.refs) == null ? void 0 : P.viewer);
      f = p.renderTo(I, {
        width: "100%",
        height: "100%",
        ...h
      }), _(), c && c(f), typeof (l == null ? void 0 : l.value) == "string" || typeof (l == null ? void 0 : l.value) == "number" ? f.display(l.value) : y.value.length > 0 && ((D = y == null ? void 0 : y.value[0]) != null && D.href) ? f.display(y.value[0].href) : f.display();
    }, w = (I) => {
      I === "next" ? T() : I === "prev" && k();
    }, _ = () => {
      f && (f.on("rendered", (I, P) => {
        var D, z;
        (D = P == null ? void 0 : P.iframe) == null || D.contentWindow.focus(), (z = h == null ? void 0 : h.flow) != null && z.includes("scrolled") || nD(P.document, w), rD(P.document, w), tD(P.document, w);
      }), f.on("locationChanged", E), f.on(
        "displayError",
        (I) => console.error("error rendering book", I)
      ), f.on(
        "selected",
        (I, P) => n("select", I, P)
      ), f.on("keyup", (I) => n("keyPress", I)));
    }, E = (I) => {
      const P = I.start;
      (l == null ? void 0 : l.value) !== P && n("update:location", P);
    };
    l && ke(
      l,
      ((I, P = 1e3) => {
        let D;
        return function(...G) {
          const J = () => {
            D = null, I(...G);
          };
          clearTimeout(D), D = setTimeout(J, P);
        };
      })((I, P) => {
        I && I === P || (typeof I == "string" && (f == null || f.display(I)), typeof I == "number" && (f == null || f.display(I)));
      }),
      {
        immediate: !0
      }
    ), ke(a, () => {
      m();
    });
    const T = () => {
      f == null || f.next();
    }, k = () => {
      f == null || f.prev();
    }, N = (I) => {
      typeof I == "string" && f.display(I), typeof I == "number" && f.display(I);
    };
    return Tt(() => {
      m();
    }), Sn(() => {
      p == null || p.destroy();
    }), i ? i({ nextPage: T, prevPage: k, setLocation: N }) : ((P) => {
      if (!s)
        throw new Error("expose should be called in setup().");
      const D = Object.keys(P);
      D.forEach((z) => {
        s.proxy[z] = P[z];
      }), Sn(() => {
        D.forEach((z) => {
          s.proxy[z] = void 0;
        });
      });
    })({ nextPage: T, prevPage: k, setLocation: N }), () => {
      var I;
      return o("div", { class: "reader" }, [
        o("div", { class: "viewHolder" }, [
          o("div", {
            ref: parseFloat(bv) >= 2.7 ? v : "viewer",
            class: "view",
            id: "viewer",
            attrs: { id: "viewer" },
            style: {
              display: b.value ? null : "none"
            }
          }),
          !b.value && o("div", (I = r.loadingView) == null ? void 0 : I.call(r))
        ])
      ]);
    };
  }
});
const $y = be({
  name: "TocComponent",
  props: {
    toc: {
      type: Array,
      default: () => []
    },
    current: {
      type: [String, Number],
      default: ""
    },
    setLocation: {
      type: Function,
      required: !0
    },
    isSubmenu: {
      type: Boolean,
      default: !1,
      required: !1
    }
  },
  setup(t) {
    const e = ht(), n = et.bind(e), { setLocation: r, isSubmenu: i } = t, { toc: s, current: o } = hn(t);
    return () => n(
      "div",
      null,
      s.value.map((a, l) => n("div", { key: l }, [
        n(
          "button",
          {
            class: [
              "tocAreaButton",
              a.href === o.value ? "active" : ""
            ],
            on: {
              click: () => {
                a.subitems.length > 0 ? (a.expansion = !a.expansion, r(a.href, !1)) : r(a.href);
              }
            },
            onClick: () => {
              a.subitems.length > 0 ? (a.expansion = !a.expansion, r(a.href, !1)) : r(a.href);
            }
          },
          [
            `${i ? " ".repeat(4) : ""}${a.label}`,
            // 展开
            a.subitems && a.subitems.length > 0 && n("div", {
              class: `${a.expansion ? "open" : ""} expansion`
            })
          ]
        ),
        //多级目录
        a.subitems && a.subitems.length > 0 && n(
          gr,
          { name: "collapse-transition" },
          {
            default: () => n(
              "div",
              {
                style: {
                  display: a.expansion ? void 0 : "none"
                }
              },
              n($y, {
                toc: a.subitems,
                current: o.value,
                setLocation: r,
                isSubmenu: !0,
                attrs: {
                  toc: s.value,
                  current: o.value,
                  setLocation: r,
                  isSubmenu: !0
                }
              })
            )
          }
        )
      ]))
    );
  }
});
be({
  name: "VueReader",
  props: {
    url: {
      required: !0
      // type: [string | ArrayBuffer],
    },
    title: String,
    showToc: {
      type: Boolean,
      default: !0
    },
    tocChanged: {
      type: Function
    },
    getRendition: {
      type: Function
    }
  },
  setup(t, e) {
    const { emit: n, slots: r, expose: i, attrs: s } = e, o = ht(), a = et.bind(o), l = K(null), u = K(null), c = K(""), { tocChanged: d, getRendition: h } = t, { title: v, url: y, showToc: b } = hn(t), p = Pn({
      toc: [],
      //目录
      expandedToc: !1
      //目录展开
    }), { toc: f, expandedToc: m } = hn(p), g = K(""), w = () => {
      m.value = !m.value;
    }, _ = (N) => {
      f.value = N.map((I) => ({ ...I, expansion: !1 })), d && d(N);
    }, E = (N) => {
      h && h(N), N.on("relocated", (P) => {
        u.value = P;
      });
      const I = N.book;
      I.ready.then(() => {
        const P = I.package.metadata;
        g.value = P.title;
      });
    }, C = (N, I = !0) => {
      const P = l.value || (o == null ? void 0 : o.refs.epubRef);
      P == null || P.setLocation(N), c.value = N, m.value = !I;
    }, T = () => {
      const N = l.value || (o == null ? void 0 : o.refs.epubRef);
      N == null || N.nextPage();
    }, k = () => {
      const N = l.value || (o == null ? void 0 : o.refs.epubRef);
      N == null || N.prevPage();
    };
    return i ? i({ setLocation: C, next: T, pre: k }) : ((I) => {
      if (!o)
        throw new Error("expose should be called in setup().");
      const P = Object.keys(I);
      P.forEach((D) => {
        o.proxy[D] = I[D];
      }), Sn(() => {
        P.forEach((D) => {
          o.proxy[D] = void 0;
        });
      });
    })({ setLocation: C, next: T, pre: k }), () => {
      var N, I, P, D, z;
      return a("div", { class: "container" }, [
        a(
          "div",
          { class: ["readerArea", { containerExpanded: m.value }] },
          [
            // 展开目录
            b.value && a(
              "button",
              {
                class: [
                  "tocButton",
                  { tocButtonExpanded: m.value }
                ],
                type: "button",
                on: {
                  click: w
                },
                onClick: w
              },
              [
                a("span", { class: "tocButtonBar", style: "top: 35%" }),
                a("span", { class: "tocButtonBar", style: "top: 66%" })
              ]
            ),
            // 书名
            a(
              "div",
              { class: "titleArea", title: g.value },
              r.title ? (N = r.title) == null ? void 0 : N.call(r) : v.value || g.value
            ),
            // 阅读区
            a(
              Py,
              {
                ref: parseFloat(bv) < 2.7 ? "epubRef" : l,
                url: y.value,
                tocChanged: _,
                getRendition: E,
                ...s,
                //vue2
                attrs: {
                  url: y.value,
                  tocChanged: _,
                  getRendition: E,
                  ...s
                },
                on: {
                  ...e.listeners
                }
              },
              {
                // loading
                loadingView: () => {
                  var G;
                  return a(
                    "div",
                    { class: "loadingView" },
                    r.loadingView ? (G = r.loadingView) == null ? void 0 : G.call(r) : "Loading..."
                  );
                }
              }
            ),
            // 翻页
            a(
              "button",
              {
                class: "arrow pre",
                on: {
                  click: k
                },
                onClick: k,
                domProps: {
                  disabled: (I = u.value) == null ? void 0 : I.atStart
                },
                disabled: (P = u.value) == null ? void 0 : P.atStart
              },
              "‹"
            ),
            a(
              "button",
              {
                class: "arrow next",
                on: {
                  click: T
                },
                onClick: T,
                domProps: {
                  disabled: (D = u.value) == null ? void 0 : D.atEnd
                },
                disabled: (z = u.value) == null ? void 0 : z.atEnd
              },
              "›"
            )
          ]
        ),
        // 目录
        b.value && a("div", [
          a(
            "div",
            { class: "tocArea" },
            a($y, {
              toc: f.value,
              current: c.value,
              setLocation: C,
              attrs: {
                toc: f.value,
                current: c.value,
                setLocation: C
              }
            })
          ),
          // 目录遮罩
          m.value && a("div", {
            class: ["tocBackground"],
            onClick: w,
            on: {
              click: w
            }
          })
        ])
      ]);
    };
  }
});
const sD = (t) => (wv("data-v-3bf5a8c5"), t = t(), _v(), t), oD = /* @__PURE__ */ sD(() => /* @__PURE__ */ ae("div", { class: "el-popover__title" }, "Table of Content", -1)), aD = {
  __name: "TocMenu",
  props: {
    toc: {
      default: () => [],
      type: Array
    }
  },
  emits: ["node-click"],
  setup(t, { emit: e }) {
    const n = Ws(), r = t, i = e, s = (o) => {
      i("node-click", o);
    };
    return (o, a) => {
      const l = Xi, u = rL, c = ta;
      return V(), Ce(c, {
        "popper-class": `popper ${x(n).theme}`,
        placement: "bottom",
        width: 380,
        trigger: "hover",
        "popper-style": { height: "85%" }
      }, {
        reference: de(() => [
          ve(l, {
            size: "small",
            icon: x(tk),
            circle: ""
          }, null, 8, ["icon"])
        ]),
        default: de(() => [
          oD,
          ve(u, {
            data: r.toc,
            onNodeClick: s
          }, null, 8, ["data"])
        ]),
        _: 1
      }, 8, ["popper-class"]);
    };
  }
}, lD = /* @__PURE__ */ Zi(aD, [["__scopeId", "data-v-3bf5a8c5"]]);
const uD = { class: "el-popover__title" }, cD = {
  __name: "SearchMenu",
  props: {
    searchResult: {
      default: () => [],
      type: Array
    }
  },
  emits: ["search", "node-click"],
  setup(t, { emit: e }) {
    const n = Ws(), r = t, { searchResult: i } = hn(r), s = e, o = K(""), a = () => {
    }, l = () => {
      o.value;
    }, u = (d) => {
      s("node-click", d);
    };
    let c = null;
    return ke(o, (d) => {
      d.length !== 0 && (clearTimeout(c), c = setTimeout(() => {
        s("search", d);
      }, 1e3));
    }), ke(i, () => {
      l();
    }), (d, h) => {
      const v = Xi, y = Yl, b = U4, p = j4, f = ta;
      return V(), Ce(f, {
        "popper-class": `popper reader-${x(n).theme}`,
        width: "350",
        trigger: "hover",
        onShow: l,
        onHide: a
      }, {
        reference: de(() => [
          ve(v, {
            size: "small",
            icon: x(Ck),
            circle: ""
          }, null, 8, ["icon"])
        ]),
        default: de(() => [
          ae("div", uD, [
            ve(y, {
              modelValue: o.value,
              "onUpdate:modelValue": h[0] || (h[0] = (m) => o.value = m),
              size: "small",
              width: "300",
              placeholder: "search"
            }, null, 8, ["modelValue"])
          ]),
          (V(), Ce(p, {
            key: x(i).length,
            "show-header": !1,
            data: x(i),
            onCellClick: u
          }, {
            default: de(() => [
              ve(b, {
                prop: "label",
                width: "350"
              })
            ]),
            _: 1
          }, 8, ["data"]))
        ]),
        _: 1
      }, 8, ["popper-class"]);
    };
  }
};
const Hs = (t) => (wv("data-v-b4a6d1f6"), t = t(), _v(), t), dD = { class: "table" }, fD = /* @__PURE__ */ Hs(() => /* @__PURE__ */ ae("td", null, "Flow", -1)), hD = /* @__PURE__ */ Hs(() => /* @__PURE__ */ ae("td", null, "Theme", -1)), pD = /* @__PURE__ */ Hs(() => /* @__PURE__ */ ae("td", null, "Line Spacing", -1)), vD = /* @__PURE__ */ Hs(() => /* @__PURE__ */ ae("td", null, "Font Size", -1)), mD = /* @__PURE__ */ Hs(() => /* @__PURE__ */ ae("td", null, "Font", -1)), gD = /* @__PURE__ */ Hs(() => /* @__PURE__ */ ae("td", null, "reset", -1)), yD = {
  __name: "ThemeMenu",
  emits: ["style-change", "theme-change", "flow-change"],
  setup(t, { emit: e }) {
    const n = Ws(), { lineSpacing: r, theme: i, flow: s, font: o, fontSize: a } = H8(n), l = e, u = () => {
      const c = {
        p: {
          "font-family": o.value !== "" ? `${o.value} !important` : "!invalid-hack",
          "font-size": a.value !== "" ? `${a.value} !important` : "!invalid-hack"
        },
        body: {
          "font-family": o.value !== "" ? `${o.value} !important` : "!invalid-hack"
          // "text-align": `${theme.ta} !important`,
        },
        "*": {
          "line-height": `${r.value} !important`,
          "font-size": a.value !== "" ? `${a.value}% !important` : "!invalid-hack"
        }
      };
      l("style-change", c);
    };
    return Tt(() => {
      u();
    }), ke(
      () => [r, o, a],
      () => {
        u();
      },
      {
        deep: !0
      }
    ), ke(i, (c) => {
      l("theme-change", c);
    }), ke(s, (c) => {
      l("flow-change", c);
    }), (c, d) => {
      const h = Xi, v = bI, y = yI, b = xg, p = j3, f = F3, m = ta;
      return V(), Ce(m, {
        "popper-class": x(i),
        trigger: "hover",
        width: 270
      }, {
        reference: de(() => [
          ve(h, {
            size: "small",
            icon: x(DC),
            circle: ""
          }, null, 8, ["icon"])
        ]),
        default: de(() => [
          ae("table", dD, [
            ae("tr", null, [
              fD,
              ae("td", null, [
                ve(y, {
                  modelValue: x(s),
                  "onUpdate:modelValue": d[0] || (d[0] = (g) => on(s) ? s.value = g : null),
                  size: "small",
                  style: { "flex-wrap": "nowrap" }
                }, {
                  default: de(() => [
                    ve(v, {
                      label: "paginated",
                      border: ""
                    }, {
                      default: de(() => [
                        cn(" Paged ")
                      ]),
                      _: 1
                    }),
                    ve(v, {
                      label: "scrolled-doc",
                      border: ""
                    }, {
                      default: de(() => [
                        cn(" Scrolled ")
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["modelValue"])
              ])
            ]),
            ae("tr", null, [
              hD,
              ae("td", null, [
                ve(y, {
                  modelValue: x(i),
                  "onUpdate:modelValue": d[1] || (d[1] = (g) => on(i) ? i.value = g : null),
                  size: "small"
                }, {
                  default: de(() => [
                    ve(v, {
                      label: "default",
                      border: ""
                    }, {
                      default: de(() => [
                        cn(" Light ")
                      ]),
                      _: 1
                    }),
                    ve(v, {
                      label: "tan",
                      border: ""
                    }, {
                      default: de(() => [
                        cn(" Tan ")
                      ]),
                      _: 1
                    }),
                    ve(v, {
                      label: "dark",
                      border: ""
                    }, {
                      default: de(() => [
                        cn(" Dark ")
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["modelValue"])
              ])
            ]),
            ae("tr", null, [
              pD,
              ae("td", null, [
                ve(b, {
                  modelValue: x(r),
                  "onUpdate:modelValue": d[2] || (d[2] = (g) => on(r) ? r.value = g : null),
                  precision: 2,
                  step: 0.1,
                  min: 1.3,
                  max: 2,
                  size: "small"
                }, null, 8, ["modelValue"])
              ])
            ]),
            ae("tr", null, [
              vD,
              ae("td", null, [
                ve(b, {
                  modelValue: x(a),
                  "onUpdate:modelValue": d[3] || (d[3] = (g) => on(a) ? a.value = g : null),
                  step: 2,
                  min: 10,
                  max: 300,
                  size: "small"
                }, null, 8, ["modelValue"])
              ])
            ]),
            ae("tr", null, [
              mD,
              ae("td", null, [
                ve(f, {
                  teleported: !1,
                  modelValue: x(o),
                  "onUpdate:modelValue": d[4] || (d[4] = (g) => on(o) ? o.value = g : null),
                  class: "font-select",
                  width: "50",
                  size: "small"
                }, {
                  default: de(() => [
                    ve(p, {
                      label: "Default",
                      value: ""
                    }),
                    ve(p, {
                      label: "Arial",
                      value: "Arial"
                    }),
                    ve(p, {
                      label: "Times New Roman",
                      value: "Times New Roman"
                    })
                  ]),
                  _: 1
                }, 8, ["modelValue"])
              ])
            ]),
            ae("tr", null, [
              gD,
              ae("td", null, [
                ve(h, {
                  onClick: x(n).reset
                }, {
                  default: de(() => [
                    cn("reset all")
                  ]),
                  _: 1
                }, 8, ["onClick"])
              ])
            ])
          ])
        ]),
        _: 1
      }, 8, ["popper-class"]);
    };
  }
}, bD = /* @__PURE__ */ Zi(yD, [["__scopeId", "data-v-b4a6d1f6"]]);
const wD = {
  name: "BubleMenu",
  data() {
    return {
      isVisible: !1,
      translateTo: "gu",
      translatedText: "",
      text: ""
    };
  },
  methods: {
    setProps(t, e, n) {
      let r = this.$refs.popRef;
      r.style.left = t.left, r.style.top = t.top, r.style.width = t.width, r.style.height = t.height, console.log(t), this.text = e, this.cfiRange = n, this.translateText(), this.isVisible = !0;
    },
    hide() {
      this.isVisible = !1, this.text = "", this.translatedText = "No Data", this.cfiRange = "";
    },
    show() {
      this.isVisible = !0;
    },
    onHLBtn() {
      this.cfiRange !== "" && this.$emit("highlight-btn-click", this.cfiRange);
    },
    copyText() {
      const t = document.createElement("textarea");
      t.style.position = "absolute", t.style.left = "-9999px", t.value = this.text, document.body.appendChild(t), t.select(), document.execCommand("copy"), document.body.removeChild(t);
    },
    translateText() {
    }
  }
}, _D = { class: "el-popover__title" }, ED = /* @__PURE__ */ ae("template", { slot: "prepend" }, [
  /* @__PURE__ */ cn(" Translate to ")
], -1), SD = {
  ref: "popRef",
  style: { position: "absolute", visibility: "hidden" }
};
function xD(t, e, n, r, i, s) {
  const o = Xi, a = Zm, l = Yl, u = ta, c = Tg;
  return V(), Ce(u, {
    modelValue: i.isVisible,
    "onUpdate:modelValue": e[1] || (e[1] = (d) => i.isVisible = d),
    "popper-class": "buble",
    trigger: "manual"
  }, {
    reference: de(() => [
      ae("span", SD, null, 512)
    ]),
    default: de(() => [
      ve(a, null, {
        default: de(() => [
          ve(o, {
            size: "small",
            icon: "brush",
            onClick: s.onHLBtn
          }, null, 8, ["onClick"]),
          ve(o, {
            size: "small",
            icon: "copy-document",
            onClick: s.copyText
          }, null, 8, ["onClick"]),
          $t(ve(o, {
            size: "small",
            icon: "collection"
          }, null, 512), [
            [c, void 0, "translatePop"]
          ])
        ]),
        _: 1
      }),
      ve(u, {
        ref: "translatePop",
        width: "200",
        trigger: "hover"
      }, {
        reference: de(() => [
          cn(st(i.translatedText), 1)
        ]),
        default: de(() => [
          ae("div", _D, [
            ve(l, {
              modelValue: i.translateTo,
              "onUpdate:modelValue": e[0] || (e[0] = (d) => i.translateTo = d),
              placeholder: "Language Code",
              width: "30",
              size: "small"
            }, {
              default: de(() => [
                ED
              ]),
              _: 1
            }, 8, ["modelValue"])
          ])
        ]),
        _: 1
      }, 512)
    ]),
    _: 1
  }, 8, ["modelValue"]);
}
const CD = /* @__PURE__ */ Zi(wD, [["render", xD]]), kD = async (t) => {
  const { toc: e } = t.navigation, { spine: n } = t, r = (l) => (l.startsWith("..") && (l = l.substring(2)), l.startsWith("/") && (l = l.substring(1)), l), i = (l) => l.split("#")[0], s = (l) => l.split("#")[1], o = [], a = async (l, u) => {
    for (let c = 0; c < l.length; c += 1) {
      const d = r(l[c].href), h = i(d), v = s(d), y = n.get(h);
      await y.load(t.load.bind(t));
      const b = y.document.getElementById(v), p = y.cfiFromElement(b), f = t.locations.percentageFromCfi(p);
      u[c] = {
        label: l[c].label.trim(),
        children: [],
        href: d,
        cfi: p,
        percentage: f
      }, l[c].subitems && await a(l[c].subitems, u[c].children);
    }
  };
  return await a(e, o), o;
}, TD = async (t, e, n) => {
  !t || typeof t != "string" || e.ready.then(() => e.locations.generate()).then(async (r) => {
    const i = e.package.metadata, s = {
      // id: key,
      title: i.title,
      author: i.creator,
      publisher: i.publisher,
      path: t,
      bookmarks: [],
      highlights: [],
      bgColorFromCover: "",
      toc: await kD(e),
      locations: r
    };
    n && n(s, e);
  });
}, OD = {
  body: {
    background: "#444 !important",
    color: "#fff !important"
  },
  "*": {
    color: "inherit !important",
    background: "inherit !important"
  },
  "a:link": {
    color: "#1e83d2 !important",
    "text-decoration": "none !important"
  },
  "a:link:hover": {
    background: "rgba(0, 0, 0, 0.1) !important"
  }
}, ND = {
  body: {
    background: "#fdf6e3 !important",
    color: "#002b36 !important"
  },
  "*": {
    color: "inherit !important",
    background: "inherit !important"
  },
  "a:link": {
    color: "#268bd2 !important",
    "text-decoration": "none !important"
  },
  "a:link:hover": {
    background: "rgba(0, 0, 0, 0.1) !important"
  }
};
const AD = {
  __name: "Reader",
  props: {
    bookInfo: {
      type: [Object, Number, ArrayBuffer]
    }
  },
  emits: ["update:showReader", "theme-change"],
  setup(t, { emit: e }) {
    const n = Ws(), r = t, i = K(!1), s = K({}), o = K(""), a = F(async () => await $fetch("/api/readibles/getReadibleFile", {
      method: "GET",
      responseType: "arrayBuffer",
      params: { filePath: `${r.bookInfo.url}` }
    }));
    let l = null, u = null;
    const c = (Y) => {
      l = Y;
      const le = l.book;
      l.on("rendered", (ce, me) => {
        iD(me.document, l, re);
      }), l.on("relocated", (ce) => {
        E.value.push(ce.start.cfi), p.value = le.locations.percentageFromCfi(ce.start.cfi), b.value = Math.floor(p.value * 1e4) / 100;
      }), l.hooks.content.register(J), le.ready.then(() => {
        const ce = le.package.metadata;
        return console.log(le.package.metadata), o.value = ce.title, le.locations.generate();
      }).then(async (ce) => {
        l.themes.registerRules("dark", OD), l.themes.registerRules("tan", ND), l.ready = !0;
        const { theme: me, flow: _e } = n;
        P(me), D(_e), await TD(a.value, le, (ze) => {
          s.value = ze, u = function Oe(Qe) {
            return [].concat(
              ...Qe.map((Be) => [Be].concat(...Oe(Be.children)))
            );
          }(ze.toc), u.sort((Oe, Qe) => Oe.percentage - Qe.percentage);
        });
      }).then(() => {
        i.value = !0;
      }).then(() => {
        i.value = !0;
      });
    }, d = K([]), h = K(""), v = (Y, le) => {
      let ce = "n/a";
      return Y.some((me) => {
        if (me.subitems.length > 0) {
          const _e = v(me.subitems, le);
          if (_e !== "n/a")
            return ce = _e, !0;
        } else if (me.href.includes(le))
          return ce = me.label, !0;
      }), ce;
    }, y = (Y) => {
      if (Y) {
        const { displayed: le, href: ce } = l.location.start;
        if (l.location.end, ce !== "titlepage.xhtml") {
          const me = v(d.value, ce);
          h.value = `${le.page}/${le.total} ${me}`;
        }
      }
    };
    Tt(() => {
    });
    const b = K(0), p = K(0), f = (Y) => {
      let le = m(Y);
      return le ? le.label : "";
    }, m = (Y) => {
      if (!u)
        return {};
      Y /= 100;
      for (let le = 0; le < u.length; le += 1)
        if (u[le].percentage > Y)
          return u[le - 1];
      return null;
    }, g = (Y) => {
      let le = l.book.locations.cfiFromPercentage(Y / 100);
      l.display(le);
    }, w = K(0);
    ((Y) => {
      var le = XMLHttpRequest.prototype.open;
      XMLHttpRequest.prototype.open = function() {
        this.addEventListener(
          "progress",
          function(ce) {
            ce.lengthComputable && Y(ce.loaded / ce.total);
          },
          !1
        ), le.apply(this, arguments);
      };
    })((Y) => {
      w.value = Math.round(Y * 100);
    });
    const E = K([]), C = () => {
      E.value.pop();
      let Y = E.value.pop();
      Y ? l.display(Y) : T("update:showReader", !1);
    }, T = e, k = () => {
      T("update:showReader", !1);
    }, N = (Y) => {
      console.log(Y.cfi, Y.href), l.display(Y.cfi || Y.href);
    }, I = K({}), P = (Y) => {
      l.themes.select(Y), n.theme = Y, G(), T("theme-change", Y);
    }, D = (Y) => {
      l.ready && l.flow(Y);
    }, z = (Y) => {
      I.value = Y, J(), G();
    }, G = () => {
      l && l.manager && l.start();
    }, J = () => {
      l && l.getContents().forEach((Y) => {
        Y.addStylesheetRules(I.value);
      });
    }, M = K([]), U = (Y) => {
      const le = l.book;
      return Promise.all(
        le.spine.spineItems.map(
          (ce) => ce.load(le.load.bind(le)).then(ce.find.bind(ce, Y)).finally(ce.unload.bind(ce))
        )
      ).then((ce) => ce.flat()).then((ce) => {
        M.value = ce.map((me) => (me.label = me.excerpt, me));
      }).then(() => {
      });
    }, j = K(null), re = (Y, le, ce, me) => {
      if (Y === "cleared") {
        j.value.hide();
        return;
      }
      console.log(j.value), j.value.setProps(le, ce, me), j.value.isBubleVisible = !0;
    }, fe = (Y) => {
      l.annotations.highlight(Y);
    };
    return (Y, le) => {
      const ce = Xi, me = Zm, _e = Og, ze = Sg, Oe = PR, Qe = zI, Be = Eg, He = jL;
      return V(), Ce(Be, { direction: "vertical" }, {
        default: de(() => [
          ve(Kg, { title: o.value }, {
            default: de(() => [
              ve(me, null, {
                default: de(() => [
                  ve(ce, {
                    size: "small",
                    icon: x(cx),
                    circle: "",
                    onClick: C
                  }, null, 8, ["icon"]),
                  ve(ce, {
                    size: "small",
                    icon: x(fC),
                    circle: "",
                    onClick: k
                  }, null, 8, ["icon"])
                ]),
                _: 1
              }),
              ve(lD, {
                toc: s.value.toc,
                onNodeClick: N
              }, null, 8, ["toc"]),
              ve(cD, {
                "search-result": M.value,
                onNodeClick: N,
                onSearch: U
              }, null, 8, ["search-result"]),
              ve(bD, {
                onThemeChange: P,
                onFlowChange: D,
                onStyleChange: z
              })
            ]),
            _: 1
          }, 8, ["title"]),
          ve(ze, { class: "container" }, {
            default: de(() => [
              $t((V(), Ce(x(Py), {
                id: "reader",
                url: a.value,
                getRendition: c,
                title: h.value,
                epubOptions: {
                  allowPopups: !0,
                  allowScriptedContent: !0
                },
                "onUpdate:location": y
              }, {
                loadingView: de(() => [
                  ve(_e, { percentage: w.value }, null, 8, ["percentage"])
                ]),
                _: 1
              }, 8, ["url", "title"])), [
                [He, !i.value]
              ])
            ]),
            _: 1
          }),
          ve(Qe, { height: "45" }, {
            default: de(() => [
              ve(Oe, {
                modelValue: b.value,
                "onUpdate:modelValue": le[0] || (le[0] = (ct) => b.value = ct),
                step: 0.01,
                "format-tooltip": f,
                onChange: g
              }, null, 8, ["modelValue"])
            ]),
            _: 1
          }),
          ve(CD, {
            ref_key: "bubleMenu",
            ref: j,
            onHighlightBtnClick: fe
          }, null, 512)
        ]),
        _: 1
      });
    };
  }
}, ID = /* @__PURE__ */ Zi(AD, [["__scopeId", "data-v-2ca3727e"]]);
const RD = {
  name: "ReaderStart"
}, LD = Object.assign(RD, {
  props: {
    passedBook: {
      type: Object,
      default: () => ({})
    }
  },
  setup(t) {
    const e = Ws(), n = K(!1), r = K({}), i = t, s = (o) => {
      r.value = o, n.value = !0;
    };
    return ke(
      i.passedBook,
      (o, a) => {
        o !== a && o && s(o);
      },
      {
        immediate: !0
        // This ensures the watcher is triggered immediately
      }
    ), (o, a) => (V(), se("div", {
      id: "index",
      ref: "app",
      class: ee("reader-" + x(e).theme)
    }, [
      ve(gr, { name: "el-fade-in-linear" }, {
        default: de(() => [
          n.value ? ye("", !0) : (V(), Ce(rP, {
            key: 0,
            "onUpdate:currentBook": s,
            showReader: n.value,
            "onUpdate:showReader": a[0] || (a[0] = (l) => n.value = l)
          }, null, 8, ["showReader"]))
        ]),
        _: 1
      }),
      ve(gr, { name: "el-fade-in-linear" }, {
        default: de(() => [
          n.value ? (V(), Ce(ID, {
            key: 0,
            bookInfo: r.value,
            "onUpdate:showReader": a[1] || (a[1] = (l) => n.value = l)
          }, null, 8, ["bookInfo"])) : ye("", !0)
        ]),
        _: 1
      })
    ], 2));
  }
}), PD = /* @__PURE__ */ Zi(LD, [["__scopeId", "data-v-3cc4b766"]]), BD = {
  install: (t) => {
    t.component("ReaderStart", PD);
  }
};
export {
  BD as default,
  Ws as useReaderStore
};
