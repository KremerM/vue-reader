import { getCurrentScope as K0, onScopeDispose as $0, unref as x, getCurrentInstance as ht, onMounted as Ct, nextTick as rt, watch as ke, ref as $, computed as F, openBlock as V, createElementBlock as se, createElementVNode as ae, warn as G0, inject as tt, isRef as on, shallowRef as zn, onBeforeUnmount as En, onBeforeMount as ld, provide as qt, defineComponent as be, mergeProps as Gn, renderSlot as Me, toRef as Cn, onUnmounted as Wo, useAttrs as hv, useSlots as Ko, withDirectives as Dt, createCommentVNode as ye, Fragment as Ft, normalizeClass as ee, createBlock as Ae, withCtx as de, resolveDynamicComponent as Nn, withModifiers as ft, createVNode as ve, toDisplayString as st, normalizeStyle as it, vShow as Jn, Transition as mr, reactive as Bn, onUpdated as Ml, cloneVNode as q0, Text as pv, Comment as vv, Teleport as gv, readonly as J0, onDeactivated as Y0, createTextVNode as cn, toRaw as yi, vModelCheckbox as nl, toRefs as hn, vModelRadio as mv, toHandlers as Q0, markRaw as Ur, effectScope as yv, renderList as qn, withKeys as vn, triggerRef as qs, resolveComponent as Mt, resolveDirective as ud, vModelText as Z0, createSlots as qu, h as et, watchEffect as oo, TransitionGroup as X0, createApp as eb, isReactive as Ll, version as bv, pushScopeId as wv, popScopeId as _v } from "vue";
const Hr = (t, e, { checkForDefaultPrevented: n = !0 } = {}) => (i) => {
  const s = t == null ? void 0 : t(i);
  if (n === !1 || !s)
    return e == null ? void 0 : e(i);
};
var tb = !1;
function ha(t, e, n) {
  return Array.isArray(t) ? (t.length = Math.max(t.length, e), t.splice(e, 1, n), n) : (t[e] = n, n);
}
function fu(t, e) {
  if (Array.isArray(t)) {
    t.splice(e, 1);
    return;
  }
  delete t[e];
}
var zf;
const St = typeof window < "u", nb = (t) => typeof t < "u", rb = (t) => typeof t == "function", ib = (t) => typeof t == "string", rl = () => {
}, Sv = St && ((zf = window == null ? void 0 : window.navigator) == null ? void 0 : zf.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function cd(t) {
  return typeof t == "function" ? t() : x(t);
}
function sb(t, e) {
  function n(...r) {
    return new Promise((i, s) => {
      Promise.resolve(t(() => e.apply(this, r), { fn: e, thisArg: this, args: r })).then(i).catch(s);
    });
  }
  return n;
}
function ob(t, e = !0, n = !0, r = !1) {
  let i = 0, s, o = !0, a = rl, l;
  const u = () => {
    s && (clearTimeout(s), s = void 0, a(), a = rl);
  };
  return (d) => {
    const h = cd(t), v = Date.now() - i, y = () => l = d();
    return u(), h <= 0 ? (i = Date.now(), y()) : (v > h && (n || !o) ? (i = Date.now(), y()) : e && (l = new Promise((b, p) => {
      a = r ? p : b, s = setTimeout(() => {
        i = Date.now(), o = !0, b(y()), u();
      }, Math.max(0, h - v));
    })), !n && !s && (s = setTimeout(() => o = !0, h)), o = !1, l);
  };
}
function ab(t) {
  return t;
}
function dd(t) {
  return K0() ? ($0(t), !0) : !1;
}
function lb(t, e = 200, n = !1, r = !0, i = !1) {
  return sb(ob(e, n, r, i), t);
}
function ub(t, e = !0) {
  ht() ? Ct(t) : e ? t() : rt(t);
}
function pi(t) {
  var e;
  const n = cd(t);
  return (e = n == null ? void 0 : n.$el) != null ? e : n;
}
const fd = St ? window : void 0;
function bn(...t) {
  let e, n, r, i;
  if (ib(t[0]) || Array.isArray(t[0]) ? ([n, r, i] = t, e = fd) : [e, n, r, i] = t, !e)
    return rl;
  Array.isArray(n) || (n = [n]), Array.isArray(r) || (r = [r]);
  const s = [], o = () => {
    s.forEach((c) => c()), s.length = 0;
  }, a = (c, d, h, v) => (c.addEventListener(d, h, v), () => c.removeEventListener(d, h, v)), l = ke(() => [pi(e), cd(i)], ([c, d]) => {
    o(), c && s.push(...n.flatMap((h) => r.map((v) => a(c, h, v, d))));
  }, { immediate: !0, flush: "post" }), u = () => {
    l(), o();
  };
  return dd(u), u;
}
let jf = !1;
function cb(t, e, n = {}) {
  const { window: r = fd, ignore: i = [], capture: s = !0, detectIframe: o = !1 } = n;
  if (!r)
    return;
  Sv && !jf && (jf = !0, Array.from(r.document.body.children).forEach((h) => h.addEventListener("click", rl)));
  let a = !0;
  const l = (h) => i.some((v) => {
    if (typeof v == "string")
      return Array.from(r.document.querySelectorAll(v)).some((y) => y === h.target || h.composedPath().includes(y));
    {
      const y = pi(v);
      return y && (h.target === y || h.composedPath().includes(y));
    }
  }), c = [
    bn(r, "click", (h) => {
      const v = pi(t);
      if (!(!v || v === h.target || h.composedPath().includes(v))) {
        if (h.detail === 0 && (a = !l(h)), !a) {
          a = !0;
          return;
        }
        e(h);
      }
    }, { passive: !0, capture: s }),
    bn(r, "pointerdown", (h) => {
      const v = pi(t);
      v && (a = !h.composedPath().includes(v) && !l(h));
    }, { passive: !0 }),
    o && bn(r, "blur", (h) => {
      var v;
      const y = pi(t);
      ((v = r.document.activeElement) == null ? void 0 : v.tagName) === "IFRAME" && !(y != null && y.contains(r.document.activeElement)) && e(h);
    })
  ].filter(Boolean);
  return () => c.forEach((h) => h());
}
function db(t, e = !1) {
  const n = $(), r = () => n.value = !!t();
  return r(), ub(r, e), n;
}
function fb(t) {
  return JSON.parse(JSON.stringify(t));
}
const Ff = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Hf = "__vueuse_ssr_handlers__";
Ff[Hf] = Ff[Hf] || {};
var Uf = Object.getOwnPropertySymbols, hb = Object.prototype.hasOwnProperty, pb = Object.prototype.propertyIsEnumerable, vb = (t, e) => {
  var n = {};
  for (var r in t)
    hb.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && Uf)
    for (var r of Uf(t))
      e.indexOf(r) < 0 && pb.call(t, r) && (n[r] = t[r]);
  return n;
};
function As(t, e, n = {}) {
  const r = n, { window: i = fd } = r, s = vb(r, ["window"]);
  let o;
  const a = db(() => i && "ResizeObserver" in i), l = () => {
    o && (o.disconnect(), o = void 0);
  }, u = ke(() => pi(t), (d) => {
    l(), a.value && i && d && (o = new ResizeObserver(e), o.observe(d, s));
  }, { immediate: !0, flush: "post" }), c = () => {
    l(), u();
  };
  return dd(c), {
    isSupported: a,
    stop: c
  };
}
var Vf;
(function(t) {
  t.UP = "UP", t.RIGHT = "RIGHT", t.DOWN = "DOWN", t.LEFT = "LEFT", t.NONE = "NONE";
})(Vf || (Vf = {}));
var gb = Object.defineProperty, Wf = Object.getOwnPropertySymbols, mb = Object.prototype.hasOwnProperty, yb = Object.prototype.propertyIsEnumerable, Kf = (t, e, n) => e in t ? gb(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, bb = (t, e) => {
  for (var n in e || (e = {}))
    mb.call(e, n) && Kf(t, n, e[n]);
  if (Wf)
    for (var n of Wf(e))
      yb.call(e, n) && Kf(t, n, e[n]);
  return t;
};
const wb = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
bb({
  linear: ab
}, wb);
function _b(t, e, n, r = {}) {
  var i, s, o;
  const {
    clone: a = !1,
    passive: l = !1,
    eventName: u,
    deep: c = !1,
    defaultValue: d
  } = r, h = ht(), v = n || (h == null ? void 0 : h.emit) || ((i = h == null ? void 0 : h.$emit) == null ? void 0 : i.bind(h)) || ((o = (s = h == null ? void 0 : h.proxy) == null ? void 0 : s.$emit) == null ? void 0 : o.bind(h == null ? void 0 : h.proxy));
  let y = u;
  e || (e = "modelValue"), y = u || y || `update:${e.toString()}`;
  const b = (f) => a ? rb(a) ? a(f) : fb(f) : f, p = () => nb(t[e]) ? b(t[e]) : d;
  if (l) {
    const f = p(), g = $(f);
    return ke(() => t[e], (m) => g.value = b(m)), ke(g, (m) => {
      (m !== t[e] || c) && v(y, m);
    }, { deep: c }), g;
  } else
    return F({
      get() {
        return p();
      },
      set(f) {
        v(y, f);
      }
    });
}
const Sb = () => St && /firefox/i.test(window.navigator.userAgent), Eb = (t, e) => {
  if (!St || !t || !e)
    return !1;
  const n = t.getBoundingClientRect();
  let r;
  return e instanceof Element ? r = e.getBoundingClientRect() : r = {
    top: 0,
    right: window.innerWidth,
    bottom: window.innerHeight,
    left: 0
  }, n.top < r.bottom && n.bottom > r.top && n.right > r.left && n.left < r.right;
};
process.env.NODE_ENV !== "production" && Object.freeze({});
process.env.NODE_ENV !== "production" && Object.freeze([]);
const en = () => {
}, xb = Object.prototype.hasOwnProperty, Tr = (t, e) => xb.call(t, e), Or = Array.isArray, gn = (t) => typeof t == "function", Gt = (t) => typeof t == "string", wn = (t) => t !== null && typeof t == "object", Ab = Object.prototype.toString, Ev = (t) => Ab.call(t), hu = (t) => Ev(t).slice(8, -1), $f = (t) => Ev(t) === "[object Object]", xv = (t) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (n) => e[n] || (e[n] = t(n));
}, kb = /-(\w)/g, Cb = xv((t) => t.replace(kb, (e, n) => n ? n.toUpperCase() : "")), Tb = /\B([A-Z])/g, Ob = xv((t) => t.replace(Tb, "-$1").toLowerCase());
var Ib = typeof global == "object" && global && global.Object === Object && global;
const Av = Ib;
var Nb = typeof self == "object" && self && self.Object === Object && self, Rb = Av || Nb || Function("return this")();
const yr = Rb;
var Pb = yr.Symbol;
const nr = Pb;
var kv = Object.prototype, Bb = kv.hasOwnProperty, Db = kv.toString, Js = nr ? nr.toStringTag : void 0;
function Mb(t) {
  var e = Bb.call(t, Js), n = t[Js];
  try {
    t[Js] = void 0;
    var r = !0;
  } catch {
  }
  var i = Db.call(t);
  return r && (e ? t[Js] = n : delete t[Js]), i;
}
var Lb = Object.prototype, zb = Lb.toString;
function jb(t) {
  return zb.call(t);
}
var Fb = "[object Null]", Hb = "[object Undefined]", Gf = nr ? nr.toStringTag : void 0;
function Ki(t) {
  return t == null ? t === void 0 ? Hb : Fb : Gf && Gf in Object(t) ? Mb(t) : jb(t);
}
function Ir(t) {
  return t != null && typeof t == "object";
}
var Ub = "[object Symbol]";
function zl(t) {
  return typeof t == "symbol" || Ir(t) && Ki(t) == Ub;
}
function Cv(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length, i = Array(r); ++n < r; )
    i[n] = e(t[n], n, t);
  return i;
}
var Vb = Array.isArray;
const Hn = Vb;
var Wb = 1 / 0, qf = nr ? nr.prototype : void 0, Jf = qf ? qf.toString : void 0;
function Tv(t) {
  if (typeof t == "string")
    return t;
  if (Hn(t))
    return Cv(t, Tv) + "";
  if (zl(t))
    return Jf ? Jf.call(t) : "";
  var e = t + "";
  return e == "0" && 1 / t == -Wb ? "-0" : e;
}
var Kb = /\s/;
function $b(t) {
  for (var e = t.length; e-- && Kb.test(t.charAt(e)); )
    ;
  return e;
}
var Gb = /^\s+/;
function qb(t) {
  return t && t.slice(0, $b(t) + 1).replace(Gb, "");
}
function Rn(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var Yf = 0 / 0, Jb = /^[-+]0x[0-9a-f]+$/i, Yb = /^0b[01]+$/i, Qb = /^0o[0-7]+$/i, Zb = parseInt;
function Ju(t) {
  if (typeof t == "number")
    return t;
  if (zl(t))
    return Yf;
  if (Rn(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = Rn(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = qb(t);
  var n = Yb.test(t);
  return n || Qb.test(t) ? Zb(t.slice(2), n ? 2 : 8) : Jb.test(t) ? Yf : +t;
}
var Qf = 1 / 0, Xb = 17976931348623157e292;
function ew(t) {
  if (!t)
    return t === 0 ? t : 0;
  if (t = Ju(t), t === Qf || t === -Qf) {
    var e = t < 0 ? -1 : 1;
    return e * Xb;
  }
  return t === t ? t : 0;
}
function tw(t) {
  var e = ew(t), n = e % 1;
  return e === e ? n ? e - n : e : 0;
}
function hd(t) {
  return t;
}
var nw = "[object AsyncFunction]", rw = "[object Function]", iw = "[object GeneratorFunction]", sw = "[object Proxy]";
function pd(t) {
  if (!Rn(t))
    return !1;
  var e = Ki(t);
  return e == rw || e == iw || e == nw || e == sw;
}
var ow = yr["__core-js_shared__"];
const pu = ow;
var Zf = function() {
  var t = /[^.]+$/.exec(pu && pu.keys && pu.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
}();
function aw(t) {
  return !!Zf && Zf in t;
}
var lw = Function.prototype, uw = lw.toString;
function $i(t) {
  if (t != null) {
    try {
      return uw.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
var cw = /[\\^$.*+?()[\]{}|]/g, dw = /^\[object .+?Constructor\]$/, fw = Function.prototype, hw = Object.prototype, pw = fw.toString, vw = hw.hasOwnProperty, gw = RegExp(
  "^" + pw.call(vw).replace(cw, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function mw(t) {
  if (!Rn(t) || aw(t))
    return !1;
  var e = pd(t) ? gw : dw;
  return e.test($i(t));
}
function yw(t, e) {
  return t == null ? void 0 : t[e];
}
function Gi(t, e) {
  var n = yw(t, e);
  return mw(n) ? n : void 0;
}
var bw = Gi(yr, "WeakMap");
const Yu = bw;
var Xf = Object.create, ww = function() {
  function t() {
  }
  return function(e) {
    if (!Rn(e))
      return {};
    if (Xf)
      return Xf(e);
    t.prototype = e;
    var n = new t();
    return t.prototype = void 0, n;
  };
}();
const _w = ww;
function Sw(t, e, n) {
  switch (n.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, n[0]);
    case 2:
      return t.call(e, n[0], n[1]);
    case 3:
      return t.call(e, n[0], n[1], n[2]);
  }
  return t.apply(e, n);
}
function Ov(t, e) {
  var n = -1, r = t.length;
  for (e || (e = Array(r)); ++n < r; )
    e[n] = t[n];
  return e;
}
var Ew = 800, xw = 16, Aw = Date.now;
function kw(t) {
  var e = 0, n = 0;
  return function() {
    var r = Aw(), i = xw - (r - n);
    if (n = r, i > 0) {
      if (++e >= Ew)
        return arguments[0];
    } else
      e = 0;
    return t.apply(void 0, arguments);
  };
}
function Cw(t) {
  return function() {
    return t;
  };
}
var Tw = function() {
  try {
    var t = Gi(Object, "defineProperty");
    return t({}, "", {}), t;
  } catch {
  }
}();
const il = Tw;
var Ow = il ? function(t, e) {
  return il(t, "toString", {
    configurable: !0,
    enumerable: !1,
    value: Cw(e),
    writable: !0
  });
} : hd;
const Iw = Ow;
var Nw = kw(Iw);
const Iv = Nw;
function Rw(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length; ++n < r && e(t[n], n, t) !== !1; )
    ;
  return t;
}
function Pw(t, e, n, r) {
  for (var i = t.length, s = n + (r ? 1 : -1); r ? s-- : ++s < i; )
    if (e(t[s], s, t))
      return s;
  return -1;
}
var Bw = 9007199254740991, Dw = /^(?:0|[1-9]\d*)$/;
function jl(t, e) {
  var n = typeof t;
  return e = e ?? Bw, !!e && (n == "number" || n != "symbol" && Dw.test(t)) && t > -1 && t % 1 == 0 && t < e;
}
function vd(t, e, n) {
  e == "__proto__" && il ? il(t, e, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : t[e] = n;
}
function $o(t, e) {
  return t === e || t !== t && e !== e;
}
var Mw = Object.prototype, Lw = Mw.hasOwnProperty;
function gd(t, e, n) {
  var r = t[e];
  (!(Lw.call(t, e) && $o(r, n)) || n === void 0 && !(e in t)) && vd(t, e, n);
}
function Go(t, e, n, r) {
  var i = !n;
  n || (n = {});
  for (var s = -1, o = e.length; ++s < o; ) {
    var a = e[s], l = r ? r(n[a], t[a], a, n, t) : void 0;
    l === void 0 && (l = t[a]), i ? vd(n, a, l) : gd(n, a, l);
  }
  return n;
}
var eh = Math.max;
function Nv(t, e, n) {
  return e = eh(e === void 0 ? t.length - 1 : e, 0), function() {
    for (var r = arguments, i = -1, s = eh(r.length - e, 0), o = Array(s); ++i < s; )
      o[i] = r[e + i];
    i = -1;
    for (var a = Array(e + 1); ++i < e; )
      a[i] = r[i];
    return a[e] = n(o), Sw(t, this, a);
  };
}
function zw(t, e) {
  return Iv(Nv(t, e, hd), t + "");
}
var jw = 9007199254740991;
function md(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= jw;
}
function js(t) {
  return t != null && md(t.length) && !pd(t);
}
function Fw(t, e, n) {
  if (!Rn(n))
    return !1;
  var r = typeof e;
  return (r == "number" ? js(n) && jl(e, n.length) : r == "string" && e in n) ? $o(n[e], t) : !1;
}
function Hw(t) {
  return zw(function(e, n) {
    var r = -1, i = n.length, s = i > 1 ? n[i - 1] : void 0, o = i > 2 ? n[2] : void 0;
    for (s = t.length > 3 && typeof s == "function" ? (i--, s) : void 0, o && Fw(n[0], n[1], o) && (s = i < 3 ? void 0 : s, i = 1), e = Object(e); ++r < i; ) {
      var a = n[r];
      a && t(e, a, r, s);
    }
    return e;
  });
}
var Uw = Object.prototype;
function yd(t) {
  var e = t && t.constructor, n = typeof e == "function" && e.prototype || Uw;
  return t === n;
}
function Vw(t, e) {
  for (var n = -1, r = Array(t); ++n < t; )
    r[n] = e(n);
  return r;
}
var Ww = "[object Arguments]";
function th(t) {
  return Ir(t) && Ki(t) == Ww;
}
var Rv = Object.prototype, Kw = Rv.hasOwnProperty, $w = Rv.propertyIsEnumerable, Gw = th(function() {
  return arguments;
}()) ? th : function(t) {
  return Ir(t) && Kw.call(t, "callee") && !$w.call(t, "callee");
};
const wo = Gw;
function qw() {
  return !1;
}
var Pv = typeof exports == "object" && exports && !exports.nodeType && exports, nh = Pv && typeof module == "object" && module && !module.nodeType && module, Jw = nh && nh.exports === Pv, rh = Jw ? yr.Buffer : void 0, Yw = rh ? rh.isBuffer : void 0, Qw = Yw || qw;
const _o = Qw;
var Zw = "[object Arguments]", Xw = "[object Array]", e1 = "[object Boolean]", t1 = "[object Date]", n1 = "[object Error]", r1 = "[object Function]", i1 = "[object Map]", s1 = "[object Number]", o1 = "[object Object]", a1 = "[object RegExp]", l1 = "[object Set]", u1 = "[object String]", c1 = "[object WeakMap]", d1 = "[object ArrayBuffer]", f1 = "[object DataView]", h1 = "[object Float32Array]", p1 = "[object Float64Array]", v1 = "[object Int8Array]", g1 = "[object Int16Array]", m1 = "[object Int32Array]", y1 = "[object Uint8Array]", b1 = "[object Uint8ClampedArray]", w1 = "[object Uint16Array]", _1 = "[object Uint32Array]", Ht = {};
Ht[h1] = Ht[p1] = Ht[v1] = Ht[g1] = Ht[m1] = Ht[y1] = Ht[b1] = Ht[w1] = Ht[_1] = !0;
Ht[Zw] = Ht[Xw] = Ht[d1] = Ht[e1] = Ht[f1] = Ht[t1] = Ht[n1] = Ht[r1] = Ht[i1] = Ht[s1] = Ht[o1] = Ht[a1] = Ht[l1] = Ht[u1] = Ht[c1] = !1;
function S1(t) {
  return Ir(t) && md(t.length) && !!Ht[Ki(t)];
}
function bd(t) {
  return function(e) {
    return t(e);
  };
}
var Bv = typeof exports == "object" && exports && !exports.nodeType && exports, ao = Bv && typeof module == "object" && module && !module.nodeType && module, E1 = ao && ao.exports === Bv, vu = E1 && Av.process, x1 = function() {
  try {
    var t = ao && ao.require && ao.require("util").types;
    return t || vu && vu.binding && vu.binding("util");
  } catch {
  }
}();
const ks = x1;
var ih = ks && ks.isTypedArray, A1 = ih ? bd(ih) : S1;
const wd = A1;
var k1 = Object.prototype, C1 = k1.hasOwnProperty;
function Dv(t, e) {
  var n = Hn(t), r = !n && wo(t), i = !n && !r && _o(t), s = !n && !r && !i && wd(t), o = n || r || i || s, a = o ? Vw(t.length, String) : [], l = a.length;
  for (var u in t)
    (e || C1.call(t, u)) && !(o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (u == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (u == "offset" || u == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (u == "buffer" || u == "byteLength" || u == "byteOffset") || // Skip index properties.
    jl(u, l))) && a.push(u);
  return a;
}
function Mv(t, e) {
  return function(n) {
    return t(e(n));
  };
}
var T1 = Mv(Object.keys, Object);
const O1 = T1;
var I1 = Object.prototype, N1 = I1.hasOwnProperty;
function R1(t) {
  if (!yd(t))
    return O1(t);
  var e = [];
  for (var n in Object(t))
    N1.call(t, n) && n != "constructor" && e.push(n);
  return e;
}
function qo(t) {
  return js(t) ? Dv(t) : R1(t);
}
function P1(t) {
  var e = [];
  if (t != null)
    for (var n in Object(t))
      e.push(n);
  return e;
}
var B1 = Object.prototype, D1 = B1.hasOwnProperty;
function M1(t) {
  if (!Rn(t))
    return P1(t);
  var e = yd(t), n = [];
  for (var r in t)
    r == "constructor" && (e || !D1.call(t, r)) || n.push(r);
  return n;
}
function Jo(t) {
  return js(t) ? Dv(t, !0) : M1(t);
}
var L1 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, z1 = /^\w*$/;
function _d(t, e) {
  if (Hn(t))
    return !1;
  var n = typeof t;
  return n == "number" || n == "symbol" || n == "boolean" || t == null || zl(t) ? !0 : z1.test(t) || !L1.test(t) || e != null && t in Object(e);
}
var j1 = Gi(Object, "create");
const So = j1;
function F1() {
  this.__data__ = So ? So(null) : {}, this.size = 0;
}
function H1(t) {
  var e = this.has(t) && delete this.__data__[t];
  return this.size -= e ? 1 : 0, e;
}
var U1 = "__lodash_hash_undefined__", V1 = Object.prototype, W1 = V1.hasOwnProperty;
function K1(t) {
  var e = this.__data__;
  if (So) {
    var n = e[t];
    return n === U1 ? void 0 : n;
  }
  return W1.call(e, t) ? e[t] : void 0;
}
var $1 = Object.prototype, G1 = $1.hasOwnProperty;
function q1(t) {
  var e = this.__data__;
  return So ? e[t] !== void 0 : G1.call(e, t);
}
var J1 = "__lodash_hash_undefined__";
function Y1(t, e) {
  var n = this.__data__;
  return this.size += this.has(t) ? 0 : 1, n[t] = So && e === void 0 ? J1 : e, this;
}
function zi(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
zi.prototype.clear = F1;
zi.prototype.delete = H1;
zi.prototype.get = K1;
zi.prototype.has = q1;
zi.prototype.set = Y1;
function Q1() {
  this.__data__ = [], this.size = 0;
}
function Fl(t, e) {
  for (var n = t.length; n--; )
    if ($o(t[n][0], e))
      return n;
  return -1;
}
var Z1 = Array.prototype, X1 = Z1.splice;
function e_(t) {
  var e = this.__data__, n = Fl(e, t);
  if (n < 0)
    return !1;
  var r = e.length - 1;
  return n == r ? e.pop() : X1.call(e, n, 1), --this.size, !0;
}
function t_(t) {
  var e = this.__data__, n = Fl(e, t);
  return n < 0 ? void 0 : e[n][1];
}
function n_(t) {
  return Fl(this.__data__, t) > -1;
}
function r_(t, e) {
  var n = this.__data__, r = Fl(n, t);
  return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this;
}
function ii(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
ii.prototype.clear = Q1;
ii.prototype.delete = e_;
ii.prototype.get = t_;
ii.prototype.has = n_;
ii.prototype.set = r_;
var i_ = Gi(yr, "Map");
const Eo = i_;
function s_() {
  this.size = 0, this.__data__ = {
    hash: new zi(),
    map: new (Eo || ii)(),
    string: new zi()
  };
}
function o_(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
function Hl(t, e) {
  var n = t.__data__;
  return o_(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map;
}
function a_(t) {
  var e = Hl(this, t).delete(t);
  return this.size -= e ? 1 : 0, e;
}
function l_(t) {
  return Hl(this, t).get(t);
}
function u_(t) {
  return Hl(this, t).has(t);
}
function c_(t, e) {
  var n = Hl(this, t), r = n.size;
  return n.set(t, e), this.size += n.size == r ? 0 : 1, this;
}
function si(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
si.prototype.clear = s_;
si.prototype.delete = a_;
si.prototype.get = l_;
si.prototype.has = u_;
si.prototype.set = c_;
var d_ = "Expected a function";
function Sd(t, e) {
  if (typeof t != "function" || e != null && typeof e != "function")
    throw new TypeError(d_);
  var n = function() {
    var r = arguments, i = e ? e.apply(this, r) : r[0], s = n.cache;
    if (s.has(i))
      return s.get(i);
    var o = t.apply(this, r);
    return n.cache = s.set(i, o) || s, o;
  };
  return n.cache = new (Sd.Cache || si)(), n;
}
Sd.Cache = si;
var f_ = 500;
function h_(t) {
  var e = Sd(t, function(r) {
    return n.size === f_ && n.clear(), r;
  }), n = e.cache;
  return e;
}
var p_ = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, v_ = /\\(\\)?/g, g_ = h_(function(t) {
  var e = [];
  return t.charCodeAt(0) === 46 && e.push(""), t.replace(p_, function(n, r, i, s) {
    e.push(i ? s.replace(v_, "$1") : r || n);
  }), e;
});
const m_ = g_;
function y_(t) {
  return t == null ? "" : Tv(t);
}
function Ul(t, e) {
  return Hn(t) ? t : _d(t, e) ? [t] : m_(y_(t));
}
var b_ = 1 / 0;
function Yo(t) {
  if (typeof t == "string" || zl(t))
    return t;
  var e = t + "";
  return e == "0" && 1 / t == -b_ ? "-0" : e;
}
function Ed(t, e) {
  e = Ul(e, t);
  for (var n = 0, r = e.length; t != null && n < r; )
    t = t[Yo(e[n++])];
  return n && n == r ? t : void 0;
}
function An(t, e, n) {
  var r = t == null ? void 0 : Ed(t, e);
  return r === void 0 ? n : r;
}
function xd(t, e) {
  for (var n = -1, r = e.length, i = t.length; ++n < r; )
    t[i + n] = e[n];
  return t;
}
var sh = nr ? nr.isConcatSpreadable : void 0;
function w_(t) {
  return Hn(t) || wo(t) || !!(sh && t && t[sh]);
}
function Ad(t, e, n, r, i) {
  var s = -1, o = t.length;
  for (n || (n = w_), i || (i = []); ++s < o; ) {
    var a = t[s];
    e > 0 && n(a) ? e > 1 ? Ad(a, e - 1, n, r, i) : xd(i, a) : r || (i[i.length] = a);
  }
  return i;
}
function __(t) {
  var e = t == null ? 0 : t.length;
  return e ? Ad(t, 1) : [];
}
function S_(t) {
  return Iv(Nv(t, void 0, __), t + "");
}
var E_ = Mv(Object.getPrototypeOf, Object);
const kd = E_;
var x_ = "[object Object]", A_ = Function.prototype, k_ = Object.prototype, Lv = A_.toString, C_ = k_.hasOwnProperty, T_ = Lv.call(Object);
function O_(t) {
  if (!Ir(t) || Ki(t) != x_)
    return !1;
  var e = kd(t);
  if (e === null)
    return !0;
  var n = C_.call(e, "constructor") && e.constructor;
  return typeof n == "function" && n instanceof n && Lv.call(n) == T_;
}
function I_() {
  this.__data__ = new ii(), this.size = 0;
}
function N_(t) {
  var e = this.__data__, n = e.delete(t);
  return this.size = e.size, n;
}
function R_(t) {
  return this.__data__.get(t);
}
function P_(t) {
  return this.__data__.has(t);
}
var B_ = 200;
function D_(t, e) {
  var n = this.__data__;
  if (n instanceof ii) {
    var r = n.__data__;
    if (!Eo || r.length < B_ - 1)
      return r.push([t, e]), this.size = ++n.size, this;
    n = this.__data__ = new si(r);
  }
  return n.set(t, e), this.size = n.size, this;
}
function pr(t) {
  var e = this.__data__ = new ii(t);
  this.size = e.size;
}
pr.prototype.clear = I_;
pr.prototype.delete = N_;
pr.prototype.get = R_;
pr.prototype.has = P_;
pr.prototype.set = D_;
function M_(t, e) {
  return t && Go(e, qo(e), t);
}
function L_(t, e) {
  return t && Go(e, Jo(e), t);
}
var zv = typeof exports == "object" && exports && !exports.nodeType && exports, oh = zv && typeof module == "object" && module && !module.nodeType && module, z_ = oh && oh.exports === zv, ah = z_ ? yr.Buffer : void 0, lh = ah ? ah.allocUnsafe : void 0;
function jv(t, e) {
  if (e)
    return t.slice();
  var n = t.length, r = lh ? lh(n) : new t.constructor(n);
  return t.copy(r), r;
}
function j_(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length, i = 0, s = []; ++n < r; ) {
    var o = t[n];
    e(o, n, t) && (s[i++] = o);
  }
  return s;
}
function Fv() {
  return [];
}
var F_ = Object.prototype, H_ = F_.propertyIsEnumerable, uh = Object.getOwnPropertySymbols, U_ = uh ? function(t) {
  return t == null ? [] : (t = Object(t), j_(uh(t), function(e) {
    return H_.call(t, e);
  }));
} : Fv;
const Cd = U_;
function V_(t, e) {
  return Go(t, Cd(t), e);
}
var W_ = Object.getOwnPropertySymbols, K_ = W_ ? function(t) {
  for (var e = []; t; )
    xd(e, Cd(t)), t = kd(t);
  return e;
} : Fv;
const Hv = K_;
function $_(t, e) {
  return Go(t, Hv(t), e);
}
function Uv(t, e, n) {
  var r = e(t);
  return Hn(t) ? r : xd(r, n(t));
}
function Qu(t) {
  return Uv(t, qo, Cd);
}
function G_(t) {
  return Uv(t, Jo, Hv);
}
var q_ = Gi(yr, "DataView");
const Zu = q_;
var J_ = Gi(yr, "Promise");
const Xu = J_;
var Y_ = Gi(yr, "Set");
const ec = Y_;
var ch = "[object Map]", Q_ = "[object Object]", dh = "[object Promise]", fh = "[object Set]", hh = "[object WeakMap]", ph = "[object DataView]", Z_ = $i(Zu), X_ = $i(Eo), eS = $i(Xu), tS = $i(ec), nS = $i(Yu), Ti = Ki;
(Zu && Ti(new Zu(new ArrayBuffer(1))) != ph || Eo && Ti(new Eo()) != ch || Xu && Ti(Xu.resolve()) != dh || ec && Ti(new ec()) != fh || Yu && Ti(new Yu()) != hh) && (Ti = function(t) {
  var e = Ki(t), n = e == Q_ ? t.constructor : void 0, r = n ? $i(n) : "";
  if (r)
    switch (r) {
      case Z_:
        return ph;
      case X_:
        return ch;
      case eS:
        return dh;
      case tS:
        return fh;
      case nS:
        return hh;
    }
  return e;
});
const xo = Ti;
var rS = Object.prototype, iS = rS.hasOwnProperty;
function sS(t) {
  var e = t.length, n = new t.constructor(e);
  return e && typeof t[0] == "string" && iS.call(t, "index") && (n.index = t.index, n.input = t.input), n;
}
var oS = yr.Uint8Array;
const sl = oS;
function Td(t) {
  var e = new t.constructor(t.byteLength);
  return new sl(e).set(new sl(t)), e;
}
function aS(t, e) {
  var n = e ? Td(t.buffer) : t.buffer;
  return new t.constructor(n, t.byteOffset, t.byteLength);
}
var lS = /\w*$/;
function uS(t) {
  var e = new t.constructor(t.source, lS.exec(t));
  return e.lastIndex = t.lastIndex, e;
}
var vh = nr ? nr.prototype : void 0, gh = vh ? vh.valueOf : void 0;
function cS(t) {
  return gh ? Object(gh.call(t)) : {};
}
function Vv(t, e) {
  var n = e ? Td(t.buffer) : t.buffer;
  return new t.constructor(n, t.byteOffset, t.length);
}
var dS = "[object Boolean]", fS = "[object Date]", hS = "[object Map]", pS = "[object Number]", vS = "[object RegExp]", gS = "[object Set]", mS = "[object String]", yS = "[object Symbol]", bS = "[object ArrayBuffer]", wS = "[object DataView]", _S = "[object Float32Array]", SS = "[object Float64Array]", ES = "[object Int8Array]", xS = "[object Int16Array]", AS = "[object Int32Array]", kS = "[object Uint8Array]", CS = "[object Uint8ClampedArray]", TS = "[object Uint16Array]", OS = "[object Uint32Array]";
function IS(t, e, n) {
  var r = t.constructor;
  switch (e) {
    case bS:
      return Td(t);
    case dS:
    case fS:
      return new r(+t);
    case wS:
      return aS(t, n);
    case _S:
    case SS:
    case ES:
    case xS:
    case AS:
    case kS:
    case CS:
    case TS:
    case OS:
      return Vv(t, n);
    case hS:
      return new r();
    case pS:
    case mS:
      return new r(t);
    case vS:
      return uS(t);
    case gS:
      return new r();
    case yS:
      return cS(t);
  }
}
function Wv(t) {
  return typeof t.constructor == "function" && !yd(t) ? _w(kd(t)) : {};
}
var NS = "[object Map]";
function RS(t) {
  return Ir(t) && xo(t) == NS;
}
var mh = ks && ks.isMap, PS = mh ? bd(mh) : RS;
const BS = PS;
var DS = "[object Set]";
function MS(t) {
  return Ir(t) && xo(t) == DS;
}
var yh = ks && ks.isSet, LS = yh ? bd(yh) : MS;
const zS = LS;
var jS = 1, FS = 2, HS = 4, Kv = "[object Arguments]", US = "[object Array]", VS = "[object Boolean]", WS = "[object Date]", KS = "[object Error]", $v = "[object Function]", $S = "[object GeneratorFunction]", GS = "[object Map]", qS = "[object Number]", Gv = "[object Object]", JS = "[object RegExp]", YS = "[object Set]", QS = "[object String]", ZS = "[object Symbol]", XS = "[object WeakMap]", eE = "[object ArrayBuffer]", tE = "[object DataView]", nE = "[object Float32Array]", rE = "[object Float64Array]", iE = "[object Int8Array]", sE = "[object Int16Array]", oE = "[object Int32Array]", aE = "[object Uint8Array]", lE = "[object Uint8ClampedArray]", uE = "[object Uint16Array]", cE = "[object Uint32Array]", jt = {};
jt[Kv] = jt[US] = jt[eE] = jt[tE] = jt[VS] = jt[WS] = jt[nE] = jt[rE] = jt[iE] = jt[sE] = jt[oE] = jt[GS] = jt[qS] = jt[Gv] = jt[JS] = jt[YS] = jt[QS] = jt[ZS] = jt[aE] = jt[lE] = jt[uE] = jt[cE] = !0;
jt[KS] = jt[$v] = jt[XS] = !1;
function Pa(t, e, n, r, i, s) {
  var o, a = e & jS, l = e & FS, u = e & HS;
  if (n && (o = i ? n(t, r, i, s) : n(t)), o !== void 0)
    return o;
  if (!Rn(t))
    return t;
  var c = Hn(t);
  if (c) {
    if (o = sS(t), !a)
      return Ov(t, o);
  } else {
    var d = xo(t), h = d == $v || d == $S;
    if (_o(t))
      return jv(t, a);
    if (d == Gv || d == Kv || h && !i) {
      if (o = l || h ? {} : Wv(t), !a)
        return l ? $_(t, L_(o, t)) : V_(t, M_(o, t));
    } else {
      if (!jt[d])
        return i ? t : {};
      o = IS(t, d, a);
    }
  }
  s || (s = new pr());
  var v = s.get(t);
  if (v)
    return v;
  s.set(t, o), zS(t) ? t.forEach(function(p) {
    o.add(Pa(p, e, n, p, t, s));
  }) : BS(t) && t.forEach(function(p, f) {
    o.set(f, Pa(p, e, n, f, t, s));
  });
  var y = u ? l ? G_ : Qu : l ? Jo : qo, b = c ? void 0 : y(t);
  return Rw(b || t, function(p, f) {
    b && (f = p, p = t[f]), gd(o, f, Pa(p, e, n, f, t, s));
  }), o;
}
var dE = 1, fE = 4;
function bh(t) {
  return Pa(t, dE | fE);
}
var hE = "__lodash_hash_undefined__";
function pE(t) {
  return this.__data__.set(t, hE), this;
}
function vE(t) {
  return this.__data__.has(t);
}
function ol(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.__data__ = new si(); ++e < n; )
    this.add(t[e]);
}
ol.prototype.add = ol.prototype.push = pE;
ol.prototype.has = vE;
function gE(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length; ++n < r; )
    if (e(t[n], n, t))
      return !0;
  return !1;
}
function mE(t, e) {
  return t.has(e);
}
var yE = 1, bE = 2;
function qv(t, e, n, r, i, s) {
  var o = n & yE, a = t.length, l = e.length;
  if (a != l && !(o && l > a))
    return !1;
  var u = s.get(t), c = s.get(e);
  if (u && c)
    return u == e && c == t;
  var d = -1, h = !0, v = n & bE ? new ol() : void 0;
  for (s.set(t, e), s.set(e, t); ++d < a; ) {
    var y = t[d], b = e[d];
    if (r)
      var p = o ? r(b, y, d, e, t, s) : r(y, b, d, t, e, s);
    if (p !== void 0) {
      if (p)
        continue;
      h = !1;
      break;
    }
    if (v) {
      if (!gE(e, function(f, g) {
        if (!mE(v, g) && (y === f || i(y, f, n, r, s)))
          return v.push(g);
      })) {
        h = !1;
        break;
      }
    } else if (!(y === b || i(y, b, n, r, s))) {
      h = !1;
      break;
    }
  }
  return s.delete(t), s.delete(e), h;
}
function wE(t) {
  var e = -1, n = Array(t.size);
  return t.forEach(function(r, i) {
    n[++e] = [i, r];
  }), n;
}
function _E(t) {
  var e = -1, n = Array(t.size);
  return t.forEach(function(r) {
    n[++e] = r;
  }), n;
}
var SE = 1, EE = 2, xE = "[object Boolean]", AE = "[object Date]", kE = "[object Error]", CE = "[object Map]", TE = "[object Number]", OE = "[object RegExp]", IE = "[object Set]", NE = "[object String]", RE = "[object Symbol]", PE = "[object ArrayBuffer]", BE = "[object DataView]", wh = nr ? nr.prototype : void 0, gu = wh ? wh.valueOf : void 0;
function DE(t, e, n, r, i, s, o) {
  switch (n) {
    case BE:
      if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
        return !1;
      t = t.buffer, e = e.buffer;
    case PE:
      return !(t.byteLength != e.byteLength || !s(new sl(t), new sl(e)));
    case xE:
    case AE:
    case TE:
      return $o(+t, +e);
    case kE:
      return t.name == e.name && t.message == e.message;
    case OE:
    case NE:
      return t == e + "";
    case CE:
      var a = wE;
    case IE:
      var l = r & SE;
      if (a || (a = _E), t.size != e.size && !l)
        return !1;
      var u = o.get(t);
      if (u)
        return u == e;
      r |= EE, o.set(t, e);
      var c = qv(a(t), a(e), r, i, s, o);
      return o.delete(t), c;
    case RE:
      if (gu)
        return gu.call(t) == gu.call(e);
  }
  return !1;
}
var ME = 1, LE = Object.prototype, zE = LE.hasOwnProperty;
function jE(t, e, n, r, i, s) {
  var o = n & ME, a = Qu(t), l = a.length, u = Qu(e), c = u.length;
  if (l != c && !o)
    return !1;
  for (var d = l; d--; ) {
    var h = a[d];
    if (!(o ? h in e : zE.call(e, h)))
      return !1;
  }
  var v = s.get(t), y = s.get(e);
  if (v && y)
    return v == e && y == t;
  var b = !0;
  s.set(t, e), s.set(e, t);
  for (var p = o; ++d < l; ) {
    h = a[d];
    var f = t[h], g = e[h];
    if (r)
      var m = o ? r(g, f, h, e, t, s) : r(f, g, h, t, e, s);
    if (!(m === void 0 ? f === g || i(f, g, n, r, s) : m)) {
      b = !1;
      break;
    }
    p || (p = h == "constructor");
  }
  if (b && !p) {
    var w = t.constructor, _ = e.constructor;
    w != _ && "constructor" in t && "constructor" in e && !(typeof w == "function" && w instanceof w && typeof _ == "function" && _ instanceof _) && (b = !1);
  }
  return s.delete(t), s.delete(e), b;
}
var FE = 1, _h = "[object Arguments]", Sh = "[object Array]", pa = "[object Object]", HE = Object.prototype, Eh = HE.hasOwnProperty;
function UE(t, e, n, r, i, s) {
  var o = Hn(t), a = Hn(e), l = o ? Sh : xo(t), u = a ? Sh : xo(e);
  l = l == _h ? pa : l, u = u == _h ? pa : u;
  var c = l == pa, d = u == pa, h = l == u;
  if (h && _o(t)) {
    if (!_o(e))
      return !1;
    o = !0, c = !1;
  }
  if (h && !c)
    return s || (s = new pr()), o || wd(t) ? qv(t, e, n, r, i, s) : DE(t, e, l, n, r, i, s);
  if (!(n & FE)) {
    var v = c && Eh.call(t, "__wrapped__"), y = d && Eh.call(e, "__wrapped__");
    if (v || y) {
      var b = v ? t.value() : t, p = y ? e.value() : e;
      return s || (s = new pr()), i(b, p, n, r, s);
    }
  }
  return h ? (s || (s = new pr()), jE(t, e, n, r, i, s)) : !1;
}
function Vl(t, e, n, r, i) {
  return t === e ? !0 : t == null || e == null || !Ir(t) && !Ir(e) ? t !== t && e !== e : UE(t, e, n, r, Vl, i);
}
var VE = 1, WE = 2;
function KE(t, e, n, r) {
  var i = n.length, s = i, o = !r;
  if (t == null)
    return !s;
  for (t = Object(t); i--; ) {
    var a = n[i];
    if (o && a[2] ? a[1] !== t[a[0]] : !(a[0] in t))
      return !1;
  }
  for (; ++i < s; ) {
    a = n[i];
    var l = a[0], u = t[l], c = a[1];
    if (o && a[2]) {
      if (u === void 0 && !(l in t))
        return !1;
    } else {
      var d = new pr();
      if (r)
        var h = r(u, c, l, t, e, d);
      if (!(h === void 0 ? Vl(c, u, VE | WE, r, d) : h))
        return !1;
    }
  }
  return !0;
}
function Jv(t) {
  return t === t && !Rn(t);
}
function $E(t) {
  for (var e = qo(t), n = e.length; n--; ) {
    var r = e[n], i = t[r];
    e[n] = [r, i, Jv(i)];
  }
  return e;
}
function Yv(t, e) {
  return function(n) {
    return n == null ? !1 : n[t] === e && (e !== void 0 || t in Object(n));
  };
}
function GE(t) {
  var e = $E(t);
  return e.length == 1 && e[0][2] ? Yv(e[0][0], e[0][1]) : function(n) {
    return n === t || KE(n, t, e);
  };
}
function qE(t, e) {
  return t != null && e in Object(t);
}
function JE(t, e, n) {
  e = Ul(e, t);
  for (var r = -1, i = e.length, s = !1; ++r < i; ) {
    var o = Yo(e[r]);
    if (!(s = t != null && n(t, o)))
      break;
    t = t[o];
  }
  return s || ++r != i ? s : (i = t == null ? 0 : t.length, !!i && md(i) && jl(o, i) && (Hn(t) || wo(t)));
}
function Qv(t, e) {
  return t != null && JE(t, e, qE);
}
var YE = 1, QE = 2;
function ZE(t, e) {
  return _d(t) && Jv(e) ? Yv(Yo(t), e) : function(n) {
    var r = An(n, t);
    return r === void 0 && r === e ? Qv(n, t) : Vl(e, r, YE | QE);
  };
}
function XE(t) {
  return function(e) {
    return e == null ? void 0 : e[t];
  };
}
function ex(t) {
  return function(e) {
    return Ed(e, t);
  };
}
function tx(t) {
  return _d(t) ? XE(Yo(t)) : ex(t);
}
function Zv(t) {
  return typeof t == "function" ? t : t == null ? hd : typeof t == "object" ? Hn(t) ? ZE(t[0], t[1]) : GE(t) : tx(t);
}
function nx(t) {
  return function(e, n, r) {
    for (var i = -1, s = Object(e), o = r(e), a = o.length; a--; ) {
      var l = o[t ? a : ++i];
      if (n(s[l], l, s) === !1)
        break;
    }
    return e;
  };
}
var rx = nx();
const Xv = rx;
function ix(t, e) {
  return t && Xv(t, e, qo);
}
function sx(t, e) {
  return function(n, r) {
    if (n == null)
      return n;
    if (!js(n))
      return t(n, r);
    for (var i = n.length, s = e ? i : -1, o = Object(n); (e ? s-- : ++s < i) && r(o[s], s, o) !== !1; )
      ;
    return n;
  };
}
var ox = sx(ix);
const ax = ox;
var lx = function() {
  return yr.Date.now();
};
const mu = lx;
var ux = "Expected a function", cx = Math.max, dx = Math.min;
function Yr(t, e, n) {
  var r, i, s, o, a, l, u = 0, c = !1, d = !1, h = !0;
  if (typeof t != "function")
    throw new TypeError(ux);
  e = Ju(e) || 0, Rn(n) && (c = !!n.leading, d = "maxWait" in n, s = d ? cx(Ju(n.maxWait) || 0, e) : s, h = "trailing" in n ? !!n.trailing : h);
  function v(S) {
    var A = r, C = i;
    return r = i = void 0, u = S, o = t.apply(C, A), o;
  }
  function y(S) {
    return u = S, a = setTimeout(f, e), c ? v(S) : o;
  }
  function b(S) {
    var A = S - l, C = S - u, k = e - A;
    return d ? dx(k, s - C) : k;
  }
  function p(S) {
    var A = S - l, C = S - u;
    return l === void 0 || A >= e || A < 0 || d && C >= s;
  }
  function f() {
    var S = mu();
    if (p(S))
      return g(S);
    a = setTimeout(f, b(S));
  }
  function g(S) {
    return a = void 0, h && r ? v(S) : (r = i = void 0, o);
  }
  function m() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = i = a = void 0;
  }
  function w() {
    return a === void 0 ? o : g(mu());
  }
  function _() {
    var S = mu(), A = p(S);
    if (r = arguments, i = this, l = S, A) {
      if (a === void 0)
        return y(l);
      if (d)
        return clearTimeout(a), a = setTimeout(f, e), v(l);
    }
    return a === void 0 && (a = setTimeout(f, e)), o;
  }
  return _.cancel = m, _.flush = w, _;
}
function tc(t, e, n) {
  (n !== void 0 && !$o(t[e], n) || n === void 0 && !(e in t)) && vd(t, e, n);
}
function fx(t) {
  return Ir(t) && js(t);
}
function nc(t, e) {
  if (!(e === "constructor" && typeof t[e] == "function") && e != "__proto__")
    return t[e];
}
function hx(t) {
  return Go(t, Jo(t));
}
function px(t, e, n, r, i, s, o) {
  var a = nc(t, n), l = nc(e, n), u = o.get(l);
  if (u) {
    tc(t, n, u);
    return;
  }
  var c = s ? s(a, l, n + "", t, e, o) : void 0, d = c === void 0;
  if (d) {
    var h = Hn(l), v = !h && _o(l), y = !h && !v && wd(l);
    c = l, h || v || y ? Hn(a) ? c = a : fx(a) ? c = Ov(a) : v ? (d = !1, c = jv(l, !0)) : y ? (d = !1, c = Vv(l, !0)) : c = [] : O_(l) || wo(l) ? (c = a, wo(a) ? c = hx(a) : (!Rn(a) || pd(a)) && (c = Wv(l))) : d = !1;
  }
  d && (o.set(l, c), i(c, l, r, s, o), o.delete(l)), tc(t, n, c);
}
function eg(t, e, n, r, i) {
  t !== e && Xv(e, function(s, o) {
    if (i || (i = new pr()), Rn(s))
      px(t, e, o, n, eg, r, i);
    else {
      var a = r ? r(nc(t, o), s, o + "", t, e, i) : void 0;
      a === void 0 && (a = s), tc(t, o, a);
    }
  }, Jo);
}
var vx = Math.max, gx = Math.min;
function mx(t, e, n) {
  var r = t == null ? 0 : t.length;
  if (!r)
    return -1;
  var i = r - 1;
  return n !== void 0 && (i = tw(n), i = n < 0 ? vx(r + i, 0) : gx(i, r - 1)), Pw(t, Zv(e), i, !0);
}
function yx(t, e) {
  var n = -1, r = js(t) ? Array(t.length) : [];
  return ax(t, function(i, s, o) {
    r[++n] = e(i, s, o);
  }), r;
}
function bx(t, e) {
  var n = Hn(t) ? Cv : yx;
  return n(t, Zv(e));
}
function wx(t, e) {
  return Ad(bx(t, e), 1);
}
function al(t) {
  for (var e = -1, n = t == null ? 0 : t.length, r = {}; ++e < n; ) {
    var i = t[e];
    r[i[0]] = i[1];
  }
  return r;
}
function ll(t, e) {
  return Vl(t, e);
}
function er(t) {
  return t == null;
}
function _x(t) {
  return t === void 0;
}
var Sx = Hw(function(t, e, n) {
  eg(t, e, n);
});
const tg = Sx;
function ng(t, e, n, r) {
  if (!Rn(t))
    return t;
  e = Ul(e, t);
  for (var i = -1, s = e.length, o = s - 1, a = t; a != null && ++i < s; ) {
    var l = Yo(e[i]), u = n;
    if (l === "__proto__" || l === "constructor" || l === "prototype")
      return t;
    if (i != o) {
      var c = a[l];
      u = r ? r(c, l, a) : void 0, u === void 0 && (u = Rn(c) ? c : jl(e[i + 1]) ? [] : {});
    }
    gd(a, l, u), a = a[l];
  }
  return t;
}
function Ex(t, e, n) {
  for (var r = -1, i = e.length, s = {}; ++r < i; ) {
    var o = e[r], a = Ed(t, o);
    n(a, o) && ng(s, Ul(o, t), a);
  }
  return s;
}
function xx(t, e) {
  return Ex(t, e, function(n, r) {
    return Qv(t, r);
  });
}
var Ax = S_(function(t, e) {
  return t == null ? {} : xx(t, e);
});
const kx = Ax;
function Cx(t, e, n) {
  return t == null ? t : ng(t, e, n);
}
var Tx = "Expected a function";
function yu(t, e, n) {
  var r = !0, i = !0;
  if (typeof t != "function")
    throw new TypeError(Tx);
  return Rn(n) && (r = "leading" in n ? !!n.leading : r, i = "trailing" in n ? !!n.trailing : i), Yr(t, e, {
    leading: r,
    maxWait: e,
    trailing: i
  });
}
const Sr = (t) => t === void 0, Qr = (t) => typeof t == "boolean", mt = (t) => typeof t == "number", ji = (t) => typeof Element > "u" ? !1 : t instanceof Element, Ox = (t) => Gt(t) ? !Number.isNaN(Number(t)) : !1, Ix = (t = "") => t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d"), rc = (t) => Object.keys(t), Nx = (t) => Object.entries(t), Rx = (t, e, n) => ({
  get value() {
    return An(t, e, n);
  },
  set value(r) {
    Cx(t, e, r);
  }
});
class rg extends Error {
  constructor(e) {
    super(e), this.name = "ElementPlusError";
  }
}
function qi(t, e) {
  throw new rg(`[${t}] ${e}`);
}
function Vt(t, e) {
  if (process.env.NODE_ENV !== "production") {
    const n = Gt(t) ? new rg(`[${t}] ${e}`) : t;
    console.warn(n);
  }
}
const Px = "utils/dom/style", ig = (t = "") => t.split(" ").filter((e) => !!e.trim()), Ba = (t, e) => {
  if (!t || !e)
    return !1;
  if (e.includes(" "))
    throw new Error("className should not contain space.");
  return t.classList.contains(e);
}, Ao = (t, e) => {
  !t || !e.trim() || t.classList.add(...ig(e));
}, Er = (t, e) => {
  !t || !e.trim() || t.classList.remove(...ig(e));
}, fs = (t, e) => {
  var n;
  if (!St || !t || !e)
    return "";
  let r = Cb(e);
  r === "float" && (r = "cssFloat");
  try {
    const i = t.style[r];
    if (i)
      return i;
    const s = (n = document.defaultView) == null ? void 0 : n.getComputedStyle(t, "");
    return s ? s[r] : "";
  } catch {
    return t.style[r];
  }
};
function ul(t, e = "px") {
  if (!t)
    return "";
  if (mt(t) || Ox(t))
    return `${t}${e}`;
  if (Gt(t))
    return t;
  Vt(Px, "binding value must be a string or number");
}
const Bx = (t, e) => {
  if (!St)
    return !1;
  const n = {
    undefined: "overflow",
    true: "overflow-y",
    false: "overflow-x"
  }[String(e)], r = fs(t, n);
  return ["scroll", "auto", "overlay"].some((i) => r.includes(i));
}, Dx = (t, e) => {
  if (!St)
    return;
  let n = t;
  for (; n; ) {
    if ([window, document, document.documentElement].includes(n))
      return window;
    if (Bx(n, e))
      return n;
    n = n.parentNode;
  }
  return n;
};
function Mx(t, e) {
  if (!St)
    return;
  if (!e) {
    t.scrollTop = 0;
    return;
  }
  const n = [];
  let r = e.offsetParent;
  for (; r !== null && t !== r && t.contains(r); )
    n.push(r), r = r.offsetParent;
  const i = e.offsetTop + n.reduce((l, u) => l + u.offsetTop, 0), s = i + e.offsetHeight, o = t.scrollTop, a = o + t.clientHeight;
  i < o ? t.scrollTop = i : s > a && (t.scrollTop = s - t.clientHeight);
}
/*! Element Plus Icons Vue v2.1.0 */
var Tt = (t, e) => {
  let n = t.__vccOpts || t;
  for (let [r, i] of e)
    n[r] = i;
  return n;
}, Lx = {
  name: "ArrowDown"
}, zx = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, jx = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
  },
  null,
  -1
  /* HOISTED */
), Fx = [
  jx
];
function Hx(t, e, n, r, i, s) {
  return V(), se("svg", zx, Fx);
}
var Od = /* @__PURE__ */ Tt(Lx, [["render", Hx], ["__file", "arrow-down.vue"]]), Ux = {
  name: "ArrowLeft"
}, Vx = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, Wx = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
  },
  null,
  -1
  /* HOISTED */
), Kx = [
  Wx
];
function $x(t, e, n, r, i, s) {
  return V(), se("svg", Vx, Kx);
}
var Gx = /* @__PURE__ */ Tt(Ux, [["render", $x], ["__file", "arrow-left.vue"]]), qx = {
  name: "ArrowRight"
}, Jx = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, Yx = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
  },
  null,
  -1
  /* HOISTED */
), Qx = [
  Yx
];
function Zx(t, e, n, r, i, s) {
  return V(), se("svg", Jx, Qx);
}
var Id = /* @__PURE__ */ Tt(qx, [["render", Zx], ["__file", "arrow-right.vue"]]), Xx = {
  name: "ArrowUp"
}, eA = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, tA = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0z"
  },
  null,
  -1
  /* HOISTED */
), nA = [
  tA
];
function rA(t, e, n, r, i, s) {
  return V(), se("svg", eA, nA);
}
var sg = /* @__PURE__ */ Tt(Xx, [["render", rA], ["__file", "arrow-up.vue"]]), iA = {
  name: "Back"
}, sA = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, oA = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M224 480h640a32 32 0 1 1 0 64H224a32 32 0 0 1 0-64z"
  },
  null,
  -1
  /* HOISTED */
), aA = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "m237.248 512 265.408 265.344a32 32 0 0 1-45.312 45.312l-288-288a32 32 0 0 1 0-45.312l288-288a32 32 0 1 1 45.312 45.312L237.248 512z"
  },
  null,
  -1
  /* HOISTED */
), lA = [
  oA,
  aA
];
function uA(t, e, n, r, i, s) {
  return V(), se("svg", sA, lA);
}
var cA = /* @__PURE__ */ Tt(iA, [["render", uA], ["__file", "back.vue"]]), dA = {
  name: "CaretRight"
}, fA = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, hA = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M384 192v640l384-320.064z"
  },
  null,
  -1
  /* HOISTED */
), pA = [
  hA
];
function vA(t, e, n, r, i, s) {
  return V(), se("svg", fA, pA);
}
var gA = /* @__PURE__ */ Tt(dA, [["render", vA], ["__file", "caret-right.vue"]]), mA = {
  name: "Check"
}, yA = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, bA = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
  },
  null,
  -1
  /* HOISTED */
), wA = [
  bA
];
function _A(t, e, n, r, i, s) {
  return V(), se("svg", yA, wA);
}
var og = /* @__PURE__ */ Tt(mA, [["render", _A], ["__file", "check.vue"]]), SA = {
  name: "CircleCheck"
}, EA = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, xA = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
  },
  null,
  -1
  /* HOISTED */
), AA = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
  },
  null,
  -1
  /* HOISTED */
), kA = [
  xA,
  AA
];
function CA(t, e, n, r, i, s) {
  return V(), se("svg", EA, kA);
}
var Nd = /* @__PURE__ */ Tt(SA, [["render", CA], ["__file", "circle-check.vue"]]), TA = {
  name: "CircleClose"
}, OA = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, IA = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248L466.752 512z"
  },
  null,
  -1
  /* HOISTED */
), NA = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
  },
  null,
  -1
  /* HOISTED */
), RA = [
  IA,
  NA
];
function PA(t, e, n, r, i, s) {
  return V(), se("svg", OA, RA);
}
var Wl = /* @__PURE__ */ Tt(TA, [["render", PA], ["__file", "circle-close.vue"]]), BA = {
  name: "Close"
}, DA = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, MA = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
  },
  null,
  -1
  /* HOISTED */
), LA = [
  MA
];
function zA(t, e, n, r, i, s) {
  return V(), se("svg", DA, LA);
}
var ko = /* @__PURE__ */ Tt(BA, [["render", zA], ["__file", "close.vue"]]), jA = {
  name: "Delete"
}, FA = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, HA = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V256zm448-64v-64H416v64h192zM224 896h576V256H224v640zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32zm192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32z"
  },
  null,
  -1
  /* HOISTED */
), UA = [
  HA
];
function VA(t, e, n, r, i, s) {
  return V(), se("svg", FA, UA);
}
var ag = /* @__PURE__ */ Tt(jA, [["render", VA], ["__file", "delete.vue"]]), WA = {
  name: "Document"
}, KA = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, $A = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M832 384H576V128H192v768h640V384zm-26.496-64L640 154.496V320h165.504zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32zm160 448h384v64H320v-64zm0-192h160v64H320v-64zm0 384h384v64H320v-64z"
  },
  null,
  -1
  /* HOISTED */
), GA = [
  $A
];
function qA(t, e, n, r, i, s) {
  return V(), se("svg", KA, GA);
}
var JA = /* @__PURE__ */ Tt(WA, [["render", qA], ["__file", "document.vue"]]), YA = {
  name: "Download"
}, QA = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, ZA = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M160 832h704a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64zm384-253.696 236.288-236.352 45.248 45.248L508.8 704 192 387.2l45.248-45.248L480 584.704V128h64v450.304z"
  },
  null,
  -1
  /* HOISTED */
), XA = [
  ZA
];
function ek(t, e, n, r, i, s) {
  return V(), se("svg", QA, XA);
}
var tk = /* @__PURE__ */ Tt(YA, [["render", ek], ["__file", "download.vue"]]), nk = {
  name: "FullScreen"
}, rk = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, ik = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64v.064zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64l-192 .192zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64l192-.192zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64v-.064z"
  },
  null,
  -1
  /* HOISTED */
), sk = [
  ik
];
function ok(t, e, n, r, i, s) {
  return V(), se("svg", rk, sk);
}
var lg = /* @__PURE__ */ Tt(nk, [["render", ok], ["__file", "full-screen.vue"]]), ak = {
  name: "Grid"
}, lk = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, uk = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M640 384v256H384V384h256zm64 0h192v256H704V384zm-64 512H384V704h256v192zm64 0V704h192v192H704zm-64-768v192H384V128h256zm64 0h192v192H704V128zM320 384v256H128V384h192zm0 512H128V704h192v192zm0-768v192H128V128h192z"
  },
  null,
  -1
  /* HOISTED */
), ck = [
  uk
];
function dk(t, e, n, r, i, s) {
  return V(), se("svg", lk, ck);
}
var fk = /* @__PURE__ */ Tt(ak, [["render", dk], ["__file", "grid.vue"]]), hk = {
  name: "Hide"
}, pk = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, vk = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2L371.2 588.8ZM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
  },
  null,
  -1
  /* HOISTED */
), gk = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
  },
  null,
  -1
  /* HOISTED */
), mk = [
  vk,
  gk
];
function yk(t, e, n, r, i, s) {
  return V(), se("svg", pk, mk);
}
var bk = /* @__PURE__ */ Tt(hk, [["render", yk], ["__file", "hide.vue"]]), wk = {
  name: "Loading"
}, _k = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, Sk = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32zm0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32zm448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32zm-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32zM195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0zm-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
  },
  null,
  -1
  /* HOISTED */
), Ek = [
  Sk
];
function xk(t, e, n, r, i, s) {
  return V(), se("svg", _k, Ek);
}
var Kl = /* @__PURE__ */ Tt(wk, [["render", xk], ["__file", "loading.vue"]]), Ak = {
  name: "Minus"
}, kk = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, Ck = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64z"
  },
  null,
  -1
  /* HOISTED */
), Tk = [
  Ck
];
function Ok(t, e, n, r, i, s) {
  return V(), se("svg", kk, Tk);
}
var Ik = /* @__PURE__ */ Tt(Ak, [["render", Ok], ["__file", "minus.vue"]]), Nk = {
  name: "Operation"
}, Rk = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, Pk = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M389.44 768a96.064 96.064 0 0 1 181.12 0H896v64H570.56a96.064 96.064 0 0 1-181.12 0H128v-64h261.44zm192-288a96.064 96.064 0 0 1 181.12 0H896v64H762.56a96.064 96.064 0 0 1-181.12 0H128v-64h453.44zm-320-288a96.064 96.064 0 0 1 181.12 0H896v64H442.56a96.064 96.064 0 0 1-181.12 0H128v-64h133.44z"
  },
  null,
  -1
  /* HOISTED */
), Bk = [
  Pk
];
function Dk(t, e, n, r, i, s) {
  return V(), se("svg", Rk, Bk);
}
var Mk = /* @__PURE__ */ Tt(Nk, [["render", Dk], ["__file", "operation.vue"]]), Lk = {
  name: "Picture"
}, zk = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, jk = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M160 160v704h704V160H160zm-32-64h768a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H128a32 32 0 0 1-32-32V128a32 32 0 0 1 32-32z"
  },
  null,
  -1
  /* HOISTED */
), Fk = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M384 288q64 0 64 64t-64 64q-64 0-64-64t64-64zM185.408 876.992l-50.816-38.912L350.72 556.032a96 96 0 0 1 134.592-17.856l1.856 1.472 122.88 99.136a32 32 0 0 0 44.992-4.864l216-269.888 49.92 39.936-215.808 269.824-.256.32a96 96 0 0 1-135.04 14.464l-122.88-99.072-.64-.512a32 32 0 0 0-44.8 5.952L185.408 876.992z"
  },
  null,
  -1
  /* HOISTED */
), Hk = [
  jk,
  Fk
];
function Uk(t, e, n, r, i, s) {
  return V(), se("svg", zk, Hk);
}
var Vk = /* @__PURE__ */ Tt(Lk, [["render", Uk], ["__file", "picture.vue"]]), Wk = {
  name: "Plus"
}, Kk = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, $k = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64h352z"
  },
  null,
  -1
  /* HOISTED */
), Gk = [
  $k
];
function qk(t, e, n, r, i, s) {
  return V(), se("svg", Kk, Gk);
}
var ug = /* @__PURE__ */ Tt(Wk, [["render", qk], ["__file", "plus.vue"]]), Jk = {
  name: "Reading"
}, Yk = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, Qk = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "m512 863.36 384-54.848v-638.72L525.568 222.72a96 96 0 0 1-27.136 0L128 169.792v638.72l384 54.848zM137.024 106.432l370.432 52.928a32 32 0 0 0 9.088 0l370.432-52.928A64 64 0 0 1 960 169.792v638.72a64 64 0 0 1-54.976 63.36l-388.48 55.488a32 32 0 0 1-9.088 0l-388.48-55.488A64 64 0 0 1 64 808.512v-638.72a64 64 0 0 1 73.024-63.36z"
  },
  null,
  -1
  /* HOISTED */
), Zk = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M480 192h64v704h-64z"
  },
  null,
  -1
  /* HOISTED */
), Xk = [
  Qk,
  Zk
];
function eC(t, e, n, r, i, s) {
  return V(), se("svg", Yk, Xk);
}
var tC = /* @__PURE__ */ Tt(Jk, [["render", eC], ["__file", "reading.vue"]]), nC = {
  name: "RefreshLeft"
}, rC = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, iC = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z"
  },
  null,
  -1
  /* HOISTED */
), sC = [
  iC
];
function oC(t, e, n, r, i, s) {
  return V(), se("svg", rC, sC);
}
var aC = /* @__PURE__ */ Tt(nC, [["render", oC], ["__file", "refresh-left.vue"]]), lC = {
  name: "RefreshRight"
}, uC = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, cC = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z"
  },
  null,
  -1
  /* HOISTED */
), dC = [
  cC
];
function fC(t, e, n, r, i, s) {
  return V(), se("svg", uC, dC);
}
var hC = /* @__PURE__ */ Tt(lC, [["render", fC], ["__file", "refresh-right.vue"]]), pC = {
  name: "ScaleToOriginal"
}, vC = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, gC = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M813.176 180.706a60.235 60.235 0 0 1 60.236 60.235v481.883a60.235 60.235 0 0 1-60.236 60.235H210.824a60.235 60.235 0 0 1-60.236-60.235V240.94a60.235 60.235 0 0 1 60.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0 0 90.353 240.94v481.883a120.47 120.47 0 0 0 120.47 120.47h602.353a120.47 120.47 0 0 0 120.471-120.47V240.94a120.47 120.47 0 0 0-120.47-120.47zm-120.47 180.705a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 0 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zm-361.412 0a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 1 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zM512 361.412a30.118 30.118 0 0 0-30.118 30.117v30.118a30.118 30.118 0 0 0 60.236 0V391.53A30.118 30.118 0 0 0 512 361.412zM512 512a30.118 30.118 0 0 0-30.118 30.118v30.117a30.118 30.118 0 0 0 60.236 0v-30.117A30.118 30.118 0 0 0 512 512z"
  },
  null,
  -1
  /* HOISTED */
), mC = [
  gC
];
function yC(t, e, n, r, i, s) {
  return V(), se("svg", vC, mC);
}
var bC = /* @__PURE__ */ Tt(pC, [["render", yC], ["__file", "scale-to-original.vue"]]), wC = {
  name: "Search"
}, _C = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, SC = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704z"
  },
  null,
  -1
  /* HOISTED */
), EC = [
  SC
];
function xC(t, e, n, r, i, s) {
  return V(), se("svg", _C, EC);
}
var AC = /* @__PURE__ */ Tt(wC, [["render", xC], ["__file", "search.vue"]]), kC = {
  name: "View"
}, CC = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, TC = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352zm0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448zm0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160z"
  },
  null,
  -1
  /* HOISTED */
), OC = [
  TC
];
function IC(t, e, n, r, i, s) {
  return V(), se("svg", CC, OC);
}
var NC = /* @__PURE__ */ Tt(kC, [["render", IC], ["__file", "view.vue"]]), RC = {
  name: "WarningFilled"
}, PC = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, BC = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256zm0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4z"
  },
  null,
  -1
  /* HOISTED */
), DC = [
  BC
];
function MC(t, e, n, r, i, s) {
  return V(), se("svg", PC, DC);
}
var LC = /* @__PURE__ */ Tt(RC, [["render", MC], ["__file", "warning-filled.vue"]]), zC = {
  name: "ZoomIn"
}, jC = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, FC = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zm-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64h96z"
  },
  null,
  -1
  /* HOISTED */
), HC = [
  FC
];
function UC(t, e, n, r, i, s) {
  return V(), se("svg", jC, HC);
}
var cg = /* @__PURE__ */ Tt(zC, [["render", UC], ["__file", "zoom-in.vue"]]), VC = {
  name: "ZoomOut"
}, WC = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, KC = /* @__PURE__ */ ae(
  "path",
  {
    fill: "currentColor",
    d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zM352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64z"
  },
  null,
  -1
  /* HOISTED */
), $C = [
  KC
];
function GC(t, e, n, r, i, s) {
  return V(), se("svg", WC, $C);
}
var qC = /* @__PURE__ */ Tt(VC, [["render", GC], ["__file", "zoom-out.vue"]]);
const dg = "__epPropKey", Be = (t) => t, JC = (t) => wn(t) && !!t[dg], $l = (t, e) => {
  if (!wn(t) || JC(t))
    return t;
  const { values: n, required: r, default: i, type: s, validator: o } = t, l = {
    type: s,
    required: !!r,
    validator: n || o ? (u) => {
      let c = !1, d = [];
      if (n && (d = Array.from(n), Tr(t, "default") && d.push(i), c || (c = d.includes(u))), o && (c || (c = o(u))), !c && d.length > 0) {
        const h = [...new Set(d)].map((v) => JSON.stringify(v)).join(", ");
        G0(`Invalid prop: validation failed${e ? ` for prop "${e}"` : ""}. Expected one of [${h}], got value ${JSON.stringify(u)}.`);
      }
      return c;
    } : void 0,
    [dg]: !0
  };
  return Tr(t, "default") && (l.default = i), l;
}, ut = (t) => al(Object.entries(t).map(([e, n]) => [
  e,
  $l(n, e)
])), bi = Be([
  String,
  Object,
  Function
]), fg = {
  validating: Kl,
  success: Nd,
  error: Wl
}, nn = (t, e) => {
  if (t.install = (n) => {
    for (const r of [t, ...Object.values(e ?? {})])
      n.component(r.name, r);
  }, e)
    for (const [n, r] of Object.entries(e))
      t[n] = r;
  return t;
}, YC = (t, e) => (t.install = (n) => {
  n.directive(e, t);
}, t), sr = (t) => (t.install = en, t), sn = {
  tab: "Tab",
  enter: "Enter",
  space: "Space",
  left: "ArrowLeft",
  up: "ArrowUp",
  right: "ArrowRight",
  down: "ArrowDown",
  esc: "Escape",
  delete: "Delete",
  backspace: "Backspace",
  numpadEnter: "NumpadEnter",
  pageUp: "PageUp",
  pageDown: "PageDown",
  home: "Home",
  end: "End"
}, Bt = "update:modelValue", Ji = "change", Pi = "input", Rd = ["", "default", "small", "large"], QC = {
  large: 40,
  default: 32,
  small: 24
}, ZC = (t) => QC[t || "default"], XC = (t) => ["", ...Rd].includes(t), hg = (t) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(t), e2 = (t) => St ? window.requestAnimationFrame(t) : setTimeout(t, 16), Cs = (t) => t, t2 = ["class", "style"], n2 = /^on[A-Z]/, pg = (t = {}) => {
  const { excludeListeners: e = !1, excludeKeys: n } = t, r = F(() => ((n == null ? void 0 : n.value) || []).concat(t2)), i = ht();
  return i ? F(() => {
    var s;
    return al(Object.entries((s = i.proxy) == null ? void 0 : s.$attrs).filter(([o]) => !r.value.includes(o) && !(e && n2.test(o))));
  }) : (Vt("use-attrs", "getCurrentInstance() returned null. useAttrs() must be called at the top of a setup function"), F(() => ({})));
}, vg = ({ from: t, replacement: e, scope: n, version: r, ref: i, type: s = "API" }, o) => {
  ke(() => x(o), (a) => {
    a && Vt(n, `[${s}] ${t} is about to be deprecated in version ${r}, please use ${e} instead.
For more detail, please visit: ${i}
`);
  }, {
    immediate: !0
  });
};
var r2 = {
  name: "en",
  el: {
    colorpicker: {
      confirm: "OK",
      clear: "Clear",
      defaultLabel: "color picker",
      description: "current color is {color}. press enter to select a new color."
    },
    datepicker: {
      now: "Now",
      today: "Today",
      cancel: "Cancel",
      clear: "Clear",
      confirm: "OK",
      dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
      monthTablePrompt: "Use the arrow keys and enter to select the month",
      yearTablePrompt: "Use the arrow keys and enter to select the year",
      selectedDate: "Selected date",
      selectDate: "Select date",
      selectTime: "Select time",
      startDate: "Start Date",
      startTime: "Start Time",
      endDate: "End Date",
      endTime: "End Time",
      prevYear: "Previous Year",
      nextYear: "Next Year",
      prevMonth: "Previous Month",
      nextMonth: "Next Month",
      year: "",
      month1: "January",
      month2: "February",
      month3: "March",
      month4: "April",
      month5: "May",
      month6: "June",
      month7: "July",
      month8: "August",
      month9: "September",
      month10: "October",
      month11: "November",
      month12: "December",
      week: "week",
      weeks: {
        sun: "Sun",
        mon: "Mon",
        tue: "Tue",
        wed: "Wed",
        thu: "Thu",
        fri: "Fri",
        sat: "Sat"
      },
      weeksFull: {
        sun: "Sunday",
        mon: "Monday",
        tue: "Tuesday",
        wed: "Wednesday",
        thu: "Thursday",
        fri: "Friday",
        sat: "Saturday"
      },
      months: {
        jan: "Jan",
        feb: "Feb",
        mar: "Mar",
        apr: "Apr",
        may: "May",
        jun: "Jun",
        jul: "Jul",
        aug: "Aug",
        sep: "Sep",
        oct: "Oct",
        nov: "Nov",
        dec: "Dec"
      }
    },
    inputNumber: {
      decrease: "decrease number",
      increase: "increase number"
    },
    select: {
      loading: "Loading",
      noMatch: "No matching data",
      noData: "No data",
      placeholder: "Select"
    },
    dropdown: {
      toggleDropdown: "Toggle Dropdown"
    },
    cascader: {
      noMatch: "No matching data",
      loading: "Loading",
      placeholder: "Select",
      noData: "No data"
    },
    pagination: {
      goto: "Go to",
      pagesize: "/page",
      total: "Total {total}",
      pageClassifier: "",
      page: "Page",
      prev: "Go to previous page",
      next: "Go to next page",
      currentPage: "page {pager}",
      prevPages: "Previous {pager} pages",
      nextPages: "Next {pager} pages",
      deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
    },
    dialog: {
      close: "Close this dialog"
    },
    drawer: {
      close: "Close this dialog"
    },
    messagebox: {
      title: "Message",
      confirm: "OK",
      cancel: "Cancel",
      error: "Illegal input",
      close: "Close this dialog"
    },
    upload: {
      deleteTip: "press delete to remove",
      delete: "Delete",
      preview: "Preview",
      continue: "Continue"
    },
    slider: {
      defaultLabel: "slider between {min} and {max}",
      defaultRangeStartLabel: "pick start value",
      defaultRangeEndLabel: "pick end value"
    },
    table: {
      emptyText: "No Data",
      confirmFilter: "Confirm",
      resetFilter: "Reset",
      clearFilter: "All",
      sumText: "Sum"
    },
    tree: {
      emptyText: "No Data"
    },
    transfer: {
      noMatch: "No matching data",
      noData: "No data",
      titles: ["List 1", "List 2"],
      filterPlaceholder: "Enter keyword",
      noCheckedFormat: "{total} items",
      hasCheckedFormat: "{checked}/{total} checked"
    },
    image: {
      error: "FAILED"
    },
    pageHeader: {
      title: "Back"
    },
    popconfirm: {
      confirmButtonText: "Yes",
      cancelButtonText: "No"
    }
  }
};
const i2 = (t) => (e, n) => s2(e, n, x(t)), s2 = (t, e, n) => An(n, t, t).replace(/\{(\w+)\}/g, (r, i) => {
  var s;
  return `${(s = e == null ? void 0 : e[i]) != null ? s : `{${i}}`}`;
}), o2 = (t) => {
  const e = F(() => x(t).name), n = on(t) ? t : $(t);
  return {
    lang: e,
    locale: n,
    t: i2(t)
  };
}, gg = Symbol("localeContextKey"), or = (t) => {
  const e = t || tt(gg, $());
  return o2(F(() => e.value || r2));
}, Da = "el", a2 = "is-", ki = (t, e, n, r, i) => {
  let s = `${t}-${e}`;
  return n && (s += `-${n}`), r && (s += `__${r}`), i && (s += `--${i}`), s;
}, mg = Symbol("namespaceContextKey"), Pd = (t) => {
  const e = t || (ht() ? tt(mg, $(Da)) : $(Da));
  return F(() => x(e) || Da);
}, Fe = (t, e) => {
  const n = Pd(e);
  return {
    namespace: n,
    b: (b = "") => ki(n.value, t, b, "", ""),
    e: (b) => b ? ki(n.value, t, "", b, "") : "",
    m: (b) => b ? ki(n.value, t, "", "", b) : "",
    be: (b, p) => b && p ? ki(n.value, t, b, p, "") : "",
    em: (b, p) => b && p ? ki(n.value, t, "", b, p) : "",
    bm: (b, p) => b && p ? ki(n.value, t, b, "", p) : "",
    bem: (b, p, f) => b && p && f ? ki(n.value, t, b, p, f) : "",
    is: (b, ...p) => {
      const f = p.length >= 1 ? p[0] : !0;
      return b && f ? `${a2}${b}` : "";
    },
    cssVar: (b) => {
      const p = {};
      for (const f in b)
        b[f] && (p[`--${n.value}-${f}`] = b[f]);
      return p;
    },
    cssVarName: (b) => `--${n.value}-${b}`,
    cssVarBlock: (b) => {
      const p = {};
      for (const f in b)
        b[f] && (p[`--${n.value}-${t}-${f}`] = b[f]);
      return p;
    },
    cssVarBlockName: (b) => `--${n.value}-${t}-${b}`
  };
}, l2 = $l({
  type: Be(Boolean),
  default: null
}), u2 = $l({
  type: Be(Function)
}), yg = (t) => {
  const e = `update:${t}`, n = `onUpdate:${t}`, r = [e], i = {
    [t]: l2,
    [n]: u2
  };
  return {
    useModelToggle: ({
      indicator: o,
      toggleReason: a,
      shouldHideWhenRouteChanges: l,
      shouldProceed: u,
      onShow: c,
      onHide: d
    }) => {
      const h = ht(), { emit: v } = h, y = h.props, b = F(() => gn(y[n])), p = F(() => y[t] === null), f = (A) => {
        o.value !== !0 && (o.value = !0, a && (a.value = A), gn(c) && c(A));
      }, g = (A) => {
        o.value !== !1 && (o.value = !1, a && (a.value = A), gn(d) && d(A));
      }, m = (A) => {
        if (y.disabled === !0 || gn(u) && !u())
          return;
        const C = b.value && St;
        C && v(e, !0), (p.value || !C) && f(A);
      }, w = (A) => {
        if (y.disabled === !0 || !St)
          return;
        const C = b.value && St;
        C && v(e, !1), (p.value || !C) && g(A);
      }, _ = (A) => {
        Qr(A) && (y.disabled && A ? b.value && v(e, !1) : o.value !== A && (A ? f() : g()));
      }, S = () => {
        o.value ? w() : m();
      };
      return ke(() => y[t], _), l && h.appContext.config.globalProperties.$route !== void 0 && ke(() => ({
        ...h.proxy.$route
      }), () => {
        l.value && o.value && w();
      }), Ct(() => {
        _(y[t]);
      }), {
        hide: w,
        show: m,
        toggle: S,
        hasUpdateHandler: b
      };
    },
    useModelToggleProps: i,
    useModelToggleEmits: r
  };
};
yg("modelValue");
const bg = (t) => {
  const e = ht();
  return F(() => {
    var n, r;
    return (r = (n = e == null ? void 0 : e.proxy) == null ? void 0 : n.$props) == null ? void 0 : r[t];
  });
};
var jn = "top", rr = "bottom", ir = "right", Fn = "left", Bd = "auto", Qo = [jn, rr, ir, Fn], Ts = "start", Co = "end", c2 = "clippingParents", wg = "viewport", Ys = "popper", d2 = "reference", xh = Qo.reduce(function(t, e) {
  return t.concat([e + "-" + Ts, e + "-" + Co]);
}, []), Fs = [].concat(Qo, [Bd]).reduce(function(t, e) {
  return t.concat([e, e + "-" + Ts, e + "-" + Co]);
}, []), f2 = "beforeRead", h2 = "read", p2 = "afterRead", v2 = "beforeMain", g2 = "main", m2 = "afterMain", y2 = "beforeWrite", b2 = "write", w2 = "afterWrite", _2 = [f2, h2, p2, v2, g2, m2, y2, b2, w2];
function Nr(t) {
  return t ? (t.nodeName || "").toLowerCase() : null;
}
function br(t) {
  if (t == null)
    return window;
  if (t.toString() !== "[object Window]") {
    var e = t.ownerDocument;
    return e && e.defaultView || window;
  }
  return t;
}
function Os(t) {
  var e = br(t).Element;
  return t instanceof e || t instanceof Element;
}
function tr(t) {
  var e = br(t).HTMLElement;
  return t instanceof e || t instanceof HTMLElement;
}
function Dd(t) {
  if (typeof ShadowRoot > "u")
    return !1;
  var e = br(t).ShadowRoot;
  return t instanceof e || t instanceof ShadowRoot;
}
function S2(t) {
  var e = t.state;
  Object.keys(e.elements).forEach(function(n) {
    var r = e.styles[n] || {}, i = e.attributes[n] || {}, s = e.elements[n];
    !tr(s) || !Nr(s) || (Object.assign(s.style, r), Object.keys(i).forEach(function(o) {
      var a = i[o];
      a === !1 ? s.removeAttribute(o) : s.setAttribute(o, a === !0 ? "" : a);
    }));
  });
}
function E2(t) {
  var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
  return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
    Object.keys(e.elements).forEach(function(r) {
      var i = e.elements[r], s = e.attributes[r] || {}, o = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), a = o.reduce(function(l, u) {
        return l[u] = "", l;
      }, {});
      !tr(i) || !Nr(i) || (Object.assign(i.style, a), Object.keys(s).forEach(function(l) {
        i.removeAttribute(l);
      }));
    });
  };
}
var _g = { name: "applyStyles", enabled: !0, phase: "write", fn: S2, effect: E2, requires: ["computeStyles"] };
function xr(t) {
  return t.split("-")[0];
}
var Bi = Math.max, cl = Math.min, Is = Math.round;
function Ns(t, e) {
  e === void 0 && (e = !1);
  var n = t.getBoundingClientRect(), r = 1, i = 1;
  if (tr(t) && e) {
    var s = t.offsetHeight, o = t.offsetWidth;
    o > 0 && (r = Is(n.width) / o || 1), s > 0 && (i = Is(n.height) / s || 1);
  }
  return { width: n.width / r, height: n.height / i, top: n.top / i, right: n.right / r, bottom: n.bottom / i, left: n.left / r, x: n.left / r, y: n.top / i };
}
function Md(t) {
  var e = Ns(t), n = t.offsetWidth, r = t.offsetHeight;
  return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), { x: t.offsetLeft, y: t.offsetTop, width: n, height: r };
}
function Sg(t, e) {
  var n = e.getRootNode && e.getRootNode();
  if (t.contains(e))
    return !0;
  if (n && Dd(n)) {
    var r = e;
    do {
      if (r && t.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function Zr(t) {
  return br(t).getComputedStyle(t);
}
function x2(t) {
  return ["table", "td", "th"].indexOf(Nr(t)) >= 0;
}
function Ei(t) {
  return ((Os(t) ? t.ownerDocument : t.document) || window.document).documentElement;
}
function Gl(t) {
  return Nr(t) === "html" ? t : t.assignedSlot || t.parentNode || (Dd(t) ? t.host : null) || Ei(t);
}
function Ah(t) {
  return !tr(t) || Zr(t).position === "fixed" ? null : t.offsetParent;
}
function A2(t) {
  var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
  if (n && tr(t)) {
    var r = Zr(t);
    if (r.position === "fixed")
      return null;
  }
  var i = Gl(t);
  for (Dd(i) && (i = i.host); tr(i) && ["html", "body"].indexOf(Nr(i)) < 0; ) {
    var s = Zr(i);
    if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || e && s.willChange === "filter" || e && s.filter && s.filter !== "none")
      return i;
    i = i.parentNode;
  }
  return null;
}
function Zo(t) {
  for (var e = br(t), n = Ah(t); n && x2(n) && Zr(n).position === "static"; )
    n = Ah(n);
  return n && (Nr(n) === "html" || Nr(n) === "body" && Zr(n).position === "static") ? e : n || A2(t) || e;
}
function Ld(t) {
  return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
}
function lo(t, e, n) {
  return Bi(t, cl(e, n));
}
function k2(t, e, n) {
  var r = lo(t, e, n);
  return r > n ? n : r;
}
function Eg() {
  return { top: 0, right: 0, bottom: 0, left: 0 };
}
function xg(t) {
  return Object.assign({}, Eg(), t);
}
function Ag(t, e) {
  return e.reduce(function(n, r) {
    return n[r] = t, n;
  }, {});
}
var C2 = function(t, e) {
  return t = typeof t == "function" ? t(Object.assign({}, e.rects, { placement: e.placement })) : t, xg(typeof t != "number" ? t : Ag(t, Qo));
};
function T2(t) {
  var e, n = t.state, r = t.name, i = t.options, s = n.elements.arrow, o = n.modifiersData.popperOffsets, a = xr(n.placement), l = Ld(a), u = [Fn, ir].indexOf(a) >= 0, c = u ? "height" : "width";
  if (!(!s || !o)) {
    var d = C2(i.padding, n), h = Md(s), v = l === "y" ? jn : Fn, y = l === "y" ? rr : ir, b = n.rects.reference[c] + n.rects.reference[l] - o[l] - n.rects.popper[c], p = o[l] - n.rects.reference[l], f = Zo(s), g = f ? l === "y" ? f.clientHeight || 0 : f.clientWidth || 0 : 0, m = b / 2 - p / 2, w = d[v], _ = g - h[c] - d[y], S = g / 2 - h[c] / 2 + m, A = lo(w, S, _), C = l;
    n.modifiersData[r] = (e = {}, e[C] = A, e.centerOffset = A - S, e);
  }
}
function O2(t) {
  var e = t.state, n = t.options, r = n.element, i = r === void 0 ? "[data-popper-arrow]" : r;
  i != null && (typeof i == "string" && (i = e.elements.popper.querySelector(i), !i) || !Sg(e.elements.popper, i) || (e.elements.arrow = i));
}
var I2 = { name: "arrow", enabled: !0, phase: "main", fn: T2, effect: O2, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
function Rs(t) {
  return t.split("-")[1];
}
var N2 = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
function R2(t) {
  var e = t.x, n = t.y, r = window, i = r.devicePixelRatio || 1;
  return { x: Is(e * i) / i || 0, y: Is(n * i) / i || 0 };
}
function kh(t) {
  var e, n = t.popper, r = t.popperRect, i = t.placement, s = t.variation, o = t.offsets, a = t.position, l = t.gpuAcceleration, u = t.adaptive, c = t.roundOffsets, d = t.isFixed, h = o.x, v = h === void 0 ? 0 : h, y = o.y, b = y === void 0 ? 0 : y, p = typeof c == "function" ? c({ x: v, y: b }) : { x: v, y: b };
  v = p.x, b = p.y;
  var f = o.hasOwnProperty("x"), g = o.hasOwnProperty("y"), m = Fn, w = jn, _ = window;
  if (u) {
    var S = Zo(n), A = "clientHeight", C = "clientWidth";
    if (S === br(n) && (S = Ei(n), Zr(S).position !== "static" && a === "absolute" && (A = "scrollHeight", C = "scrollWidth")), S = S, i === jn || (i === Fn || i === ir) && s === Co) {
      w = rr;
      var k = d && S === _ && _.visualViewport ? _.visualViewport.height : S[A];
      b -= k - r.height, b *= l ? 1 : -1;
    }
    if (i === Fn || (i === jn || i === rr) && s === Co) {
      m = ir;
      var O = d && S === _ && _.visualViewport ? _.visualViewport.width : S[C];
      v -= O - r.width, v *= l ? 1 : -1;
    }
  }
  var N = Object.assign({ position: a }, u && N2), B = c === !0 ? R2({ x: v, y: b }) : { x: v, y: b };
  if (v = B.x, b = B.y, l) {
    var M;
    return Object.assign({}, N, (M = {}, M[w] = g ? "0" : "", M[m] = f ? "0" : "", M.transform = (_.devicePixelRatio || 1) <= 1 ? "translate(" + v + "px, " + b + "px)" : "translate3d(" + v + "px, " + b + "px, 0)", M));
  }
  return Object.assign({}, N, (e = {}, e[w] = g ? b + "px" : "", e[m] = f ? v + "px" : "", e.transform = "", e));
}
function P2(t) {
  var e = t.state, n = t.options, r = n.gpuAcceleration, i = r === void 0 ? !0 : r, s = n.adaptive, o = s === void 0 ? !0 : s, a = n.roundOffsets, l = a === void 0 ? !0 : a, u = { placement: xr(e.placement), variation: Rs(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: i, isFixed: e.options.strategy === "fixed" };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, kh(Object.assign({}, u, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: o, roundOffsets: l })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, kh(Object.assign({}, u, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: l })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement });
}
var kg = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: P2, data: {} }, va = { passive: !0 };
function B2(t) {
  var e = t.state, n = t.instance, r = t.options, i = r.scroll, s = i === void 0 ? !0 : i, o = r.resize, a = o === void 0 ? !0 : o, l = br(e.elements.popper), u = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return s && u.forEach(function(c) {
    c.addEventListener("scroll", n.update, va);
  }), a && l.addEventListener("resize", n.update, va), function() {
    s && u.forEach(function(c) {
      c.removeEventListener("scroll", n.update, va);
    }), a && l.removeEventListener("resize", n.update, va);
  };
}
var Cg = { name: "eventListeners", enabled: !0, phase: "write", fn: function() {
}, effect: B2, data: {} }, D2 = { left: "right", right: "left", bottom: "top", top: "bottom" };
function Ma(t) {
  return t.replace(/left|right|bottom|top/g, function(e) {
    return D2[e];
  });
}
var M2 = { start: "end", end: "start" };
function Ch(t) {
  return t.replace(/start|end/g, function(e) {
    return M2[e];
  });
}
function zd(t) {
  var e = br(t), n = e.pageXOffset, r = e.pageYOffset;
  return { scrollLeft: n, scrollTop: r };
}
function jd(t) {
  return Ns(Ei(t)).left + zd(t).scrollLeft;
}
function L2(t) {
  var e = br(t), n = Ei(t), r = e.visualViewport, i = n.clientWidth, s = n.clientHeight, o = 0, a = 0;
  return r && (i = r.width, s = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (o = r.offsetLeft, a = r.offsetTop)), { width: i, height: s, x: o + jd(t), y: a };
}
function z2(t) {
  var e, n = Ei(t), r = zd(t), i = (e = t.ownerDocument) == null ? void 0 : e.body, s = Bi(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), o = Bi(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), a = -r.scrollLeft + jd(t), l = -r.scrollTop;
  return Zr(i || n).direction === "rtl" && (a += Bi(n.clientWidth, i ? i.clientWidth : 0) - s), { width: s, height: o, x: a, y: l };
}
function Fd(t) {
  var e = Zr(t), n = e.overflow, r = e.overflowX, i = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + i + r);
}
function Tg(t) {
  return ["html", "body", "#document"].indexOf(Nr(t)) >= 0 ? t.ownerDocument.body : tr(t) && Fd(t) ? t : Tg(Gl(t));
}
function uo(t, e) {
  var n;
  e === void 0 && (e = []);
  var r = Tg(t), i = r === ((n = t.ownerDocument) == null ? void 0 : n.body), s = br(r), o = i ? [s].concat(s.visualViewport || [], Fd(r) ? r : []) : r, a = e.concat(o);
  return i ? a : a.concat(uo(Gl(o)));
}
function ic(t) {
  return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height });
}
function j2(t) {
  var e = Ns(t);
  return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e;
}
function Th(t, e) {
  return e === wg ? ic(L2(t)) : Os(e) ? j2(e) : ic(z2(Ei(t)));
}
function F2(t) {
  var e = uo(Gl(t)), n = ["absolute", "fixed"].indexOf(Zr(t).position) >= 0, r = n && tr(t) ? Zo(t) : t;
  return Os(r) ? e.filter(function(i) {
    return Os(i) && Sg(i, r) && Nr(i) !== "body";
  }) : [];
}
function H2(t, e, n) {
  var r = e === "clippingParents" ? F2(t) : [].concat(e), i = [].concat(r, [n]), s = i[0], o = i.reduce(function(a, l) {
    var u = Th(t, l);
    return a.top = Bi(u.top, a.top), a.right = cl(u.right, a.right), a.bottom = cl(u.bottom, a.bottom), a.left = Bi(u.left, a.left), a;
  }, Th(t, s));
  return o.width = o.right - o.left, o.height = o.bottom - o.top, o.x = o.left, o.y = o.top, o;
}
function Og(t) {
  var e = t.reference, n = t.element, r = t.placement, i = r ? xr(r) : null, s = r ? Rs(r) : null, o = e.x + e.width / 2 - n.width / 2, a = e.y + e.height / 2 - n.height / 2, l;
  switch (i) {
    case jn:
      l = { x: o, y: e.y - n.height };
      break;
    case rr:
      l = { x: o, y: e.y + e.height };
      break;
    case ir:
      l = { x: e.x + e.width, y: a };
      break;
    case Fn:
      l = { x: e.x - n.width, y: a };
      break;
    default:
      l = { x: e.x, y: e.y };
  }
  var u = i ? Ld(i) : null;
  if (u != null) {
    var c = u === "y" ? "height" : "width";
    switch (s) {
      case Ts:
        l[u] = l[u] - (e[c] / 2 - n[c] / 2);
        break;
      case Co:
        l[u] = l[u] + (e[c] / 2 - n[c] / 2);
        break;
    }
  }
  return l;
}
function To(t, e) {
  e === void 0 && (e = {});
  var n = e, r = n.placement, i = r === void 0 ? t.placement : r, s = n.boundary, o = s === void 0 ? c2 : s, a = n.rootBoundary, l = a === void 0 ? wg : a, u = n.elementContext, c = u === void 0 ? Ys : u, d = n.altBoundary, h = d === void 0 ? !1 : d, v = n.padding, y = v === void 0 ? 0 : v, b = xg(typeof y != "number" ? y : Ag(y, Qo)), p = c === Ys ? d2 : Ys, f = t.rects.popper, g = t.elements[h ? p : c], m = H2(Os(g) ? g : g.contextElement || Ei(t.elements.popper), o, l), w = Ns(t.elements.reference), _ = Og({ reference: w, element: f, strategy: "absolute", placement: i }), S = ic(Object.assign({}, f, _)), A = c === Ys ? S : w, C = { top: m.top - A.top + b.top, bottom: A.bottom - m.bottom + b.bottom, left: m.left - A.left + b.left, right: A.right - m.right + b.right }, k = t.modifiersData.offset;
  if (c === Ys && k) {
    var O = k[i];
    Object.keys(C).forEach(function(N) {
      var B = [ir, rr].indexOf(N) >= 0 ? 1 : -1, M = [jn, rr].indexOf(N) >= 0 ? "y" : "x";
      C[N] += O[M] * B;
    });
  }
  return C;
}
function U2(t, e) {
  e === void 0 && (e = {});
  var n = e, r = n.placement, i = n.boundary, s = n.rootBoundary, o = n.padding, a = n.flipVariations, l = n.allowedAutoPlacements, u = l === void 0 ? Fs : l, c = Rs(r), d = c ? a ? xh : xh.filter(function(y) {
    return Rs(y) === c;
  }) : Qo, h = d.filter(function(y) {
    return u.indexOf(y) >= 0;
  });
  h.length === 0 && (h = d);
  var v = h.reduce(function(y, b) {
    return y[b] = To(t, { placement: b, boundary: i, rootBoundary: s, padding: o })[xr(b)], y;
  }, {});
  return Object.keys(v).sort(function(y, b) {
    return v[y] - v[b];
  });
}
function V2(t) {
  if (xr(t) === Bd)
    return [];
  var e = Ma(t);
  return [Ch(t), e, Ch(e)];
}
function W2(t) {
  var e = t.state, n = t.options, r = t.name;
  if (!e.modifiersData[r]._skip) {
    for (var i = n.mainAxis, s = i === void 0 ? !0 : i, o = n.altAxis, a = o === void 0 ? !0 : o, l = n.fallbackPlacements, u = n.padding, c = n.boundary, d = n.rootBoundary, h = n.altBoundary, v = n.flipVariations, y = v === void 0 ? !0 : v, b = n.allowedAutoPlacements, p = e.options.placement, f = xr(p), g = f === p, m = l || (g || !y ? [Ma(p)] : V2(p)), w = [p].concat(m).reduce(function(ce, ge) {
      return ce.concat(xr(ge) === Bd ? U2(e, { placement: ge, boundary: c, rootBoundary: d, padding: u, flipVariations: y, allowedAutoPlacements: b }) : ge);
    }, []), _ = e.rects.reference, S = e.rects.popper, A = /* @__PURE__ */ new Map(), C = !0, k = w[0], O = 0; O < w.length; O++) {
      var N = w[O], B = xr(N), M = Rs(N) === Ts, j = [jn, rr].indexOf(B) >= 0, q = j ? "width" : "height", X = To(e, { placement: N, boundary: c, rootBoundary: d, altBoundary: h, padding: u }), z = j ? M ? ir : Fn : M ? rr : jn;
      _[q] > S[q] && (z = Ma(z));
      var U = Ma(z), H = [];
      if (s && H.push(X[B] <= 0), a && H.push(X[z] <= 0, X[U] <= 0), H.every(function(ce) {
        return ce;
      })) {
        k = N, C = !1;
        break;
      }
      A.set(N, H);
    }
    if (C)
      for (var re = y ? 3 : 1, fe = function(ce) {
        var ge = w.find(function(_e) {
          var je = A.get(_e);
          if (je)
            return je.slice(0, ce).every(function(Te) {
              return Te;
            });
        });
        if (ge)
          return k = ge, "break";
      }, J = re; J > 0; J--) {
        var le = fe(J);
        if (le === "break")
          break;
      }
    e.placement !== k && (e.modifiersData[r]._skip = !0, e.placement = k, e.reset = !0);
  }
}
var K2 = { name: "flip", enabled: !0, phase: "main", fn: W2, requiresIfExists: ["offset"], data: { _skip: !1 } };
function Oh(t, e, n) {
  return n === void 0 && (n = { x: 0, y: 0 }), { top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x };
}
function Ih(t) {
  return [jn, ir, rr, Fn].some(function(e) {
    return t[e] >= 0;
  });
}
function $2(t) {
  var e = t.state, n = t.name, r = e.rects.reference, i = e.rects.popper, s = e.modifiersData.preventOverflow, o = To(e, { elementContext: "reference" }), a = To(e, { altBoundary: !0 }), l = Oh(o, r), u = Oh(a, i, s), c = Ih(l), d = Ih(u);
  e.modifiersData[n] = { referenceClippingOffsets: l, popperEscapeOffsets: u, isReferenceHidden: c, hasPopperEscaped: d }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": c, "data-popper-escaped": d });
}
var G2 = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: $2 };
function q2(t, e, n) {
  var r = xr(t), i = [Fn, jn].indexOf(r) >= 0 ? -1 : 1, s = typeof n == "function" ? n(Object.assign({}, e, { placement: t })) : n, o = s[0], a = s[1];
  return o = o || 0, a = (a || 0) * i, [Fn, ir].indexOf(r) >= 0 ? { x: a, y: o } : { x: o, y: a };
}
function J2(t) {
  var e = t.state, n = t.options, r = t.name, i = n.offset, s = i === void 0 ? [0, 0] : i, o = Fs.reduce(function(c, d) {
    return c[d] = q2(d, e.rects, s), c;
  }, {}), a = o[e.placement], l = a.x, u = a.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += u), e.modifiersData[r] = o;
}
var Y2 = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: J2 };
function Q2(t) {
  var e = t.state, n = t.name;
  e.modifiersData[n] = Og({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement });
}
var Ig = { name: "popperOffsets", enabled: !0, phase: "read", fn: Q2, data: {} };
function Z2(t) {
  return t === "x" ? "y" : "x";
}
function X2(t) {
  var e = t.state, n = t.options, r = t.name, i = n.mainAxis, s = i === void 0 ? !0 : i, o = n.altAxis, a = o === void 0 ? !1 : o, l = n.boundary, u = n.rootBoundary, c = n.altBoundary, d = n.padding, h = n.tether, v = h === void 0 ? !0 : h, y = n.tetherOffset, b = y === void 0 ? 0 : y, p = To(e, { boundary: l, rootBoundary: u, padding: d, altBoundary: c }), f = xr(e.placement), g = Rs(e.placement), m = !g, w = Ld(f), _ = Z2(w), S = e.modifiersData.popperOffsets, A = e.rects.reference, C = e.rects.popper, k = typeof b == "function" ? b(Object.assign({}, e.rects, { placement: e.placement })) : b, O = typeof k == "number" ? { mainAxis: k, altAxis: k } : Object.assign({ mainAxis: 0, altAxis: 0 }, k), N = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, B = { x: 0, y: 0 };
  if (S) {
    if (s) {
      var M, j = w === "y" ? jn : Fn, q = w === "y" ? rr : ir, X = w === "y" ? "height" : "width", z = S[w], U = z + p[j], H = z - p[q], re = v ? -C[X] / 2 : 0, fe = g === Ts ? A[X] : C[X], J = g === Ts ? -C[X] : -A[X], le = e.elements.arrow, ce = v && le ? Md(le) : { width: 0, height: 0 }, ge = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : Eg(), _e = ge[j], je = ge[q], Te = lo(0, A[X], ce[X]), Ze = m ? A[X] / 2 - re - Te - _e - O.mainAxis : fe - Te - _e - O.mainAxis, Le = m ? -A[X] / 2 + re + Te + je + O.mainAxis : J + Te + je + O.mainAxis, Ke = e.elements.arrow && Zo(e.elements.arrow), ct = Ke ? w === "y" ? Ke.clientTop || 0 : Ke.clientLeft || 0 : 0, nt = (M = N == null ? void 0 : N[w]) != null ? M : 0, Et = z + Ze - nt - ct, yt = z + Le - nt, Nt = lo(v ? cl(U, Et) : U, z, v ? Bi(H, yt) : H);
      S[w] = Nt, B[w] = Nt - z;
    }
    if (a) {
      var ot, bt = w === "x" ? jn : Fn, $t = w === "x" ? rr : ir, wt = S[_], xt = _ === "y" ? "height" : "width", lt = wt + p[bt], qe = wt - p[$t], Rt = [jn, Fn].indexOf(f) !== -1, we = (ot = N == null ? void 0 : N[_]) != null ? ot : 0, Ue = Rt ? lt : wt - A[xt] - C[xt] - we + O.altAxis, at = Rt ? wt + A[xt] + C[xt] - we - O.altAxis : qe, Pt = v && Rt ? k2(Ue, wt, at) : lo(v ? Ue : lt, wt, v ? at : qe);
      S[_] = Pt, B[_] = Pt - wt;
    }
    e.modifiersData[r] = B;
  }
}
var eT = { name: "preventOverflow", enabled: !0, phase: "main", fn: X2, requiresIfExists: ["offset"] };
function tT(t) {
  return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop };
}
function nT(t) {
  return t === br(t) || !tr(t) ? zd(t) : tT(t);
}
function rT(t) {
  var e = t.getBoundingClientRect(), n = Is(e.width) / t.offsetWidth || 1, r = Is(e.height) / t.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function iT(t, e, n) {
  n === void 0 && (n = !1);
  var r = tr(e), i = tr(e) && rT(e), s = Ei(e), o = Ns(t, i), a = { scrollLeft: 0, scrollTop: 0 }, l = { x: 0, y: 0 };
  return (r || !r && !n) && ((Nr(e) !== "body" || Fd(s)) && (a = nT(e)), tr(e) ? (l = Ns(e, !0), l.x += e.clientLeft, l.y += e.clientTop) : s && (l.x = jd(s))), { x: o.left + a.scrollLeft - l.x, y: o.top + a.scrollTop - l.y, width: o.width, height: o.height };
}
function sT(t) {
  var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
  t.forEach(function(s) {
    e.set(s.name, s);
  });
  function i(s) {
    n.add(s.name);
    var o = [].concat(s.requires || [], s.requiresIfExists || []);
    o.forEach(function(a) {
      if (!n.has(a)) {
        var l = e.get(a);
        l && i(l);
      }
    }), r.push(s);
  }
  return t.forEach(function(s) {
    n.has(s.name) || i(s);
  }), r;
}
function oT(t) {
  var e = sT(t);
  return _2.reduce(function(n, r) {
    return n.concat(e.filter(function(i) {
      return i.phase === r;
    }));
  }, []);
}
function aT(t) {
  var e;
  return function() {
    return e || (e = new Promise(function(n) {
      Promise.resolve().then(function() {
        e = void 0, n(t());
      });
    })), e;
  };
}
function lT(t) {
  var e = t.reduce(function(n, r) {
    var i = n[r.name];
    return n[r.name] = i ? Object.assign({}, i, r, { options: Object.assign({}, i.options, r.options), data: Object.assign({}, i.data, r.data) }) : r, n;
  }, {});
  return Object.keys(e).map(function(n) {
    return e[n];
  });
}
var Nh = { placement: "bottom", modifiers: [], strategy: "absolute" };
function Rh() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return !e.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function Hd(t) {
  t === void 0 && (t = {});
  var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, i = e.defaultOptions, s = i === void 0 ? Nh : i;
  return function(o, a, l) {
    l === void 0 && (l = s);
    var u = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Nh, s), modifiersData: {}, elements: { reference: o, popper: a }, attributes: {}, styles: {} }, c = [], d = !1, h = { state: u, setOptions: function(b) {
      var p = typeof b == "function" ? b(u.options) : b;
      y(), u.options = Object.assign({}, s, u.options, p), u.scrollParents = { reference: Os(o) ? uo(o) : o.contextElement ? uo(o.contextElement) : [], popper: uo(a) };
      var f = oT(lT([].concat(r, u.options.modifiers)));
      return u.orderedModifiers = f.filter(function(g) {
        return g.enabled;
      }), v(), h.update();
    }, forceUpdate: function() {
      if (!d) {
        var b = u.elements, p = b.reference, f = b.popper;
        if (Rh(p, f)) {
          u.rects = { reference: iT(p, Zo(f), u.options.strategy === "fixed"), popper: Md(f) }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function(C) {
            return u.modifiersData[C.name] = Object.assign({}, C.data);
          });
          for (var g = 0; g < u.orderedModifiers.length; g++) {
            if (u.reset === !0) {
              u.reset = !1, g = -1;
              continue;
            }
            var m = u.orderedModifiers[g], w = m.fn, _ = m.options, S = _ === void 0 ? {} : _, A = m.name;
            typeof w == "function" && (u = w({ state: u, options: S, name: A, instance: h }) || u);
          }
        }
      }
    }, update: aT(function() {
      return new Promise(function(b) {
        h.forceUpdate(), b(u);
      });
    }), destroy: function() {
      y(), d = !0;
    } };
    if (!Rh(o, a))
      return h;
    h.setOptions(l).then(function(b) {
      !d && l.onFirstUpdate && l.onFirstUpdate(b);
    });
    function v() {
      u.orderedModifiers.forEach(function(b) {
        var p = b.name, f = b.options, g = f === void 0 ? {} : f, m = b.effect;
        if (typeof m == "function") {
          var w = m({ state: u, name: p, instance: h, options: g }), _ = function() {
          };
          c.push(w || _);
        }
      });
    }
    function y() {
      c.forEach(function(b) {
        return b();
      }), c = [];
    }
    return h;
  };
}
Hd();
var uT = [Cg, Ig, kg, _g];
Hd({ defaultModifiers: uT });
var cT = [Cg, Ig, kg, _g, Y2, K2, eT, I2, G2], Ng = Hd({ defaultModifiers: cT });
const dT = (t, e, n = {}) => {
  const r = {
    name: "updateState",
    enabled: !0,
    phase: "write",
    fn: ({ state: l }) => {
      const u = fT(l);
      Object.assign(o.value, u);
    },
    requires: ["computeStyles"]
  }, i = F(() => {
    const { onFirstUpdate: l, placement: u, strategy: c, modifiers: d } = x(n);
    return {
      onFirstUpdate: l,
      placement: u || "bottom",
      strategy: c || "absolute",
      modifiers: [
        ...d || [],
        r,
        { name: "applyStyles", enabled: !1 }
      ]
    };
  }), s = zn(), o = $({
    styles: {
      popper: {
        position: x(i).strategy,
        left: "0",
        top: "0"
      },
      arrow: {
        position: "absolute"
      }
    },
    attributes: {}
  }), a = () => {
    s.value && (s.value.destroy(), s.value = void 0);
  };
  return ke(i, (l) => {
    const u = x(s);
    u && u.setOptions(l);
  }, {
    deep: !0
  }), ke([t, e], ([l, u]) => {
    a(), !(!l || !u) && (s.value = Ng(l, u, x(i)));
  }), En(() => {
    a();
  }), {
    state: F(() => {
      var l;
      return { ...((l = x(s)) == null ? void 0 : l.state) || {} };
    }),
    styles: F(() => x(o).styles),
    attributes: F(() => x(o).attributes),
    update: () => {
      var l;
      return (l = x(s)) == null ? void 0 : l.update();
    },
    forceUpdate: () => {
      var l;
      return (l = x(s)) == null ? void 0 : l.forceUpdate();
    },
    instanceRef: F(() => x(s))
  };
};
function fT(t) {
  const e = Object.keys(t.elements), n = al(e.map((i) => [i, t.styles[i] || {}])), r = al(e.map((i) => [i, t.attributes[i]]));
  return {
    styles: n,
    attributes: r
  };
}
function Ph() {
  let t;
  const e = (r, i) => {
    n(), t = window.setTimeout(r, i);
  }, n = () => window.clearTimeout(t);
  return dd(() => n()), {
    registerTimeout: e,
    cancelTimeout: n
  };
}
const sc = {
  prefix: Math.floor(Math.random() * 1e4),
  current: 0
}, hT = Symbol("elIdInjection"), Rg = () => ht() ? tt(hT, sc) : sc, Xo = (t) => {
  const e = Rg();
  !St && e === sc && Vt("IdInjection", `Looks like you are using server rendering, you must provide a id provider to ensure the hydration process to be succeed
usage: app.provide(ID_INJECTION_KEY, {
  prefix: number,
  current: number,
})`);
  const n = Pd();
  return F(() => x(t) || `${n.value}-id-${e.prefix}-${e.current++}`);
};
let hs = [];
const Bh = (t) => {
  const e = t;
  e.key === sn.esc && hs.forEach((n) => n(e));
}, pT = (t) => {
  Ct(() => {
    hs.length === 0 && document.addEventListener("keydown", Bh), St && hs.push(t);
  }), En(() => {
    hs = hs.filter((e) => e !== t), hs.length === 0 && St && document.removeEventListener("keydown", Bh);
  });
};
let Dh;
const Pg = () => {
  const t = Pd(), e = Rg(), n = F(() => `${t.value}-popper-container-${e.prefix}`), r = F(() => `#${n.value}`);
  return {
    id: n,
    selector: r
  };
}, vT = (t) => {
  const e = document.createElement("div");
  return e.id = t, document.body.appendChild(e), e;
}, gT = () => {
  const { id: t, selector: e } = Pg();
  return ld(() => {
    St && (process.env.NODE_ENV === "test" || !Dh && !document.body.querySelector(e.value)) && (Dh = vT(t.value));
  }), {
    id: t,
    selector: e
  };
}, mT = ut({
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  autoClose: {
    type: Number,
    default: 0
  }
}), Bg = ({
  showAfter: t,
  hideAfter: e,
  autoClose: n,
  open: r,
  close: i
}) => {
  const { registerTimeout: s } = Ph(), {
    registerTimeout: o,
    cancelTimeout: a
  } = Ph();
  return {
    onOpen: (c) => {
      s(() => {
        r(c);
        const d = x(n);
        mt(d) && d > 0 && o(() => {
          i(c);
        }, d);
      }, x(t));
    },
    onClose: (c) => {
      a(), s(() => {
        i(c);
      }, x(e));
    }
  };
}, Dg = Symbol("elForwardRef"), yT = (t) => {
  qt(Dg, {
    setForwardRef: (n) => {
      t.value = n;
    }
  });
}, bT = (t) => ({
  mounted(e) {
    t(e);
  },
  updated(e) {
    t(e);
  },
  unmounted() {
    t(null);
  }
}), Mh = $(0), Mg = 2e3, Lg = Symbol("zIndexContextKey"), ql = (t) => {
  const e = t || (ht() ? tt(Lg, void 0) : void 0), n = F(() => {
    const s = x(e);
    return mt(s) ? s : Mg;
  }), r = F(() => n.value + Mh.value);
  return {
    initialZIndex: n,
    currentZIndex: r,
    nextZIndex: () => (Mh.value++, r.value)
  };
};
function wT(t) {
  const e = $();
  function n() {
    if (t.value == null)
      return;
    const { selectionStart: i, selectionEnd: s, value: o } = t.value;
    if (i == null || s == null)
      return;
    const a = o.slice(0, Math.max(0, i)), l = o.slice(Math.max(0, s));
    e.value = {
      selectionStart: i,
      selectionEnd: s,
      value: o,
      beforeTxt: a,
      afterTxt: l
    };
  }
  function r() {
    if (t.value == null || e.value == null)
      return;
    const { value: i } = t.value, { beforeTxt: s, afterTxt: o, selectionStart: a } = e.value;
    if (s == null || o == null || a == null)
      return;
    let l = i.length;
    if (i.endsWith(o))
      l = i.length - o.length;
    else if (i.startsWith(s))
      l = s.length;
    else {
      const u = s[a - 1], c = i.indexOf(u, a - 1);
      c !== -1 && (l = c + 1);
    }
    t.value.setSelectionRange(l, l);
  }
  return [n, r];
}
const Rr = $l({
  type: String,
  values: Rd,
  required: !1
}), zg = Symbol("size"), _T = () => {
  const t = tt(zg, {});
  return F(() => x(t.size) || "");
};
function ST(t, { afterFocus: e, beforeBlur: n, afterBlur: r } = {}) {
  const i = ht(), { emit: s } = i, o = zn(), a = $(!1), l = (d) => {
    a.value || (a.value = !0, s("focus", d), e == null || e());
  }, u = (d) => {
    var h;
    gn(n) && n(d) || d.relatedTarget && ((h = o.value) != null && h.contains(d.relatedTarget)) || (a.value = !1, s("blur", d), r == null || r());
  }, c = () => {
    var d;
    (d = t.value) == null || d.focus();
  };
  return ke(o, (d) => {
    d && d.setAttribute("tabindex", "-1");
  }), bn(o, "click", c), {
    wrapperRef: o,
    isFocused: a,
    handleFocus: l,
    handleBlur: u
  };
}
const jg = Symbol(), dl = $();
function Ud(t, e = void 0) {
  const n = ht() ? tt(jg, dl) : dl;
  return t ? F(() => {
    var r, i;
    return (i = (r = n.value) == null ? void 0 : r[t]) != null ? i : e;
  }) : n;
}
function ET(t, e) {
  const n = Ud(), r = Fe(t, F(() => {
    var a;
    return ((a = n.value) == null ? void 0 : a.namespace) || Da;
  })), i = or(F(() => {
    var a;
    return (a = n.value) == null ? void 0 : a.locale;
  })), s = ql(F(() => {
    var a;
    return ((a = n.value) == null ? void 0 : a.zIndex) || Mg;
  })), o = F(() => {
    var a;
    return x(e) || ((a = n.value) == null ? void 0 : a.size) || "";
  });
  return xT(F(() => x(n) || {})), {
    ns: r,
    locale: i,
    zIndex: s,
    size: o
  };
}
const xT = (t, e, n = !1) => {
  var r;
  const i = !!ht(), s = i ? Ud() : void 0, o = (r = e == null ? void 0 : e.provide) != null ? r : i ? qt : void 0;
  if (!o) {
    Vt("provideGlobalConfig", "provideGlobalConfig() can only be used inside setup().");
    return;
  }
  const a = F(() => {
    const l = x(t);
    return s != null && s.value ? AT(s.value, l) : l;
  });
  return o(jg, a), o(gg, F(() => a.value.locale)), o(mg, F(() => a.value.namespace)), o(Lg, F(() => a.value.zIndex)), o(zg, {
    size: F(() => a.value.size || "")
  }), (n || !dl.value) && (dl.value = a.value), a;
}, AT = (t, e) => {
  var n;
  const r = [.../* @__PURE__ */ new Set([...rc(t), ...rc(e)])], i = {};
  for (const s of r)
    i[s] = (n = e[s]) != null ? n : t[s];
  return i;
};
var Ge = (t, e) => {
  const n = t.__vccOpts || t;
  for (const [r, i] of e)
    n[r] = i;
  return n;
};
const kT = ut({
  size: {
    type: Be([Number, String])
  },
  color: {
    type: String
  }
}), CT = be({
  name: "ElIcon",
  inheritAttrs: !1
}), TT = /* @__PURE__ */ be({
  ...CT,
  props: kT,
  setup(t) {
    const e = t, n = Fe("icon"), r = F(() => {
      const { size: i, color: s } = e;
      return !i && !s ? {} : {
        fontSize: Sr(i) ? void 0 : ul(i),
        "--color": s
      };
    });
    return (i, s) => (V(), se("i", Gn({
      class: x(n).b(),
      style: x(r)
    }, i.$attrs), [
      Me(i.$slots, "default")
    ], 16));
  }
});
var OT = /* @__PURE__ */ Ge(TT, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/icon/src/icon.vue"]]);
const _t = nn(OT), Vd = Symbol("formContextKey"), Oo = Symbol("formItemContextKey"), Pr = (t, e = {}) => {
  const n = $(void 0), r = e.prop ? n : bg("size"), i = e.global ? n : _T(), s = e.form ? { size: void 0 } : tt(Vd, void 0), o = e.formItem ? { size: void 0 } : tt(Oo, void 0);
  return F(() => r.value || x(t) || (o == null ? void 0 : o.size) || (s == null ? void 0 : s.size) || i.value || "");
}, Br = (t) => {
  const e = bg("disabled"), n = tt(Vd, void 0);
  return F(() => e.value || x(t) || (n == null ? void 0 : n.disabled) || !1);
}, oi = () => {
  const t = tt(Vd, void 0), e = tt(Oo, void 0);
  return {
    form: t,
    formItem: e
  };
}, ea = (t, {
  formItemContext: e,
  disableIdGeneration: n,
  disableIdManagement: r
}) => {
  n || (n = $(!1)), r || (r = $(!1));
  const i = $();
  let s;
  const o = F(() => {
    var a;
    return !!(!t.label && e && e.inputIds && ((a = e.inputIds) == null ? void 0 : a.length) <= 1);
  });
  return Ct(() => {
    s = ke([Cn(t, "id"), n], ([a, l]) => {
      const u = a ?? (l ? void 0 : Xo().value);
      u !== i.value && (e != null && e.removeInputId && (i.value && e.removeInputId(i.value), !(r != null && r.value) && !l && u && e.addInputId(u)), i.value = u);
    }, { immediate: !0 });
  }), Wo(() => {
    s && s(), e != null && e.removeInputId && i.value && e.removeInputId(i.value);
  }), {
    isLabeledByFormItem: o,
    inputId: i
  };
};
let lr;
const IT = `
  height:0 !important;
  visibility:hidden !important;
  ${Sb() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`, NT = [
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "font-family",
  "font-weight",
  "font-size",
  "text-rendering",
  "text-transform",
  "width",
  "text-indent",
  "padding-left",
  "padding-right",
  "border-width",
  "box-sizing"
];
function RT(t) {
  const e = window.getComputedStyle(t), n = e.getPropertyValue("box-sizing"), r = Number.parseFloat(e.getPropertyValue("padding-bottom")) + Number.parseFloat(e.getPropertyValue("padding-top")), i = Number.parseFloat(e.getPropertyValue("border-bottom-width")) + Number.parseFloat(e.getPropertyValue("border-top-width"));
  return { contextStyle: NT.map((o) => `${o}:${e.getPropertyValue(o)}`).join(";"), paddingSize: r, borderSize: i, boxSizing: n };
}
function Lh(t, e = 1, n) {
  var r;
  lr || (lr = document.createElement("textarea"), document.body.appendChild(lr));
  const { paddingSize: i, borderSize: s, boxSizing: o, contextStyle: a } = RT(t);
  lr.setAttribute("style", `${a};${IT}`), lr.value = t.value || t.placeholder || "";
  let l = lr.scrollHeight;
  const u = {};
  o === "border-box" ? l = l + s : o === "content-box" && (l = l - i), lr.value = "";
  const c = lr.scrollHeight - i;
  if (mt(e)) {
    let d = c * e;
    o === "border-box" && (d = d + i + s), l = Math.max(d, l), u.minHeight = `${d}px`;
  }
  if (mt(n)) {
    let d = c * n;
    o === "border-box" && (d = d + i + s), l = Math.min(d, l);
  }
  return u.height = `${l}px`, (r = lr.parentNode) == null || r.removeChild(lr), lr = void 0, u;
}
const PT = ut({
  id: {
    type: String,
    default: void 0
  },
  size: Rr,
  disabled: Boolean,
  modelValue: {
    type: Be([
      String,
      Number,
      Object
    ]),
    default: ""
  },
  type: {
    type: String,
    default: "text"
  },
  resize: {
    type: String,
    values: ["none", "both", "horizontal", "vertical"]
  },
  autosize: {
    type: Be([Boolean, Object]),
    default: !1
  },
  autocomplete: {
    type: String,
    default: "off"
  },
  formatter: {
    type: Function
  },
  parser: {
    type: Function
  },
  placeholder: {
    type: String
  },
  form: {
    type: String
  },
  readonly: {
    type: Boolean,
    default: !1
  },
  clearable: {
    type: Boolean,
    default: !1
  },
  showPassword: {
    type: Boolean,
    default: !1
  },
  showWordLimit: {
    type: Boolean,
    default: !1
  },
  suffixIcon: {
    type: bi
  },
  prefixIcon: {
    type: bi
  },
  containerRole: {
    type: String,
    default: void 0
  },
  label: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  inputStyle: {
    type: Be([Object, Array, String]),
    default: () => Cs({})
  },
  autofocus: {
    type: Boolean,
    default: !1
  }
}), BT = {
  [Bt]: (t) => Gt(t),
  input: (t) => Gt(t),
  change: (t) => Gt(t),
  focus: (t) => t instanceof FocusEvent,
  blur: (t) => t instanceof FocusEvent,
  clear: () => !0,
  mouseleave: (t) => t instanceof MouseEvent,
  mouseenter: (t) => t instanceof MouseEvent,
  keydown: (t) => t instanceof Event,
  compositionstart: (t) => t instanceof CompositionEvent,
  compositionupdate: (t) => t instanceof CompositionEvent,
  compositionend: (t) => t instanceof CompositionEvent
}, DT = ["role"], MT = ["id", "type", "disabled", "formatter", "parser", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus"], LT = ["id", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus"], zT = be({
  name: "ElInput",
  inheritAttrs: !1
}), jT = /* @__PURE__ */ be({
  ...zT,
  props: PT,
  emits: BT,
  setup(t, { expose: e, emit: n }) {
    const r = t, i = hv(), s = Ko(), o = F(() => {
      const we = {};
      return r.containerRole === "combobox" && (we["aria-haspopup"] = i["aria-haspopup"], we["aria-owns"] = i["aria-owns"], we["aria-expanded"] = i["aria-expanded"]), we;
    }), a = F(() => [
      r.type === "textarea" ? p.b() : b.b(),
      b.m(v.value),
      b.is("disabled", y.value),
      b.is("exceed", ce.value),
      {
        [b.b("group")]: s.prepend || s.append,
        [b.bm("group", "append")]: s.append,
        [b.bm("group", "prepend")]: s.prepend,
        [b.m("prefix")]: s.prefix || r.prefixIcon,
        [b.m("suffix")]: s.suffix || r.suffixIcon || r.clearable || r.showPassword,
        [b.bm("suffix", "password-clear")]: re.value && fe.value
      },
      i.class
    ]), l = F(() => [
      b.e("wrapper"),
      b.is("focus", O.value)
    ]), u = pg({
      excludeKeys: F(() => Object.keys(o.value))
    }), { form: c, formItem: d } = oi(), { inputId: h } = ea(r, {
      formItemContext: d
    }), v = Pr(), y = Br(), b = Fe("input"), p = Fe("textarea"), f = zn(), g = zn(), m = $(!1), w = $(!1), _ = $(!1), S = $(), A = zn(r.inputStyle), C = F(() => f.value || g.value), { wrapperRef: k, isFocused: O, handleFocus: N, handleBlur: B } = ST(C, {
      afterBlur() {
        var we;
        r.validateEvent && ((we = d == null ? void 0 : d.validate) == null || we.call(d, "blur").catch((Ue) => Vt(Ue)));
      }
    }), M = F(() => {
      var we;
      return (we = c == null ? void 0 : c.statusIcon) != null ? we : !1;
    }), j = F(() => (d == null ? void 0 : d.validateState) || ""), q = F(() => j.value && fg[j.value]), X = F(() => _.value ? NC : bk), z = F(() => [
      i.style,
      r.inputStyle
    ]), U = F(() => [
      r.inputStyle,
      A.value,
      { resize: r.resize }
    ]), H = F(() => er(r.modelValue) ? "" : String(r.modelValue)), re = F(() => r.clearable && !y.value && !r.readonly && !!H.value && (O.value || m.value)), fe = F(() => r.showPassword && !y.value && !r.readonly && !!H.value && (!!H.value || O.value)), J = F(() => r.showWordLimit && !!u.value.maxlength && (r.type === "text" || r.type === "textarea") && !y.value && !r.readonly && !r.showPassword), le = F(() => H.value.length), ce = F(() => !!J.value && le.value > Number(u.value.maxlength)), ge = F(() => !!s.suffix || !!r.suffixIcon || re.value || r.showPassword || J.value || !!j.value && M.value), [_e, je] = wT(f);
    As(g, (we) => {
      if (Le(), !J.value || r.resize !== "both")
        return;
      const Ue = we[0], { width: at } = Ue.contentRect;
      S.value = {
        right: `calc(100% - ${at + 15 + 6}px)`
      };
    });
    const Te = () => {
      const { type: we, autosize: Ue } = r;
      if (!(!St || we !== "textarea" || !g.value))
        if (Ue) {
          const at = wn(Ue) ? Ue.minRows : void 0, Pt = wn(Ue) ? Ue.maxRows : void 0, Qt = Lh(g.value, at, Pt);
          A.value = {
            overflowY: "hidden",
            ...Qt
          }, rt(() => {
            g.value.offsetHeight, A.value = Qt;
          });
        } else
          A.value = {
            minHeight: Lh(g.value).minHeight
          };
    }, Le = ((we) => {
      let Ue = !1;
      return () => {
        var at;
        if (Ue || !r.autosize)
          return;
        ((at = g.value) == null ? void 0 : at.offsetParent) === null || (we(), Ue = !0);
      };
    })(Te), Ke = () => {
      const we = C.value, Ue = r.formatter ? r.formatter(H.value) : H.value;
      !we || we.value === Ue || (we.value = Ue);
    }, ct = async (we) => {
      _e();
      let { value: Ue } = we.target;
      if (r.formatter && (Ue = r.parser ? r.parser(Ue) : Ue), !w.value) {
        if (Ue === H.value) {
          Ke();
          return;
        }
        n(Bt, Ue), n("input", Ue), await rt(), Ke(), je();
      }
    }, nt = (we) => {
      n("change", we.target.value);
    }, Et = (we) => {
      n("compositionstart", we), w.value = !0;
    }, yt = (we) => {
      var Ue;
      n("compositionupdate", we);
      const at = (Ue = we.target) == null ? void 0 : Ue.value, Pt = at[at.length - 1] || "";
      w.value = !hg(Pt);
    }, Nt = (we) => {
      n("compositionend", we), w.value && (w.value = !1, ct(we));
    }, ot = () => {
      _.value = !_.value, bt();
    }, bt = async () => {
      var we;
      await rt(), (we = C.value) == null || we.focus();
    }, $t = () => {
      var we;
      return (we = C.value) == null ? void 0 : we.blur();
    }, wt = (we) => {
      m.value = !1, n("mouseleave", we);
    }, xt = (we) => {
      m.value = !0, n("mouseenter", we);
    }, lt = (we) => {
      n("keydown", we);
    }, qe = () => {
      var we;
      (we = C.value) == null || we.select();
    }, Rt = () => {
      n(Bt, ""), n("change", ""), n("clear"), n("input", "");
    };
    return ke(() => r.modelValue, () => {
      var we;
      rt(() => Te()), r.validateEvent && ((we = d == null ? void 0 : d.validate) == null || we.call(d, "change").catch((Ue) => Vt(Ue)));
    }), ke(H, () => Ke()), ke(() => r.type, async () => {
      await rt(), Ke(), Te();
    }), Ct(() => {
      !r.formatter && r.parser && Vt("ElInput", "If you set the parser, you also need to set the formatter."), Ke(), rt(Te);
    }), e({
      input: f,
      textarea: g,
      ref: C,
      textareaStyle: U,
      autosize: Cn(r, "autosize"),
      focus: bt,
      blur: $t,
      select: qe,
      clear: Rt,
      resizeTextarea: Te
    }), (we, Ue) => Dt((V(), se("div", Gn(x(o), {
      class: x(a),
      style: x(z),
      role: we.containerRole,
      onMouseenter: xt,
      onMouseleave: wt
    }), [
      ye(" input "),
      we.type !== "textarea" ? (V(), se(Ft, { key: 0 }, [
        ye(" prepend slot "),
        we.$slots.prepend ? (V(), se("div", {
          key: 0,
          class: ee(x(b).be("group", "prepend"))
        }, [
          Me(we.$slots, "prepend")
        ], 2)) : ye("v-if", !0),
        ae("div", {
          ref_key: "wrapperRef",
          ref: k,
          class: ee(x(l))
        }, [
          ye(" prefix slot "),
          we.$slots.prefix || we.prefixIcon ? (V(), se("span", {
            key: 0,
            class: ee(x(b).e("prefix"))
          }, [
            ae("span", {
              class: ee(x(b).e("prefix-inner"))
            }, [
              Me(we.$slots, "prefix"),
              we.prefixIcon ? (V(), Ae(x(_t), {
                key: 0,
                class: ee(x(b).e("icon"))
              }, {
                default: de(() => [
                  (V(), Ae(Nn(we.prefixIcon)))
                ]),
                _: 1
              }, 8, ["class"])) : ye("v-if", !0)
            ], 2)
          ], 2)) : ye("v-if", !0),
          ae("input", Gn({
            id: x(h),
            ref_key: "input",
            ref: f,
            class: x(b).e("inner")
          }, x(u), {
            type: we.showPassword ? _.value ? "text" : "password" : we.type,
            disabled: x(y),
            formatter: we.formatter,
            parser: we.parser,
            readonly: we.readonly,
            autocomplete: we.autocomplete,
            tabindex: we.tabindex,
            "aria-label": we.label,
            placeholder: we.placeholder,
            style: we.inputStyle,
            form: r.form,
            autofocus: r.autofocus,
            onCompositionstart: Et,
            onCompositionupdate: yt,
            onCompositionend: Nt,
            onInput: ct,
            onFocus: Ue[0] || (Ue[0] = (...at) => x(N) && x(N)(...at)),
            onBlur: Ue[1] || (Ue[1] = (...at) => x(B) && x(B)(...at)),
            onChange: nt,
            onKeydown: lt
          }), null, 16, MT),
          ye(" suffix slot "),
          x(ge) ? (V(), se("span", {
            key: 1,
            class: ee(x(b).e("suffix"))
          }, [
            ae("span", {
              class: ee(x(b).e("suffix-inner"))
            }, [
              !x(re) || !x(fe) || !x(J) ? (V(), se(Ft, { key: 0 }, [
                Me(we.$slots, "suffix"),
                we.suffixIcon ? (V(), Ae(x(_t), {
                  key: 0,
                  class: ee(x(b).e("icon"))
                }, {
                  default: de(() => [
                    (V(), Ae(Nn(we.suffixIcon)))
                  ]),
                  _: 1
                }, 8, ["class"])) : ye("v-if", !0)
              ], 64)) : ye("v-if", !0),
              x(re) ? (V(), Ae(x(_t), {
                key: 1,
                class: ee([x(b).e("icon"), x(b).e("clear")]),
                onMousedown: ft(x(en), ["prevent"]),
                onClick: Rt
              }, {
                default: de(() => [
                  ve(x(Wl))
                ]),
                _: 1
              }, 8, ["class", "onMousedown"])) : ye("v-if", !0),
              x(fe) ? (V(), Ae(x(_t), {
                key: 2,
                class: ee([x(b).e("icon"), x(b).e("password")]),
                onClick: ot
              }, {
                default: de(() => [
                  (V(), Ae(Nn(x(X))))
                ]),
                _: 1
              }, 8, ["class"])) : ye("v-if", !0),
              x(J) ? (V(), se("span", {
                key: 3,
                class: ee(x(b).e("count"))
              }, [
                ae("span", {
                  class: ee(x(b).e("count-inner"))
                }, st(x(le)) + " / " + st(x(u).maxlength), 3)
              ], 2)) : ye("v-if", !0),
              x(j) && x(q) && x(M) ? (V(), Ae(x(_t), {
                key: 4,
                class: ee([
                  x(b).e("icon"),
                  x(b).e("validateIcon"),
                  x(b).is("loading", x(j) === "validating")
                ])
              }, {
                default: de(() => [
                  (V(), Ae(Nn(x(q))))
                ]),
                _: 1
              }, 8, ["class"])) : ye("v-if", !0)
            ], 2)
          ], 2)) : ye("v-if", !0)
        ], 2),
        ye(" append slot "),
        we.$slots.append ? (V(), se("div", {
          key: 1,
          class: ee(x(b).be("group", "append"))
        }, [
          Me(we.$slots, "append")
        ], 2)) : ye("v-if", !0)
      ], 64)) : (V(), se(Ft, { key: 1 }, [
        ye(" textarea "),
        ae("textarea", Gn({
          id: x(h),
          ref_key: "textarea",
          ref: g,
          class: x(p).e("inner")
        }, x(u), {
          tabindex: we.tabindex,
          disabled: x(y),
          readonly: we.readonly,
          autocomplete: we.autocomplete,
          style: x(U),
          "aria-label": we.label,
          placeholder: we.placeholder,
          form: r.form,
          autofocus: r.autofocus,
          onCompositionstart: Et,
          onCompositionupdate: yt,
          onCompositionend: Nt,
          onInput: ct,
          onFocus: Ue[2] || (Ue[2] = (...at) => x(N) && x(N)(...at)),
          onBlur: Ue[3] || (Ue[3] = (...at) => x(B) && x(B)(...at)),
          onChange: nt,
          onKeydown: lt
        }), null, 16, LT),
        x(J) ? (V(), se("span", {
          key: 0,
          style: it(S.value),
          class: ee(x(b).e("count"))
        }, st(x(le)) + " / " + st(x(u).maxlength), 7)) : ye("v-if", !0)
      ], 64))
    ], 16, DT)), [
      [Jn, we.type !== "hidden"]
    ]);
  }
});
var FT = /* @__PURE__ */ Ge(jT, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input/src/input.vue"]]);
const Jl = nn(FT), ys = 4, HT = {
  vertical: {
    offset: "offsetHeight",
    scroll: "scrollTop",
    scrollSize: "scrollHeight",
    size: "height",
    key: "vertical",
    axis: "Y",
    client: "clientY",
    direction: "top"
  },
  horizontal: {
    offset: "offsetWidth",
    scroll: "scrollLeft",
    scrollSize: "scrollWidth",
    size: "width",
    key: "horizontal",
    axis: "X",
    client: "clientX",
    direction: "left"
  }
}, UT = ({
  move: t,
  size: e,
  bar: n
}) => ({
  [n.size]: e,
  transform: `translate${n.axis}(${t}%)`
}), Fg = Symbol("scrollbarContextKey"), VT = ut({
  vertical: Boolean,
  size: String,
  move: Number,
  ratio: {
    type: Number,
    required: !0
  },
  always: Boolean
}), WT = "Thumb", KT = /* @__PURE__ */ be({
  __name: "thumb",
  props: VT,
  setup(t) {
    const e = t, n = tt(Fg), r = Fe("scrollbar");
    n || qi(WT, "can not inject scrollbar context");
    const i = $(), s = $(), o = $({}), a = $(!1);
    let l = !1, u = !1, c = St ? document.onselectstart : null;
    const d = F(() => HT[e.vertical ? "vertical" : "horizontal"]), h = F(() => UT({
      size: e.size,
      move: e.move,
      bar: d.value
    })), v = F(() => i.value[d.value.offset] ** 2 / n.wrapElement[d.value.scrollSize] / e.ratio / s.value[d.value.offset]), y = (S) => {
      var A;
      if (S.stopPropagation(), S.ctrlKey || [1, 2].includes(S.button))
        return;
      (A = window.getSelection()) == null || A.removeAllRanges(), p(S);
      const C = S.currentTarget;
      C && (o.value[d.value.axis] = C[d.value.offset] - (S[d.value.client] - C.getBoundingClientRect()[d.value.direction]));
    }, b = (S) => {
      if (!s.value || !i.value || !n.wrapElement)
        return;
      const A = Math.abs(S.target.getBoundingClientRect()[d.value.direction] - S[d.value.client]), C = s.value[d.value.offset] / 2, k = (A - C) * 100 * v.value / i.value[d.value.offset];
      n.wrapElement[d.value.scroll] = k * n.wrapElement[d.value.scrollSize] / 100;
    }, p = (S) => {
      S.stopImmediatePropagation(), l = !0, document.addEventListener("mousemove", f), document.addEventListener("mouseup", g), c = document.onselectstart, document.onselectstart = () => !1;
    }, f = (S) => {
      if (!i.value || !s.value || l === !1)
        return;
      const A = o.value[d.value.axis];
      if (!A)
        return;
      const C = (i.value.getBoundingClientRect()[d.value.direction] - S[d.value.client]) * -1, k = s.value[d.value.offset] - A, O = (C - k) * 100 * v.value / i.value[d.value.offset];
      n.wrapElement[d.value.scroll] = O * n.wrapElement[d.value.scrollSize] / 100;
    }, g = () => {
      l = !1, o.value[d.value.axis] = 0, document.removeEventListener("mousemove", f), document.removeEventListener("mouseup", g), _(), u && (a.value = !1);
    }, m = () => {
      u = !1, a.value = !!e.size;
    }, w = () => {
      u = !0, a.value = l;
    };
    En(() => {
      _(), document.removeEventListener("mouseup", g);
    });
    const _ = () => {
      document.onselectstart !== c && (document.onselectstart = c);
    };
    return bn(Cn(n, "scrollbarElement"), "mousemove", m), bn(Cn(n, "scrollbarElement"), "mouseleave", w), (S, A) => (V(), Ae(mr, {
      name: x(r).b("fade"),
      persisted: ""
    }, {
      default: de(() => [
        Dt(ae("div", {
          ref_key: "instance",
          ref: i,
          class: ee([x(r).e("bar"), x(r).is(x(d).key)]),
          onMousedown: b
        }, [
          ae("div", {
            ref_key: "thumb",
            ref: s,
            class: ee(x(r).e("thumb")),
            style: it(x(h)),
            onMousedown: y
          }, null, 38)
        ], 34), [
          [Jn, S.always || a.value]
        ])
      ]),
      _: 1
    }, 8, ["name"]));
  }
});
var zh = /* @__PURE__ */ Ge(KT, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/thumb.vue"]]);
const $T = ut({
  always: {
    type: Boolean,
    default: !0
  },
  width: String,
  height: String,
  ratioX: {
    type: Number,
    default: 1
  },
  ratioY: {
    type: Number,
    default: 1
  }
}), GT = /* @__PURE__ */ be({
  __name: "bar",
  props: $T,
  setup(t, { expose: e }) {
    const n = t, r = $(0), i = $(0);
    return e({
      handleScroll: (o) => {
        if (o) {
          const a = o.offsetHeight - ys, l = o.offsetWidth - ys;
          i.value = o.scrollTop * 100 / a * n.ratioY, r.value = o.scrollLeft * 100 / l * n.ratioX;
        }
      }
    }), (o, a) => (V(), se(Ft, null, [
      ve(zh, {
        move: r.value,
        ratio: o.ratioX,
        size: o.width,
        always: o.always
      }, null, 8, ["move", "ratio", "size", "always"]),
      ve(zh, {
        move: i.value,
        ratio: o.ratioY,
        size: o.height,
        vertical: "",
        always: o.always
      }, null, 8, ["move", "ratio", "size", "always"])
    ], 64));
  }
});
var qT = /* @__PURE__ */ Ge(GT, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/bar.vue"]]);
const JT = ut({
  height: {
    type: [String, Number],
    default: ""
  },
  maxHeight: {
    type: [String, Number],
    default: ""
  },
  native: {
    type: Boolean,
    default: !1
  },
  wrapStyle: {
    type: Be([String, Object, Array]),
    default: ""
  },
  wrapClass: {
    type: [String, Array],
    default: ""
  },
  viewClass: {
    type: [String, Array],
    default: ""
  },
  viewStyle: {
    type: [String, Array, Object],
    default: ""
  },
  noresize: Boolean,
  tag: {
    type: String,
    default: "div"
  },
  always: Boolean,
  minSize: {
    type: Number,
    default: 20
  },
  id: String,
  role: String,
  ariaLabel: String,
  ariaOrientation: {
    type: String,
    values: ["horizontal", "vertical"]
  }
}), YT = {
  scroll: ({
    scrollTop: t,
    scrollLeft: e
  }) => [t, e].every(mt)
}, oc = "ElScrollbar", QT = be({
  name: oc
}), ZT = /* @__PURE__ */ be({
  ...QT,
  props: JT,
  emits: YT,
  setup(t, { expose: e, emit: n }) {
    const r = t, i = Fe("scrollbar");
    let s, o;
    const a = $(), l = $(), u = $(), c = $("0"), d = $("0"), h = $(), v = $(1), y = $(1), b = F(() => {
      const A = {};
      return r.height && (A.height = ul(r.height)), r.maxHeight && (A.maxHeight = ul(r.maxHeight)), [r.wrapStyle, A];
    }), p = F(() => [
      r.wrapClass,
      i.e("wrap"),
      { [i.em("wrap", "hidden-default")]: !r.native }
    ]), f = F(() => [i.e("view"), r.viewClass]), g = () => {
      var A;
      l.value && ((A = h.value) == null || A.handleScroll(l.value), n("scroll", {
        scrollTop: l.value.scrollTop,
        scrollLeft: l.value.scrollLeft
      }));
    };
    function m(A, C) {
      wn(A) ? l.value.scrollTo(A) : mt(A) && mt(C) && l.value.scrollTo(A, C);
    }
    const w = (A) => {
      if (!mt(A)) {
        Vt(oc, "value must be a number");
        return;
      }
      l.value.scrollTop = A;
    }, _ = (A) => {
      if (!mt(A)) {
        Vt(oc, "value must be a number");
        return;
      }
      l.value.scrollLeft = A;
    }, S = () => {
      if (!l.value)
        return;
      const A = l.value.offsetHeight - ys, C = l.value.offsetWidth - ys, k = A ** 2 / l.value.scrollHeight, O = C ** 2 / l.value.scrollWidth, N = Math.max(k, r.minSize), B = Math.max(O, r.minSize);
      v.value = k / (A - k) / (N / (A - N)), y.value = O / (C - O) / (B / (C - B)), d.value = N + ys < A ? `${N}px` : "", c.value = B + ys < C ? `${B}px` : "";
    };
    return ke(() => r.noresize, (A) => {
      A ? (s == null || s(), o == null || o()) : ({ stop: s } = As(u, S), o = bn("resize", S));
    }, { immediate: !0 }), ke(() => [r.maxHeight, r.height], () => {
      r.native || rt(() => {
        var A;
        S(), l.value && ((A = h.value) == null || A.handleScroll(l.value));
      });
    }), qt(Fg, Bn({
      scrollbarElement: a,
      wrapElement: l
    })), Ct(() => {
      r.native || rt(() => {
        S();
      });
    }), Ml(() => S()), e({
      wrapRef: l,
      update: S,
      scrollTo: m,
      setScrollTop: w,
      setScrollLeft: _,
      handleScroll: g
    }), (A, C) => (V(), se("div", {
      ref_key: "scrollbarRef",
      ref: a,
      class: ee(x(i).b())
    }, [
      ae("div", {
        ref_key: "wrapRef",
        ref: l,
        class: ee(x(p)),
        style: it(x(b)),
        onScroll: g
      }, [
        (V(), Ae(Nn(A.tag), {
          id: A.id,
          ref_key: "resizeRef",
          ref: u,
          class: ee(x(f)),
          style: it(A.viewStyle),
          role: A.role,
          "aria-label": A.ariaLabel,
          "aria-orientation": A.ariaOrientation
        }, {
          default: de(() => [
            Me(A.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "class", "style", "role", "aria-label", "aria-orientation"]))
      ], 38),
      A.native ? ye("v-if", !0) : (V(), Ae(qT, {
        key: 0,
        ref_key: "barRef",
        ref: h,
        height: d.value,
        width: c.value,
        always: A.always,
        "ratio-x": y.value,
        "ratio-y": v.value
      }, null, 8, ["height", "width", "always", "ratio-x", "ratio-y"]))
    ], 2));
  }
});
var XT = /* @__PURE__ */ Ge(ZT, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/scrollbar.vue"]]);
const Wd = nn(XT), Kd = Symbol("popper"), Hg = Symbol("popperContent"), eO = [
  "dialog",
  "grid",
  "group",
  "listbox",
  "menu",
  "navigation",
  "tooltip",
  "tree"
], Ug = ut({
  role: {
    type: String,
    values: eO,
    default: "tooltip"
  }
}), tO = be({
  name: "ElPopper",
  inheritAttrs: !1
}), nO = /* @__PURE__ */ be({
  ...tO,
  props: Ug,
  setup(t, { expose: e }) {
    const n = t, r = $(), i = $(), s = $(), o = $(), a = F(() => n.role), l = {
      triggerRef: r,
      popperInstanceRef: i,
      contentRef: s,
      referenceRef: o,
      role: a
    };
    return e(l), qt(Kd, l), (u, c) => Me(u.$slots, "default");
  }
});
var rO = /* @__PURE__ */ Ge(nO, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/popper.vue"]]);
const Vg = ut({
  arrowOffset: {
    type: Number,
    default: 5
  }
}), iO = be({
  name: "ElPopperArrow",
  inheritAttrs: !1
}), sO = /* @__PURE__ */ be({
  ...iO,
  props: Vg,
  setup(t, { expose: e }) {
    const n = t, r = Fe("popper"), { arrowOffset: i, arrowRef: s, arrowStyle: o } = tt(Hg, void 0);
    return ke(() => n.arrowOffset, (a) => {
      i.value = a;
    }), En(() => {
      s.value = void 0;
    }), e({
      arrowRef: s
    }), (a, l) => (V(), se("span", {
      ref_key: "arrowRef",
      ref: s,
      class: ee(x(r).e("arrow")),
      style: it(x(o)),
      "data-popper-arrow": ""
    }, null, 6));
  }
});
var oO = /* @__PURE__ */ Ge(sO, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/arrow.vue"]]);
const bu = "ElOnlyChild", aO = be({
  name: bu,
  setup(t, {
    slots: e,
    attrs: n
  }) {
    var r;
    const i = tt(Dg), s = bT((r = i == null ? void 0 : i.setForwardRef) != null ? r : en);
    return () => {
      var o;
      const a = (o = e.default) == null ? void 0 : o.call(e, n);
      if (!a)
        return null;
      if (a.length > 1)
        return Vt(bu, "requires exact only one valid child."), null;
      const l = Wg(a);
      return l ? Dt(q0(l, n), [[s]]) : (Vt(bu, "no valid child node found"), null);
    };
  }
});
function Wg(t) {
  if (!t)
    return null;
  const e = t;
  for (const n of e) {
    if (wn(n))
      switch (n.type) {
        case vv:
          continue;
        case pv:
        case "svg":
          return jh(n);
        case Ft:
          return Wg(n.children);
        default:
          return n;
      }
    return jh(n);
  }
  return null;
}
function jh(t) {
  const e = Fe("only-child");
  return ve("span", {
    class: e.e("content")
  }, [t]);
}
const Kg = ut({
  virtualRef: {
    type: Be(Object)
  },
  virtualTriggering: Boolean,
  onMouseenter: {
    type: Be(Function)
  },
  onMouseleave: {
    type: Be(Function)
  },
  onClick: {
    type: Be(Function)
  },
  onKeydown: {
    type: Be(Function)
  },
  onFocus: {
    type: Be(Function)
  },
  onBlur: {
    type: Be(Function)
  },
  onContextmenu: {
    type: Be(Function)
  },
  id: String,
  open: Boolean
}), lO = be({
  name: "ElPopperTrigger",
  inheritAttrs: !1
}), uO = /* @__PURE__ */ be({
  ...lO,
  props: Kg,
  setup(t, { expose: e }) {
    const n = t, { role: r, triggerRef: i } = tt(Kd, void 0);
    yT(i);
    const s = F(() => a.value ? n.id : void 0), o = F(() => {
      if (r && r.value === "tooltip")
        return n.open && n.id ? n.id : void 0;
    }), a = F(() => {
      if (r && r.value !== "tooltip")
        return r.value;
    }), l = F(() => a.value ? `${n.open}` : void 0);
    let u;
    return Ct(() => {
      ke(() => n.virtualRef, (c) => {
        c && (i.value = pi(c));
      }, {
        immediate: !0
      }), ke(i, (c, d) => {
        u == null || u(), u = void 0, ji(c) && ([
          "onMouseenter",
          "onMouseleave",
          "onClick",
          "onKeydown",
          "onFocus",
          "onBlur",
          "onContextmenu"
        ].forEach((h) => {
          var v;
          const y = n[h];
          y && (c.addEventListener(h.slice(2).toLowerCase(), y), (v = d == null ? void 0 : d.removeEventListener) == null || v.call(d, h.slice(2).toLowerCase(), y));
        }), u = ke([s, o, a, l], (h) => {
          [
            "aria-controls",
            "aria-describedby",
            "aria-haspopup",
            "aria-expanded"
          ].forEach((v, y) => {
            er(h[y]) ? c.removeAttribute(v) : c.setAttribute(v, h[y]);
          });
        }, { immediate: !0 })), ji(d) && [
          "aria-controls",
          "aria-describedby",
          "aria-haspopup",
          "aria-expanded"
        ].forEach((h) => d.removeAttribute(h));
      }, {
        immediate: !0
      });
    }), En(() => {
      u == null || u(), u = void 0;
    }), e({
      triggerRef: i
    }), (c, d) => c.virtualTriggering ? ye("v-if", !0) : (V(), Ae(x(aO), Gn({ key: 0 }, c.$attrs, {
      "aria-controls": x(s),
      "aria-describedby": x(o),
      "aria-expanded": x(l),
      "aria-haspopup": x(a)
    }), {
      default: de(() => [
        Me(c.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"]));
  }
});
var cO = /* @__PURE__ */ Ge(uO, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/trigger.vue"]]);
const wu = "focus-trap.focus-after-trapped", _u = "focus-trap.focus-after-released", dO = "focus-trap.focusout-prevented", Fh = {
  cancelable: !0,
  bubbles: !1
}, fO = {
  cancelable: !0,
  bubbles: !1
}, Hh = "focusAfterTrapped", Uh = "focusAfterReleased", hO = Symbol("elFocusTrap"), $d = $(), Yl = $(0), Gd = $(0);
let ga = 0;
const $g = (t) => {
  const e = [], n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 || r === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); )
    e.push(n.currentNode);
  return e;
}, Vh = (t, e) => {
  for (const n of t)
    if (!pO(n, e))
      return n;
}, pO = (t, e) => {
  if (process.env.NODE_ENV === "test")
    return !1;
  if (getComputedStyle(t).visibility === "hidden")
    return !0;
  for (; t; ) {
    if (e && t === e)
      return !1;
    if (getComputedStyle(t).display === "none")
      return !0;
    t = t.parentElement;
  }
  return !1;
}, vO = (t) => {
  const e = $g(t), n = Vh(e, t), r = Vh(e.reverse(), t);
  return [n, r];
}, gO = (t) => t instanceof HTMLInputElement && "select" in t, ui = (t, e) => {
  if (t && t.focus) {
    const n = document.activeElement;
    t.focus({ preventScroll: !0 }), Gd.value = window.performance.now(), t !== n && gO(t) && e && t.select();
  }
};
function Wh(t, e) {
  const n = [...t], r = t.indexOf(e);
  return r !== -1 && n.splice(r, 1), n;
}
const mO = () => {
  let t = [];
  return {
    push: (r) => {
      const i = t[0];
      i && r !== i && i.pause(), t = Wh(t, r), t.unshift(r);
    },
    remove: (r) => {
      var i, s;
      t = Wh(t, r), (s = (i = t[0]) == null ? void 0 : i.resume) == null || s.call(i);
    }
  };
}, yO = (t, e = !1) => {
  const n = document.activeElement;
  for (const r of t)
    if (ui(r, e), document.activeElement !== n)
      return;
}, Kh = mO(), bO = () => Yl.value > Gd.value, ma = () => {
  $d.value = "pointer", Yl.value = window.performance.now();
}, $h = () => {
  $d.value = "keyboard", Yl.value = window.performance.now();
}, wO = () => (Ct(() => {
  ga === 0 && (document.addEventListener("mousedown", ma), document.addEventListener("touchstart", ma), document.addEventListener("keydown", $h)), ga++;
}), En(() => {
  ga--, ga <= 0 && (document.removeEventListener("mousedown", ma), document.removeEventListener("touchstart", ma), document.removeEventListener("keydown", $h));
}), {
  focusReason: $d,
  lastUserFocusTimestamp: Yl,
  lastAutomatedFocusTimestamp: Gd
}), ya = (t) => new CustomEvent(dO, {
  ...fO,
  detail: t
}), _O = be({
  name: "ElFocusTrap",
  inheritAttrs: !1,
  props: {
    loop: Boolean,
    trapped: Boolean,
    focusTrapEl: Object,
    focusStartEl: {
      type: [Object, String],
      default: "first"
    }
  },
  emits: [
    Hh,
    Uh,
    "focusin",
    "focusout",
    "focusout-prevented",
    "release-requested"
  ],
  setup(t, { emit: e }) {
    const n = $();
    let r, i;
    const { focusReason: s } = wO();
    pT((y) => {
      t.trapped && !o.paused && e("release-requested", y);
    });
    const o = {
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    }, a = (y) => {
      if (!t.loop && !t.trapped || o.paused)
        return;
      const { key: b, altKey: p, ctrlKey: f, metaKey: g, currentTarget: m, shiftKey: w } = y, { loop: _ } = t, S = b === sn.tab && !p && !f && !g, A = document.activeElement;
      if (S && A) {
        const C = m, [k, O] = vO(C);
        if (k && O) {
          if (!w && A === O) {
            const B = ya({
              focusReason: s.value
            });
            e("focusout-prevented", B), B.defaultPrevented || (y.preventDefault(), _ && ui(k, !0));
          } else if (w && [k, C].includes(A)) {
            const B = ya({
              focusReason: s.value
            });
            e("focusout-prevented", B), B.defaultPrevented || (y.preventDefault(), _ && ui(O, !0));
          }
        } else if (A === C) {
          const B = ya({
            focusReason: s.value
          });
          e("focusout-prevented", B), B.defaultPrevented || y.preventDefault();
        }
      }
    };
    qt(hO, {
      focusTrapRef: n,
      onKeydown: a
    }), ke(() => t.focusTrapEl, (y) => {
      y && (n.value = y);
    }, { immediate: !0 }), ke([n], ([y], [b]) => {
      y && (y.addEventListener("keydown", a), y.addEventListener("focusin", c), y.addEventListener("focusout", d)), b && (b.removeEventListener("keydown", a), b.removeEventListener("focusin", c), b.removeEventListener("focusout", d));
    });
    const l = (y) => {
      e(Hh, y);
    }, u = (y) => e(Uh, y), c = (y) => {
      const b = x(n);
      if (!b)
        return;
      const p = y.target, f = y.relatedTarget, g = p && b.contains(p);
      t.trapped || f && b.contains(f) || (r = f), g && e("focusin", y), !o.paused && t.trapped && (g ? i = p : ui(i, !0));
    }, d = (y) => {
      const b = x(n);
      if (!(o.paused || !b))
        if (t.trapped) {
          const p = y.relatedTarget;
          !er(p) && !b.contains(p) && setTimeout(() => {
            if (!o.paused && t.trapped) {
              const f = ya({
                focusReason: s.value
              });
              e("focusout-prevented", f), f.defaultPrevented || ui(i, !0);
            }
          }, 0);
        } else {
          const p = y.target;
          p && b.contains(p) || e("focusout", y);
        }
    };
    async function h() {
      await rt();
      const y = x(n);
      if (y) {
        Kh.push(o);
        const b = y.contains(document.activeElement) ? r : document.activeElement;
        if (r = b, !y.contains(b)) {
          const f = new Event(wu, Fh);
          y.addEventListener(wu, l), y.dispatchEvent(f), f.defaultPrevented || rt(() => {
            let g = t.focusStartEl;
            Gt(g) || (ui(g), document.activeElement !== g && (g = "first")), g === "first" && yO($g(y), !0), (document.activeElement === b || g === "container") && ui(y);
          });
        }
      }
    }
    function v() {
      const y = x(n);
      if (y) {
        y.removeEventListener(wu, l);
        const b = new CustomEvent(_u, {
          ...Fh,
          detail: {
            focusReason: s.value
          }
        });
        y.addEventListener(_u, u), y.dispatchEvent(b), !b.defaultPrevented && (s.value == "keyboard" || !bO() || y.contains(document.activeElement)) && ui(r ?? document.body), y.removeEventListener(_u, u), Kh.remove(o);
      }
    }
    return Ct(() => {
      t.trapped && h(), ke(() => t.trapped, (y) => {
        y ? h() : v();
      });
    }), En(() => {
      t.trapped && v();
    }), {
      onKeydown: a
    };
  }
});
function SO(t, e, n, r, i, s) {
  return Me(t.$slots, "default", { handleKeydown: t.onKeydown });
}
var EO = /* @__PURE__ */ Ge(_O, [["render", SO], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue"]]);
const xO = ["fixed", "absolute"], AO = ut({
  boundariesPadding: {
    type: Number,
    default: 0
  },
  fallbackPlacements: {
    type: Be(Array),
    default: void 0
  },
  gpuAcceleration: {
    type: Boolean,
    default: !0
  },
  offset: {
    type: Number,
    default: 12
  },
  placement: {
    type: String,
    values: Fs,
    default: "bottom"
  },
  popperOptions: {
    type: Be(Object),
    default: () => ({})
  },
  strategy: {
    type: String,
    values: xO,
    default: "absolute"
  }
}), Gg = ut({
  ...AO,
  id: String,
  style: {
    type: Be([String, Array, Object])
  },
  className: {
    type: Be([String, Array, Object])
  },
  effect: {
    type: String,
    default: "dark"
  },
  visible: Boolean,
  enterable: {
    type: Boolean,
    default: !0
  },
  pure: Boolean,
  focusOnShow: {
    type: Boolean,
    default: !1
  },
  trapping: {
    type: Boolean,
    default: !1
  },
  popperClass: {
    type: Be([String, Array, Object])
  },
  popperStyle: {
    type: Be([String, Array, Object])
  },
  referenceEl: {
    type: Be(Object)
  },
  triggerTargetEl: {
    type: Be(Object)
  },
  stopPopperMouseEvent: {
    type: Boolean,
    default: !0
  },
  ariaLabel: {
    type: String,
    default: void 0
  },
  virtualTriggering: Boolean,
  zIndex: Number
}), kO = {
  mouseenter: (t) => t instanceof MouseEvent,
  mouseleave: (t) => t instanceof MouseEvent,
  focus: () => !0,
  blur: () => !0,
  close: () => !0
}, CO = (t, e = []) => {
  const { placement: n, strategy: r, popperOptions: i } = t, s = {
    placement: n,
    strategy: r,
    ...i,
    modifiers: [...OO(t), ...e]
  };
  return IO(s, i == null ? void 0 : i.modifiers), s;
}, TO = (t) => {
  if (St)
    return pi(t);
};
function OO(t) {
  const { offset: e, gpuAcceleration: n, fallbackPlacements: r } = t;
  return [
    {
      name: "offset",
      options: {
        offset: [0, e ?? 12]
      }
    },
    {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    },
    {
      name: "flip",
      options: {
        padding: 5,
        fallbackPlacements: r
      }
    },
    {
      name: "computeStyles",
      options: {
        gpuAcceleration: n
      }
    }
  ];
}
function IO(t, e) {
  e && (t.modifiers = [...t.modifiers, ...e ?? []]);
}
const NO = 0, RO = (t) => {
  const { popperInstanceRef: e, contentRef: n, triggerRef: r, role: i } = tt(Kd, void 0), s = $(), o = $(), a = F(() => ({
    name: "eventListeners",
    enabled: !!t.visible
  })), l = F(() => {
    var f;
    const g = x(s), m = (f = x(o)) != null ? f : NO;
    return {
      name: "arrow",
      enabled: !_x(g),
      options: {
        element: g,
        padding: m
      }
    };
  }), u = F(() => ({
    onFirstUpdate: () => {
      y();
    },
    ...CO(t, [
      x(l),
      x(a)
    ])
  })), c = F(() => TO(t.referenceEl) || x(r)), { attributes: d, state: h, styles: v, update: y, forceUpdate: b, instanceRef: p } = dT(c, n, u);
  return ke(p, (f) => e.value = f), Ct(() => {
    ke(() => {
      var f;
      return (f = x(c)) == null ? void 0 : f.getBoundingClientRect();
    }, () => {
      y();
    });
  }), {
    attributes: d,
    arrowRef: s,
    contentRef: n,
    instanceRef: p,
    state: h,
    styles: v,
    role: i,
    forceUpdate: b,
    update: y
  };
}, PO = (t, {
  attributes: e,
  styles: n,
  role: r
}) => {
  const { nextZIndex: i } = ql(), s = Fe("popper"), o = F(() => x(e).popper), a = $(mt(t.zIndex) ? t.zIndex : i()), l = F(() => [
    s.b(),
    s.is("pure", t.pure),
    s.is(t.effect),
    t.popperClass
  ]), u = F(() => [
    { zIndex: x(a) },
    x(n).popper,
    t.popperStyle || {}
  ]), c = F(() => r.value === "dialog" ? "false" : void 0), d = F(() => x(n).arrow || {});
  return {
    ariaModal: c,
    arrowStyle: d,
    contentAttrs: o,
    contentClass: l,
    contentStyle: u,
    contentZIndex: a,
    updateZIndex: () => {
      a.value = mt(t.zIndex) ? t.zIndex : i();
    }
  };
}, BO = (t, e) => {
  const n = $(!1), r = $();
  return {
    focusStartRef: r,
    trapped: n,
    onFocusAfterReleased: (u) => {
      var c;
      ((c = u.detail) == null ? void 0 : c.focusReason) !== "pointer" && (r.value = "first", e("blur"));
    },
    onFocusAfterTrapped: () => {
      e("focus");
    },
    onFocusInTrap: (u) => {
      t.visible && !n.value && (u.target && (r.value = u.target), n.value = !0);
    },
    onFocusoutPrevented: (u) => {
      t.trapping || (u.detail.focusReason === "pointer" && u.preventDefault(), n.value = !1);
    },
    onReleaseRequested: () => {
      n.value = !1, e("close");
    }
  };
}, DO = be({
  name: "ElPopperContent"
}), MO = /* @__PURE__ */ be({
  ...DO,
  props: Gg,
  emits: kO,
  setup(t, { expose: e, emit: n }) {
    const r = t, {
      focusStartRef: i,
      trapped: s,
      onFocusAfterReleased: o,
      onFocusAfterTrapped: a,
      onFocusInTrap: l,
      onFocusoutPrevented: u,
      onReleaseRequested: c
    } = BO(r, n), { attributes: d, arrowRef: h, contentRef: v, styles: y, instanceRef: b, role: p, update: f } = RO(r), {
      ariaModal: g,
      arrowStyle: m,
      contentAttrs: w,
      contentClass: _,
      contentStyle: S,
      updateZIndex: A
    } = PO(r, {
      styles: y,
      attributes: d,
      role: p
    }), C = tt(Oo, void 0), k = $();
    qt(Hg, {
      arrowStyle: m,
      arrowRef: h,
      arrowOffset: k
    }), C && (C.addInputId || C.removeInputId) && qt(Oo, {
      ...C,
      addInputId: en,
      removeInputId: en
    });
    let O;
    const N = (M = !0) => {
      f(), M && A();
    }, B = () => {
      N(!1), r.visible && r.focusOnShow ? s.value = !0 : r.visible === !1 && (s.value = !1);
    };
    return Ct(() => {
      ke(() => r.triggerTargetEl, (M, j) => {
        O == null || O(), O = void 0;
        const q = x(M || v.value), X = x(j || v.value);
        ji(q) && (O = ke([p, () => r.ariaLabel, g, () => r.id], (z) => {
          ["role", "aria-label", "aria-modal", "id"].forEach((U, H) => {
            er(z[H]) ? q.removeAttribute(U) : q.setAttribute(U, z[H]);
          });
        }, { immediate: !0 })), X !== q && ji(X) && ["role", "aria-label", "aria-modal", "id"].forEach((z) => {
          X.removeAttribute(z);
        });
      }, { immediate: !0 }), ke(() => r.visible, B, { immediate: !0 });
    }), En(() => {
      O == null || O(), O = void 0;
    }), e({
      popperContentRef: v,
      popperInstanceRef: b,
      updatePopper: N,
      contentStyle: S
    }), (M, j) => (V(), se("div", Gn({
      ref_key: "contentRef",
      ref: v
    }, x(w), {
      style: x(S),
      class: x(_),
      tabindex: "-1",
      onMouseenter: j[0] || (j[0] = (q) => M.$emit("mouseenter", q)),
      onMouseleave: j[1] || (j[1] = (q) => M.$emit("mouseleave", q))
    }), [
      ve(x(EO), {
        trapped: x(s),
        "trap-on-focus-in": !0,
        "focus-trap-el": x(v),
        "focus-start-el": x(i),
        onFocusAfterTrapped: x(a),
        onFocusAfterReleased: x(o),
        onFocusin: x(l),
        onFocusoutPrevented: x(u),
        onReleaseRequested: x(c)
      }, {
        default: de(() => [
          Me(M.$slots, "default")
        ]),
        _: 3
      }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
    ], 16));
  }
});
var LO = /* @__PURE__ */ Ge(MO, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/content.vue"]]);
const zO = nn(rO), qd = Symbol("elTooltip"), $n = ut({
  ...mT,
  ...Gg,
  appendTo: {
    type: Be([String, Object])
  },
  content: {
    type: String,
    default: ""
  },
  rawContent: {
    type: Boolean,
    default: !1
  },
  persistent: Boolean,
  ariaLabel: String,
  visible: {
    type: Be(Boolean),
    default: null
  },
  transition: String,
  teleported: {
    type: Boolean,
    default: !0
  },
  disabled: Boolean
}), Io = ut({
  ...Kg,
  disabled: Boolean,
  trigger: {
    type: Be([String, Array]),
    default: "hover"
  },
  triggerKeys: {
    type: Be(Array),
    default: () => [sn.enter, sn.space]
  }
}), {
  useModelToggleProps: jO,
  useModelToggleEmits: FO,
  useModelToggle: HO
} = yg("visible"), UO = ut({
  ...Ug,
  ...jO,
  ...$n,
  ...Io,
  ...Vg,
  showArrow: {
    type: Boolean,
    default: !0
  }
}), VO = [
  ...FO,
  "before-show",
  "before-hide",
  "show",
  "hide",
  "open",
  "close"
], WO = (t, e) => Or(t) ? t.includes(e) : t === e, rs = (t, e, n) => (r) => {
  WO(x(t), e) && n(r);
}, KO = be({
  name: "ElTooltipTrigger"
}), $O = /* @__PURE__ */ be({
  ...KO,
  props: Io,
  setup(t, { expose: e }) {
    const n = t, r = Fe("tooltip"), { controlled: i, id: s, open: o, onOpen: a, onClose: l, onToggle: u } = tt(qd, void 0), c = $(null), d = () => {
      if (x(i) || n.disabled)
        return !0;
    }, h = Cn(n, "trigger"), v = Hr(d, rs(h, "hover", a)), y = Hr(d, rs(h, "hover", l)), b = Hr(d, rs(h, "click", (w) => {
      w.button === 0 && u(w);
    })), p = Hr(d, rs(h, "focus", a)), f = Hr(d, rs(h, "focus", l)), g = Hr(d, rs(h, "contextmenu", (w) => {
      w.preventDefault(), u(w);
    })), m = Hr(d, (w) => {
      const { code: _ } = w;
      n.triggerKeys.includes(_) && (w.preventDefault(), u(w));
    });
    return e({
      triggerRef: c
    }), (w, _) => (V(), Ae(x(cO), {
      id: x(s),
      "virtual-ref": w.virtualRef,
      open: x(o),
      "virtual-triggering": w.virtualTriggering,
      class: ee(x(r).e("trigger")),
      onBlur: x(f),
      onClick: x(b),
      onContextmenu: x(g),
      onFocus: x(p),
      onMouseenter: x(v),
      onMouseleave: x(y),
      onKeydown: x(m)
    }, {
      default: de(() => [
        Me(w.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]));
  }
});
var GO = /* @__PURE__ */ Ge($O, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/trigger.vue"]]);
const qO = be({
  name: "ElTooltipContent",
  inheritAttrs: !1
}), JO = /* @__PURE__ */ be({
  ...qO,
  props: $n,
  setup(t, { expose: e }) {
    const n = t, { selector: r } = Pg(), i = Fe("tooltip"), s = $(null), o = $(!1), {
      controlled: a,
      id: l,
      open: u,
      trigger: c,
      onClose: d,
      onOpen: h,
      onShow: v,
      onHide: y,
      onBeforeShow: b,
      onBeforeHide: p
    } = tt(qd, void 0), f = F(() => n.transition || `${i.namespace.value}-fade-in-linear`), g = F(() => process.env.NODE_ENV === "test" ? !0 : n.persistent);
    En(() => {
      o.value = !0;
    });
    const m = F(() => x(g) ? !0 : x(u)), w = F(() => n.disabled ? !1 : x(u)), _ = F(() => n.appendTo || r.value), S = F(() => {
      var z;
      return (z = n.style) != null ? z : {};
    }), A = F(() => !x(u)), C = () => {
      y();
    }, k = () => {
      if (x(a))
        return !0;
    }, O = Hr(k, () => {
      n.enterable && x(c) === "hover" && h();
    }), N = Hr(k, () => {
      x(c) === "hover" && d();
    }), B = () => {
      var z, U;
      (U = (z = s.value) == null ? void 0 : z.updatePopper) == null || U.call(z), b == null || b();
    }, M = () => {
      p == null || p();
    }, j = () => {
      v(), X = cb(F(() => {
        var z;
        return (z = s.value) == null ? void 0 : z.popperContentRef;
      }), () => {
        if (x(a))
          return;
        x(c) !== "hover" && d();
      });
    }, q = () => {
      n.virtualTriggering || d();
    };
    let X;
    return ke(() => x(u), (z) => {
      z || X == null || X();
    }, {
      flush: "post"
    }), ke(() => n.content, () => {
      var z, U;
      (U = (z = s.value) == null ? void 0 : z.updatePopper) == null || U.call(z);
    }), e({
      contentRef: s
    }), (z, U) => (V(), Ae(gv, {
      disabled: !z.teleported,
      to: x(_)
    }, [
      ve(mr, {
        name: x(f),
        onAfterLeave: C,
        onBeforeEnter: B,
        onAfterEnter: j,
        onBeforeLeave: M
      }, {
        default: de(() => [
          x(m) ? Dt((V(), Ae(x(LO), Gn({
            key: 0,
            id: x(l),
            ref_key: "contentRef",
            ref: s
          }, z.$attrs, {
            "aria-label": z.ariaLabel,
            "aria-hidden": x(A),
            "boundaries-padding": z.boundariesPadding,
            "fallback-placements": z.fallbackPlacements,
            "gpu-acceleration": z.gpuAcceleration,
            offset: z.offset,
            placement: z.placement,
            "popper-options": z.popperOptions,
            strategy: z.strategy,
            effect: z.effect,
            enterable: z.enterable,
            pure: z.pure,
            "popper-class": z.popperClass,
            "popper-style": [z.popperStyle, x(S)],
            "reference-el": z.referenceEl,
            "trigger-target-el": z.triggerTargetEl,
            visible: x(w),
            "z-index": z.zIndex,
            onMouseenter: x(O),
            onMouseleave: x(N),
            onBlur: q,
            onClose: x(d)
          }), {
            default: de(() => [
              o.value ? ye("v-if", !0) : Me(z.$slots, "default", { key: 0 })
            ]),
            _: 3
          }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
            [Jn, x(w)]
          ]) : ye("v-if", !0)
        ]),
        _: 3
      }, 8, ["name"])
    ], 8, ["disabled", "to"]));
  }
});
var YO = /* @__PURE__ */ Ge(JO, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/content.vue"]]);
const QO = ["innerHTML"], ZO = { key: 1 }, XO = be({
  name: "ElTooltip"
}), eI = /* @__PURE__ */ be({
  ...XO,
  props: UO,
  emits: VO,
  setup(t, { expose: e, emit: n }) {
    const r = t;
    gT();
    const i = Xo(), s = $(), o = $(), a = () => {
      var f;
      const g = x(s);
      g && ((f = g.popperInstanceRef) == null || f.update());
    }, l = $(!1), u = $(), { show: c, hide: d, hasUpdateHandler: h } = HO({
      indicator: l,
      toggleReason: u
    }), { onOpen: v, onClose: y } = Bg({
      showAfter: Cn(r, "showAfter"),
      hideAfter: Cn(r, "hideAfter"),
      autoClose: Cn(r, "autoClose"),
      open: c,
      close: d
    }), b = F(() => Qr(r.visible) && !h.value);
    qt(qd, {
      controlled: b,
      id: i,
      open: J0(l),
      trigger: Cn(r, "trigger"),
      onOpen: (f) => {
        v(f);
      },
      onClose: (f) => {
        y(f);
      },
      onToggle: (f) => {
        x(l) ? y(f) : v(f);
      },
      onShow: () => {
        n("show", u.value);
      },
      onHide: () => {
        n("hide", u.value);
      },
      onBeforeShow: () => {
        n("before-show", u.value);
      },
      onBeforeHide: () => {
        n("before-hide", u.value);
      },
      updatePopper: a
    }), ke(() => r.disabled, (f) => {
      f && l.value && (l.value = !1);
    });
    const p = (f) => {
      var g, m;
      const w = (m = (g = o.value) == null ? void 0 : g.contentRef) == null ? void 0 : m.popperContentRef, _ = (f == null ? void 0 : f.relatedTarget) || document.activeElement;
      return w && w.contains(_);
    };
    return Y0(() => l.value && d()), e({
      popperRef: s,
      contentRef: o,
      isFocusInsideContent: p,
      updatePopper: a,
      onOpen: v,
      onClose: y,
      hide: d
    }), (f, g) => (V(), Ae(x(zO), {
      ref_key: "popperRef",
      ref: s,
      role: f.role
    }, {
      default: de(() => [
        ve(GO, {
          disabled: f.disabled,
          trigger: f.trigger,
          "trigger-keys": f.triggerKeys,
          "virtual-ref": f.virtualRef,
          "virtual-triggering": f.virtualTriggering
        }, {
          default: de(() => [
            f.$slots.default ? Me(f.$slots, "default", { key: 0 }) : ye("v-if", !0)
          ]),
          _: 3
        }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
        ve(YO, {
          ref_key: "contentRef",
          ref: o,
          "aria-label": f.ariaLabel,
          "boundaries-padding": f.boundariesPadding,
          content: f.content,
          disabled: f.disabled,
          effect: f.effect,
          enterable: f.enterable,
          "fallback-placements": f.fallbackPlacements,
          "hide-after": f.hideAfter,
          "gpu-acceleration": f.gpuAcceleration,
          offset: f.offset,
          persistent: f.persistent,
          "popper-class": f.popperClass,
          "popper-style": f.popperStyle,
          placement: f.placement,
          "popper-options": f.popperOptions,
          pure: f.pure,
          "raw-content": f.rawContent,
          "reference-el": f.referenceEl,
          "trigger-target-el": f.triggerTargetEl,
          "show-after": f.showAfter,
          strategy: f.strategy,
          teleported: f.teleported,
          transition: f.transition,
          "virtual-triggering": f.virtualTriggering,
          "z-index": f.zIndex,
          "append-to": f.appendTo
        }, {
          default: de(() => [
            Me(f.$slots, "content", {}, () => [
              f.rawContent ? (V(), se("span", {
                key: 0,
                innerHTML: f.content
              }, null, 8, QO)) : (V(), se("span", ZO, st(f.content), 1))
            ]),
            f.showArrow ? (V(), Ae(x(oO), {
              key: 0,
              "arrow-offset": f.arrowOffset
            }, null, 8, ["arrow-offset"])) : ye("v-if", !0)
          ]),
          _: 3
        }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
      ]),
      _: 3
    }, 8, ["role"]));
  }
});
var tI = /* @__PURE__ */ Ge(eI, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/tooltip.vue"]]);
const Ql = nn(tI), qg = Symbol("buttonGroupContextKey"), nI = (t, e) => {
  vg({
    from: "type.text",
    replacement: "link",
    version: "3.0.0",
    scope: "props",
    ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
  }, F(() => t.type === "text"));
  const n = tt(qg, void 0), r = Ud("button"), { form: i } = oi(), s = Pr(F(() => n == null ? void 0 : n.size)), o = Br(), a = $(), l = Ko(), u = F(() => t.type || (n == null ? void 0 : n.type) || ""), c = F(() => {
    var y, b, p;
    return (p = (b = t.autoInsertSpace) != null ? b : (y = r.value) == null ? void 0 : y.autoInsertSpace) != null ? p : !1;
  }), d = F(() => t.tag === "button" ? {
    ariaDisabled: o.value || t.loading,
    disabled: o.value || t.loading,
    autofocus: t.autofocus,
    type: t.nativeType
  } : {}), h = F(() => {
    var y;
    const b = (y = l.default) == null ? void 0 : y.call(l);
    if (c.value && (b == null ? void 0 : b.length) === 1) {
      const p = b[0];
      if ((p == null ? void 0 : p.type) === pv) {
        const f = p.children;
        return /^\p{Unified_Ideograph}{2}$/u.test(f.trim());
      }
    }
    return !1;
  });
  return {
    _disabled: o,
    _size: s,
    _type: u,
    _ref: a,
    _props: d,
    shouldAddSpace: h,
    handleClick: (y) => {
      t.nativeType === "reset" && (i == null || i.resetFields()), e("click", y);
    }
  };
}, rI = [
  "default",
  "primary",
  "success",
  "warning",
  "info",
  "danger",
  "text",
  ""
], iI = ["button", "submit", "reset"], ac = ut({
  size: Rr,
  disabled: Boolean,
  type: {
    type: String,
    values: rI,
    default: ""
  },
  icon: {
    type: bi
  },
  nativeType: {
    type: String,
    values: iI,
    default: "button"
  },
  loading: Boolean,
  loadingIcon: {
    type: bi,
    default: () => Kl
  },
  plain: Boolean,
  text: Boolean,
  link: Boolean,
  bg: Boolean,
  autofocus: Boolean,
  round: Boolean,
  circle: Boolean,
  color: String,
  dark: Boolean,
  autoInsertSpace: {
    type: Boolean,
    default: void 0
  },
  tag: {
    type: Be([String, Object]),
    default: "button"
  }
}), sI = {
  click: (t) => t instanceof MouseEvent
};
function _n(t, e) {
  oI(t) && (t = "100%");
  var n = aI(t);
  return t = e === 360 ? t : Math.min(e, Math.max(0, parseFloat(t))), n && (t = parseInt(String(t * e), 10) / 100), Math.abs(t - e) < 1e-6 ? 1 : (e === 360 ? t = (t < 0 ? t % e + e : t % e) / parseFloat(String(e)) : t = t % e / parseFloat(String(e)), t);
}
function ba(t) {
  return Math.min(1, Math.max(0, t));
}
function oI(t) {
  return typeof t == "string" && t.indexOf(".") !== -1 && parseFloat(t) === 1;
}
function aI(t) {
  return typeof t == "string" && t.indexOf("%") !== -1;
}
function Jg(t) {
  return t = parseFloat(t), (isNaN(t) || t < 0 || t > 1) && (t = 1), t;
}
function wa(t) {
  return t <= 1 ? "".concat(Number(t) * 100, "%") : t;
}
function Ii(t) {
  return t.length === 1 ? "0" + t : String(t);
}
function lI(t, e, n) {
  return {
    r: _n(t, 255) * 255,
    g: _n(e, 255) * 255,
    b: _n(n, 255) * 255
  };
}
function Gh(t, e, n) {
  t = _n(t, 255), e = _n(e, 255), n = _n(n, 255);
  var r = Math.max(t, e, n), i = Math.min(t, e, n), s = 0, o = 0, a = (r + i) / 2;
  if (r === i)
    o = 0, s = 0;
  else {
    var l = r - i;
    switch (o = a > 0.5 ? l / (2 - r - i) : l / (r + i), r) {
      case t:
        s = (e - n) / l + (e < n ? 6 : 0);
        break;
      case e:
        s = (n - t) / l + 2;
        break;
      case n:
        s = (t - e) / l + 4;
        break;
    }
    s /= 6;
  }
  return { h: s, s: o, l: a };
}
function Su(t, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * (6 * n) : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t;
}
function uI(t, e, n) {
  var r, i, s;
  if (t = _n(t, 360), e = _n(e, 100), n = _n(n, 100), e === 0)
    i = n, s = n, r = n;
  else {
    var o = n < 0.5 ? n * (1 + e) : n + e - n * e, a = 2 * n - o;
    r = Su(a, o, t + 1 / 3), i = Su(a, o, t), s = Su(a, o, t - 1 / 3);
  }
  return { r: r * 255, g: i * 255, b: s * 255 };
}
function qh(t, e, n) {
  t = _n(t, 255), e = _n(e, 255), n = _n(n, 255);
  var r = Math.max(t, e, n), i = Math.min(t, e, n), s = 0, o = r, a = r - i, l = r === 0 ? 0 : a / r;
  if (r === i)
    s = 0;
  else {
    switch (r) {
      case t:
        s = (e - n) / a + (e < n ? 6 : 0);
        break;
      case e:
        s = (n - t) / a + 2;
        break;
      case n:
        s = (t - e) / a + 4;
        break;
    }
    s /= 6;
  }
  return { h: s, s: l, v: o };
}
function cI(t, e, n) {
  t = _n(t, 360) * 6, e = _n(e, 100), n = _n(n, 100);
  var r = Math.floor(t), i = t - r, s = n * (1 - e), o = n * (1 - i * e), a = n * (1 - (1 - i) * e), l = r % 6, u = [n, o, s, s, a, n][l], c = [a, n, n, o, s, s][l], d = [s, s, a, n, n, o][l];
  return { r: u * 255, g: c * 255, b: d * 255 };
}
function Jh(t, e, n, r) {
  var i = [
    Ii(Math.round(t).toString(16)),
    Ii(Math.round(e).toString(16)),
    Ii(Math.round(n).toString(16))
  ];
  return r && i[0].startsWith(i[0].charAt(1)) && i[1].startsWith(i[1].charAt(1)) && i[2].startsWith(i[2].charAt(1)) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("");
}
function dI(t, e, n, r, i) {
  var s = [
    Ii(Math.round(t).toString(16)),
    Ii(Math.round(e).toString(16)),
    Ii(Math.round(n).toString(16)),
    Ii(fI(r))
  ];
  return i && s[0].startsWith(s[0].charAt(1)) && s[1].startsWith(s[1].charAt(1)) && s[2].startsWith(s[2].charAt(1)) && s[3].startsWith(s[3].charAt(1)) ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0) + s[3].charAt(0) : s.join("");
}
function fI(t) {
  return Math.round(parseFloat(t) * 255).toString(16);
}
function Yh(t) {
  return Wn(t) / 255;
}
function Wn(t) {
  return parseInt(t, 16);
}
function hI(t) {
  return {
    r: t >> 16,
    g: (t & 65280) >> 8,
    b: t & 255
  };
}
var lc = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function pI(t) {
  var e = { r: 0, g: 0, b: 0 }, n = 1, r = null, i = null, s = null, o = !1, a = !1;
  return typeof t == "string" && (t = mI(t)), typeof t == "object" && (zr(t.r) && zr(t.g) && zr(t.b) ? (e = lI(t.r, t.g, t.b), o = !0, a = String(t.r).substr(-1) === "%" ? "prgb" : "rgb") : zr(t.h) && zr(t.s) && zr(t.v) ? (r = wa(t.s), i = wa(t.v), e = cI(t.h, r, i), o = !0, a = "hsv") : zr(t.h) && zr(t.s) && zr(t.l) && (r = wa(t.s), s = wa(t.l), e = uI(t.h, r, s), o = !0, a = "hsl"), Object.prototype.hasOwnProperty.call(t, "a") && (n = t.a)), n = Jg(n), {
    ok: o,
    format: t.format || a,
    r: Math.min(255, Math.max(e.r, 0)),
    g: Math.min(255, Math.max(e.g, 0)),
    b: Math.min(255, Math.max(e.b, 0)),
    a: n
  };
}
var vI = "[-\\+]?\\d+%?", gI = "[-\\+]?\\d*\\.\\d+%?", vi = "(?:".concat(gI, ")|(?:").concat(vI, ")"), Eu = "[\\s|\\(]+(".concat(vi, ")[,|\\s]+(").concat(vi, ")[,|\\s]+(").concat(vi, ")\\s*\\)?"), xu = "[\\s|\\(]+(".concat(vi, ")[,|\\s]+(").concat(vi, ")[,|\\s]+(").concat(vi, ")[,|\\s]+(").concat(vi, ")\\s*\\)?"), cr = {
  CSS_UNIT: new RegExp(vi),
  rgb: new RegExp("rgb" + Eu),
  rgba: new RegExp("rgba" + xu),
  hsl: new RegExp("hsl" + Eu),
  hsla: new RegExp("hsla" + xu),
  hsv: new RegExp("hsv" + Eu),
  hsva: new RegExp("hsva" + xu),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function mI(t) {
  if (t = t.trim().toLowerCase(), t.length === 0)
    return !1;
  var e = !1;
  if (lc[t])
    t = lc[t], e = !0;
  else if (t === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  var n = cr.rgb.exec(t);
  return n ? { r: n[1], g: n[2], b: n[3] } : (n = cr.rgba.exec(t), n ? { r: n[1], g: n[2], b: n[3], a: n[4] } : (n = cr.hsl.exec(t), n ? { h: n[1], s: n[2], l: n[3] } : (n = cr.hsla.exec(t), n ? { h: n[1], s: n[2], l: n[3], a: n[4] } : (n = cr.hsv.exec(t), n ? { h: n[1], s: n[2], v: n[3] } : (n = cr.hsva.exec(t), n ? { h: n[1], s: n[2], v: n[3], a: n[4] } : (n = cr.hex8.exec(t), n ? {
    r: Wn(n[1]),
    g: Wn(n[2]),
    b: Wn(n[3]),
    a: Yh(n[4]),
    format: e ? "name" : "hex8"
  } : (n = cr.hex6.exec(t), n ? {
    r: Wn(n[1]),
    g: Wn(n[2]),
    b: Wn(n[3]),
    format: e ? "name" : "hex"
  } : (n = cr.hex4.exec(t), n ? {
    r: Wn(n[1] + n[1]),
    g: Wn(n[2] + n[2]),
    b: Wn(n[3] + n[3]),
    a: Yh(n[4] + n[4]),
    format: e ? "name" : "hex8"
  } : (n = cr.hex3.exec(t), n ? {
    r: Wn(n[1] + n[1]),
    g: Wn(n[2] + n[2]),
    b: Wn(n[3] + n[3]),
    format: e ? "name" : "hex"
  } : !1)))))))));
}
function zr(t) {
  return !!cr.CSS_UNIT.exec(String(t));
}
var yI = (
  /** @class */
  function() {
    function t(e, n) {
      e === void 0 && (e = ""), n === void 0 && (n = {});
      var r;
      if (e instanceof t)
        return e;
      typeof e == "number" && (e = hI(e)), this.originalInput = e;
      var i = pI(e);
      this.originalInput = e, this.r = i.r, this.g = i.g, this.b = i.b, this.a = i.a, this.roundA = Math.round(100 * this.a) / 100, this.format = (r = n.format) !== null && r !== void 0 ? r : i.format, this.gradientType = n.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = i.ok;
    }
    return t.prototype.isDark = function() {
      return this.getBrightness() < 128;
    }, t.prototype.isLight = function() {
      return !this.isDark();
    }, t.prototype.getBrightness = function() {
      var e = this.toRgb();
      return (e.r * 299 + e.g * 587 + e.b * 114) / 1e3;
    }, t.prototype.getLuminance = function() {
      var e = this.toRgb(), n, r, i, s = e.r / 255, o = e.g / 255, a = e.b / 255;
      return s <= 0.03928 ? n = s / 12.92 : n = Math.pow((s + 0.055) / 1.055, 2.4), o <= 0.03928 ? r = o / 12.92 : r = Math.pow((o + 0.055) / 1.055, 2.4), a <= 0.03928 ? i = a / 12.92 : i = Math.pow((a + 0.055) / 1.055, 2.4), 0.2126 * n + 0.7152 * r + 0.0722 * i;
    }, t.prototype.getAlpha = function() {
      return this.a;
    }, t.prototype.setAlpha = function(e) {
      return this.a = Jg(e), this.roundA = Math.round(100 * this.a) / 100, this;
    }, t.prototype.isMonochrome = function() {
      var e = this.toHsl().s;
      return e === 0;
    }, t.prototype.toHsv = function() {
      var e = qh(this.r, this.g, this.b);
      return { h: e.h * 360, s: e.s, v: e.v, a: this.a };
    }, t.prototype.toHsvString = function() {
      var e = qh(this.r, this.g, this.b), n = Math.round(e.h * 360), r = Math.round(e.s * 100), i = Math.round(e.v * 100);
      return this.a === 1 ? "hsv(".concat(n, ", ").concat(r, "%, ").concat(i, "%)") : "hsva(".concat(n, ", ").concat(r, "%, ").concat(i, "%, ").concat(this.roundA, ")");
    }, t.prototype.toHsl = function() {
      var e = Gh(this.r, this.g, this.b);
      return { h: e.h * 360, s: e.s, l: e.l, a: this.a };
    }, t.prototype.toHslString = function() {
      var e = Gh(this.r, this.g, this.b), n = Math.round(e.h * 360), r = Math.round(e.s * 100), i = Math.round(e.l * 100);
      return this.a === 1 ? "hsl(".concat(n, ", ").concat(r, "%, ").concat(i, "%)") : "hsla(".concat(n, ", ").concat(r, "%, ").concat(i, "%, ").concat(this.roundA, ")");
    }, t.prototype.toHex = function(e) {
      return e === void 0 && (e = !1), Jh(this.r, this.g, this.b, e);
    }, t.prototype.toHexString = function(e) {
      return e === void 0 && (e = !1), "#" + this.toHex(e);
    }, t.prototype.toHex8 = function(e) {
      return e === void 0 && (e = !1), dI(this.r, this.g, this.b, this.a, e);
    }, t.prototype.toHex8String = function(e) {
      return e === void 0 && (e = !1), "#" + this.toHex8(e);
    }, t.prototype.toHexShortString = function(e) {
      return e === void 0 && (e = !1), this.a === 1 ? this.toHexString(e) : this.toHex8String(e);
    }, t.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    }, t.prototype.toRgbString = function() {
      var e = Math.round(this.r), n = Math.round(this.g), r = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(e, ", ").concat(n, ", ").concat(r, ")") : "rgba(".concat(e, ", ").concat(n, ", ").concat(r, ", ").concat(this.roundA, ")");
    }, t.prototype.toPercentageRgb = function() {
      var e = function(n) {
        return "".concat(Math.round(_n(n, 255) * 100), "%");
      };
      return {
        r: e(this.r),
        g: e(this.g),
        b: e(this.b),
        a: this.a
      };
    }, t.prototype.toPercentageRgbString = function() {
      var e = function(n) {
        return Math.round(_n(n, 255) * 100);
      };
      return this.a === 1 ? "rgb(".concat(e(this.r), "%, ").concat(e(this.g), "%, ").concat(e(this.b), "%)") : "rgba(".concat(e(this.r), "%, ").concat(e(this.g), "%, ").concat(e(this.b), "%, ").concat(this.roundA, ")");
    }, t.prototype.toName = function() {
      if (this.a === 0)
        return "transparent";
      if (this.a < 1)
        return !1;
      for (var e = "#" + Jh(this.r, this.g, this.b, !1), n = 0, r = Object.entries(lc); n < r.length; n++) {
        var i = r[n], s = i[0], o = i[1];
        if (e === o)
          return s;
      }
      return !1;
    }, t.prototype.toString = function(e) {
      var n = !!e;
      e = e ?? this.format;
      var r = !1, i = this.a < 1 && this.a >= 0, s = !n && i && (e.startsWith("hex") || e === "name");
      return s ? e === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (e === "rgb" && (r = this.toRgbString()), e === "prgb" && (r = this.toPercentageRgbString()), (e === "hex" || e === "hex6") && (r = this.toHexString()), e === "hex3" && (r = this.toHexString(!0)), e === "hex4" && (r = this.toHex8String(!0)), e === "hex8" && (r = this.toHex8String()), e === "name" && (r = this.toName()), e === "hsl" && (r = this.toHslString()), e === "hsv" && (r = this.toHsvString()), r || this.toHexString());
    }, t.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    }, t.prototype.clone = function() {
      return new t(this.toString());
    }, t.prototype.lighten = function(e) {
      e === void 0 && (e = 10);
      var n = this.toHsl();
      return n.l += e / 100, n.l = ba(n.l), new t(n);
    }, t.prototype.brighten = function(e) {
      e === void 0 && (e = 10);
      var n = this.toRgb();
      return n.r = Math.max(0, Math.min(255, n.r - Math.round(255 * -(e / 100)))), n.g = Math.max(0, Math.min(255, n.g - Math.round(255 * -(e / 100)))), n.b = Math.max(0, Math.min(255, n.b - Math.round(255 * -(e / 100)))), new t(n);
    }, t.prototype.darken = function(e) {
      e === void 0 && (e = 10);
      var n = this.toHsl();
      return n.l -= e / 100, n.l = ba(n.l), new t(n);
    }, t.prototype.tint = function(e) {
      return e === void 0 && (e = 10), this.mix("white", e);
    }, t.prototype.shade = function(e) {
      return e === void 0 && (e = 10), this.mix("black", e);
    }, t.prototype.desaturate = function(e) {
      e === void 0 && (e = 10);
      var n = this.toHsl();
      return n.s -= e / 100, n.s = ba(n.s), new t(n);
    }, t.prototype.saturate = function(e) {
      e === void 0 && (e = 10);
      var n = this.toHsl();
      return n.s += e / 100, n.s = ba(n.s), new t(n);
    }, t.prototype.greyscale = function() {
      return this.desaturate(100);
    }, t.prototype.spin = function(e) {
      var n = this.toHsl(), r = (n.h + e) % 360;
      return n.h = r < 0 ? 360 + r : r, new t(n);
    }, t.prototype.mix = function(e, n) {
      n === void 0 && (n = 50);
      var r = this.toRgb(), i = new t(e).toRgb(), s = n / 100, o = {
        r: (i.r - r.r) * s + r.r,
        g: (i.g - r.g) * s + r.g,
        b: (i.b - r.b) * s + r.b,
        a: (i.a - r.a) * s + r.a
      };
      return new t(o);
    }, t.prototype.analogous = function(e, n) {
      e === void 0 && (e = 6), n === void 0 && (n = 30);
      var r = this.toHsl(), i = 360 / n, s = [this];
      for (r.h = (r.h - (i * e >> 1) + 720) % 360; --e; )
        r.h = (r.h + i) % 360, s.push(new t(r));
      return s;
    }, t.prototype.complement = function() {
      var e = this.toHsl();
      return e.h = (e.h + 180) % 360, new t(e);
    }, t.prototype.monochromatic = function(e) {
      e === void 0 && (e = 6);
      for (var n = this.toHsv(), r = n.h, i = n.s, s = n.v, o = [], a = 1 / e; e--; )
        o.push(new t({ h: r, s: i, v: s })), s = (s + a) % 1;
      return o;
    }, t.prototype.splitcomplement = function() {
      var e = this.toHsl(), n = e.h;
      return [
        this,
        new t({ h: (n + 72) % 360, s: e.s, l: e.l }),
        new t({ h: (n + 216) % 360, s: e.s, l: e.l })
      ];
    }, t.prototype.onBackground = function(e) {
      var n = this.toRgb(), r = new t(e).toRgb(), i = n.a + r.a * (1 - n.a);
      return new t({
        r: (n.r * n.a + r.r * r.a * (1 - n.a)) / i,
        g: (n.g * n.a + r.g * r.a * (1 - n.a)) / i,
        b: (n.b * n.a + r.b * r.a * (1 - n.a)) / i,
        a: i
      });
    }, t.prototype.triad = function() {
      return this.polyad(3);
    }, t.prototype.tetrad = function() {
      return this.polyad(4);
    }, t.prototype.polyad = function(e) {
      for (var n = this.toHsl(), r = n.h, i = [this], s = 360 / e, o = 1; o < e; o++)
        i.push(new t({ h: (r + o * s) % 360, s: n.s, l: n.l }));
      return i;
    }, t.prototype.equals = function(e) {
      return this.toRgbString() === new t(e).toRgbString();
    }, t;
  }()
);
function ai(t, e = 20) {
  return t.mix("#141414", e).toString();
}
function bI(t) {
  const e = Br(), n = Fe("button");
  return F(() => {
    let r = {};
    const i = t.color;
    if (i) {
      const s = new yI(i), o = t.dark ? s.tint(20).toString() : ai(s, 20);
      if (t.plain)
        r = n.cssVarBlock({
          "bg-color": t.dark ? ai(s, 90) : s.tint(90).toString(),
          "text-color": i,
          "border-color": t.dark ? ai(s, 50) : s.tint(50).toString(),
          "hover-text-color": `var(${n.cssVarName("color-white")})`,
          "hover-bg-color": i,
          "hover-border-color": i,
          "active-bg-color": o,
          "active-text-color": `var(${n.cssVarName("color-white")})`,
          "active-border-color": o
        }), e.value && (r[n.cssVarBlockName("disabled-bg-color")] = t.dark ? ai(s, 90) : s.tint(90).toString(), r[n.cssVarBlockName("disabled-text-color")] = t.dark ? ai(s, 50) : s.tint(50).toString(), r[n.cssVarBlockName("disabled-border-color")] = t.dark ? ai(s, 80) : s.tint(80).toString());
      else {
        const a = t.dark ? ai(s, 30) : s.tint(30).toString(), l = s.isDark() ? `var(${n.cssVarName("color-white")})` : `var(${n.cssVarName("color-black")})`;
        if (r = n.cssVarBlock({
          "bg-color": i,
          "text-color": l,
          "border-color": i,
          "hover-bg-color": a,
          "hover-text-color": l,
          "hover-border-color": a,
          "active-bg-color": o,
          "active-border-color": o
        }), e.value) {
          const u = t.dark ? ai(s, 50) : s.tint(50).toString();
          r[n.cssVarBlockName("disabled-bg-color")] = u, r[n.cssVarBlockName("disabled-text-color")] = t.dark ? "rgba(255, 255, 255, 0.5)" : `var(${n.cssVarName("color-white")})`, r[n.cssVarBlockName("disabled-border-color")] = u;
        }
      }
    }
    return r;
  });
}
const wI = be({
  name: "ElButton"
}), _I = /* @__PURE__ */ be({
  ...wI,
  props: ac,
  emits: sI,
  setup(t, { expose: e, emit: n }) {
    const r = t, i = bI(r), s = Fe("button"), { _ref: o, _size: a, _type: l, _disabled: u, _props: c, shouldAddSpace: d, handleClick: h } = nI(r, n);
    return e({
      ref: o,
      size: a,
      type: l,
      disabled: u,
      shouldAddSpace: d
    }), (v, y) => (V(), Ae(Nn(v.tag), Gn({
      ref_key: "_ref",
      ref: o
    }, x(c), {
      class: [
        x(s).b(),
        x(s).m(x(l)),
        x(s).m(x(a)),
        x(s).is("disabled", x(u)),
        x(s).is("loading", v.loading),
        x(s).is("plain", v.plain),
        x(s).is("round", v.round),
        x(s).is("circle", v.circle),
        x(s).is("text", v.text),
        x(s).is("link", v.link),
        x(s).is("has-bg", v.bg)
      ],
      style: x(i),
      onClick: x(h)
    }), {
      default: de(() => [
        v.loading ? (V(), se(Ft, { key: 0 }, [
          v.$slots.loading ? Me(v.$slots, "loading", { key: 0 }) : (V(), Ae(x(_t), {
            key: 1,
            class: ee(x(s).is("loading"))
          }, {
            default: de(() => [
              (V(), Ae(Nn(v.loadingIcon)))
            ]),
            _: 1
          }, 8, ["class"]))
        ], 64)) : v.icon || v.$slots.icon ? (V(), Ae(x(_t), { key: 1 }, {
          default: de(() => [
            v.icon ? (V(), Ae(Nn(v.icon), { key: 0 })) : Me(v.$slots, "icon", { key: 1 })
          ]),
          _: 3
        })) : ye("v-if", !0),
        v.$slots.default ? (V(), se("span", {
          key: 2,
          class: ee({ [x(s).em("text", "expand")]: x(d) })
        }, [
          Me(v.$slots, "default")
        ], 2)) : ye("v-if", !0)
      ]),
      _: 3
    }, 16, ["class", "style", "onClick"]));
  }
});
var SI = /* @__PURE__ */ Ge(_I, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button.vue"]]);
const EI = {
  size: ac.size,
  type: ac.type
}, xI = be({
  name: "ElButtonGroup"
}), AI = /* @__PURE__ */ be({
  ...xI,
  props: EI,
  setup(t) {
    const e = t;
    qt(qg, Bn({
      size: Cn(e, "size"),
      type: Cn(e, "type")
    }));
    const n = Fe("button");
    return (r, i) => (V(), se("div", {
      class: ee(`${x(n).b("group")}`)
    }, [
      Me(r.$slots, "default")
    ], 2));
  }
});
var Yg = /* @__PURE__ */ Ge(AI, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button-group.vue"]]);
const Yi = nn(SI, {
  ButtonGroup: Yg
}), Qg = sr(Yg);
var mn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
const ci = /* @__PURE__ */ new Map();
let Qh;
St && (document.addEventListener("mousedown", (t) => Qh = t), document.addEventListener("mouseup", (t) => {
  for (const e of ci.values())
    for (const { documentHandler: n } of e)
      n(t, Qh);
}));
function Zh(t, e) {
  let n = [];
  return Array.isArray(e.arg) ? n = e.arg : ji(e.arg) && n.push(e.arg), function(r, i) {
    const s = e.instance.popperRef, o = r.target, a = i == null ? void 0 : i.target, l = !e || !e.instance, u = !o || !a, c = t.contains(o) || t.contains(a), d = t === o, h = n.length && n.some((y) => y == null ? void 0 : y.contains(o)) || n.length && n.includes(a), v = s && (s.contains(o) || s.contains(a));
    l || u || c || d || h || v || e.value(r, i);
  };
}
const Zg = {
  beforeMount(t, e) {
    ci.has(t) || ci.set(t, []), ci.get(t).push({
      documentHandler: Zh(t, e),
      bindingFn: e.value
    });
  },
  updated(t, e) {
    ci.has(t) || ci.set(t, []);
    const n = ci.get(t), r = n.findIndex((s) => s.bindingFn === e.oldValue), i = {
      documentHandler: Zh(t, e),
      bindingFn: e.value
    };
    r >= 0 ? n.splice(r, 1, i) : n.push(i);
  },
  unmounted(t) {
    ci.delete(t);
  }
}, kI = 100, CI = 600, Xh = {
  beforeMount(t, e) {
    const n = e.value, { interval: r = kI, delay: i = CI } = gn(n) ? {} : n;
    let s, o;
    const a = () => gn(n) ? n() : n.handler(), l = () => {
      o && (clearTimeout(o), o = void 0), s && (clearInterval(s), s = void 0);
    };
    t.addEventListener("mousedown", (u) => {
      u.button === 0 && (l(), a(), document.addEventListener("mouseup", () => l(), {
        once: !0
      }), o = setTimeout(() => {
        s = setInterval(() => {
          a();
        }, r);
      }, i));
    });
  }
};
var ep = !1, Oi, uc, cc, La, za, Xg, ja, dc, fc, hc, em, pc, vc, tm, nm;
function Mn() {
  if (!ep) {
    ep = !0;
    var t = navigator.userAgent, e = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(t), n = /(Mac OS X)|(Windows)|(Linux)/.exec(t);
    if (pc = /\b(iPhone|iP[ao]d)/.exec(t), vc = /\b(iP[ao]d)/.exec(t), hc = /Android/i.exec(t), tm = /FBAN\/\w+;/i.exec(t), nm = /Mobile/i.exec(t), em = !!/Win64/.exec(t), e) {
      Oi = e[1] ? parseFloat(e[1]) : e[5] ? parseFloat(e[5]) : NaN, Oi && document && document.documentMode && (Oi = document.documentMode);
      var r = /(?:Trident\/(\d+.\d+))/.exec(t);
      Xg = r ? parseFloat(r[1]) + 4 : Oi, uc = e[2] ? parseFloat(e[2]) : NaN, cc = e[3] ? parseFloat(e[3]) : NaN, La = e[4] ? parseFloat(e[4]) : NaN, La ? (e = /(?:Chrome\/(\d+\.\d+))/.exec(t), za = e && e[1] ? parseFloat(e[1]) : NaN) : za = NaN;
    } else
      Oi = uc = cc = za = La = NaN;
    if (n) {
      if (n[1]) {
        var i = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(t);
        ja = i ? parseFloat(i[1].replace("_", ".")) : !0;
      } else
        ja = !1;
      dc = !!n[2], fc = !!n[3];
    } else
      ja = dc = fc = !1;
  }
}
var gc = { ie: function() {
  return Mn() || Oi;
}, ieCompatibilityMode: function() {
  return Mn() || Xg > Oi;
}, ie64: function() {
  return gc.ie() && em;
}, firefox: function() {
  return Mn() || uc;
}, opera: function() {
  return Mn() || cc;
}, webkit: function() {
  return Mn() || La;
}, safari: function() {
  return gc.webkit();
}, chrome: function() {
  return Mn() || za;
}, windows: function() {
  return Mn() || dc;
}, osx: function() {
  return Mn() || ja;
}, linux: function() {
  return Mn() || fc;
}, iphone: function() {
  return Mn() || pc;
}, mobile: function() {
  return Mn() || pc || vc || hc || nm;
}, nativeApp: function() {
  return Mn() || tm;
}, android: function() {
  return Mn() || hc;
}, ipad: function() {
  return Mn() || vc;
} }, TI = gc, _a = !!(typeof window < "u" && window.document && window.document.createElement), OI = { canUseDOM: _a, canUseWorkers: typeof Worker < "u", canUseEventListeners: _a && !!(window.addEventListener || window.attachEvent), canUseViewport: _a && !!window.screen, isInWorker: !_a }, rm = OI, im;
rm.canUseDOM && (im = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== !0);
function II(t, e) {
  if (!rm.canUseDOM || e && !("addEventListener" in document))
    return !1;
  var n = "on" + t, r = n in document;
  if (!r) {
    var i = document.createElement("div");
    i.setAttribute(n, "return;"), r = typeof i[n] == "function";
  }
  return !r && im && t === "wheel" && (r = document.implementation.hasFeature("Events.wheel", "3.0")), r;
}
var NI = II, tp = 10, np = 40, rp = 800;
function sm(t) {
  var e = 0, n = 0, r = 0, i = 0;
  return "detail" in t && (n = t.detail), "wheelDelta" in t && (n = -t.wheelDelta / 120), "wheelDeltaY" in t && (n = -t.wheelDeltaY / 120), "wheelDeltaX" in t && (e = -t.wheelDeltaX / 120), "axis" in t && t.axis === t.HORIZONTAL_AXIS && (e = n, n = 0), r = e * tp, i = n * tp, "deltaY" in t && (i = t.deltaY), "deltaX" in t && (r = t.deltaX), (r || i) && t.deltaMode && (t.deltaMode == 1 ? (r *= np, i *= np) : (r *= rp, i *= rp)), r && !e && (e = r < 1 ? -1 : 1), i && !n && (n = i < 1 ? -1 : 1), { spinX: e, spinY: n, pixelX: r, pixelY: i };
}
sm.getEventType = function() {
  return TI.firefox() ? "DOMMouseScroll" : NI("wheel") ? "wheel" : "mousewheel";
};
var RI = sm;
/**
* Checks if an event is supported in the current execution environment.
*
* NOTE: This will not work correctly for non-generic events such as `change`,
* `reset`, `load`, `error`, and `select`.
*
* Borrows from Modernizr.
*
* @param {string} eventNameSuffix Event name, e.g. "click".
* @param {?boolean} capture Check if the capture phase is supported.
* @return {boolean} True if the event is supported.
* @internal
* @license Modernizr 3.0.0pre (Custom Build) | MIT
*/
const PI = function(t, e) {
  if (t && t.addEventListener) {
    const n = function(r) {
      const i = RI(r);
      e && Reflect.apply(e, this, [r, i]);
    };
    t.addEventListener("wheel", n, { passive: !0 });
  }
}, BI = {
  beforeMount(t, e) {
    PI(t, e.value);
  }
}, DI = ut({
  header: {
    type: String,
    default: ""
  },
  bodyStyle: {
    type: Be([String, Object, Array]),
    default: ""
  },
  bodyClass: String,
  shadow: {
    type: String,
    values: ["always", "hover", "never"],
    default: "always"
  }
}), MI = be({
  name: "ElCard"
}), LI = /* @__PURE__ */ be({
  ...MI,
  props: DI,
  setup(t) {
    const e = Fe("card");
    return (n, r) => (V(), se("div", {
      class: ee([x(e).b(), x(e).is(`${n.shadow}-shadow`)])
    }, [
      n.$slots.header || n.header ? (V(), se("div", {
        key: 0,
        class: ee(x(e).e("header"))
      }, [
        Me(n.$slots, "header", {}, () => [
          cn(st(n.header), 1)
        ])
      ], 2)) : ye("v-if", !0),
      ae("div", {
        class: ee([x(e).e("body"), n.bodyClass]),
        style: it(n.bodyStyle)
      }, [
        Me(n.$slots, "default")
      ], 6)
    ], 2));
  }
});
var zI = /* @__PURE__ */ Ge(LI, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/card/src/card.vue"]]);
const jI = nn(zI), om = {
  modelValue: {
    type: [Number, String, Boolean],
    default: void 0
  },
  label: {
    type: [String, Boolean, Number, Object],
    default: void 0
  },
  indeterminate: Boolean,
  disabled: Boolean,
  checked: Boolean,
  name: {
    type: String,
    default: void 0
  },
  trueLabel: {
    type: [String, Number],
    default: void 0
  },
  falseLabel: {
    type: [String, Number],
    default: void 0
  },
  id: {
    type: String,
    default: void 0
  },
  controls: {
    type: String,
    default: void 0
  },
  border: Boolean,
  size: Rr,
  tabindex: [String, Number],
  validateEvent: {
    type: Boolean,
    default: !0
  }
}, am = {
  [Bt]: (t) => Gt(t) || mt(t) || Qr(t),
  change: (t) => Gt(t) || mt(t) || Qr(t)
}, Hs = Symbol("checkboxGroupContextKey"), FI = ({
  model: t,
  isChecked: e
}) => {
  const n = tt(Hs, void 0), r = F(() => {
    var s, o;
    const a = (s = n == null ? void 0 : n.max) == null ? void 0 : s.value, l = (o = n == null ? void 0 : n.min) == null ? void 0 : o.value;
    return !Sr(a) && t.value.length >= a && !e.value || !Sr(l) && t.value.length <= l && e.value;
  });
  return {
    isDisabled: Br(F(() => (n == null ? void 0 : n.disabled.value) || r.value)),
    isLimitDisabled: r
  };
}, HI = (t, {
  model: e,
  isLimitExceeded: n,
  hasOwnLabel: r,
  isDisabled: i,
  isLabeledByFormItem: s
}) => {
  const o = tt(Hs, void 0), { formItem: a } = oi(), { emit: l } = ht();
  function u(y) {
    var b, p;
    return y === t.trueLabel || y === !0 ? (b = t.trueLabel) != null ? b : !0 : (p = t.falseLabel) != null ? p : !1;
  }
  function c(y, b) {
    l("change", u(y), b);
  }
  function d(y) {
    if (n.value)
      return;
    const b = y.target;
    l("change", u(b.checked), y);
  }
  async function h(y) {
    n.value || !r.value && !i.value && s.value && (y.composedPath().some((f) => f.tagName === "LABEL") || (e.value = u([!1, t.falseLabel].includes(e.value)), await rt(), c(e.value, y)));
  }
  const v = F(() => (o == null ? void 0 : o.validateEvent) || t.validateEvent);
  return ke(() => t.modelValue, () => {
    v.value && (a == null || a.validate("change").catch((y) => Vt(y)));
  }), {
    handleChange: d,
    onClickRoot: h
  };
}, UI = (t) => {
  const e = $(!1), { emit: n } = ht(), r = tt(Hs, void 0), i = F(() => Sr(r) === !1), s = $(!1);
  return {
    model: F({
      get() {
        var a, l;
        return i.value ? (a = r == null ? void 0 : r.modelValue) == null ? void 0 : a.value : (l = t.modelValue) != null ? l : e.value;
      },
      set(a) {
        var l, u;
        i.value && Or(a) ? (s.value = ((l = r == null ? void 0 : r.max) == null ? void 0 : l.value) !== void 0 && a.length > (r == null ? void 0 : r.max.value), s.value === !1 && ((u = r == null ? void 0 : r.changeEvent) == null || u.call(r, a))) : (n(Bt, a), e.value = a);
      }
    }),
    isGroup: i,
    isLimitExceeded: s
  };
}, VI = (t, e, { model: n }) => {
  const r = tt(Hs, void 0), i = $(!1), s = F(() => {
    const u = n.value;
    return Qr(u) ? u : Or(u) ? wn(t.label) ? u.map(yi).some((c) => ll(c, t.label)) : u.map(yi).includes(t.label) : u != null ? u === t.trueLabel : !!u;
  }), o = Pr(F(() => {
    var u;
    return (u = r == null ? void 0 : r.size) == null ? void 0 : u.value;
  }), {
    prop: !0
  }), a = Pr(F(() => {
    var u;
    return (u = r == null ? void 0 : r.size) == null ? void 0 : u.value;
  })), l = F(() => !!e.default || !er(t.label));
  return {
    checkboxButtonSize: o,
    isChecked: s,
    isFocused: i,
    checkboxSize: a,
    hasOwnLabel: l
  };
}, WI = (t, { model: e }) => {
  function n() {
    Or(e.value) && !e.value.includes(t.label) ? e.value.push(t.label) : e.value = t.trueLabel || !0;
  }
  t.checked && n();
}, lm = (t, e) => {
  const { formItem: n } = oi(), { model: r, isGroup: i, isLimitExceeded: s } = UI(t), {
    isFocused: o,
    isChecked: a,
    checkboxButtonSize: l,
    checkboxSize: u,
    hasOwnLabel: c
  } = VI(t, e, { model: r }), { isDisabled: d } = FI({ model: r, isChecked: a }), { inputId: h, isLabeledByFormItem: v } = ea(t, {
    formItemContext: n,
    disableIdGeneration: c,
    disableIdManagement: i
  }), { handleChange: y, onClickRoot: b } = HI(t, {
    model: r,
    isLimitExceeded: s,
    hasOwnLabel: c,
    isDisabled: d,
    isLabeledByFormItem: v
  });
  return WI(t, { model: r }), {
    inputId: h,
    isLabeledByFormItem: v,
    isChecked: a,
    isDisabled: d,
    isFocused: o,
    checkboxButtonSize: l,
    checkboxSize: u,
    hasOwnLabel: c,
    model: r,
    handleChange: y,
    onClickRoot: b
  };
}, KI = ["id", "indeterminate", "name", "tabindex", "disabled", "true-value", "false-value"], $I = ["id", "indeterminate", "disabled", "value", "name", "tabindex"], GI = be({
  name: "ElCheckbox"
}), qI = /* @__PURE__ */ be({
  ...GI,
  props: om,
  emits: am,
  setup(t) {
    const e = t, n = Ko(), {
      inputId: r,
      isLabeledByFormItem: i,
      isChecked: s,
      isDisabled: o,
      isFocused: a,
      checkboxSize: l,
      hasOwnLabel: u,
      model: c,
      handleChange: d,
      onClickRoot: h
    } = lm(e, n), v = Fe("checkbox"), y = F(() => [
      v.b(),
      v.m(l.value),
      v.is("disabled", o.value),
      v.is("bordered", e.border),
      v.is("checked", s.value)
    ]), b = F(() => [
      v.e("input"),
      v.is("disabled", o.value),
      v.is("checked", s.value),
      v.is("indeterminate", e.indeterminate),
      v.is("focus", a.value)
    ]);
    return (p, f) => (V(), Ae(Nn(!x(u) && x(i) ? "span" : "label"), {
      class: ee(x(y)),
      "aria-controls": p.indeterminate ? p.controls : null,
      onClick: x(h)
    }, {
      default: de(() => [
        ae("span", {
          class: ee(x(b))
        }, [
          p.trueLabel || p.falseLabel ? Dt((V(), se("input", {
            key: 0,
            id: x(r),
            "onUpdate:modelValue": f[0] || (f[0] = (g) => on(c) ? c.value = g : null),
            class: ee(x(v).e("original")),
            type: "checkbox",
            indeterminate: p.indeterminate,
            name: p.name,
            tabindex: p.tabindex,
            disabled: x(o),
            "true-value": p.trueLabel,
            "false-value": p.falseLabel,
            onChange: f[1] || (f[1] = (...g) => x(d) && x(d)(...g)),
            onFocus: f[2] || (f[2] = (g) => a.value = !0),
            onBlur: f[3] || (f[3] = (g) => a.value = !1),
            onClick: f[4] || (f[4] = ft(() => {
            }, ["stop"]))
          }, null, 42, KI)), [
            [nl, x(c)]
          ]) : Dt((V(), se("input", {
            key: 1,
            id: x(r),
            "onUpdate:modelValue": f[5] || (f[5] = (g) => on(c) ? c.value = g : null),
            class: ee(x(v).e("original")),
            type: "checkbox",
            indeterminate: p.indeterminate,
            disabled: x(o),
            value: p.label,
            name: p.name,
            tabindex: p.tabindex,
            onChange: f[6] || (f[6] = (...g) => x(d) && x(d)(...g)),
            onFocus: f[7] || (f[7] = (g) => a.value = !0),
            onBlur: f[8] || (f[8] = (g) => a.value = !1),
            onClick: f[9] || (f[9] = ft(() => {
            }, ["stop"]))
          }, null, 42, $I)), [
            [nl, x(c)]
          ]),
          ae("span", {
            class: ee(x(v).e("inner"))
          }, null, 2)
        ], 2),
        x(u) ? (V(), se("span", {
          key: 0,
          class: ee(x(v).e("label"))
        }, [
          Me(p.$slots, "default"),
          p.$slots.default ? ye("v-if", !0) : (V(), se(Ft, { key: 0 }, [
            cn(st(p.label), 1)
          ], 64))
        ], 2)) : ye("v-if", !0)
      ]),
      _: 3
    }, 8, ["class", "aria-controls", "onClick"]));
  }
});
var JI = /* @__PURE__ */ Ge(qI, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox.vue"]]);
const YI = ["name", "tabindex", "disabled", "true-value", "false-value"], QI = ["name", "tabindex", "disabled", "value"], ZI = be({
  name: "ElCheckboxButton"
}), XI = /* @__PURE__ */ be({
  ...ZI,
  props: om,
  emits: am,
  setup(t) {
    const e = t, n = Ko(), {
      isFocused: r,
      isChecked: i,
      isDisabled: s,
      checkboxButtonSize: o,
      model: a,
      handleChange: l
    } = lm(e, n), u = tt(Hs, void 0), c = Fe("checkbox"), d = F(() => {
      var v, y, b, p;
      const f = (y = (v = u == null ? void 0 : u.fill) == null ? void 0 : v.value) != null ? y : "";
      return {
        backgroundColor: f,
        borderColor: f,
        color: (p = (b = u == null ? void 0 : u.textColor) == null ? void 0 : b.value) != null ? p : "",
        boxShadow: f ? `-1px 0 0 0 ${f}` : void 0
      };
    }), h = F(() => [
      c.b("button"),
      c.bm("button", o.value),
      c.is("disabled", s.value),
      c.is("checked", i.value),
      c.is("focus", r.value)
    ]);
    return (v, y) => (V(), se("label", {
      class: ee(x(h))
    }, [
      v.trueLabel || v.falseLabel ? Dt((V(), se("input", {
        key: 0,
        "onUpdate:modelValue": y[0] || (y[0] = (b) => on(a) ? a.value = b : null),
        class: ee(x(c).be("button", "original")),
        type: "checkbox",
        name: v.name,
        tabindex: v.tabindex,
        disabled: x(s),
        "true-value": v.trueLabel,
        "false-value": v.falseLabel,
        onChange: y[1] || (y[1] = (...b) => x(l) && x(l)(...b)),
        onFocus: y[2] || (y[2] = (b) => r.value = !0),
        onBlur: y[3] || (y[3] = (b) => r.value = !1),
        onClick: y[4] || (y[4] = ft(() => {
        }, ["stop"]))
      }, null, 42, YI)), [
        [nl, x(a)]
      ]) : Dt((V(), se("input", {
        key: 1,
        "onUpdate:modelValue": y[5] || (y[5] = (b) => on(a) ? a.value = b : null),
        class: ee(x(c).be("button", "original")),
        type: "checkbox",
        name: v.name,
        tabindex: v.tabindex,
        disabled: x(s),
        value: v.label,
        onChange: y[6] || (y[6] = (...b) => x(l) && x(l)(...b)),
        onFocus: y[7] || (y[7] = (b) => r.value = !0),
        onBlur: y[8] || (y[8] = (b) => r.value = !1),
        onClick: y[9] || (y[9] = ft(() => {
        }, ["stop"]))
      }, null, 42, QI)), [
        [nl, x(a)]
      ]),
      v.$slots.default || v.label ? (V(), se("span", {
        key: 2,
        class: ee(x(c).be("button", "inner")),
        style: it(x(i) ? x(d) : void 0)
      }, [
        Me(v.$slots, "default", {}, () => [
          cn(st(v.label), 1)
        ])
      ], 6)) : ye("v-if", !0)
    ], 2));
  }
});
var um = /* @__PURE__ */ Ge(XI, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-button.vue"]]);
const e4 = ut({
  modelValue: {
    type: Be(Array),
    default: () => []
  },
  disabled: Boolean,
  min: Number,
  max: Number,
  size: Rr,
  label: String,
  fill: String,
  textColor: String,
  tag: {
    type: String,
    default: "div"
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), t4 = {
  [Bt]: (t) => Or(t),
  change: (t) => Or(t)
}, n4 = be({
  name: "ElCheckboxGroup"
}), r4 = /* @__PURE__ */ be({
  ...n4,
  props: e4,
  emits: t4,
  setup(t, { emit: e }) {
    const n = t, r = Fe("checkbox"), { formItem: i } = oi(), { inputId: s, isLabeledByFormItem: o } = ea(n, {
      formItemContext: i
    }), a = async (u) => {
      e(Bt, u), await rt(), e("change", u);
    }, l = F({
      get() {
        return n.modelValue;
      },
      set(u) {
        a(u);
      }
    });
    return qt(Hs, {
      ...kx(hn(n), [
        "size",
        "min",
        "max",
        "disabled",
        "validateEvent",
        "fill",
        "textColor"
      ]),
      modelValue: l,
      changeEvent: a
    }), ke(() => n.modelValue, () => {
      n.validateEvent && (i == null || i.validate("change").catch((u) => Vt(u)));
    }), (u, c) => {
      var d;
      return V(), Ae(Nn(u.tag), {
        id: x(s),
        class: ee(x(r).b("group")),
        role: "group",
        "aria-label": x(o) ? void 0 : u.label || "checkbox-group",
        "aria-labelledby": x(o) ? (d = x(i)) == null ? void 0 : d.labelId : void 0
      }, {
        default: de(() => [
          Me(u.$slots, "default")
        ]),
        _: 3
      }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
    };
  }
});
var cm = /* @__PURE__ */ Ge(r4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-group.vue"]]);
const Fi = nn(JI, {
  CheckboxButton: um,
  CheckboxGroup: cm
});
sr(um);
sr(cm);
const dm = ut({
  size: Rr,
  disabled: Boolean,
  label: {
    type: [String, Number, Boolean],
    default: ""
  }
}), i4 = ut({
  ...dm,
  modelValue: {
    type: [String, Number, Boolean],
    default: ""
  },
  name: {
    type: String,
    default: ""
  },
  border: Boolean
}), fm = {
  [Bt]: (t) => Gt(t) || mt(t) || Qr(t),
  [Ji]: (t) => Gt(t) || mt(t) || Qr(t)
}, hm = Symbol("radioGroupKey"), pm = (t, e) => {
  const n = $(), r = tt(hm, void 0), i = F(() => !!r), s = F({
    get() {
      return i.value ? r.modelValue : t.modelValue;
    },
    set(c) {
      i.value ? r.changeEvent(c) : e && e(Bt, c), n.value.checked = t.modelValue === t.label;
    }
  }), o = Pr(F(() => r == null ? void 0 : r.size)), a = Br(F(() => r == null ? void 0 : r.disabled)), l = $(!1), u = F(() => a.value || i.value && s.value !== t.label ? -1 : 0);
  return {
    radioRef: n,
    isGroup: i,
    radioGroup: r,
    focus: l,
    size: o,
    disabled: a,
    tabIndex: u,
    modelValue: s
  };
}, s4 = ["value", "name", "disabled"], o4 = be({
  name: "ElRadio"
}), a4 = /* @__PURE__ */ be({
  ...o4,
  props: i4,
  emits: fm,
  setup(t, { emit: e }) {
    const n = t, r = Fe("radio"), { radioRef: i, radioGroup: s, focus: o, size: a, disabled: l, modelValue: u } = pm(n, e);
    function c() {
      rt(() => e("change", u.value));
    }
    return (d, h) => {
      var v;
      return V(), se("label", {
        class: ee([
          x(r).b(),
          x(r).is("disabled", x(l)),
          x(r).is("focus", x(o)),
          x(r).is("bordered", d.border),
          x(r).is("checked", x(u) === d.label),
          x(r).m(x(a))
        ])
      }, [
        ae("span", {
          class: ee([
            x(r).e("input"),
            x(r).is("disabled", x(l)),
            x(r).is("checked", x(u) === d.label)
          ])
        }, [
          Dt(ae("input", {
            ref_key: "radioRef",
            ref: i,
            "onUpdate:modelValue": h[0] || (h[0] = (y) => on(u) ? u.value = y : null),
            class: ee(x(r).e("original")),
            value: d.label,
            name: d.name || ((v = x(s)) == null ? void 0 : v.name),
            disabled: x(l),
            type: "radio",
            onFocus: h[1] || (h[1] = (y) => o.value = !0),
            onBlur: h[2] || (h[2] = (y) => o.value = !1),
            onChange: c,
            onClick: h[3] || (h[3] = ft(() => {
            }, ["stop"]))
          }, null, 42, s4), [
            [mv, x(u)]
          ]),
          ae("span", {
            class: ee(x(r).e("inner"))
          }, null, 2)
        ], 2),
        ae("span", {
          class: ee(x(r).e("label")),
          onKeydown: h[4] || (h[4] = ft(() => {
          }, ["stop"]))
        }, [
          Me(d.$slots, "default", {}, () => [
            cn(st(d.label), 1)
          ])
        ], 34)
      ], 2);
    };
  }
});
var l4 = /* @__PURE__ */ Ge(a4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio.vue"]]);
const u4 = ut({
  ...dm,
  name: {
    type: String,
    default: ""
  }
}), c4 = ["value", "name", "disabled"], d4 = be({
  name: "ElRadioButton"
}), f4 = /* @__PURE__ */ be({
  ...d4,
  props: u4,
  setup(t) {
    const e = t, n = Fe("radio"), { radioRef: r, focus: i, size: s, disabled: o, modelValue: a, radioGroup: l } = pm(e), u = F(() => ({
      backgroundColor: (l == null ? void 0 : l.fill) || "",
      borderColor: (l == null ? void 0 : l.fill) || "",
      boxShadow: l != null && l.fill ? `-1px 0 0 0 ${l.fill}` : "",
      color: (l == null ? void 0 : l.textColor) || ""
    }));
    return (c, d) => {
      var h;
      return V(), se("label", {
        class: ee([
          x(n).b("button"),
          x(n).is("active", x(a) === c.label),
          x(n).is("disabled", x(o)),
          x(n).is("focus", x(i)),
          x(n).bm("button", x(s))
        ])
      }, [
        Dt(ae("input", {
          ref_key: "radioRef",
          ref: r,
          "onUpdate:modelValue": d[0] || (d[0] = (v) => on(a) ? a.value = v : null),
          class: ee(x(n).be("button", "original-radio")),
          value: c.label,
          type: "radio",
          name: c.name || ((h = x(l)) == null ? void 0 : h.name),
          disabled: x(o),
          onFocus: d[1] || (d[1] = (v) => i.value = !0),
          onBlur: d[2] || (d[2] = (v) => i.value = !1),
          onClick: d[3] || (d[3] = ft(() => {
          }, ["stop"]))
        }, null, 42, c4), [
          [mv, x(a)]
        ]),
        ae("span", {
          class: ee(x(n).be("button", "inner")),
          style: it(x(a) === c.label ? x(u) : {}),
          onKeydown: d[4] || (d[4] = ft(() => {
          }, ["stop"]))
        }, [
          Me(c.$slots, "default", {}, () => [
            cn(st(c.label), 1)
          ])
        ], 38)
      ], 2);
    };
  }
});
var vm = /* @__PURE__ */ Ge(f4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio-button.vue"]]);
const h4 = ut({
  id: {
    type: String,
    default: void 0
  },
  size: Rr,
  disabled: Boolean,
  modelValue: {
    type: [String, Number, Boolean],
    default: ""
  },
  fill: {
    type: String,
    default: ""
  },
  label: {
    type: String,
    default: void 0
  },
  textColor: {
    type: String,
    default: ""
  },
  name: {
    type: String,
    default: void 0
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), p4 = fm, v4 = ["id", "aria-label", "aria-labelledby"], g4 = be({
  name: "ElRadioGroup"
}), m4 = /* @__PURE__ */ be({
  ...g4,
  props: h4,
  emits: p4,
  setup(t, { emit: e }) {
    const n = t, r = Fe("radio"), i = Xo(), s = $(), { formItem: o } = oi(), { inputId: a, isLabeledByFormItem: l } = ea(n, {
      formItemContext: o
    }), u = (d) => {
      e(Bt, d), rt(() => e("change", d));
    };
    Ct(() => {
      const d = s.value.querySelectorAll("[type=radio]"), h = d[0];
      !Array.from(d).some((v) => v.checked) && h && (h.tabIndex = 0);
    });
    const c = F(() => n.name || i.value);
    return qt(hm, Bn({
      ...hn(n),
      changeEvent: u,
      name: c
    })), ke(() => n.modelValue, () => {
      n.validateEvent && (o == null || o.validate("change").catch((d) => Vt(d)));
    }), (d, h) => (V(), se("div", {
      id: x(a),
      ref_key: "radioGroupRef",
      ref: s,
      class: ee(x(r).b("group")),
      role: "radiogroup",
      "aria-label": x(l) ? void 0 : d.label || "radio-group",
      "aria-labelledby": x(l) ? x(o).labelId : void 0
    }, [
      Me(d.$slots, "default")
    ], 10, v4));
  }
});
var gm = /* @__PURE__ */ Ge(m4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio-group.vue"]]);
nn(l4, {
  RadioButton: vm,
  RadioGroup: gm
});
const y4 = sr(gm), b4 = sr(vm), mm = ut({
  type: {
    type: String,
    values: ["success", "info", "warning", "danger", ""],
    default: ""
  },
  closable: Boolean,
  disableTransitions: Boolean,
  hit: Boolean,
  color: {
    type: String,
    default: ""
  },
  size: {
    type: String,
    values: Rd,
    default: ""
  },
  effect: {
    type: String,
    values: ["dark", "light", "plain"],
    default: "light"
  },
  round: Boolean
}), w4 = {
  close: (t) => t instanceof MouseEvent,
  click: (t) => t instanceof MouseEvent
}, _4 = be({
  name: "ElTag"
}), S4 = /* @__PURE__ */ be({
  ..._4,
  props: mm,
  emits: w4,
  setup(t, { emit: e }) {
    const n = t, r = Pr(), i = Fe("tag"), s = F(() => {
      const { type: l, hit: u, effect: c, closable: d, round: h } = n;
      return [
        i.b(),
        i.is("closable", d),
        i.m(l),
        i.m(r.value),
        i.m(c),
        i.is("hit", u),
        i.is("round", h)
      ];
    }), o = (l) => {
      e("close", l);
    }, a = (l) => {
      e("click", l);
    };
    return (l, u) => l.disableTransitions ? (V(), se("span", {
      key: 0,
      class: ee(x(s)),
      style: it({ backgroundColor: l.color }),
      onClick: a
    }, [
      ae("span", {
        class: ee(x(i).e("content"))
      }, [
        Me(l.$slots, "default")
      ], 2),
      l.closable ? (V(), Ae(x(_t), {
        key: 0,
        class: ee(x(i).e("close")),
        onClick: ft(o, ["stop"])
      }, {
        default: de(() => [
          ve(x(ko))
        ]),
        _: 1
      }, 8, ["class", "onClick"])) : ye("v-if", !0)
    ], 6)) : (V(), Ae(mr, {
      key: 1,
      name: `${x(i).namespace.value}-zoom-in-center`,
      appear: ""
    }, {
      default: de(() => [
        ae("span", {
          class: ee(x(s)),
          style: it({ backgroundColor: l.color }),
          onClick: a
        }, [
          ae("span", {
            class: ee(x(i).e("content"))
          }, [
            Me(l.$slots, "default")
          ], 2),
          l.closable ? (V(), Ae(x(_t), {
            key: 0,
            class: ee(x(i).e("close")),
            onClick: ft(o, ["stop"])
          }, {
            default: de(() => [
              ve(x(ko))
            ]),
            _: 1
          }, 8, ["class", "onClick"])) : ye("v-if", !0)
        ], 6)
      ]),
      _: 3
    }, 8, ["name"]));
  }
});
var E4 = /* @__PURE__ */ Ge(S4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tag/src/tag.vue"]]);
const x4 = nn(E4), A4 = be({
  name: "ElCollapseTransition"
}), k4 = /* @__PURE__ */ be({
  ...A4,
  setup(t) {
    const e = Fe("collapse-transition"), n = (i) => {
      i.style.maxHeight = "", i.style.overflow = i.dataset.oldOverflow, i.style.paddingTop = i.dataset.oldPaddingTop, i.style.paddingBottom = i.dataset.oldPaddingBottom;
    }, r = {
      beforeEnter(i) {
        i.dataset || (i.dataset = {}), i.dataset.oldPaddingTop = i.style.paddingTop, i.dataset.oldPaddingBottom = i.style.paddingBottom, i.style.maxHeight = 0, i.style.paddingTop = 0, i.style.paddingBottom = 0;
      },
      enter(i) {
        i.dataset.oldOverflow = i.style.overflow, i.scrollHeight !== 0 ? i.style.maxHeight = `${i.scrollHeight}px` : i.style.maxHeight = 0, i.style.paddingTop = i.dataset.oldPaddingTop, i.style.paddingBottom = i.dataset.oldPaddingBottom, i.style.overflow = "hidden";
      },
      afterEnter(i) {
        i.style.maxHeight = "", i.style.overflow = i.dataset.oldOverflow;
      },
      enterCancelled(i) {
        n(i);
      },
      beforeLeave(i) {
        i.dataset || (i.dataset = {}), i.dataset.oldPaddingTop = i.style.paddingTop, i.dataset.oldPaddingBottom = i.style.paddingBottom, i.dataset.oldOverflow = i.style.overflow, i.style.maxHeight = `${i.scrollHeight}px`, i.style.overflow = "hidden";
      },
      leave(i) {
        i.scrollHeight !== 0 && (i.style.maxHeight = 0, i.style.paddingTop = 0, i.style.paddingBottom = 0);
      },
      afterLeave(i) {
        n(i);
      },
      leaveCancelled(i) {
        n(i);
      }
    };
    return (i, s) => (V(), Ae(mr, Gn({
      name: x(e).b()
    }, Q0(r)), {
      default: de(() => [
        Me(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["name"]));
  }
});
var Fa = /* @__PURE__ */ Ge(k4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/collapse-transition/src/collapse-transition.vue"]]);
Fa.install = (t) => {
  t.component(Fa.name, Fa);
};
const C4 = Fa, T4 = be({
  name: "ElContainer"
}), O4 = /* @__PURE__ */ be({
  ...T4,
  props: {
    direction: {
      type: String
    }
  },
  setup(t) {
    const e = t, n = Ko(), r = Fe("container"), i = F(() => e.direction === "vertical" ? !0 : e.direction === "horizontal" ? !1 : n && n.default ? n.default().some((o) => {
      const a = o.type.name;
      return a === "ElHeader" || a === "ElFooter";
    }) : !1);
    return (s, o) => (V(), se("section", {
      class: ee([x(r).b(), x(r).is("vertical", x(i))])
    }, [
      Me(s.$slots, "default")
    ], 2));
  }
});
var I4 = /* @__PURE__ */ Ge(O4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/container.vue"]]);
const N4 = be({
  name: "ElAside"
}), R4 = /* @__PURE__ */ be({
  ...N4,
  props: {
    width: {
      type: String,
      default: null
    }
  },
  setup(t) {
    const e = t, n = Fe("aside"), r = F(() => e.width ? n.cssVarBlock({ width: e.width }) : {});
    return (i, s) => (V(), se("aside", {
      class: ee(x(n).b()),
      style: it(x(r))
    }, [
      Me(i.$slots, "default")
    ], 6));
  }
});
var ym = /* @__PURE__ */ Ge(R4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/aside.vue"]]);
const P4 = be({
  name: "ElFooter"
}), B4 = /* @__PURE__ */ be({
  ...P4,
  props: {
    height: {
      type: String,
      default: null
    }
  },
  setup(t) {
    const e = t, n = Fe("footer"), r = F(() => e.height ? n.cssVarBlock({ height: e.height }) : {});
    return (i, s) => (V(), se("footer", {
      class: ee(x(n).b()),
      style: it(x(r))
    }, [
      Me(i.$slots, "default")
    ], 6));
  }
});
var bm = /* @__PURE__ */ Ge(B4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/footer.vue"]]);
const D4 = be({
  name: "ElHeader"
}), M4 = /* @__PURE__ */ be({
  ...D4,
  props: {
    height: {
      type: String,
      default: null
    }
  },
  setup(t) {
    const e = t, n = Fe("header"), r = F(() => e.height ? n.cssVarBlock({
      height: e.height
    }) : {});
    return (i, s) => (V(), se("header", {
      class: ee(x(n).b()),
      style: it(x(r))
    }, [
      Me(i.$slots, "default")
    ], 6));
  }
});
var wm = /* @__PURE__ */ Ge(M4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/header.vue"]]);
const L4 = be({
  name: "ElMain"
}), z4 = /* @__PURE__ */ be({
  ...L4,
  setup(t) {
    const e = Fe("main");
    return (n, r) => (V(), se("main", {
      class: ee(x(e).b())
    }, [
      Me(n.$slots, "default")
    ], 2));
  }
});
var _m = /* @__PURE__ */ Ge(z4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/main.vue"]]);
const Sm = nn(I4, {
  Aside: ym,
  Footer: bm,
  Header: wm,
  Main: _m
});
sr(ym);
const j4 = sr(bm), F4 = sr(wm), Em = sr(_m), H4 = ut({
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  contentPosition: {
    type: String,
    values: ["left", "center", "right"],
    default: "center"
  },
  borderStyle: {
    type: Be(String),
    default: "solid"
  }
}), U4 = be({
  name: "ElDivider"
}), V4 = /* @__PURE__ */ be({
  ...U4,
  props: H4,
  setup(t) {
    const e = t, n = Fe("divider"), r = F(() => n.cssVar({
      "border-style": e.borderStyle
    }));
    return (i, s) => (V(), se("div", {
      class: ee([x(n).b(), x(n).m(i.direction)]),
      style: it(x(r)),
      role: "separator"
    }, [
      i.$slots.default && i.direction !== "vertical" ? (V(), se("div", {
        key: 0,
        class: ee([x(n).e("text"), x(n).is(i.contentPosition)])
      }, [
        Me(i.$slots, "default")
      ], 2)) : ye("v-if", !0)
    ], 6));
  }
});
var W4 = /* @__PURE__ */ Ge(V4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/divider/src/divider.vue"]]);
const K4 = nn(W4), $4 = /* @__PURE__ */ be({
  inheritAttrs: !1
});
function G4(t, e, n, r, i, s) {
  return Me(t.$slots, "default");
}
var q4 = /* @__PURE__ */ Ge($4, [["render", G4], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection.vue"]]);
const J4 = /* @__PURE__ */ be({
  name: "ElCollectionItem",
  inheritAttrs: !1
});
function Y4(t, e, n, r, i, s) {
  return Me(t.$slots, "default");
}
var Q4 = /* @__PURE__ */ Ge(J4, [["render", Y4], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection-item.vue"]]);
const Z4 = "data-el-collection-item", X4 = (t) => {
  const e = `El${t}Collection`, n = `${e}Item`, r = Symbol(e), i = Symbol(n), s = {
    ...q4,
    name: e,
    setup() {
      const a = $(null), l = /* @__PURE__ */ new Map();
      qt(r, {
        itemMap: l,
        getItems: () => {
          const c = x(a);
          if (!c)
            return [];
          const d = Array.from(c.querySelectorAll(`[${Z4}]`));
          return [...l.values()].sort((v, y) => d.indexOf(v.ref) - d.indexOf(y.ref));
        },
        collectionRef: a
      });
    }
  }, o = {
    ...Q4,
    name: n,
    setup(a, { attrs: l }) {
      const u = $(null), c = tt(r, void 0);
      qt(i, {
        collectionItemRef: u
      }), Ct(() => {
        const d = x(u);
        d && c.itemMap.set(d, {
          ref: d,
          ...l
        });
      }), En(() => {
        const d = x(u);
        c.itemMap.delete(d);
      });
    }
  };
  return {
    COLLECTION_INJECTION_KEY: r,
    COLLECTION_ITEM_INJECTION_KEY: i,
    ElCollection: s,
    ElCollectionItem: o
  };
}, Au = ut({
  trigger: Io.trigger,
  effect: {
    ...$n.effect,
    default: "light"
  },
  type: {
    type: Be(String)
  },
  placement: {
    type: Be(String),
    default: "bottom"
  },
  popperOptions: {
    type: Be(Object),
    default: () => ({})
  },
  id: String,
  size: {
    type: String,
    default: ""
  },
  splitButton: Boolean,
  hideOnClick: {
    type: Boolean,
    default: !0
  },
  loop: {
    type: Boolean,
    default: !0
  },
  showTimeout: {
    type: Number,
    default: 150
  },
  hideTimeout: {
    type: Number,
    default: 150
  },
  tabindex: {
    type: Be([Number, String]),
    default: 0
  },
  maxHeight: {
    type: Be([Number, String]),
    default: ""
  },
  popperClass: {
    type: String,
    default: ""
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  role: {
    type: String,
    default: "menu"
  },
  buttonProps: {
    type: Be(Object)
  },
  teleported: $n.teleported
});
ut({
  command: {
    type: [Object, String, Number],
    default: () => ({})
  },
  disabled: Boolean,
  divided: Boolean,
  textValue: String,
  icon: {
    type: bi
  }
});
ut({
  onKeydown: { type: Be(Function) }
});
X4("Dropdown");
const eN = ut({
  urlList: {
    type: Be(Array),
    default: () => Cs([])
  },
  zIndex: {
    type: Number
  },
  initialIndex: {
    type: Number,
    default: 0
  },
  infinite: {
    type: Boolean,
    default: !0
  },
  hideOnClickModal: Boolean,
  teleported: Boolean,
  closeOnPressEscape: {
    type: Boolean,
    default: !0
  },
  zoomRate: {
    type: Number,
    default: 1.2
  },
  minScale: {
    type: Number,
    default: 0.2
  },
  maxScale: {
    type: Number,
    default: 7
  }
}), tN = {
  close: () => !0,
  switch: (t) => mt(t),
  rotate: (t) => mt(t)
}, nN = ["src"], rN = be({
  name: "ElImageViewer"
}), iN = /* @__PURE__ */ be({
  ...rN,
  props: eN,
  emits: tN,
  setup(t, { expose: e, emit: n }) {
    const r = t, i = {
      CONTAIN: {
        name: "contain",
        icon: Ur(lg)
      },
      ORIGINAL: {
        name: "original",
        icon: Ur(bC)
      }
    }, { t: s } = or(), o = Fe("image-viewer"), { nextZIndex: a } = ql(), l = $(), u = $([]), c = yv(), d = $(!0), h = $(r.initialIndex), v = zn(i.CONTAIN), y = $({
      scale: 1,
      deg: 0,
      offsetX: 0,
      offsetY: 0,
      enableTransition: !1
    }), b = F(() => {
      const { urlList: H } = r;
      return H.length <= 1;
    }), p = F(() => h.value === 0), f = F(() => h.value === r.urlList.length - 1), g = F(() => r.urlList[h.value]), m = F(() => [
      o.e("btn"),
      o.e("prev"),
      o.is("disabled", !r.infinite && p.value)
    ]), w = F(() => [
      o.e("btn"),
      o.e("next"),
      o.is("disabled", !r.infinite && f.value)
    ]), _ = F(() => {
      const { scale: H, deg: re, offsetX: fe, offsetY: J, enableTransition: le } = y.value;
      let ce = fe / H, ge = J / H;
      switch (re % 360) {
        case 90:
        case -270:
          [ce, ge] = [ge, -ce];
          break;
        case 180:
        case -180:
          [ce, ge] = [-ce, -ge];
          break;
        case 270:
        case -90:
          [ce, ge] = [-ge, ce];
          break;
      }
      const _e = {
        transform: `scale(${H}) rotate(${re}deg) translate(${ce}px, ${ge}px)`,
        transition: le ? "transform .3s" : ""
      };
      return v.value.name === i.CONTAIN.name && (_e.maxWidth = _e.maxHeight = "100%"), _e;
    }), S = F(() => mt(r.zIndex) ? r.zIndex : a());
    function A() {
      k(), n("close");
    }
    function C() {
      const H = yu((fe) => {
        switch (fe.code) {
          case sn.esc:
            r.closeOnPressEscape && A();
            break;
          case sn.space:
            j();
            break;
          case sn.left:
            X();
            break;
          case sn.up:
            U("zoomIn");
            break;
          case sn.right:
            z();
            break;
          case sn.down:
            U("zoomOut");
            break;
        }
      }), re = yu((fe) => {
        const J = fe.deltaY || fe.deltaX;
        U(J < 0 ? "zoomIn" : "zoomOut", {
          zoomRate: r.zoomRate,
          enableTransition: !1
        });
      });
      c.run(() => {
        bn(document, "keydown", H), bn(document, "wheel", re);
      });
    }
    function k() {
      c.stop();
    }
    function O() {
      d.value = !1;
    }
    function N(H) {
      d.value = !1, H.target.alt = s("el.image.error");
    }
    function B(H) {
      if (d.value || H.button !== 0 || !l.value)
        return;
      y.value.enableTransition = !1;
      const { offsetX: re, offsetY: fe } = y.value, J = H.pageX, le = H.pageY, ce = yu((_e) => {
        y.value = {
          ...y.value,
          offsetX: re + _e.pageX - J,
          offsetY: fe + _e.pageY - le
        };
      }), ge = bn(document, "mousemove", ce);
      bn(document, "mouseup", () => {
        ge();
      }), H.preventDefault();
    }
    function M() {
      y.value = {
        scale: 1,
        deg: 0,
        offsetX: 0,
        offsetY: 0,
        enableTransition: !1
      };
    }
    function j() {
      if (d.value)
        return;
      const H = rc(i), re = Object.values(i), fe = v.value.name, le = (re.findIndex((ce) => ce.name === fe) + 1) % H.length;
      v.value = i[H[le]], M();
    }
    function q(H) {
      const re = r.urlList.length;
      h.value = (H + re) % re;
    }
    function X() {
      p.value && !r.infinite || q(h.value - 1);
    }
    function z() {
      f.value && !r.infinite || q(h.value + 1);
    }
    function U(H, re = {}) {
      if (d.value)
        return;
      const { minScale: fe, maxScale: J } = r, { zoomRate: le, rotateDeg: ce, enableTransition: ge } = {
        zoomRate: r.zoomRate,
        rotateDeg: 90,
        enableTransition: !0,
        ...re
      };
      switch (H) {
        case "zoomOut":
          y.value.scale > fe && (y.value.scale = Number.parseFloat((y.value.scale / le).toFixed(3)));
          break;
        case "zoomIn":
          y.value.scale < J && (y.value.scale = Number.parseFloat((y.value.scale * le).toFixed(3)));
          break;
        case "clockwise":
          y.value.deg += ce, n("rotate", y.value.deg);
          break;
        case "anticlockwise":
          y.value.deg -= ce, n("rotate", y.value.deg);
          break;
      }
      y.value.enableTransition = ge;
    }
    return ke(g, () => {
      rt(() => {
        const H = u.value[0];
        H != null && H.complete || (d.value = !0);
      });
    }), ke(h, (H) => {
      M(), n("switch", H);
    }), Ct(() => {
      var H, re;
      C(), (re = (H = l.value) == null ? void 0 : H.focus) == null || re.call(H);
    }), e({
      setActiveItem: q
    }), (H, re) => (V(), Ae(gv, {
      to: "body",
      disabled: !H.teleported
    }, [
      ve(mr, {
        name: "viewer-fade",
        appear: ""
      }, {
        default: de(() => [
          ae("div", {
            ref_key: "wrapper",
            ref: l,
            tabindex: -1,
            class: ee(x(o).e("wrapper")),
            style: it({ zIndex: x(S) })
          }, [
            ae("div", {
              class: ee(x(o).e("mask")),
              onClick: re[0] || (re[0] = ft((fe) => H.hideOnClickModal && A(), ["self"]))
            }, null, 2),
            ye(" CLOSE "),
            ae("span", {
              class: ee([x(o).e("btn"), x(o).e("close")]),
              onClick: A
            }, [
              ve(x(_t), null, {
                default: de(() => [
                  ve(x(ko))
                ]),
                _: 1
              })
            ], 2),
            ye(" ARROW "),
            x(b) ? ye("v-if", !0) : (V(), se(Ft, { key: 0 }, [
              ae("span", {
                class: ee(x(m)),
                onClick: X
              }, [
                ve(x(_t), null, {
                  default: de(() => [
                    ve(x(Gx))
                  ]),
                  _: 1
                })
              ], 2),
              ae("span", {
                class: ee(x(w)),
                onClick: z
              }, [
                ve(x(_t), null, {
                  default: de(() => [
                    ve(x(Id))
                  ]),
                  _: 1
                })
              ], 2)
            ], 64)),
            ye(" ACTIONS "),
            ae("div", {
              class: ee([x(o).e("btn"), x(o).e("actions")])
            }, [
              ae("div", {
                class: ee(x(o).e("actions__inner"))
              }, [
                ve(x(_t), {
                  onClick: re[1] || (re[1] = (fe) => U("zoomOut"))
                }, {
                  default: de(() => [
                    ve(x(qC))
                  ]),
                  _: 1
                }),
                ve(x(_t), {
                  onClick: re[2] || (re[2] = (fe) => U("zoomIn"))
                }, {
                  default: de(() => [
                    ve(x(cg))
                  ]),
                  _: 1
                }),
                ae("i", {
                  class: ee(x(o).e("actions__divider"))
                }, null, 2),
                ve(x(_t), { onClick: j }, {
                  default: de(() => [
                    (V(), Ae(Nn(x(v).icon)))
                  ]),
                  _: 1
                }),
                ae("i", {
                  class: ee(x(o).e("actions__divider"))
                }, null, 2),
                ve(x(_t), {
                  onClick: re[3] || (re[3] = (fe) => U("anticlockwise"))
                }, {
                  default: de(() => [
                    ve(x(aC))
                  ]),
                  _: 1
                }),
                ve(x(_t), {
                  onClick: re[4] || (re[4] = (fe) => U("clockwise"))
                }, {
                  default: de(() => [
                    ve(x(hC))
                  ]),
                  _: 1
                })
              ], 2)
            ], 2),
            ye(" CANVAS "),
            ae("div", {
              class: ee(x(o).e("canvas"))
            }, [
              (V(!0), se(Ft, null, qn(H.urlList, (fe, J) => Dt((V(), se("img", {
                ref_for: !0,
                ref: (le) => u.value[J] = le,
                key: fe,
                src: fe,
                style: it(x(_)),
                class: ee(x(o).e("img")),
                onLoad: O,
                onError: N,
                onMousedown: B
              }, null, 46, nN)), [
                [Jn, J === h.value]
              ])), 128))
            ], 2),
            Me(H.$slots, "default")
          ], 6)
        ]),
        _: 3
      })
    ], 8, ["disabled"]));
  }
});
var sN = /* @__PURE__ */ Ge(iN, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/image-viewer/src/image-viewer.vue"]]);
const oN = nn(sN), aN = ut({
  hideOnClickModal: Boolean,
  src: {
    type: String,
    default: ""
  },
  fit: {
    type: String,
    values: ["", "contain", "cover", "fill", "none", "scale-down"],
    default: ""
  },
  loading: {
    type: String,
    values: ["eager", "lazy"]
  },
  lazy: Boolean,
  scrollContainer: {
    type: Be([String, Object])
  },
  previewSrcList: {
    type: Be(Array),
    default: () => Cs([])
  },
  previewTeleported: Boolean,
  zIndex: {
    type: Number
  },
  initialIndex: {
    type: Number,
    default: 0
  },
  infinite: {
    type: Boolean,
    default: !0
  },
  closeOnPressEscape: {
    type: Boolean,
    default: !0
  },
  zoomRate: {
    type: Number,
    default: 1.2
  },
  minScale: {
    type: Number,
    default: 0.2
  },
  maxScale: {
    type: Number,
    default: 7
  }
}), lN = {
  load: (t) => t instanceof Event,
  error: (t) => t instanceof Event,
  switch: (t) => mt(t),
  close: () => !0,
  show: () => !0
}, uN = ["src", "loading"], cN = { key: 0 }, dN = be({
  name: "ElImage",
  inheritAttrs: !1
}), fN = /* @__PURE__ */ be({
  ...dN,
  props: aN,
  emits: lN,
  setup(t, { emit: e }) {
    const n = t;
    let r = "";
    const { t: i } = or(), s = Fe("image"), o = hv(), a = pg(), l = $(), u = $(!1), c = $(!0), d = $(!1), h = $(), v = $(), y = St && "loading" in HTMLImageElement.prototype;
    let b, p;
    const f = F(() => [
      s.e("inner"),
      w.value && s.e("preview"),
      c.value && s.is("loading")
    ]), g = F(() => o.style), m = F(() => {
      const { fit: U } = n;
      return St && U ? { objectFit: U } : {};
    }), w = F(() => {
      const { previewSrcList: U } = n;
      return Array.isArray(U) && U.length > 0;
    }), _ = F(() => {
      const { previewSrcList: U, initialIndex: H } = n;
      let re = H;
      return H > U.length - 1 && (re = 0), re;
    }), S = F(() => n.loading === "eager" ? !1 : !y && n.loading === "lazy" || n.lazy), A = () => {
      St && (c.value = !0, u.value = !1, l.value = n.src);
    };
    function C(U) {
      c.value = !1, u.value = !1, e("load", U);
    }
    function k(U) {
      c.value = !1, u.value = !0, e("error", U);
    }
    function O() {
      Eb(h.value, v.value) && (A(), M());
    }
    const N = lb(O, 200, !0);
    async function B() {
      var U;
      if (!St)
        return;
      await rt();
      const { scrollContainer: H } = n;
      ji(H) ? v.value = H : Gt(H) && H !== "" ? v.value = (U = document.querySelector(H)) != null ? U : void 0 : h.value && (v.value = Dx(h.value)), v.value && (b = bn(v, "scroll", N), setTimeout(() => O(), 100));
    }
    function M() {
      !St || !v.value || !N || (b == null || b(), v.value = void 0);
    }
    function j(U) {
      if (U.ctrlKey) {
        if (U.deltaY < 0)
          return U.preventDefault(), !1;
        if (U.deltaY > 0)
          return U.preventDefault(), !1;
      }
    }
    function q() {
      w.value && (p = bn("wheel", j, {
        passive: !1
      }), r = document.body.style.overflow, document.body.style.overflow = "hidden", d.value = !0, e("show"));
    }
    function X() {
      p == null || p(), document.body.style.overflow = r, d.value = !1, e("close");
    }
    function z(U) {
      e("switch", U);
    }
    return ke(() => n.src, () => {
      S.value ? (c.value = !0, u.value = !1, M(), B()) : A();
    }), Ct(() => {
      S.value ? B() : A();
    }), (U, H) => (V(), se("div", {
      ref_key: "container",
      ref: h,
      class: ee([x(s).b(), U.$attrs.class]),
      style: it(x(g))
    }, [
      u.value ? Me(U.$slots, "error", { key: 0 }, () => [
        ae("div", {
          class: ee(x(s).e("error"))
        }, st(x(i)("el.image.error")), 3)
      ]) : (V(), se(Ft, { key: 1 }, [
        l.value !== void 0 ? (V(), se("img", Gn({ key: 0 }, x(a), {
          src: l.value,
          loading: U.loading,
          style: x(m),
          class: x(f),
          onClick: q,
          onLoad: C,
          onError: k
        }), null, 16, uN)) : ye("v-if", !0),
        c.value ? (V(), se("div", {
          key: 1,
          class: ee(x(s).e("wrapper"))
        }, [
          Me(U.$slots, "placeholder", {}, () => [
            ae("div", {
              class: ee(x(s).e("placeholder"))
            }, null, 2)
          ])
        ], 2)) : ye("v-if", !0)
      ], 64)),
      x(w) ? (V(), se(Ft, { key: 2 }, [
        d.value ? (V(), Ae(x(oN), {
          key: 0,
          "z-index": U.zIndex,
          "initial-index": x(_),
          infinite: U.infinite,
          "zoom-rate": U.zoomRate,
          "min-scale": U.minScale,
          "max-scale": U.maxScale,
          "url-list": U.previewSrcList,
          "hide-on-click-modal": U.hideOnClickModal,
          teleported: U.previewTeleported,
          "close-on-press-escape": U.closeOnPressEscape,
          onClose: X,
          onSwitch: z
        }, {
          default: de(() => [
            U.$slots.viewer ? (V(), se("div", cN, [
              Me(U.$slots, "viewer")
            ])) : ye("v-if", !0)
          ]),
          _: 3
        }, 8, ["z-index", "initial-index", "infinite", "zoom-rate", "min-scale", "max-scale", "url-list", "hide-on-click-modal", "teleported", "close-on-press-escape"])) : ye("v-if", !0)
      ], 64)) : ye("v-if", !0)
    ], 6));
  }
});
var hN = /* @__PURE__ */ Ge(fN, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/image/src/image.vue"]]);
const pN = nn(hN), vN = ut({
  id: {
    type: String,
    default: void 0
  },
  step: {
    type: Number,
    default: 1
  },
  stepStrictly: Boolean,
  max: {
    type: Number,
    default: Number.POSITIVE_INFINITY
  },
  min: {
    type: Number,
    default: Number.NEGATIVE_INFINITY
  },
  modelValue: Number,
  readonly: Boolean,
  disabled: Boolean,
  size: Rr,
  controls: {
    type: Boolean,
    default: !0
  },
  controlsPosition: {
    type: String,
    default: "",
    values: ["", "right"]
  },
  valueOnClear: {
    type: [String, Number, null],
    validator: (t) => t === null || mt(t) || ["min", "max"].includes(t),
    default: null
  },
  name: String,
  label: String,
  placeholder: String,
  precision: {
    type: Number,
    validator: (t) => t >= 0 && t === Number.parseInt(`${t}`, 10)
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), gN = {
  [Ji]: (t, e) => e !== t,
  blur: (t) => t instanceof FocusEvent,
  focus: (t) => t instanceof FocusEvent,
  [Pi]: (t) => mt(t) || er(t),
  [Bt]: (t) => mt(t) || er(t)
}, mN = ["aria-label", "onKeydown"], yN = ["aria-label", "onKeydown"], bN = be({
  name: "ElInputNumber"
}), wN = /* @__PURE__ */ be({
  ...bN,
  props: vN,
  emits: gN,
  setup(t, { expose: e, emit: n }) {
    const r = t, { t: i } = or(), s = Fe("input-number"), o = $(), a = Bn({
      currentValue: r.modelValue,
      userInput: null
    }), { formItem: l } = oi(), u = F(() => mt(r.modelValue) && r.modelValue <= r.min), c = F(() => mt(r.modelValue) && r.modelValue >= r.max), d = F(() => {
      const M = f(r.step);
      return Sr(r.precision) ? Math.max(f(r.modelValue), M) : (M > r.precision && Vt("InputNumber", "precision should not be less than the decimal places of step"), r.precision);
    }), h = F(() => r.controls && r.controlsPosition === "right"), v = Pr(), y = Br(), b = F(() => {
      if (a.userInput !== null)
        return a.userInput;
      let M = a.currentValue;
      if (er(M))
        return "";
      if (mt(M)) {
        if (Number.isNaN(M))
          return "";
        Sr(r.precision) || (M = M.toFixed(r.precision));
      }
      return M;
    }), p = (M, j) => {
      if (Sr(j) && (j = d.value), j === 0)
        return Math.round(M);
      let q = String(M);
      const X = q.indexOf(".");
      if (X === -1 || !q.replace(".", "").split("")[X + j])
        return M;
      const H = q.length;
      return q.charAt(H - 1) === "5" && (q = `${q.slice(0, Math.max(0, H - 1))}6`), Number.parseFloat(Number(q).toFixed(j));
    }, f = (M) => {
      if (er(M))
        return 0;
      const j = M.toString(), q = j.indexOf(".");
      let X = 0;
      return q !== -1 && (X = j.length - q - 1), X;
    }, g = (M, j = 1) => mt(M) ? p(M + r.step * j) : a.currentValue, m = () => {
      if (r.readonly || y.value || c.value)
        return;
      const M = Number(b.value) || 0, j = g(M);
      S(j), n(Pi, a.currentValue);
    }, w = () => {
      if (r.readonly || y.value || u.value)
        return;
      const M = Number(b.value) || 0, j = g(M, -1);
      S(j), n(Pi, a.currentValue);
    }, _ = (M, j) => {
      const { max: q, min: X, step: z, precision: U, stepStrictly: H, valueOnClear: re } = r;
      q < X && qi("InputNumber", "min should not be greater than max.");
      let fe = Number(M);
      if (er(M) || Number.isNaN(fe))
        return null;
      if (M === "") {
        if (re === null)
          return null;
        fe = Gt(re) ? { min: X, max: q }[re] : re;
      }
      return H && (fe = p(Math.round(fe / z) * z, U)), Sr(U) || (fe = p(fe, U)), (fe > q || fe < X) && (fe = fe > q ? q : X, j && n(Bt, fe)), fe;
    }, S = (M, j = !0) => {
      var q;
      const X = a.currentValue, z = _(M);
      if (!j) {
        n(Bt, z);
        return;
      }
      X !== z && (a.userInput = null, n(Bt, z), n(Ji, z, X), r.validateEvent && ((q = l == null ? void 0 : l.validate) == null || q.call(l, "change").catch((U) => Vt(U))), a.currentValue = z);
    }, A = (M) => {
      a.userInput = M;
      const j = M === "" ? null : Number(M);
      n(Pi, j), S(j, !1);
    }, C = (M) => {
      const j = M !== "" ? Number(M) : "";
      (mt(j) && !Number.isNaN(j) || M === "") && S(j), a.userInput = null;
    }, k = () => {
      var M, j;
      (j = (M = o.value) == null ? void 0 : M.focus) == null || j.call(M);
    }, O = () => {
      var M, j;
      (j = (M = o.value) == null ? void 0 : M.blur) == null || j.call(M);
    }, N = (M) => {
      n("focus", M);
    }, B = (M) => {
      var j;
      n("blur", M), r.validateEvent && ((j = l == null ? void 0 : l.validate) == null || j.call(l, "blur").catch((q) => Vt(q)));
    };
    return ke(() => r.modelValue, (M) => {
      const j = _(a.userInput), q = _(M, !0);
      !mt(j) && (!j || j !== q) && (a.currentValue = q, a.userInput = null);
    }, { immediate: !0 }), Ct(() => {
      var M;
      const { min: j, max: q, modelValue: X } = r, z = (M = o.value) == null ? void 0 : M.input;
      if (z.setAttribute("role", "spinbutton"), Number.isFinite(q) ? z.setAttribute("aria-valuemax", String(q)) : z.removeAttribute("aria-valuemax"), Number.isFinite(j) ? z.setAttribute("aria-valuemin", String(j)) : z.removeAttribute("aria-valuemin"), z.setAttribute("aria-valuenow", a.currentValue || a.currentValue === 0 ? String(a.currentValue) : ""), z.setAttribute("aria-disabled", String(y.value)), !mt(X) && X != null) {
        let U = Number(X);
        Number.isNaN(U) && (U = null), n(Bt, U);
      }
    }), Ml(() => {
      var M, j;
      const q = (M = o.value) == null ? void 0 : M.input;
      q == null || q.setAttribute("aria-valuenow", `${(j = a.currentValue) != null ? j : ""}`);
    }), e({
      focus: k,
      blur: O
    }), (M, j) => (V(), se("div", {
      class: ee([
        x(s).b(),
        x(s).m(x(v)),
        x(s).is("disabled", x(y)),
        x(s).is("without-controls", !M.controls),
        x(s).is("controls-right", x(h))
      ]),
      onDragstart: j[1] || (j[1] = ft(() => {
      }, ["prevent"]))
    }, [
      M.controls ? Dt((V(), se("span", {
        key: 0,
        role: "button",
        "aria-label": x(i)("el.inputNumber.decrease"),
        class: ee([x(s).e("decrease"), x(s).is("disabled", x(u))]),
        onKeydown: vn(w, ["enter"])
      }, [
        ve(x(_t), null, {
          default: de(() => [
            x(h) ? (V(), Ae(x(Od), { key: 0 })) : (V(), Ae(x(Ik), { key: 1 }))
          ]),
          _: 1
        })
      ], 42, mN)), [
        [x(Xh), w]
      ]) : ye("v-if", !0),
      M.controls ? Dt((V(), se("span", {
        key: 1,
        role: "button",
        "aria-label": x(i)("el.inputNumber.increase"),
        class: ee([x(s).e("increase"), x(s).is("disabled", x(c))]),
        onKeydown: vn(m, ["enter"])
      }, [
        ve(x(_t), null, {
          default: de(() => [
            x(h) ? (V(), Ae(x(sg), { key: 0 })) : (V(), Ae(x(ug), { key: 1 }))
          ]),
          _: 1
        })
      ], 42, yN)), [
        [x(Xh), m]
      ]) : ye("v-if", !0),
      ve(x(Jl), {
        id: M.id,
        ref_key: "input",
        ref: o,
        type: "number",
        step: M.step,
        "model-value": x(b),
        placeholder: M.placeholder,
        readonly: M.readonly,
        disabled: x(y),
        size: x(v),
        max: M.max,
        min: M.min,
        name: M.name,
        label: M.label,
        "validate-event": !1,
        onWheel: j[0] || (j[0] = ft(() => {
        }, ["prevent"])),
        onKeydown: [
          vn(ft(m, ["prevent"]), ["up"]),
          vn(ft(w, ["prevent"]), ["down"])
        ],
        onBlur: B,
        onFocus: N,
        onInput: A,
        onChange: C
      }, null, 8, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "label", "onKeydown"])
    ], 34));
  }
});
var _N = /* @__PURE__ */ Ge(wN, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input-number/src/input-number.vue"]]);
const xm = nn(_N), Am = Symbol("ElSelectGroup"), Zl = Symbol("ElSelect");
function SN(t, e) {
  const n = tt(Zl), r = tt(Am, { disabled: !1 }), i = F(() => wn(t.value)), s = F(() => n.props.multiple ? d(n.props.modelValue, t.value) : h(t.value, n.props.modelValue)), o = F(() => {
    if (n.props.multiple) {
      const b = n.props.modelValue || [];
      return !s.value && b.length >= n.props.multipleLimit && n.props.multipleLimit > 0;
    } else
      return !1;
  }), a = F(() => t.label || (i.value ? "" : t.value)), l = F(() => t.value || t.label || ""), u = F(() => t.disabled || e.groupDisabled || o.value), c = ht(), d = (b = [], p) => {
    if (i.value) {
      const f = n.props.valueKey;
      return b && b.some((g) => yi(An(g, f)) === An(p, f));
    } else
      return b && b.includes(p);
  }, h = (b, p) => {
    if (i.value) {
      const { valueKey: f } = n.props;
      return An(b, f) === An(p, f);
    } else
      return b === p;
  }, v = () => {
    !t.disabled && !r.disabled && (n.hoverIndex = n.optionsArray.indexOf(c.proxy));
  };
  ke(() => a.value, () => {
    !t.created && !n.props.remote && n.setSelected();
  }), ke(() => t.value, (b, p) => {
    const { remote: f, valueKey: g } = n.props;
    if (Object.is(b, p) || (n.onOptionDestroy(p, c.proxy), n.onOptionCreate(c.proxy)), !t.created && !f) {
      if (g && wn(b) && wn(p) && b[g] === p[g])
        return;
      n.setSelected();
    }
  }), ke(() => r.disabled, () => {
    e.groupDisabled = r.disabled;
  }, { immediate: !0 });
  const { queryChange: y } = yi(n);
  return ke(y, (b) => {
    const { query: p } = x(b), f = new RegExp(Ix(p), "i");
    e.visible = f.test(a.value) || t.created, e.visible || n.filteredOptionsCount--;
  }, { immediate: !0 }), {
    select: n,
    currentLabel: a,
    currentValue: l,
    itemSelected: s,
    isDisabled: u,
    hoverItem: v
  };
}
const EN = be({
  name: "ElOption",
  componentName: "ElOption",
  props: {
    value: {
      required: !0,
      type: [String, Number, Boolean, Object]
    },
    label: [String, Number],
    created: Boolean,
    disabled: Boolean
  },
  setup(t) {
    const e = Fe("select"), n = Xo(), r = F(() => [
      e.be("dropdown", "item"),
      e.is("disabled", x(a)),
      {
        selected: x(o),
        hover: x(d)
      }
    ]), i = Bn({
      index: -1,
      groupDisabled: !1,
      visible: !0,
      hitState: !1,
      hover: !1
    }), { currentLabel: s, itemSelected: o, isDisabled: a, select: l, hoverItem: u } = SN(t, i), { visible: c, hover: d } = hn(i), h = ht().proxy;
    l.onOptionCreate(h), En(() => {
      const y = h.value, { selected: b } = l, f = (l.props.multiple ? b : [b]).some((g) => g.value === h.value);
      rt(() => {
        l.cachedOptions.get(y) === h && !f && l.cachedOptions.delete(y);
      }), l.onOptionDestroy(y, h);
    });
    function v() {
      t.disabled !== !0 && i.groupDisabled !== !0 && l.handleOptionSelect(h);
    }
    return {
      ns: e,
      id: n,
      containerKls: r,
      currentLabel: s,
      itemSelected: o,
      isDisabled: a,
      select: l,
      hoverItem: u,
      visible: c,
      hover: d,
      selectOptionClick: v,
      states: i
    };
  }
}), xN = ["id", "aria-disabled", "aria-selected"];
function AN(t, e, n, r, i, s) {
  return Dt((V(), se("li", {
    id: t.id,
    class: ee(t.containerKls),
    role: "option",
    "aria-disabled": t.isDisabled || void 0,
    "aria-selected": t.itemSelected,
    onMouseenter: e[0] || (e[0] = (...o) => t.hoverItem && t.hoverItem(...o)),
    onClick: e[1] || (e[1] = ft((...o) => t.selectOptionClick && t.selectOptionClick(...o), ["stop"]))
  }, [
    Me(t.$slots, "default", {}, () => [
      ae("span", null, st(t.currentLabel), 1)
    ])
  ], 42, xN)), [
    [Jn, t.visible]
  ]);
}
var Jd = /* @__PURE__ */ Ge(EN, [["render", AN], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option.vue"]]);
const kN = be({
  name: "ElSelectDropdown",
  componentName: "ElSelectDropdown",
  setup() {
    const t = tt(Zl), e = Fe("select"), n = F(() => t.props.popperClass), r = F(() => t.props.multiple), i = F(() => t.props.fitInputWidth), s = $("");
    function o() {
      var a;
      s.value = `${(a = t.selectWrapper) == null ? void 0 : a.offsetWidth}px`;
    }
    return Ct(() => {
      o(), As(t.selectWrapper, o);
    }), {
      ns: e,
      minWidth: s,
      popperClass: n,
      isMultiple: r,
      isFitInputWidth: i
    };
  }
});
function CN(t, e, n, r, i, s) {
  return V(), se("div", {
    class: ee([t.ns.b("dropdown"), t.ns.is("multiple", t.isMultiple), t.popperClass]),
    style: it({ [t.isFitInputWidth ? "width" : "minWidth"]: t.minWidth })
  }, [
    Me(t.$slots, "default")
  ], 6);
}
var TN = /* @__PURE__ */ Ge(kN, [["render", CN], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select-dropdown.vue"]]);
function ON(t) {
  const { t: e } = or();
  return Bn({
    options: /* @__PURE__ */ new Map(),
    cachedOptions: /* @__PURE__ */ new Map(),
    disabledOptions: /* @__PURE__ */ new Map(),
    createdLabel: null,
    createdSelected: !1,
    selected: t.multiple ? [] : {},
    inputLength: 20,
    inputWidth: 0,
    optionsCount: 0,
    filteredOptionsCount: 0,
    visible: !1,
    selectedLabel: "",
    hoverIndex: -1,
    query: "",
    previousQuery: null,
    inputHovering: !1,
    cachedPlaceHolder: "",
    currentPlaceholder: e("el.select.placeholder"),
    menuVisibleOnFocus: !1,
    isOnComposition: !1,
    prefixWidth: 11,
    mouseEnter: !1,
    focused: !1
  });
}
const IN = (t, e, n) => {
  const { t: r } = or(), i = Fe("select");
  vg({
    from: "suffixTransition",
    replacement: "override style scheme",
    version: "2.3.0",
    scope: "props",
    ref: "https://element-plus.org/en-US/component/select.html#select-attributes"
  }, F(() => t.suffixTransition === !1));
  const s = $(null), o = $(null), a = $(null), l = $(null), u = $(null), c = $(null), d = $(null), h = $(null), v = $(), y = zn({ query: "" }), b = zn(""), p = $([]);
  let f = 0;
  const { form: g, formItem: m } = oi(), w = F(() => !t.filterable || t.multiple || !e.visible), _ = F(() => t.disabled || (g == null ? void 0 : g.disabled)), S = F(() => {
    const L = t.multiple ? Array.isArray(t.modelValue) && t.modelValue.length > 0 : t.modelValue !== void 0 && t.modelValue !== null && t.modelValue !== "";
    return t.clearable && !_.value && e.inputHovering && L;
  }), A = F(() => t.remote && t.filterable && !t.remoteShowSuffix ? "" : t.suffixIcon), C = F(() => i.is("reverse", A.value && e.visible && t.suffixTransition)), k = F(() => (g == null ? void 0 : g.statusIcon) && (m == null ? void 0 : m.validateState) && fg[m == null ? void 0 : m.validateState]), O = F(() => t.remote ? 300 : 0), N = F(() => t.loading ? t.loadingText || r("el.select.loading") : t.remote && e.query === "" && e.options.size === 0 ? !1 : t.filterable && e.query && e.options.size > 0 && e.filteredOptionsCount === 0 ? t.noMatchText || r("el.select.noMatch") : e.options.size === 0 ? t.noDataText || r("el.select.noData") : null), B = F(() => {
    const L = Array.from(e.options.values()), oe = [];
    return p.value.forEach((E) => {
      const Q = L.findIndex((ie) => ie.currentLabel === E);
      Q > -1 && oe.push(L[Q]);
    }), oe.length >= L.length ? oe : L;
  }), M = F(() => Array.from(e.cachedOptions.values())), j = F(() => {
    const L = B.value.filter((oe) => !oe.created).some((oe) => oe.currentLabel === e.query);
    return t.filterable && t.allowCreate && e.query !== "" && !L;
  }), q = Pr(), X = F(() => ["small"].includes(q.value) ? "small" : "default"), z = F({
    get() {
      return e.visible && N.value !== !1;
    },
    set(L) {
      e.visible = L;
    }
  });
  ke([() => _.value, () => q.value, () => g == null ? void 0 : g.size], () => {
    rt(() => {
      U();
    });
  }), ke(() => t.placeholder, (L) => {
    e.cachedPlaceHolder = e.currentPlaceholder = L, t.multiple && Array.isArray(t.modelValue) && t.modelValue.length > 0 && (e.currentPlaceholder = "");
  }), ke(() => t.modelValue, (L, oe) => {
    t.multiple && (U(), L && L.length > 0 || o.value && e.query !== "" ? e.currentPlaceholder = "" : e.currentPlaceholder = e.cachedPlaceHolder, t.filterable && !t.reserveKeyword && (e.query = "", H(e.query))), J(), t.filterable && !t.multiple && (e.inputLength = 20), !ll(L, oe) && t.validateEvent && (m == null || m.validate("change").catch((E) => Vt(E)));
  }, {
    flush: "post",
    deep: !0
  }), ke(() => e.visible, (L) => {
    var oe, E, Q, ie, I;
    L ? ((E = (oe = l.value) == null ? void 0 : oe.updatePopper) == null || E.call(oe), t.filterable && (e.filteredOptionsCount = e.optionsCount, e.query = t.remote ? "" : e.selectedLabel, (ie = (Q = a.value) == null ? void 0 : Q.focus) == null || ie.call(Q), t.multiple ? (I = o.value) == null || I.focus() : e.selectedLabel && (e.currentPlaceholder = `${e.selectedLabel}`, e.selectedLabel = ""), H(e.query), !t.multiple && !t.remote && (y.value.query = "", qs(y), qs(b)))) : (t.filterable && (gn(t.filterMethod) && t.filterMethod(""), gn(t.remoteMethod) && t.remoteMethod("")), e.query = "", e.previousQuery = null, e.selectedLabel = "", e.inputLength = 20, e.menuVisibleOnFocus = !1, ce(), rt(() => {
      o.value && o.value.value === "" && e.selected.length === 0 && (e.currentPlaceholder = e.cachedPlaceHolder);
    }), t.multiple || (e.selected && (t.filterable && t.allowCreate && e.createdSelected && e.createdLabel ? e.selectedLabel = e.createdLabel : e.selectedLabel = e.selected.currentLabel, t.filterable && (e.query = e.selectedLabel)), t.filterable && (e.currentPlaceholder = e.cachedPlaceHolder))), n.emit("visible-change", L);
  }), ke(() => e.options.entries(), () => {
    var L, oe, E;
    if (!St)
      return;
    (oe = (L = l.value) == null ? void 0 : L.updatePopper) == null || oe.call(L), t.multiple && U();
    const Q = ((E = d.value) == null ? void 0 : E.querySelectorAll("input")) || [];
    (!t.filterable && !t.defaultFirstOption && !Sr(t.modelValue) || !Array.from(Q).includes(document.activeElement)) && J(), t.defaultFirstOption && (t.filterable || t.remote) && e.filteredOptionsCount && fe();
  }, {
    flush: "post"
  }), ke(() => e.hoverIndex, (L) => {
    mt(L) && L > -1 ? v.value = B.value[L] || {} : v.value = {}, B.value.forEach((oe) => {
      oe.hover = v.value === oe;
    });
  });
  const U = () => {
    rt(() => {
      var L, oe;
      if (!s.value)
        return;
      const E = s.value.$el.querySelector("input");
      f = f || (E.clientHeight > 0 ? E.clientHeight + 2 : 0);
      const Q = c.value, ie = getComputedStyle(E).getPropertyValue(i.cssVarName("input-height")), I = Number.parseFloat(ie) || ZC(q.value || (g == null ? void 0 : g.size)), W = q.value || I === f || f <= 0 ? I : f;
      !(E.offsetParent === null) && (E.style.height = `${(e.selected.length === 0 ? W : Math.max(Q ? Q.clientHeight + (Q.clientHeight > W ? 6 : 0) : 0, W)) - 2}px`), e.visible && N.value !== !1 && ((oe = (L = l.value) == null ? void 0 : L.updatePopper) == null || oe.call(L));
    });
  }, H = async (L) => {
    if (!(e.previousQuery === L || e.isOnComposition)) {
      if (e.previousQuery === null && (gn(t.filterMethod) || gn(t.remoteMethod))) {
        e.previousQuery = L;
        return;
      }
      e.previousQuery = L, rt(() => {
        var oe, E;
        e.visible && ((E = (oe = l.value) == null ? void 0 : oe.updatePopper) == null || E.call(oe));
      }), e.hoverIndex = -1, t.multiple && t.filterable && rt(() => {
        if (!_.value) {
          const oe = o.value.value.length * 15 + 20;
          e.inputLength = t.collapseTags ? Math.min(50, oe) : oe, re();
        }
        U();
      }), t.remote && gn(t.remoteMethod) ? (e.hoverIndex = -1, t.remoteMethod(L)) : gn(t.filterMethod) ? (t.filterMethod(L), qs(b)) : (e.filteredOptionsCount = e.optionsCount, y.value.query = L, qs(y), qs(b)), t.defaultFirstOption && (t.filterable || t.remote) && e.filteredOptionsCount && (await rt(), fe());
    }
  }, re = () => {
    e.currentPlaceholder !== "" && (e.currentPlaceholder = o.value.value ? "" : e.cachedPlaceHolder);
  }, fe = () => {
    const L = B.value.filter((Q) => Q.visible && !Q.disabled && !Q.states.groupDisabled), oe = L.find((Q) => Q.created), E = L[0];
    e.hoverIndex = Nt(B.value, oe || E);
  }, J = () => {
    var L;
    if (t.multiple)
      e.selectedLabel = "";
    else {
      const E = le(t.modelValue);
      (L = E.props) != null && L.created ? (e.createdLabel = E.props.value, e.createdSelected = !0) : e.createdSelected = !1, e.selectedLabel = E.currentLabel, e.selected = E, t.filterable && (e.query = e.selectedLabel);
      return;
    }
    const oe = [];
    Array.isArray(t.modelValue) && t.modelValue.forEach((E) => {
      oe.push(le(E));
    }), e.selected = oe, rt(() => {
      U();
    });
  }, le = (L) => {
    let oe;
    const E = hu(L).toLowerCase() === "object", Q = hu(L).toLowerCase() === "null", ie = hu(L).toLowerCase() === "undefined";
    for (let ne = e.cachedOptions.size - 1; ne >= 0; ne--) {
      const Pe = M.value[ne];
      if (E ? An(Pe.value, t.valueKey) === An(L, t.valueKey) : Pe.value === L) {
        oe = {
          value: L,
          currentLabel: Pe.currentLabel,
          isDisabled: Pe.isDisabled
        };
        break;
      }
    }
    if (oe)
      return oe;
    const I = E ? L.label : !Q && !ie ? L : "", W = {
      value: L,
      currentLabel: I
    };
    return t.multiple && (W.hitState = !1), W;
  }, ce = () => {
    setTimeout(() => {
      const L = t.valueKey;
      t.multiple ? e.selected.length > 0 ? e.hoverIndex = Math.min.apply(null, e.selected.map((oe) => B.value.findIndex((E) => An(E, L) === An(oe, L)))) : e.hoverIndex = -1 : e.hoverIndex = B.value.findIndex((oe) => Qe(oe) === Qe(e.selected));
    }, 300);
  }, ge = () => {
    var L, oe;
    _e(), (oe = (L = l.value) == null ? void 0 : L.updatePopper) == null || oe.call(L), t.multiple && U();
  }, _e = () => {
    var L;
    e.inputWidth = (L = s.value) == null ? void 0 : L.$el.offsetWidth;
  }, je = () => {
    t.filterable && e.query !== e.selectedLabel && (e.query = e.selectedLabel, H(e.query));
  }, Te = Yr(() => {
    je();
  }, O.value), Ze = Yr((L) => {
    H(L.target.value);
  }, O.value), Le = (L) => {
    ll(t.modelValue, L) || n.emit(Ji, L);
  }, Ke = (L) => mx(L, (oe) => !e.disabledOptions.has(oe)), ct = (L) => {
    if (L.code !== sn.delete) {
      if (L.target.value.length <= 0 && !lt()) {
        const oe = t.modelValue.slice(), E = Ke(oe);
        if (E < 0)
          return;
        oe.splice(E, 1), n.emit(Bt, oe), Le(oe);
      }
      L.target.value.length === 1 && t.modelValue.length === 0 && (e.currentPlaceholder = e.cachedPlaceHolder);
    }
  }, nt = (L, oe) => {
    const E = e.selected.indexOf(oe);
    if (E > -1 && !_.value) {
      const Q = t.modelValue.slice();
      Q.splice(E, 1), n.emit(Bt, Q), Le(Q), n.emit("remove-tag", oe.value);
    }
    L.stopPropagation(), Ue();
  }, Et = (L) => {
    L.stopPropagation();
    const oe = t.multiple ? [] : "";
    if (!Gt(oe))
      for (const E of e.selected)
        E.isDisabled && oe.push(E.value);
    n.emit(Bt, oe), Le(oe), e.hoverIndex = -1, e.visible = !1, n.emit("clear"), Ue();
  }, yt = (L) => {
    var oe;
    if (t.multiple) {
      const E = (t.modelValue || []).slice(), Q = Nt(E, L.value);
      Q > -1 ? E.splice(Q, 1) : (t.multipleLimit <= 0 || E.length < t.multipleLimit) && E.push(L.value), n.emit(Bt, E), Le(E), L.created && (e.query = "", H(""), e.inputLength = 20), t.filterable && ((oe = o.value) == null || oe.focus());
    } else
      n.emit(Bt, L.value), Le(L.value), e.visible = !1;
    ot(), !e.visible && rt(() => {
      bt(L);
    });
  }, Nt = (L = [], oe) => {
    if (!wn(oe))
      return L.indexOf(oe);
    const E = t.valueKey;
    let Q = -1;
    return L.some((ie, I) => yi(An(ie, E)) === An(oe, E) ? (Q = I, !0) : !1), Q;
  }, ot = () => {
    const L = o.value || s.value;
    L && (L == null || L.focus());
  }, bt = (L) => {
    var oe, E, Q, ie, I;
    const W = Array.isArray(L) ? L[0] : L;
    let ne = null;
    if (W != null && W.value) {
      const Pe = B.value.filter((Oe) => Oe.value === W.value);
      Pe.length > 0 && (ne = Pe[0].$el);
    }
    if (l.value && ne) {
      const Pe = (ie = (Q = (E = (oe = l.value) == null ? void 0 : oe.popperRef) == null ? void 0 : E.contentRef) == null ? void 0 : Q.querySelector) == null ? void 0 : ie.call(Q, `.${i.be("dropdown", "wrap")}`);
      Pe && Mx(Pe, ne);
    }
    (I = h.value) == null || I.handleScroll();
  }, $t = (L) => {
    e.optionsCount++, e.filteredOptionsCount++, e.options.set(L.value, L), e.cachedOptions.set(L.value, L), L.disabled && e.disabledOptions.set(L.value, L);
  }, wt = (L, oe) => {
    e.options.get(L) === oe && (e.optionsCount--, e.filteredOptionsCount--, e.options.delete(L));
  }, xt = (L) => {
    L.code !== sn.backspace && lt(!1), e.inputLength = o.value.value.length * 15 + 20, U();
  }, lt = (L) => {
    if (!Array.isArray(e.selected))
      return;
    const oe = Ke(e.selected.map((Q) => Q.value)), E = e.selected[oe];
    if (E)
      return L === !0 || L === !1 ? (E.hitState = L, L) : (E.hitState = !E.hitState, E.hitState);
  }, qe = (L) => {
    const oe = L.target.value;
    if (L.type === "compositionend")
      e.isOnComposition = !1, rt(() => H(oe));
    else {
      const E = oe[oe.length - 1] || "";
      e.isOnComposition = !hg(E);
    }
  }, Rt = () => {
    rt(() => bt(e.selected));
  }, we = (L) => {
    e.focused || ((t.automaticDropdown || t.filterable) && (t.filterable && !e.visible && (e.menuVisibleOnFocus = !0), e.visible = !0), e.focused = !0, n.emit("focus", L));
  }, Ue = () => {
    var L, oe;
    e.visible ? (L = o.value || s.value) == null || L.focus() : (oe = s.value) == null || oe.focus();
  }, at = () => {
    var L, oe, E;
    e.visible = !1, (L = s.value) == null || L.blur(), (E = (oe = a.value) == null ? void 0 : oe.blur) == null || E.call(oe);
  }, Pt = (L) => {
    var oe, E, Q;
    (oe = l.value) != null && oe.isFocusInsideContent(L) || (E = u.value) != null && E.isFocusInsideContent(L) || (Q = d.value) != null && Q.contains(L.relatedTarget) || (e.visible && Ie(), e.focused = !1, n.emit("blur", L));
  }, Qt = (L) => {
    Et(L);
  }, Ie = () => {
    e.visible = !1;
  }, Ve = (L) => {
    e.visible && (L.preventDefault(), L.stopPropagation(), e.visible = !1);
  }, Je = (L) => {
    L && !e.mouseEnter || _.value || (e.menuVisibleOnFocus ? e.menuVisibleOnFocus = !1 : (!l.value || !l.value.isFocusInsideContent()) && (e.visible = !e.visible), Ue());
  }, He = () => {
    e.visible ? B.value[e.hoverIndex] && yt(B.value[e.hoverIndex]) : Je();
  }, Qe = (L) => wn(L.value) ? An(L.value, t.valueKey) : L.value, At = F(() => B.value.filter((L) => L.visible).every((L) => L.disabled)), P = F(() => t.multiple ? e.selected.slice(0, t.maxCollapseTags) : []), he = F(() => t.multiple ? e.selected.slice(t.maxCollapseTags) : []), me = (L) => {
    if (!e.visible) {
      e.visible = !0;
      return;
    }
    if (!(e.options.size === 0 || e.filteredOptionsCount === 0) && !e.isOnComposition && !At.value) {
      L === "next" ? (e.hoverIndex++, e.hoverIndex === e.options.size && (e.hoverIndex = 0)) : L === "prev" && (e.hoverIndex--, e.hoverIndex < 0 && (e.hoverIndex = e.options.size - 1));
      const oe = B.value[e.hoverIndex];
      (oe.disabled === !0 || oe.states.groupDisabled === !0 || !oe.visible) && me(L), rt(() => bt(v.value));
    }
  }, Ne = () => {
    e.mouseEnter = !0;
  }, G = () => {
    e.mouseEnter = !1;
  }, ue = (L, oe) => {
    var E, Q;
    nt(L, oe), (Q = (E = u.value) == null ? void 0 : E.updatePopper) == null || Q.call(E);
  }, T = F(() => ({
    maxWidth: `${x(e.inputWidth) - 32 - (k.value ? 22 : 0)}px`,
    width: "100%"
  }));
  return {
    optionList: p,
    optionsArray: B,
    hoverOption: v,
    selectSize: q,
    handleResize: ge,
    debouncedOnInputChange: Te,
    debouncedQueryChange: Ze,
    deletePrevTag: ct,
    deleteTag: nt,
    deleteSelected: Et,
    handleOptionSelect: yt,
    scrollToOption: bt,
    readonly: w,
    resetInputHeight: U,
    showClose: S,
    iconComponent: A,
    iconReverse: C,
    showNewOption: j,
    collapseTagSize: X,
    setSelected: J,
    managePlaceholder: re,
    selectDisabled: _,
    emptyText: N,
    toggleLastOptionHitState: lt,
    resetInputState: xt,
    handleComposition: qe,
    onOptionCreate: $t,
    onOptionDestroy: wt,
    handleMenuEnter: Rt,
    handleFocus: we,
    focus: Ue,
    blur: at,
    handleBlur: Pt,
    handleClearClick: Qt,
    handleClose: Ie,
    handleKeydownEscape: Ve,
    toggleMenu: Je,
    selectOption: He,
    getValueKey: Qe,
    navigateOptions: me,
    handleDeleteTooltipTag: ue,
    dropMenuVisible: z,
    queryChange: y,
    groupQueryChange: b,
    showTagList: P,
    collapseTagList: he,
    selectTagsStyle: T,
    reference: s,
    input: o,
    iOSInput: a,
    tooltipRef: l,
    tagTooltipRef: u,
    tags: c,
    selectWrapper: d,
    scrollbar: h,
    handleMouseEnter: Ne,
    handleMouseLeave: G
  };
};
var NN = be({
  name: "ElOptions",
  emits: ["update-options"],
  setup(t, { slots: e, emit: n }) {
    let r = [];
    function i(s, o) {
      if (s.length !== o.length)
        return !1;
      for (const [a] of s.entries())
        if (s[a] != o[a])
          return !1;
      return !0;
    }
    return () => {
      var s, o;
      const a = (s = e.default) == null ? void 0 : s.call(e), l = [];
      function u(c) {
        Array.isArray(c) && c.forEach((d) => {
          var h, v, y, b;
          const p = (h = (d == null ? void 0 : d.type) || {}) == null ? void 0 : h.name;
          p === "ElOptionGroup" ? u(!Gt(d.children) && !Array.isArray(d.children) && gn((v = d.children) == null ? void 0 : v.default) ? (y = d.children) == null ? void 0 : y.default() : d.children) : p === "ElOption" ? l.push((b = d.props) == null ? void 0 : b.label) : Array.isArray(d.children) && u(d.children);
        });
      }
      return a.length && u((o = a[0]) == null ? void 0 : o.children), i(l, r) || (r = l, n("update-options", l)), a;
    };
  }
});
const ip = "ElSelect", RN = be({
  name: ip,
  componentName: ip,
  components: {
    ElInput: Jl,
    ElSelectMenu: TN,
    ElOption: Jd,
    ElOptions: NN,
    ElTag: x4,
    ElScrollbar: Wd,
    ElTooltip: Ql,
    ElIcon: _t
  },
  directives: { ClickOutside: Zg },
  props: {
    name: String,
    id: String,
    modelValue: {
      type: [Array, String, Number, Boolean, Object],
      default: void 0
    },
    autocomplete: {
      type: String,
      default: "off"
    },
    automaticDropdown: Boolean,
    size: {
      type: String,
      validator: XC
    },
    effect: {
      type: String,
      default: "light"
    },
    disabled: Boolean,
    clearable: Boolean,
    filterable: Boolean,
    allowCreate: Boolean,
    loading: Boolean,
    popperClass: {
      type: String,
      default: ""
    },
    popperOptions: {
      type: Object,
      default: () => ({})
    },
    remote: Boolean,
    loadingText: String,
    noMatchText: String,
    noDataText: String,
    remoteMethod: Function,
    filterMethod: Function,
    multiple: Boolean,
    multipleLimit: {
      type: Number,
      default: 0
    },
    placeholder: {
      type: String
    },
    defaultFirstOption: Boolean,
    reserveKeyword: {
      type: Boolean,
      default: !0
    },
    valueKey: {
      type: String,
      default: "value"
    },
    collapseTags: Boolean,
    collapseTagsTooltip: Boolean,
    maxCollapseTags: {
      type: Number,
      default: 1
    },
    teleported: $n.teleported,
    persistent: {
      type: Boolean,
      default: !0
    },
    clearIcon: {
      type: bi,
      default: Wl
    },
    fitInputWidth: Boolean,
    suffixIcon: {
      type: bi,
      default: Od
    },
    tagType: { ...mm.type, default: "info" },
    validateEvent: {
      type: Boolean,
      default: !0
    },
    remoteShowSuffix: Boolean,
    suffixTransition: {
      type: Boolean,
      default: !0
    },
    placement: {
      type: String,
      values: Fs,
      default: "bottom-start"
    },
    ariaLabel: {
      type: String,
      default: void 0
    }
  },
  emits: [
    Bt,
    Ji,
    "remove-tag",
    "clear",
    "visible-change",
    "focus",
    "blur"
  ],
  setup(t, e) {
    const n = Fe("select"), r = Fe("input"), { t: i } = or(), s = Xo(), o = ON(t), {
      optionList: a,
      optionsArray: l,
      hoverOption: u,
      selectSize: c,
      readonly: d,
      handleResize: h,
      collapseTagSize: v,
      debouncedOnInputChange: y,
      debouncedQueryChange: b,
      deletePrevTag: p,
      deleteTag: f,
      deleteSelected: g,
      handleOptionSelect: m,
      scrollToOption: w,
      setSelected: _,
      resetInputHeight: S,
      managePlaceholder: A,
      showClose: C,
      selectDisabled: k,
      iconComponent: O,
      iconReverse: N,
      showNewOption: B,
      emptyText: M,
      toggleLastOptionHitState: j,
      resetInputState: q,
      handleComposition: X,
      onOptionCreate: z,
      onOptionDestroy: U,
      handleMenuEnter: H,
      handleFocus: re,
      focus: fe,
      blur: J,
      handleBlur: le,
      handleClearClick: ce,
      handleClose: ge,
      handleKeydownEscape: _e,
      toggleMenu: je,
      selectOption: Te,
      getValueKey: Ze,
      navigateOptions: Le,
      handleDeleteTooltipTag: Ke,
      dropMenuVisible: ct,
      reference: nt,
      input: Et,
      iOSInput: yt,
      tooltipRef: Nt,
      tagTooltipRef: ot,
      tags: bt,
      selectWrapper: $t,
      scrollbar: wt,
      queryChange: xt,
      groupQueryChange: lt,
      handleMouseEnter: qe,
      handleMouseLeave: Rt,
      showTagList: we,
      collapseTagList: Ue,
      selectTagsStyle: at
    } = IN(t, o, e), {
      inputWidth: Pt,
      selected: Qt,
      inputLength: Ie,
      filteredOptionsCount: Ve,
      visible: Je,
      selectedLabel: He,
      hoverIndex: Qe,
      query: At,
      inputHovering: P,
      currentPlaceholder: he,
      menuVisibleOnFocus: me,
      isOnComposition: Ne,
      options: G,
      cachedOptions: ue,
      optionsCount: T,
      prefixWidth: L
    } = hn(o), oe = F(() => {
      const Ye = [n.b()], ln = x(c);
      return ln && Ye.push(n.m(ln)), t.disabled && Ye.push(n.m("disabled")), Ye;
    }), E = F(() => [
      n.e("tags"),
      n.is("disabled", x(k))
    ]), Q = F(() => [
      n.b("tags-wrapper"),
      { "has-prefix": x(L) && x(Qt).length }
    ]), ie = F(() => [
      n.e("input"),
      n.is(x(c)),
      n.is("disabled", x(k))
    ]), I = F(() => [
      n.e("input"),
      n.is(x(c)),
      n.em("input", "iOS")
    ]), W = F(() => [
      n.is("empty", !t.allowCreate && !!x(At) && x(Ve) === 0)
    ]), ne = F(() => ({ maxWidth: `${x(Pt) > 123 ? x(Pt) - 123 : x(Pt) - 75}px` })), Pe = F(() => ({
      marginLeft: `${x(L)}px`,
      flexGrow: 1,
      width: `${x(Ie) / (x(Pt) - 32)}%`,
      maxWidth: `${x(Pt) - 42}px`
    }));
    qt(Zl, Bn({
      props: t,
      options: G,
      optionsArray: l,
      cachedOptions: ue,
      optionsCount: T,
      filteredOptionsCount: Ve,
      hoverIndex: Qe,
      handleOptionSelect: m,
      onOptionCreate: z,
      onOptionDestroy: U,
      selectWrapper: $t,
      selected: Qt,
      setSelected: _,
      queryChange: xt,
      groupQueryChange: lt
    })), Ct(() => {
      o.cachedPlaceHolder = he.value = t.placeholder || (() => i("el.select.placeholder")), t.multiple && Array.isArray(t.modelValue) && t.modelValue.length > 0 && (he.value = ""), As($t, h), t.remote && t.multiple && S(), rt(() => {
        const Ye = nt.value && nt.value.$el;
        if (Ye && (Pt.value = Ye.getBoundingClientRect().width, e.slots.prefix)) {
          const ln = Ye.querySelector(`.${r.e("prefix")}`);
          L.value = Math.max(ln.getBoundingClientRect().width + 11, 30);
        }
      }), _();
    }), t.multiple && !Array.isArray(t.modelValue) && e.emit(Bt, []), !t.multiple && Array.isArray(t.modelValue) && e.emit(Bt, "");
    const Oe = F(() => {
      var Ye, ln;
      return (ln = (Ye = Nt.value) == null ? void 0 : Ye.popperRef) == null ? void 0 : ln.contentRef;
    });
    return {
      isIOS: Sv,
      onOptionsRendered: (Ye) => {
        a.value = Ye;
      },
      prefixWidth: L,
      selectSize: c,
      readonly: d,
      handleResize: h,
      collapseTagSize: v,
      debouncedOnInputChange: y,
      debouncedQueryChange: b,
      deletePrevTag: p,
      deleteTag: f,
      handleDeleteTooltipTag: Ke,
      deleteSelected: g,
      handleOptionSelect: m,
      scrollToOption: w,
      inputWidth: Pt,
      selected: Qt,
      inputLength: Ie,
      filteredOptionsCount: Ve,
      visible: Je,
      selectedLabel: He,
      hoverIndex: Qe,
      query: At,
      inputHovering: P,
      currentPlaceholder: he,
      menuVisibleOnFocus: me,
      isOnComposition: Ne,
      options: G,
      resetInputHeight: S,
      managePlaceholder: A,
      showClose: C,
      selectDisabled: k,
      iconComponent: O,
      iconReverse: N,
      showNewOption: B,
      emptyText: M,
      toggleLastOptionHitState: j,
      resetInputState: q,
      handleComposition: X,
      handleMenuEnter: H,
      handleFocus: re,
      focus: fe,
      blur: J,
      handleBlur: le,
      handleClearClick: ce,
      handleClose: ge,
      handleKeydownEscape: _e,
      toggleMenu: je,
      selectOption: Te,
      getValueKey: Ze,
      navigateOptions: Le,
      dropMenuVisible: ct,
      reference: nt,
      input: Et,
      iOSInput: yt,
      tooltipRef: Nt,
      popperPaneRef: Oe,
      tags: bt,
      selectWrapper: $t,
      scrollbar: wt,
      wrapperKls: oe,
      tagsKls: E,
      tagWrapperKls: Q,
      inputKls: ie,
      iOSInputKls: I,
      scrollbarKls: W,
      selectTagsStyle: at,
      nsSelect: n,
      tagTextStyle: ne,
      inputStyle: Pe,
      handleMouseEnter: qe,
      handleMouseLeave: Rt,
      showTagList: we,
      collapseTagList: Ue,
      tagTooltipRef: ot,
      contentId: s,
      hoverOption: u
    };
  }
}), PN = ["disabled", "autocomplete", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label"], BN = ["disabled"], DN = { style: { height: "100%", display: "flex", "justify-content": "center", "align-items": "center" } };
function MN(t, e, n, r, i, s) {
  const o = Mt("el-tag"), a = Mt("el-tooltip"), l = Mt("el-icon"), u = Mt("el-input"), c = Mt("el-option"), d = Mt("el-options"), h = Mt("el-scrollbar"), v = Mt("el-select-menu"), y = ud("click-outside");
  return Dt((V(), se("div", {
    ref: "selectWrapper",
    class: ee(t.wrapperKls),
    onMouseenter: e[22] || (e[22] = (...b) => t.handleMouseEnter && t.handleMouseEnter(...b)),
    onMouseleave: e[23] || (e[23] = (...b) => t.handleMouseLeave && t.handleMouseLeave(...b)),
    onClick: e[24] || (e[24] = ft((...b) => t.toggleMenu && t.toggleMenu(...b), ["stop"]))
  }, [
    ve(a, {
      ref: "tooltipRef",
      visible: t.dropMenuVisible,
      placement: t.placement,
      teleported: t.teleported,
      "popper-class": [t.nsSelect.e("popper"), t.popperClass],
      "popper-options": t.popperOptions,
      "fallback-placements": ["bottom-start", "top-start", "right", "left"],
      effect: t.effect,
      pure: "",
      trigger: "click",
      transition: `${t.nsSelect.namespace.value}-zoom-in-top`,
      "stop-popper-mouse-event": !1,
      "gpu-acceleration": !1,
      persistent: t.persistent,
      onShow: t.handleMenuEnter
    }, {
      default: de(() => {
        var b, p;
        return [
          ae("div", {
            class: "select-trigger",
            onMouseenter: e[20] || (e[20] = (f) => t.inputHovering = !0),
            onMouseleave: e[21] || (e[21] = (f) => t.inputHovering = !1)
          }, [
            t.multiple ? (V(), se("div", {
              key: 0,
              ref: "tags",
              tabindex: "-1",
              class: ee(t.tagsKls),
              style: it(t.selectTagsStyle),
              onClick: e[15] || (e[15] = (...f) => t.focus && t.focus(...f))
            }, [
              t.collapseTags && t.selected.length ? (V(), Ae(mr, {
                key: 0,
                onAfterLeave: t.resetInputHeight
              }, {
                default: de(() => [
                  ae("span", {
                    class: ee(t.tagWrapperKls)
                  }, [
                    (V(!0), se(Ft, null, qn(t.showTagList, (f) => (V(), Ae(o, {
                      key: t.getValueKey(f),
                      closable: !t.selectDisabled && !f.isDisabled,
                      size: t.collapseTagSize,
                      hit: f.hitState,
                      type: t.tagType,
                      "disable-transitions": "",
                      onClose: (g) => t.deleteTag(g, f)
                    }, {
                      default: de(() => [
                        ae("span", {
                          class: ee(t.nsSelect.e("tags-text")),
                          style: it(t.tagTextStyle)
                        }, st(f.currentLabel), 7)
                      ]),
                      _: 2
                    }, 1032, ["closable", "size", "hit", "type", "onClose"]))), 128)),
                    t.selected.length > t.maxCollapseTags ? (V(), Ae(o, {
                      key: 0,
                      closable: !1,
                      size: t.collapseTagSize,
                      type: t.tagType,
                      "disable-transitions": ""
                    }, {
                      default: de(() => [
                        t.collapseTagsTooltip ? (V(), Ae(a, {
                          key: 0,
                          ref: "tagTooltipRef",
                          disabled: t.dropMenuVisible,
                          "fallback-placements": ["bottom", "top", "right", "left"],
                          effect: t.effect,
                          placement: "bottom",
                          teleported: t.teleported
                        }, {
                          default: de(() => [
                            ae("span", {
                              class: ee(t.nsSelect.e("tags-text"))
                            }, "+ " + st(t.selected.length - t.maxCollapseTags), 3)
                          ]),
                          content: de(() => [
                            ae("div", {
                              class: ee(t.nsSelect.e("collapse-tags"))
                            }, [
                              (V(!0), se(Ft, null, qn(t.collapseTagList, (f) => (V(), se("div", {
                                key: t.getValueKey(f),
                                class: ee(t.nsSelect.e("collapse-tag"))
                              }, [
                                ve(o, {
                                  class: "in-tooltip",
                                  closable: !t.selectDisabled && !f.isDisabled,
                                  size: t.collapseTagSize,
                                  hit: f.hitState,
                                  type: t.tagType,
                                  "disable-transitions": "",
                                  style: { margin: "2px" },
                                  onClose: (g) => t.handleDeleteTooltipTag(g, f)
                                }, {
                                  default: de(() => [
                                    ae("span", {
                                      class: ee(t.nsSelect.e("tags-text")),
                                      style: it({
                                        maxWidth: t.inputWidth - 75 + "px"
                                      })
                                    }, st(f.currentLabel), 7)
                                  ]),
                                  _: 2
                                }, 1032, ["closable", "size", "hit", "type", "onClose"])
                              ], 2))), 128))
                            ], 2)
                          ]),
                          _: 1
                        }, 8, ["disabled", "effect", "teleported"])) : (V(), se("span", {
                          key: 1,
                          class: ee(t.nsSelect.e("tags-text"))
                        }, "+ " + st(t.selected.length - t.maxCollapseTags), 3))
                      ]),
                      _: 1
                    }, 8, ["size", "type"])) : ye("v-if", !0)
                  ], 2)
                ]),
                _: 1
              }, 8, ["onAfterLeave"])) : ye("v-if", !0),
              t.collapseTags ? ye("v-if", !0) : (V(), Ae(mr, {
                key: 1,
                onAfterLeave: t.resetInputHeight
              }, {
                default: de(() => [
                  ae("span", {
                    class: ee(t.tagWrapperKls),
                    style: it(t.prefixWidth && t.selected.length ? { marginLeft: `${t.prefixWidth}px` } : "")
                  }, [
                    (V(!0), se(Ft, null, qn(t.selected, (f) => (V(), Ae(o, {
                      key: t.getValueKey(f),
                      closable: !t.selectDisabled && !f.isDisabled,
                      size: t.collapseTagSize,
                      hit: f.hitState,
                      type: t.tagType,
                      "disable-transitions": "",
                      onClose: (g) => t.deleteTag(g, f)
                    }, {
                      default: de(() => [
                        ae("span", {
                          class: ee(t.nsSelect.e("tags-text")),
                          style: it({ maxWidth: t.inputWidth - 75 + "px" })
                        }, st(f.currentLabel), 7)
                      ]),
                      _: 2
                    }, 1032, ["closable", "size", "hit", "type", "onClose"]))), 128))
                  ], 6)
                ]),
                _: 1
              }, 8, ["onAfterLeave"])),
              t.filterable && !t.selectDisabled ? Dt((V(), se("input", {
                key: 2,
                ref: "input",
                "onUpdate:modelValue": e[0] || (e[0] = (f) => t.query = f),
                type: "text",
                class: ee(t.inputKls),
                disabled: t.selectDisabled,
                autocomplete: t.autocomplete,
                style: it(t.inputStyle),
                role: "combobox",
                "aria-activedescendant": ((b = t.hoverOption) == null ? void 0 : b.id) || "",
                "aria-controls": t.contentId,
                "aria-expanded": t.dropMenuVisible,
                "aria-label": t.ariaLabel,
                "aria-autocomplete": "none",
                "aria-haspopup": "listbox",
                onFocus: e[1] || (e[1] = (...f) => t.handleFocus && t.handleFocus(...f)),
                onBlur: e[2] || (e[2] = (...f) => t.handleBlur && t.handleBlur(...f)),
                onKeyup: e[3] || (e[3] = (...f) => t.managePlaceholder && t.managePlaceholder(...f)),
                onKeydown: [
                  e[4] || (e[4] = (...f) => t.resetInputState && t.resetInputState(...f)),
                  e[5] || (e[5] = vn(ft((f) => t.navigateOptions("next"), ["prevent"]), ["down"])),
                  e[6] || (e[6] = vn(ft((f) => t.navigateOptions("prev"), ["prevent"]), ["up"])),
                  e[7] || (e[7] = vn((...f) => t.handleKeydownEscape && t.handleKeydownEscape(...f), ["esc"])),
                  e[8] || (e[8] = vn(ft((...f) => t.selectOption && t.selectOption(...f), ["stop", "prevent"]), ["enter"])),
                  e[9] || (e[9] = vn((...f) => t.deletePrevTag && t.deletePrevTag(...f), ["delete"])),
                  e[10] || (e[10] = vn((f) => t.visible = !1, ["tab"]))
                ],
                onCompositionstart: e[11] || (e[11] = (...f) => t.handleComposition && t.handleComposition(...f)),
                onCompositionupdate: e[12] || (e[12] = (...f) => t.handleComposition && t.handleComposition(...f)),
                onCompositionend: e[13] || (e[13] = (...f) => t.handleComposition && t.handleComposition(...f)),
                onInput: e[14] || (e[14] = (...f) => t.debouncedQueryChange && t.debouncedQueryChange(...f))
              }, null, 46, PN)), [
                [Z0, t.query]
              ]) : ye("v-if", !0)
            ], 6)) : ye("v-if", !0),
            t.isIOS && !t.multiple && t.filterable && t.readonly ? (V(), se("input", {
              key: 1,
              ref: "iOSInput",
              class: ee(t.iOSInputKls),
              disabled: t.selectDisabled,
              type: "text"
            }, null, 10, BN)) : ye("v-if", !0),
            ve(u, {
              id: t.id,
              ref: "reference",
              modelValue: t.selectedLabel,
              "onUpdate:modelValue": e[16] || (e[16] = (f) => t.selectedLabel = f),
              type: "text",
              placeholder: typeof t.currentPlaceholder == "function" ? t.currentPlaceholder() : t.currentPlaceholder,
              name: t.name,
              autocomplete: t.autocomplete,
              size: t.selectSize,
              disabled: t.selectDisabled,
              readonly: t.readonly,
              "validate-event": !1,
              class: ee([t.nsSelect.is("focus", t.visible)]),
              tabindex: t.multiple && t.filterable ? -1 : void 0,
              role: "combobox",
              "aria-activedescendant": ((p = t.hoverOption) == null ? void 0 : p.id) || "",
              "aria-controls": t.contentId,
              "aria-expanded": t.dropMenuVisible,
              label: t.ariaLabel,
              "aria-autocomplete": "none",
              "aria-haspopup": "listbox",
              onFocus: t.handleFocus,
              onBlur: t.handleBlur,
              onInput: t.debouncedOnInputChange,
              onPaste: t.debouncedOnInputChange,
              onCompositionstart: t.handleComposition,
              onCompositionupdate: t.handleComposition,
              onCompositionend: t.handleComposition,
              onKeydown: [
                e[17] || (e[17] = vn(ft((f) => t.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
                e[18] || (e[18] = vn(ft((f) => t.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
                vn(ft(t.selectOption, ["stop", "prevent"]), ["enter"]),
                vn(t.handleKeydownEscape, ["esc"]),
                e[19] || (e[19] = vn((f) => t.visible = !1, ["tab"]))
              ]
            }, qu({
              suffix: de(() => [
                t.iconComponent && !t.showClose ? (V(), Ae(l, {
                  key: 0,
                  class: ee([t.nsSelect.e("caret"), t.nsSelect.e("icon"), t.iconReverse])
                }, {
                  default: de(() => [
                    (V(), Ae(Nn(t.iconComponent)))
                  ]),
                  _: 1
                }, 8, ["class"])) : ye("v-if", !0),
                t.showClose && t.clearIcon ? (V(), Ae(l, {
                  key: 1,
                  class: ee([t.nsSelect.e("caret"), t.nsSelect.e("icon")]),
                  onClick: t.handleClearClick
                }, {
                  default: de(() => [
                    (V(), Ae(Nn(t.clearIcon)))
                  ]),
                  _: 1
                }, 8, ["class", "onClick"])) : ye("v-if", !0)
              ]),
              _: 2
            }, [
              t.$slots.prefix ? {
                name: "prefix",
                fn: de(() => [
                  ae("div", DN, [
                    Me(t.$slots, "prefix")
                  ])
                ])
              } : void 0
            ]), 1032, ["id", "modelValue", "placeholder", "name", "autocomplete", "size", "disabled", "readonly", "class", "tabindex", "aria-activedescendant", "aria-controls", "aria-expanded", "label", "onFocus", "onBlur", "onInput", "onPaste", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onKeydown"])
          ], 32)
        ];
      }),
      content: de(() => [
        ve(v, null, {
          default: de(() => [
            Dt(ve(h, {
              id: t.contentId,
              ref: "scrollbar",
              tag: "ul",
              "wrap-class": t.nsSelect.be("dropdown", "wrap"),
              "view-class": t.nsSelect.be("dropdown", "list"),
              class: ee(t.scrollbarKls),
              role: "listbox",
              "aria-label": t.ariaLabel,
              "aria-orientation": "vertical"
            }, {
              default: de(() => [
                t.showNewOption ? (V(), Ae(c, {
                  key: 0,
                  value: t.query,
                  created: !0
                }, null, 8, ["value"])) : ye("v-if", !0),
                ve(d, { onUpdateOptions: t.onOptionsRendered }, {
                  default: de(() => [
                    Me(t.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["onUpdateOptions"])
              ]),
              _: 3
            }, 8, ["id", "wrap-class", "view-class", "class", "aria-label"]), [
              [Jn, t.options.size > 0 && !t.loading]
            ]),
            t.emptyText && (!t.allowCreate || t.loading || t.allowCreate && t.options.size === 0) ? (V(), se(Ft, { key: 0 }, [
              t.$slots.empty ? Me(t.$slots, "empty", { key: 0 }) : (V(), se("p", {
                key: 1,
                class: ee(t.nsSelect.be("dropdown", "empty"))
              }, st(t.emptyText), 3))
            ], 64)) : ye("v-if", !0)
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "effect", "transition", "persistent", "onShow"])
  ], 34)), [
    [y, t.handleClose, t.popperPaneRef]
  ]);
}
var LN = /* @__PURE__ */ Ge(RN, [["render", MN], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select.vue"]]);
const zN = be({
  name: "ElOptionGroup",
  componentName: "ElOptionGroup",
  props: {
    label: String,
    disabled: Boolean
  },
  setup(t) {
    const e = Fe("select"), n = $(!0), r = ht(), i = $([]);
    qt(Am, Bn({
      ...hn(t)
    }));
    const s = tt(Zl);
    Ct(() => {
      i.value = o(r.subTree);
    });
    const o = (l) => {
      const u = [];
      return Array.isArray(l.children) && l.children.forEach((c) => {
        var d;
        c.type && c.type.name === "ElOption" && c.component && c.component.proxy ? u.push(c.component.proxy) : (d = c.children) != null && d.length && u.push(...o(c));
      }), u;
    }, { groupQueryChange: a } = yi(s);
    return ke(a, () => {
      n.value = i.value.some((l) => l.visible === !0);
    }, { flush: "post" }), {
      visible: n,
      ns: e
    };
  }
});
function jN(t, e, n, r, i, s) {
  return Dt((V(), se("ul", {
    class: ee(t.ns.be("group", "wrap"))
  }, [
    ae("li", {
      class: ee(t.ns.be("group", "title"))
    }, st(t.label), 3),
    ae("li", null, [
      ae("ul", {
        class: ee(t.ns.b("group"))
      }, [
        Me(t.$slots, "default")
      ], 2)
    ])
  ], 2)), [
    [Jn, t.visible]
  ]);
}
var km = /* @__PURE__ */ Ge(zN, [["render", jN], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option-group.vue"]]);
const FN = nn(LN, {
  Option: Jd,
  OptionGroup: km
}), HN = sr(Jd);
sr(km);
const UN = ut({
  trigger: Io.trigger,
  placement: Au.placement,
  disabled: Io.disabled,
  visible: $n.visible,
  transition: $n.transition,
  popperOptions: Au.popperOptions,
  tabindex: Au.tabindex,
  content: $n.content,
  popperStyle: $n.popperStyle,
  popperClass: $n.popperClass,
  enterable: {
    ...$n.enterable,
    default: !0
  },
  effect: {
    ...$n.effect,
    default: "light"
  },
  teleported: $n.teleported,
  title: String,
  width: {
    type: [String, Number],
    default: 150
  },
  offset: {
    type: Number,
    default: void 0
  },
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  autoClose: {
    type: Number,
    default: 0
  },
  showArrow: {
    type: Boolean,
    default: !0
  },
  persistent: {
    type: Boolean,
    default: !0
  },
  "onUpdate:visible": {
    type: Function
  }
}), VN = {
  "update:visible": (t) => Qr(t),
  "before-enter": () => !0,
  "before-leave": () => !0,
  "after-enter": () => !0,
  "after-leave": () => !0
}, WN = "onUpdate:visible", KN = be({
  name: "ElPopover"
}), $N = /* @__PURE__ */ be({
  ...KN,
  props: UN,
  emits: VN,
  setup(t, { expose: e, emit: n }) {
    const r = t, i = F(() => r[WN]), s = Fe("popover"), o = $(), a = F(() => {
      var p;
      return (p = x(o)) == null ? void 0 : p.popperRef;
    }), l = F(() => [
      {
        width: ul(r.width)
      },
      r.popperStyle
    ]), u = F(() => [s.b(), r.popperClass, { [s.m("plain")]: !!r.content }]), c = F(() => r.transition === `${s.namespace.value}-fade-in-linear`), d = () => {
      var p;
      (p = o.value) == null || p.hide();
    }, h = () => {
      n("before-enter");
    }, v = () => {
      n("before-leave");
    }, y = () => {
      n("after-enter");
    }, b = () => {
      n("update:visible", !1), n("after-leave");
    };
    return e({
      popperRef: a,
      hide: d
    }), (p, f) => (V(), Ae(x(Ql), Gn({
      ref_key: "tooltipRef",
      ref: o
    }, p.$attrs, {
      trigger: p.trigger,
      placement: p.placement,
      disabled: p.disabled,
      visible: p.visible,
      transition: p.transition,
      "popper-options": p.popperOptions,
      tabindex: p.tabindex,
      content: p.content,
      offset: p.offset,
      "show-after": p.showAfter,
      "hide-after": p.hideAfter,
      "auto-close": p.autoClose,
      "show-arrow": p.showArrow,
      "aria-label": p.title,
      effect: p.effect,
      enterable: p.enterable,
      "popper-class": x(u),
      "popper-style": x(l),
      teleported: p.teleported,
      persistent: p.persistent,
      "gpu-acceleration": x(c),
      "onUpdate:visible": x(i),
      onBeforeShow: h,
      onBeforeHide: v,
      onShow: y,
      onHide: b
    }), {
      content: de(() => [
        p.title ? (V(), se("div", {
          key: 0,
          class: ee(x(s).e("title")),
          role: "title"
        }, st(p.title), 3)) : ye("v-if", !0),
        Me(p.$slots, "default", {}, () => [
          cn(st(p.content), 1)
        ])
      ]),
      default: de(() => [
        p.$slots.reference ? Me(p.$slots, "reference", { key: 0 }) : ye("v-if", !0)
      ]),
      _: 3
    }, 16, ["trigger", "placement", "disabled", "visible", "transition", "popper-options", "tabindex", "content", "offset", "show-after", "hide-after", "auto-close", "show-arrow", "aria-label", "effect", "enterable", "popper-class", "popper-style", "teleported", "persistent", "gpu-acceleration", "onUpdate:visible"]));
  }
});
var GN = /* @__PURE__ */ Ge($N, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popover/src/popover.vue"]]);
const sp = (t, e) => {
  const n = e.arg || e.value, r = n == null ? void 0 : n.popperRef;
  r && (r.triggerRef = t);
};
var qN = {
  mounted(t, e) {
    sp(t, e);
  },
  updated(t, e) {
    sp(t, e);
  }
};
const JN = "popover", Cm = YC(qN, JN), ta = nn(GN, {
  directive: Cm
}), YN = ut({
  type: {
    type: String,
    default: "line",
    values: ["line", "circle", "dashboard"]
  },
  percentage: {
    type: Number,
    default: 0,
    validator: (t) => t >= 0 && t <= 100
  },
  status: {
    type: String,
    default: "",
    values: ["", "success", "exception", "warning"]
  },
  indeterminate: {
    type: Boolean,
    default: !1
  },
  duration: {
    type: Number,
    default: 3
  },
  strokeWidth: {
    type: Number,
    default: 6
  },
  strokeLinecap: {
    type: Be(String),
    default: "round"
  },
  textInside: {
    type: Boolean,
    default: !1
  },
  width: {
    type: Number,
    default: 126
  },
  showText: {
    type: Boolean,
    default: !0
  },
  color: {
    type: Be([
      String,
      Array,
      Function
    ]),
    default: ""
  },
  striped: Boolean,
  stripedFlow: Boolean,
  format: {
    type: Be(Function),
    default: (t) => `${t}%`
  }
}), QN = ["aria-valuenow"], ZN = { viewBox: "0 0 100 100" }, XN = ["d", "stroke", "stroke-linecap", "stroke-width"], eR = ["d", "stroke", "opacity", "stroke-linecap", "stroke-width"], tR = { key: 0 }, nR = be({
  name: "ElProgress"
}), rR = /* @__PURE__ */ be({
  ...nR,
  props: YN,
  setup(t) {
    const e = t, n = {
      success: "#13ce66",
      exception: "#ff4949",
      warning: "#e6a23c",
      default: "#20a0ff"
    }, r = Fe("progress"), i = F(() => ({
      width: `${e.percentage}%`,
      animationDuration: `${e.duration}s`,
      backgroundColor: g(e.percentage)
    })), s = F(() => (e.strokeWidth / e.width * 100).toFixed(1)), o = F(() => ["circle", "dashboard"].includes(e.type) ? Number.parseInt(`${50 - Number.parseFloat(s.value) / 2}`, 10) : 0), a = F(() => {
      const m = o.value, w = e.type === "dashboard";
      return `
          M 50 50
          m 0 ${w ? "" : "-"}${m}
          a ${m} ${m} 0 1 1 0 ${w ? "-" : ""}${m * 2}
          a ${m} ${m} 0 1 1 0 ${w ? "" : "-"}${m * 2}
          `;
    }), l = F(() => 2 * Math.PI * o.value), u = F(() => e.type === "dashboard" ? 0.75 : 1), c = F(() => `${-1 * l.value * (1 - u.value) / 2}px`), d = F(() => ({
      strokeDasharray: `${l.value * u.value}px, ${l.value}px`,
      strokeDashoffset: c.value
    })), h = F(() => ({
      strokeDasharray: `${l.value * u.value * (e.percentage / 100)}px, ${l.value}px`,
      strokeDashoffset: c.value,
      transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s"
    })), v = F(() => {
      let m;
      return e.color ? m = g(e.percentage) : m = n[e.status] || n.default, m;
    }), y = F(() => e.status === "warning" ? LC : e.type === "line" ? e.status === "success" ? Nd : Wl : e.status === "success" ? og : ko), b = F(() => e.type === "line" ? 12 + e.strokeWidth * 0.4 : e.width * 0.111111 + 2), p = F(() => e.format(e.percentage));
    function f(m) {
      const w = 100 / m.length;
      return m.map((S, A) => Gt(S) ? {
        color: S,
        percentage: (A + 1) * w
      } : S).sort((S, A) => S.percentage - A.percentage);
    }
    const g = (m) => {
      var w;
      const { color: _ } = e;
      if (gn(_))
        return _(m);
      if (Gt(_))
        return _;
      {
        const S = f(_);
        for (const A of S)
          if (A.percentage > m)
            return A.color;
        return (w = S[S.length - 1]) == null ? void 0 : w.color;
      }
    };
    return (m, w) => (V(), se("div", {
      class: ee([
        x(r).b(),
        x(r).m(m.type),
        x(r).is(m.status),
        {
          [x(r).m("without-text")]: !m.showText,
          [x(r).m("text-inside")]: m.textInside
        }
      ]),
      role: "progressbar",
      "aria-valuenow": m.percentage,
      "aria-valuemin": "0",
      "aria-valuemax": "100"
    }, [
      m.type === "line" ? (V(), se("div", {
        key: 0,
        class: ee(x(r).b("bar"))
      }, [
        ae("div", {
          class: ee(x(r).be("bar", "outer")),
          style: it({ height: `${m.strokeWidth}px` })
        }, [
          ae("div", {
            class: ee([
              x(r).be("bar", "inner"),
              { [x(r).bem("bar", "inner", "indeterminate")]: m.indeterminate },
              { [x(r).bem("bar", "inner", "striped")]: m.striped },
              { [x(r).bem("bar", "inner", "striped-flow")]: m.stripedFlow }
            ]),
            style: it(x(i))
          }, [
            (m.showText || m.$slots.default) && m.textInside ? (V(), se("div", {
              key: 0,
              class: ee(x(r).be("bar", "innerText"))
            }, [
              Me(m.$slots, "default", { percentage: m.percentage }, () => [
                ae("span", null, st(x(p)), 1)
              ])
            ], 2)) : ye("v-if", !0)
          ], 6)
        ], 6)
      ], 2)) : (V(), se("div", {
        key: 1,
        class: ee(x(r).b("circle")),
        style: it({ height: `${m.width}px`, width: `${m.width}px` })
      }, [
        (V(), se("svg", ZN, [
          ae("path", {
            class: ee(x(r).be("circle", "track")),
            d: x(a),
            stroke: `var(${x(r).cssVarName("fill-color-light")}, #e5e9f2)`,
            "stroke-linecap": m.strokeLinecap,
            "stroke-width": x(s),
            fill: "none",
            style: it(x(d))
          }, null, 14, XN),
          ae("path", {
            class: ee(x(r).be("circle", "path")),
            d: x(a),
            stroke: x(v),
            fill: "none",
            opacity: m.percentage ? 1 : 0,
            "stroke-linecap": m.strokeLinecap,
            "stroke-width": x(s),
            style: it(x(h))
          }, null, 14, eR)
        ]))
      ], 6)),
      (m.showText || m.$slots.default) && !m.textInside ? (V(), se("div", {
        key: 2,
        class: ee(x(r).e("text")),
        style: it({ fontSize: `${x(b)}px` })
      }, [
        Me(m.$slots, "default", { percentage: m.percentage }, () => [
          m.status ? (V(), Ae(x(_t), { key: 1 }, {
            default: de(() => [
              (V(), Ae(Nn(x(y))))
            ]),
            _: 1
          })) : (V(), se("span", tR, st(x(p)), 1))
        ])
      ], 6)) : ye("v-if", !0)
    ], 10, QN));
  }
});
var iR = /* @__PURE__ */ Ge(rR, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/progress/src/progress.vue"]]);
const Tm = nn(iR), Om = Symbol("sliderContextKey"), sR = ut({
  modelValue: {
    type: Be([Number, Array]),
    default: 0
  },
  id: {
    type: String,
    default: void 0
  },
  min: {
    type: Number,
    default: 0
  },
  max: {
    type: Number,
    default: 100
  },
  step: {
    type: Number,
    default: 1
  },
  showInput: Boolean,
  showInputControls: {
    type: Boolean,
    default: !0
  },
  size: Rr,
  inputSize: Rr,
  showStops: Boolean,
  showTooltip: {
    type: Boolean,
    default: !0
  },
  formatTooltip: {
    type: Be(Function),
    default: void 0
  },
  disabled: Boolean,
  range: Boolean,
  vertical: Boolean,
  height: String,
  debounce: {
    type: Number,
    default: 300
  },
  label: {
    type: String,
    default: void 0
  },
  rangeStartLabel: {
    type: String,
    default: void 0
  },
  rangeEndLabel: {
    type: String,
    default: void 0
  },
  formatValueText: {
    type: Be(Function),
    default: void 0
  },
  tooltipClass: {
    type: String,
    default: void 0
  },
  placement: {
    type: String,
    values: Fs,
    default: "top"
  },
  marks: {
    type: Be(Object)
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), ku = (t) => mt(t) || Or(t) && t.every(mt), oR = {
  [Bt]: ku,
  [Pi]: ku,
  [Ji]: ku
}, aR = (t, e, n) => {
  const r = $();
  return Ct(async () => {
    t.range ? (Array.isArray(t.modelValue) ? (e.firstValue = Math.max(t.min, t.modelValue[0]), e.secondValue = Math.min(t.max, t.modelValue[1])) : (e.firstValue = t.min, e.secondValue = t.max), e.oldValue = [e.firstValue, e.secondValue]) : (typeof t.modelValue != "number" || Number.isNaN(t.modelValue) ? e.firstValue = t.min : e.firstValue = Math.min(t.max, Math.max(t.min, t.modelValue)), e.oldValue = e.firstValue), bn(window, "resize", n), await rt(), n();
  }), {
    sliderWrapper: r
  };
}, lR = (t) => F(() => t.marks ? Object.keys(t.marks).map(Number.parseFloat).sort((n, r) => n - r).filter((n) => n <= t.max && n >= t.min).map((n) => ({
  point: n,
  position: (n - t.min) * 100 / (t.max - t.min),
  mark: t.marks[n]
})) : []), uR = (t, e, n) => {
  const { form: r, formItem: i } = oi(), s = zn(), o = $(), a = $(), l = {
    firstButton: o,
    secondButton: a
  }, u = F(() => t.disabled || (r == null ? void 0 : r.disabled) || !1), c = F(() => Math.min(e.firstValue, e.secondValue)), d = F(() => Math.max(e.firstValue, e.secondValue)), h = F(() => t.range ? `${100 * (d.value - c.value) / (t.max - t.min)}%` : `${100 * (e.firstValue - t.min) / (t.max - t.min)}%`), v = F(() => t.range ? `${100 * (c.value - t.min) / (t.max - t.min)}%` : "0%"), y = F(() => t.vertical ? { height: t.height } : {}), b = F(() => t.vertical ? {
    height: h.value,
    bottom: v.value
  } : {
    width: h.value,
    left: v.value
  }), p = () => {
    s.value && (e.sliderSize = s.value[`client${t.vertical ? "Height" : "Width"}`]);
  }, f = (N) => {
    const B = t.min + N * (t.max - t.min) / 100;
    if (!t.range)
      return o;
    let M;
    return Math.abs(c.value - B) < Math.abs(d.value - B) ? M = e.firstValue < e.secondValue ? "firstButton" : "secondButton" : M = e.firstValue > e.secondValue ? "firstButton" : "secondButton", l[M];
  }, g = (N) => {
    const B = f(N);
    return B.value.setPosition(N), B;
  }, m = (N) => {
    e.firstValue = N, _(t.range ? [c.value, d.value] : N);
  }, w = (N) => {
    e.secondValue = N, t.range && _([c.value, d.value]);
  }, _ = (N) => {
    n(Bt, N), n(Pi, N);
  }, S = async () => {
    await rt(), n(Ji, t.range ? [c.value, d.value] : t.modelValue);
  }, A = (N) => {
    var B, M, j, q, X, z;
    if (u.value || e.dragging)
      return;
    p();
    let U = 0;
    if (t.vertical) {
      const H = (j = (M = (B = N.touches) == null ? void 0 : B.item(0)) == null ? void 0 : M.clientY) != null ? j : N.clientY;
      U = (s.value.getBoundingClientRect().bottom - H) / e.sliderSize * 100;
    } else {
      const H = (z = (X = (q = N.touches) == null ? void 0 : q.item(0)) == null ? void 0 : X.clientX) != null ? z : N.clientX, re = s.value.getBoundingClientRect().left;
      U = (H - re) / e.sliderSize * 100;
    }
    if (!(U < 0 || U > 100))
      return g(U);
  };
  return {
    elFormItem: i,
    slider: s,
    firstButton: o,
    secondButton: a,
    sliderDisabled: u,
    minValue: c,
    maxValue: d,
    runwayStyle: y,
    barStyle: b,
    resetSize: p,
    setPosition: g,
    emitChange: S,
    onSliderWrapperPrevent: (N) => {
      var B, M;
      ((B = l.firstButton.value) != null && B.dragging || (M = l.secondButton.value) != null && M.dragging) && N.preventDefault();
    },
    onSliderClick: (N) => {
      A(N) && S();
    },
    onSliderDown: async (N) => {
      const B = A(N);
      B && (await rt(), B.value.onButtonDown(N));
    },
    setFirstValue: m,
    setSecondValue: w
  };
}, { left: cR, down: dR, right: fR, up: hR, home: pR, end: vR, pageUp: gR, pageDown: mR } = sn, yR = (t, e, n) => {
  const r = $(), i = $(!1), s = F(() => e.value instanceof Function), o = F(() => s.value && e.value(t.modelValue) || t.modelValue), a = Yr(() => {
    n.value && (i.value = !0);
  }, 50), l = Yr(() => {
    n.value && (i.value = !1);
  }, 50);
  return {
    tooltip: r,
    tooltipVisible: i,
    formatValue: o,
    displayTooltip: a,
    hideTooltip: l
  };
}, bR = (t, e, n) => {
  const {
    disabled: r,
    min: i,
    max: s,
    step: o,
    showTooltip: a,
    precision: l,
    sliderSize: u,
    formatTooltip: c,
    emitChange: d,
    resetSize: h,
    updateDragging: v
  } = tt(Om), { tooltip: y, tooltipVisible: b, formatValue: p, displayTooltip: f, hideTooltip: g } = yR(t, c, a), m = $(), w = F(() => `${(t.modelValue - i.value) / (s.value - i.value) * 100}%`), _ = F(() => t.vertical ? { bottom: w.value } : { left: w.value }), S = () => {
    e.hovering = !0, f();
  }, A = () => {
    e.hovering = !1, e.dragging || g();
  }, C = (J) => {
    r.value || (J.preventDefault(), U(J), window.addEventListener("mousemove", H), window.addEventListener("touchmove", H), window.addEventListener("mouseup", re), window.addEventListener("touchend", re), window.addEventListener("contextmenu", re), m.value.focus());
  }, k = (J) => {
    r.value || (e.newPosition = Number.parseFloat(w.value) + J / (s.value - i.value) * 100, fe(e.newPosition), d());
  }, O = () => {
    k(-o.value);
  }, N = () => {
    k(o.value);
  }, B = () => {
    k(-o.value * 4);
  }, M = () => {
    k(o.value * 4);
  }, j = () => {
    r.value || (fe(0), d());
  }, q = () => {
    r.value || (fe(100), d());
  }, X = (J) => {
    let le = !0;
    [cR, dR].includes(J.key) ? O() : [fR, hR].includes(J.key) ? N() : J.key === pR ? j() : J.key === vR ? q() : J.key === mR ? B() : J.key === gR ? M() : le = !1, le && J.preventDefault();
  }, z = (J) => {
    let le, ce;
    return J.type.startsWith("touch") ? (ce = J.touches[0].clientY, le = J.touches[0].clientX) : (ce = J.clientY, le = J.clientX), {
      clientX: le,
      clientY: ce
    };
  }, U = (J) => {
    e.dragging = !0, e.isClick = !0;
    const { clientX: le, clientY: ce } = z(J);
    t.vertical ? e.startY = ce : e.startX = le, e.startPosition = Number.parseFloat(w.value), e.newPosition = e.startPosition;
  }, H = (J) => {
    if (e.dragging) {
      e.isClick = !1, f(), h();
      let le;
      const { clientX: ce, clientY: ge } = z(J);
      t.vertical ? (e.currentY = ge, le = (e.startY - e.currentY) / u.value * 100) : (e.currentX = ce, le = (e.currentX - e.startX) / u.value * 100), e.newPosition = e.startPosition + le, fe(e.newPosition);
    }
  }, re = () => {
    e.dragging && (setTimeout(() => {
      e.dragging = !1, e.hovering || g(), e.isClick || fe(e.newPosition), d();
    }, 0), window.removeEventListener("mousemove", H), window.removeEventListener("touchmove", H), window.removeEventListener("mouseup", re), window.removeEventListener("touchend", re), window.removeEventListener("contextmenu", re));
  }, fe = async (J) => {
    if (J === null || Number.isNaN(+J))
      return;
    J < 0 ? J = 0 : J > 100 && (J = 100);
    const le = 100 / ((s.value - i.value) / o.value);
    let ge = Math.round(J / le) * le * (s.value - i.value) * 0.01 + i.value;
    ge = Number.parseFloat(ge.toFixed(l.value)), ge !== t.modelValue && n(Bt, ge), !e.dragging && t.modelValue !== e.oldValue && (e.oldValue = t.modelValue), await rt(), e.dragging && f(), y.value.updatePopper();
  };
  return ke(() => e.dragging, (J) => {
    v(J);
  }), {
    disabled: r,
    button: m,
    tooltip: y,
    tooltipVisible: b,
    showTooltip: a,
    wrapperStyle: _,
    formatValue: p,
    handleMouseEnter: S,
    handleMouseLeave: A,
    onButtonDown: C,
    onKeyDown: X,
    setPosition: fe
  };
}, wR = (t, e, n, r) => ({
  stops: F(() => {
    if (!t.showStops || t.min > t.max)
      return [];
    if (t.step === 0)
      return Vt("ElSlider", "step should not be 0."), [];
    const o = (t.max - t.min) / t.step, a = 100 * t.step / (t.max - t.min), l = Array.from({ length: o - 1 }).map((u, c) => (c + 1) * a);
    return t.range ? l.filter((u) => u < 100 * (n.value - t.min) / (t.max - t.min) || u > 100 * (r.value - t.min) / (t.max - t.min)) : l.filter((u) => u > 100 * (e.firstValue - t.min) / (t.max - t.min));
  }),
  getStopStyle: (o) => t.vertical ? { bottom: `${o}%` } : { left: `${o}%` }
}), _R = (t, e, n, r, i, s) => {
  const o = (u) => {
    i(Bt, u), i(Pi, u);
  }, a = () => t.range ? ![n.value, r.value].every((u, c) => u === e.oldValue[c]) : t.modelValue !== e.oldValue, l = () => {
    var u, c;
    t.min > t.max && qi("Slider", "min should not be greater than max.");
    const d = t.modelValue;
    t.range && Array.isArray(d) ? d[1] < t.min ? o([t.min, t.min]) : d[0] > t.max ? o([t.max, t.max]) : d[0] < t.min ? o([t.min, d[1]]) : d[1] > t.max ? o([d[0], t.max]) : (e.firstValue = d[0], e.secondValue = d[1], a() && (t.validateEvent && ((u = s == null ? void 0 : s.validate) == null || u.call(s, "change").catch((h) => Vt(h))), e.oldValue = d.slice())) : !t.range && typeof d == "number" && !Number.isNaN(d) && (d < t.min ? o(t.min) : d > t.max ? o(t.max) : (e.firstValue = d, a() && (t.validateEvent && ((c = s == null ? void 0 : s.validate) == null || c.call(s, "change").catch((h) => Vt(h))), e.oldValue = d)));
  };
  l(), ke(() => e.dragging, (u) => {
    u || l();
  }), ke(() => t.modelValue, (u, c) => {
    e.dragging || Array.isArray(u) && Array.isArray(c) && u.every((d, h) => d === c[h]) && e.firstValue === u[0] && e.secondValue === u[1] || l();
  }, {
    deep: !0
  }), ke(() => [t.min, t.max], () => {
    l();
  });
}, SR = ut({
  modelValue: {
    type: Number,
    default: 0
  },
  vertical: Boolean,
  tooltipClass: String,
  placement: {
    type: String,
    values: Fs,
    default: "top"
  }
}), ER = {
  [Bt]: (t) => mt(t)
}, xR = ["tabindex"], AR = be({
  name: "ElSliderButton"
}), kR = /* @__PURE__ */ be({
  ...AR,
  props: SR,
  emits: ER,
  setup(t, { expose: e, emit: n }) {
    const r = t, i = Fe("slider"), s = Bn({
      hovering: !1,
      dragging: !1,
      isClick: !1,
      startX: 0,
      currentX: 0,
      startY: 0,
      currentY: 0,
      startPosition: 0,
      newPosition: 0,
      oldValue: r.modelValue
    }), {
      disabled: o,
      button: a,
      tooltip: l,
      showTooltip: u,
      tooltipVisible: c,
      wrapperStyle: d,
      formatValue: h,
      handleMouseEnter: v,
      handleMouseLeave: y,
      onButtonDown: b,
      onKeyDown: p,
      setPosition: f
    } = bR(r, s, n), { hovering: g, dragging: m } = hn(s);
    return e({
      onButtonDown: b,
      onKeyDown: p,
      setPosition: f,
      hovering: g,
      dragging: m
    }), (w, _) => (V(), se("div", {
      ref_key: "button",
      ref: a,
      class: ee([x(i).e("button-wrapper"), { hover: x(g), dragging: x(m) }]),
      style: it(x(d)),
      tabindex: x(o) ? -1 : 0,
      onMouseenter: _[0] || (_[0] = (...S) => x(v) && x(v)(...S)),
      onMouseleave: _[1] || (_[1] = (...S) => x(y) && x(y)(...S)),
      onMousedown: _[2] || (_[2] = (...S) => x(b) && x(b)(...S)),
      onTouchstart: _[3] || (_[3] = (...S) => x(b) && x(b)(...S)),
      onFocus: _[4] || (_[4] = (...S) => x(v) && x(v)(...S)),
      onBlur: _[5] || (_[5] = (...S) => x(y) && x(y)(...S)),
      onKeydown: _[6] || (_[6] = (...S) => x(p) && x(p)(...S))
    }, [
      ve(x(Ql), {
        ref_key: "tooltip",
        ref: l,
        visible: x(c),
        placement: w.placement,
        "fallback-placements": ["top", "bottom", "right", "left"],
        "stop-popper-mouse-event": !1,
        "popper-class": w.tooltipClass,
        disabled: !x(u),
        persistent: ""
      }, {
        content: de(() => [
          ae("span", null, st(x(h)), 1)
        ]),
        default: de(() => [
          ae("div", {
            class: ee([x(i).e("button"), { hover: x(g), dragging: x(m) }])
          }, null, 2)
        ]),
        _: 1
      }, 8, ["visible", "placement", "popper-class", "disabled"])
    ], 46, xR));
  }
});
var op = /* @__PURE__ */ Ge(kR, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/button.vue"]]);
const CR = ut({
  mark: {
    type: Be([String, Object]),
    default: void 0
  }
});
var TR = be({
  name: "ElSliderMarker",
  props: CR,
  setup(t) {
    const e = Fe("slider"), n = F(() => Gt(t.mark) ? t.mark : t.mark.label), r = F(() => Gt(t.mark) ? void 0 : t.mark.style);
    return () => et("div", {
      class: e.e("marks-text"),
      style: r.value
    }, n.value);
  }
});
const OR = ["id", "role", "aria-label", "aria-labelledby"], IR = { key: 1 }, NR = be({
  name: "ElSlider"
}), RR = /* @__PURE__ */ be({
  ...NR,
  props: sR,
  emits: oR,
  setup(t, { expose: e, emit: n }) {
    const r = t, i = Fe("slider"), { t: s } = or(), o = Bn({
      firstValue: 0,
      secondValue: 0,
      oldValue: 0,
      dragging: !1,
      sliderSize: 1
    }), {
      elFormItem: a,
      slider: l,
      firstButton: u,
      secondButton: c,
      sliderDisabled: d,
      minValue: h,
      maxValue: v,
      runwayStyle: y,
      barStyle: b,
      resetSize: p,
      emitChange: f,
      onSliderWrapperPrevent: g,
      onSliderClick: m,
      onSliderDown: w,
      setFirstValue: _,
      setSecondValue: S
    } = uR(r, o, n), { stops: A, getStopStyle: C } = wR(r, o, h, v), { inputId: k, isLabeledByFormItem: O } = ea(r, {
      formItemContext: a
    }), N = Pr(), B = F(() => r.inputSize || N.value), M = F(() => r.label || s("el.slider.defaultLabel", {
      min: r.min,
      max: r.max
    })), j = F(() => r.range ? r.rangeStartLabel || s("el.slider.defaultRangeStartLabel") : M.value), q = F(() => r.formatValueText ? r.formatValueText(J.value) : `${J.value}`), X = F(() => r.rangeEndLabel || s("el.slider.defaultRangeEndLabel")), z = F(() => r.formatValueText ? r.formatValueText(le.value) : `${le.value}`), U = F(() => [
      i.b(),
      i.m(N.value),
      i.is("vertical", r.vertical),
      { [i.m("with-input")]: r.showInput }
    ]), H = lR(r);
    _R(r, o, h, v, n, a);
    const re = F(() => {
      const _e = [r.min, r.max, r.step].map((je) => {
        const Te = `${je}`.split(".")[1];
        return Te ? Te.length : 0;
      });
      return Math.max.apply(null, _e);
    }), { sliderWrapper: fe } = aR(r, o, p), { firstValue: J, secondValue: le, sliderSize: ce } = hn(o), ge = (_e) => {
      o.dragging = _e;
    };
    return qt(Om, {
      ...hn(r),
      sliderSize: ce,
      disabled: d,
      precision: re,
      emitChange: f,
      resetSize: p,
      updateDragging: ge
    }), e({
      onSliderClick: m
    }), (_e, je) => {
      var Te, Ze;
      return V(), se("div", {
        id: _e.range ? x(k) : void 0,
        ref_key: "sliderWrapper",
        ref: fe,
        class: ee(x(U)),
        role: _e.range ? "group" : void 0,
        "aria-label": _e.range && !x(O) ? x(M) : void 0,
        "aria-labelledby": _e.range && x(O) ? (Te = x(a)) == null ? void 0 : Te.labelId : void 0,
        onTouchstart: je[2] || (je[2] = (...Le) => x(g) && x(g)(...Le)),
        onTouchmove: je[3] || (je[3] = (...Le) => x(g) && x(g)(...Le))
      }, [
        ae("div", {
          ref_key: "slider",
          ref: l,
          class: ee([
            x(i).e("runway"),
            { "show-input": _e.showInput && !_e.range },
            x(i).is("disabled", x(d))
          ]),
          style: it(x(y)),
          onMousedown: je[0] || (je[0] = (...Le) => x(w) && x(w)(...Le)),
          onTouchstart: je[1] || (je[1] = (...Le) => x(w) && x(w)(...Le))
        }, [
          ae("div", {
            class: ee(x(i).e("bar")),
            style: it(x(b))
          }, null, 6),
          ve(op, {
            id: _e.range ? void 0 : x(k),
            ref_key: "firstButton",
            ref: u,
            "model-value": x(J),
            vertical: _e.vertical,
            "tooltip-class": _e.tooltipClass,
            placement: _e.placement,
            role: "slider",
            "aria-label": _e.range || !x(O) ? x(j) : void 0,
            "aria-labelledby": !_e.range && x(O) ? (Ze = x(a)) == null ? void 0 : Ze.labelId : void 0,
            "aria-valuemin": _e.min,
            "aria-valuemax": _e.range ? x(le) : _e.max,
            "aria-valuenow": x(J),
            "aria-valuetext": x(q),
            "aria-orientation": _e.vertical ? "vertical" : "horizontal",
            "aria-disabled": x(d),
            "onUpdate:modelValue": x(_)
          }, null, 8, ["id", "model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-labelledby", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"]),
          _e.range ? (V(), Ae(op, {
            key: 0,
            ref_key: "secondButton",
            ref: c,
            "model-value": x(le),
            vertical: _e.vertical,
            "tooltip-class": _e.tooltipClass,
            placement: _e.placement,
            role: "slider",
            "aria-label": x(X),
            "aria-valuemin": x(J),
            "aria-valuemax": _e.max,
            "aria-valuenow": x(le),
            "aria-valuetext": x(z),
            "aria-orientation": _e.vertical ? "vertical" : "horizontal",
            "aria-disabled": x(d),
            "onUpdate:modelValue": x(S)
          }, null, 8, ["model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"])) : ye("v-if", !0),
          _e.showStops ? (V(), se("div", IR, [
            (V(!0), se(Ft, null, qn(x(A), (Le, Ke) => (V(), se("div", {
              key: Ke,
              class: ee(x(i).e("stop")),
              style: it(x(C)(Le))
            }, null, 6))), 128))
          ])) : ye("v-if", !0),
          x(H).length > 0 ? (V(), se(Ft, { key: 2 }, [
            ae("div", null, [
              (V(!0), se(Ft, null, qn(x(H), (Le, Ke) => (V(), se("div", {
                key: Ke,
                style: it(x(C)(Le.position)),
                class: ee([x(i).e("stop"), x(i).e("marks-stop")])
              }, null, 6))), 128))
            ]),
            ae("div", {
              class: ee(x(i).e("marks"))
            }, [
              (V(!0), se(Ft, null, qn(x(H), (Le, Ke) => (V(), Ae(x(TR), {
                key: Ke,
                mark: Le.mark,
                style: it(x(C)(Le.position))
              }, null, 8, ["mark", "style"]))), 128))
            ], 2)
          ], 64)) : ye("v-if", !0)
        ], 38),
        _e.showInput && !_e.range ? (V(), Ae(x(xm), {
          key: 0,
          ref: "input",
          "model-value": x(J),
          class: ee(x(i).e("input")),
          step: _e.step,
          disabled: x(d),
          controls: _e.showInputControls,
          min: _e.min,
          max: _e.max,
          debounce: _e.debounce,
          size: x(B),
          "onUpdate:modelValue": x(_),
          onChange: x(f)
        }, null, 8, ["model-value", "class", "step", "disabled", "controls", "min", "max", "debounce", "size", "onUpdate:modelValue", "onChange"])) : ye("v-if", !0)
      ], 42, OR);
    };
  }
});
var PR = /* @__PURE__ */ Ge(RR, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/slider.vue"]]);
const BR = nn(PR);
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
var DR = /["'&<>]/, MR = LR;
function LR(t) {
  var e = "" + t, n = DR.exec(e);
  if (!n)
    return e;
  var r, i = "", s = 0, o = 0;
  for (s = n.index; s < e.length; s++) {
    switch (e.charCodeAt(s)) {
      case 34:
        r = "&quot;";
        break;
      case 38:
        r = "&amp;";
        break;
      case 39:
        r = "&#39;";
        break;
      case 60:
        r = "&lt;";
        break;
      case 62:
        r = "&gt;";
        break;
      default:
        continue;
    }
    o !== s && (i += e.substring(o, s)), o = s + 1, i += r;
  }
  return o !== s ? i + e.substring(o, s) : i;
}
const Cu = function(t) {
  var e;
  return (e = t.target) == null ? void 0 : e.closest("td");
}, zR = function(t, e, n, r, i) {
  if (!e && !r && (!i || Array.isArray(i) && !i.length))
    return t;
  typeof n == "string" ? n = n === "descending" ? -1 : 1 : n = n && n < 0 ? -1 : 1;
  const s = r ? null : function(a, l) {
    return i ? (Array.isArray(i) || (i = [i]), i.map((u) => typeof u == "string" ? An(a, u) : u(a, l, t))) : (e !== "$key" && wn(a) && "$value" in a && (a = a.$value), [wn(a) ? An(a, e) : a]);
  }, o = function(a, l) {
    if (r)
      return r(a.value, l.value);
    for (let u = 0, c = a.key.length; u < c; u++) {
      if (a.key[u] < l.key[u])
        return -1;
      if (a.key[u] > l.key[u])
        return 1;
    }
    return 0;
  };
  return t.map((a, l) => ({
    value: a,
    index: l,
    key: s ? s(a, l) : null
  })).sort((a, l) => {
    let u = o(a, l);
    return u || (u = a.index - l.index), u * +n;
  }).map((a) => a.value);
}, Im = function(t, e) {
  let n = null;
  return t.columns.forEach((r) => {
    r.id === e && (n = r);
  }), n;
}, jR = function(t, e) {
  let n = null;
  for (let r = 0; r < t.columns.length; r++) {
    const i = t.columns[r];
    if (i.columnKey === e) {
      n = i;
      break;
    }
  }
  return n || qi("ElTable", `No column matching with column-key: ${e}`), n;
}, ap = function(t, e, n) {
  const r = (e.className || "").match(new RegExp(`${n}-table_[^\\s]+`, "gm"));
  return r ? Im(t, r[0]) : null;
}, yn = (t, e) => {
  if (!t)
    throw new Error("Row is required when get row identity");
  if (typeof e == "string") {
    if (!e.includes("."))
      return `${t[e]}`;
    const n = e.split(".");
    let r = t;
    for (const i of n)
      r = r[i];
    return `${r}`;
  } else if (typeof e == "function")
    return e.call(null, t);
}, Ni = function(t, e) {
  const n = {};
  return (t || []).forEach((r, i) => {
    n[yn(r, e)] = { row: r, index: i };
  }), n;
};
function FR(t, e) {
  const n = {};
  let r;
  for (r in t)
    n[r] = t[r];
  for (r in e)
    if (Tr(e, r)) {
      const i = e[r];
      typeof i < "u" && (n[r] = i);
    }
  return n;
}
function Yd(t) {
  return t === "" || t !== void 0 && (t = Number.parseInt(t, 10), Number.isNaN(t) && (t = "")), t;
}
function Nm(t) {
  return t === "" || t !== void 0 && (t = Yd(t), Number.isNaN(t) && (t = 80)), t;
}
function HR(t) {
  return typeof t == "number" ? t : typeof t == "string" ? /^\d+(?:px)?$/.test(t) ? Number.parseInt(t, 10) : t : null;
}
function UR(...t) {
  return t.length === 0 ? (e) => e : t.length === 1 ? t[0] : t.reduce((e, n) => (...r) => e(n(...r)));
}
function co(t, e, n) {
  let r = !1;
  const i = t.indexOf(e), s = i !== -1, o = (a) => {
    a === "add" ? t.push(e) : t.splice(i, 1), r = !0, Or(e.children) && e.children.forEach((l) => {
      co(t, l, n ?? !s);
    });
  };
  return Qr(n) ? n && !s ? o("add") : !n && s && o("remove") : o(s ? "remove" : "add"), r;
}
function VR(t, e, n = "children", r = "hasChildren") {
  const i = (o) => !(Array.isArray(o) && o.length);
  function s(o, a, l) {
    e(o, a, l), a.forEach((u) => {
      if (u[r]) {
        e(u, null, l + 1);
        return;
      }
      const c = u[n];
      i(c) || s(u, c, l + 1);
    });
  }
  t.forEach((o) => {
    if (o[r]) {
      e(o, null, 0);
      return;
    }
    const a = o[n];
    i(a) || s(o, a, 0);
  });
}
let Fr;
function WR(t, e, n, r, i) {
  i = tg({
    enterable: !0,
    showArrow: !0
  }, i);
  const s = t == null ? void 0 : t.dataset.prefix, o = t == null ? void 0 : t.querySelector(`.${s}-scrollbar__wrap`);
  function a() {
    const p = i.effect === "light", f = document.createElement("div");
    return f.className = [
      `${s}-popper`,
      p ? "is-light" : "is-dark",
      i.popperClass || ""
    ].join(" "), n = MR(n), f.innerHTML = n, f.style.zIndex = String(r()), t == null || t.appendChild(f), f;
  }
  function l() {
    const p = document.createElement("div");
    return p.className = `${s}-popper__arrow`, p;
  }
  function u() {
    c && c.update();
  }
  Fr == null || Fr(), Fr = () => {
    try {
      c && c.destroy(), v && (t == null || t.removeChild(v)), e.removeEventListener("mouseenter", d), e.removeEventListener("mouseleave", h), o == null || o.removeEventListener("scroll", Fr), Fr = void 0;
    } catch {
    }
  };
  let c = null, d = u, h = Fr;
  i.enterable && ({ onOpen: d, onClose: h } = Bg({
    showAfter: i.showAfter,
    hideAfter: i.hideAfter,
    open: u,
    close: Fr
  }));
  const v = a();
  v.onmouseenter = d, v.onmouseleave = h;
  const y = [];
  if (i.offset && y.push({
    name: "offset",
    options: {
      offset: [0, i.offset]
    }
  }), i.showArrow) {
    const p = v.appendChild(l());
    y.push({
      name: "arrow",
      options: {
        element: p,
        padding: 10
      }
    });
  }
  const b = i.popperOptions || {};
  return c = Ng(e, v, {
    placement: i.placement || "top",
    strategy: "fixed",
    ...b,
    modifiers: b.modifiers ? y.concat(b.modifiers) : y
  }), e.addEventListener("mouseenter", d), e.addEventListener("mouseleave", h), o == null || o.addEventListener("scroll", Fr), c;
}
function Rm(t) {
  return t.children ? wx(t.children, Rm) : [t];
}
function lp(t, e) {
  return t + e.colSpan;
}
const Pm = (t, e, n, r) => {
  let i = 0, s = t;
  const o = n.states.columns.value;
  if (r) {
    const l = Rm(r[t]);
    i = o.slice(0, o.indexOf(l[0])).reduce(lp, 0), s = i + l.reduce(lp, 0) - 1;
  } else
    i = t;
  let a;
  switch (e) {
    case "left":
      s < n.states.fixedLeafColumnsLength.value && (a = "left");
      break;
    case "right":
      i >= o.length - n.states.rightFixedLeafColumnsLength.value && (a = "right");
      break;
    default:
      s < n.states.fixedLeafColumnsLength.value ? a = "left" : i >= o.length - n.states.rightFixedLeafColumnsLength.value && (a = "right");
  }
  return a ? {
    direction: a,
    start: i,
    after: s
  } : {};
}, Qd = (t, e, n, r, i, s = 0) => {
  const o = [], { direction: a, start: l, after: u } = Pm(e, n, r, i);
  if (a) {
    const c = a === "left";
    o.push(`${t}-fixed-column--${a}`), c && u + s === r.states.fixedLeafColumnsLength.value - 1 ? o.push("is-last-column") : !c && l - s === r.states.columns.value.length - r.states.rightFixedLeafColumnsLength.value && o.push("is-first-column");
  }
  return o;
};
function up(t, e) {
  return t + (e.realWidth === null || Number.isNaN(e.realWidth) ? Number(e.width) : e.realWidth);
}
const Zd = (t, e, n, r) => {
  const {
    direction: i,
    start: s = 0,
    after: o = 0
  } = Pm(t, e, n, r);
  if (!i)
    return;
  const a = {}, l = i === "left", u = n.states.columns.value;
  return l ? a.left = u.slice(0, s).reduce(up, 0) : a.right = u.slice(o + 1).reverse().reduce(up, 0), a;
}, Ps = (t, e) => {
  t && (Number.isNaN(t[e]) || (t[e] = `${t[e]}px`));
};
function KR(t) {
  const e = ht(), n = $(!1), r = $([]);
  return {
    updateExpandRows: () => {
      const l = t.data.value || [], u = t.rowKey.value;
      if (n.value)
        r.value = l.slice();
      else if (u) {
        const c = Ni(r.value, u);
        r.value = l.reduce((d, h) => {
          const v = yn(h, u);
          return c[v] && d.push(h), d;
        }, []);
      } else
        r.value = [];
    },
    toggleRowExpansion: (l, u) => {
      co(r.value, l, u) && e.emit("expand-change", l, r.value.slice());
    },
    setExpandRowKeys: (l) => {
      e.store.assertRowKey();
      const u = t.data.value || [], c = t.rowKey.value, d = Ni(u, c);
      r.value = l.reduce((h, v) => {
        const y = d[v];
        return y && h.push(y.row), h;
      }, []);
    },
    isRowExpanded: (l) => {
      const u = t.rowKey.value;
      return u ? !!Ni(r.value, u)[yn(l, u)] : r.value.includes(l);
    },
    states: {
      expandRows: r,
      defaultExpandAll: n
    }
  };
}
function $R(t) {
  const e = ht(), n = $(null), r = $(null), i = (u) => {
    e.store.assertRowKey(), n.value = u, o(u);
  }, s = () => {
    n.value = null;
  }, o = (u) => {
    const { data: c, rowKey: d } = t;
    let h = null;
    d.value && (h = (x(c) || []).find((v) => yn(v, d.value) === u)), r.value = h, e.emit("current-change", r.value, null);
  };
  return {
    setCurrentRowKey: i,
    restoreCurrentRowKey: s,
    setCurrentRowByKey: o,
    updateCurrentRow: (u) => {
      const c = r.value;
      if (u && u !== c) {
        r.value = u, e.emit("current-change", r.value, c);
        return;
      }
      !u && c && (r.value = null, e.emit("current-change", null, c));
    },
    updateCurrentRowData: () => {
      const u = t.rowKey.value, c = t.data.value || [], d = r.value;
      if (!c.includes(d) && d) {
        if (u) {
          const h = yn(d, u);
          o(h);
        } else
          r.value = null;
        r.value === null && e.emit("current-change", null, d);
      } else
        n.value && (o(n.value), s());
    },
    states: {
      _currentRowKey: n,
      currentRow: r
    }
  };
}
function GR(t) {
  const e = $([]), n = $({}), r = $(16), i = $(!1), s = $({}), o = $("hasChildren"), a = $("children"), l = ht(), u = F(() => {
    if (!t.rowKey.value)
      return {};
    const f = t.data.value || [];
    return d(f);
  }), c = F(() => {
    const f = t.rowKey.value, g = Object.keys(s.value), m = {};
    return g.length && g.forEach((w) => {
      if (s.value[w].length) {
        const _ = { children: [] };
        s.value[w].forEach((S) => {
          const A = yn(S, f);
          _.children.push(A), S[o.value] && !m[A] && (m[A] = { children: [] });
        }), m[w] = _;
      }
    }), m;
  }), d = (f) => {
    const g = t.rowKey.value, m = {};
    return VR(f, (w, _, S) => {
      const A = yn(w, g);
      Array.isArray(_) ? m[A] = {
        children: _.map((C) => yn(C, g)),
        level: S
      } : i.value && (m[A] = {
        children: [],
        lazy: !0,
        level: S
      });
    }, a.value, o.value), m;
  }, h = (f = !1, g = ((m) => (m = l.store) == null ? void 0 : m.states.defaultExpandAll.value)()) => {
    var m;
    const w = u.value, _ = c.value, S = Object.keys(w), A = {};
    if (S.length) {
      const C = x(n), k = [], O = (B, M) => {
        if (f)
          return e.value ? g || e.value.includes(M) : !!(g || B != null && B.expanded);
        {
          const j = g || e.value && e.value.includes(M);
          return !!(B != null && B.expanded || j);
        }
      };
      S.forEach((B) => {
        const M = C[B], j = { ...w[B] };
        if (j.expanded = O(M, B), j.lazy) {
          const { loaded: q = !1, loading: X = !1 } = M || {};
          j.loaded = !!q, j.loading = !!X, k.push(B);
        }
        A[B] = j;
      });
      const N = Object.keys(_);
      i.value && N.length && k.length && N.forEach((B) => {
        const M = C[B], j = _[B].children;
        if (k.includes(B)) {
          if (A[B].children.length !== 0)
            throw new Error("[ElTable]children must be an empty array.");
          A[B].children = j;
        } else {
          const { loaded: q = !1, loading: X = !1 } = M || {};
          A[B] = {
            lazy: !0,
            loaded: !!q,
            loading: !!X,
            expanded: O(M, B),
            children: j,
            level: ""
          };
        }
      });
    }
    n.value = A, (m = l.store) == null || m.updateTableScrollY();
  };
  ke(() => e.value, () => {
    h(!0);
  }), ke(() => u.value, () => {
    h();
  }), ke(() => c.value, () => {
    h();
  });
  const v = (f) => {
    e.value = f, h();
  }, y = (f, g) => {
    l.store.assertRowKey();
    const m = t.rowKey.value, w = yn(f, m), _ = w && n.value[w];
    if (w && _ && "expanded" in _) {
      const S = _.expanded;
      g = typeof g > "u" ? !_.expanded : g, n.value[w].expanded = g, S !== g && l.emit("expand-change", f, g), l.store.updateTableScrollY();
    }
  }, b = (f) => {
    l.store.assertRowKey();
    const g = t.rowKey.value, m = yn(f, g), w = n.value[m];
    i.value && w && "loaded" in w && !w.loaded ? p(f, m, w) : y(f, void 0);
  }, p = (f, g, m) => {
    const { load: w } = l.props;
    w && !n.value[g].loaded && (n.value[g].loading = !0, w(f, m, (_) => {
      if (!Array.isArray(_))
        throw new TypeError("[ElTable] data must be an array");
      n.value[g].loading = !1, n.value[g].loaded = !0, n.value[g].expanded = !0, _.length && (s.value[g] = _), l.emit("expand-change", f, !0);
    }));
  };
  return {
    loadData: p,
    loadOrToggle: b,
    toggleTreeExpansion: y,
    updateTreeExpandKeys: v,
    updateTreeData: h,
    normalize: d,
    states: {
      expandRowKeys: e,
      treeData: n,
      indent: r,
      lazy: i,
      lazyTreeNodeMap: s,
      lazyColumnIdentifier: o,
      childrenColumnName: a
    }
  };
}
const qR = (t, e) => {
  const n = e.sortingColumn;
  return !n || typeof n.sortable == "string" ? t : zR(t, e.sortProp, e.sortOrder, n.sortMethod, n.sortBy);
}, Ha = (t) => {
  const e = [];
  return t.forEach((n) => {
    n.children && n.children.length > 0 ? e.push.apply(e, Ha(n.children)) : e.push(n);
  }), e;
};
function JR() {
  var t;
  const e = ht(), { size: n } = hn((t = e.proxy) == null ? void 0 : t.$props), r = $(null), i = $([]), s = $([]), o = $(!1), a = $([]), l = $([]), u = $([]), c = $([]), d = $([]), h = $([]), v = $([]), y = $([]), b = [], p = $(0), f = $(0), g = $(0), m = $(!1), w = $([]), _ = $(!1), S = $(!1), A = $(null), C = $({}), k = $(null), O = $(null), N = $(null), B = $(null), M = $(null);
  ke(i, () => e.state && z(!1), {
    deep: !0
  });
  const j = () => {
    if (!r.value)
      throw new Error("[ElTable] prop row-key is required");
  }, q = (Ie) => {
    var Ve;
    (Ve = Ie.children) == null || Ve.forEach((Je) => {
      Je.fixed = Ie.fixed, q(Je);
    });
  }, X = () => {
    a.value.forEach((Qe) => {
      q(Qe);
    }), c.value = a.value.filter((Qe) => Qe.fixed === !0 || Qe.fixed === "left"), d.value = a.value.filter((Qe) => Qe.fixed === "right"), c.value.length > 0 && a.value[0] && a.value[0].type === "selection" && !a.value[0].fixed && (a.value[0].fixed = !0, c.value.unshift(a.value[0]));
    const Ie = a.value.filter((Qe) => !Qe.fixed);
    l.value = [].concat(c.value).concat(Ie).concat(d.value);
    const Ve = Ha(Ie), Je = Ha(c.value), He = Ha(d.value);
    p.value = Ve.length, f.value = Je.length, g.value = He.length, u.value = [].concat(Je).concat(Ve).concat(He), o.value = c.value.length > 0 || d.value.length > 0;
  }, z = (Ie, Ve = !1) => {
    Ie && X(), Ve ? e.state.doLayout() : e.state.debouncedUpdateLayout();
  }, U = (Ie) => w.value.includes(Ie), H = () => {
    m.value = !1, w.value.length && (w.value = [], e.emit("selection-change", []));
  }, re = () => {
    let Ie;
    if (r.value) {
      Ie = [];
      const Ve = Ni(w.value, r.value), Je = Ni(i.value, r.value);
      for (const He in Ve)
        Tr(Ve, He) && !Je[He] && Ie.push(Ve[He].row);
    } else
      Ie = w.value.filter((Ve) => !i.value.includes(Ve));
    if (Ie.length) {
      const Ve = w.value.filter((Je) => !Ie.includes(Je));
      w.value = Ve, e.emit("selection-change", Ve.slice());
    }
  }, fe = () => (w.value || []).slice(), J = (Ie, Ve = void 0, Je = !0) => {
    if (co(w.value, Ie, Ve)) {
      const Qe = (w.value || []).slice();
      Je && e.emit("select", Qe, Ie), e.emit("selection-change", Qe);
    }
  }, le = () => {
    var Ie, Ve;
    const Je = S.value ? !m.value : !(m.value || w.value.length);
    m.value = Je;
    let He = !1, Qe = 0;
    const At = (Ve = (Ie = e == null ? void 0 : e.store) == null ? void 0 : Ie.states) == null ? void 0 : Ve.rowKey.value;
    i.value.forEach((P, he) => {
      const me = he + Qe;
      A.value ? A.value.call(null, P, me) && co(w.value, P, Je) && (He = !0) : co(w.value, P, Je) && (He = !0), Qe += _e(yn(P, At));
    }), He && e.emit("selection-change", w.value ? w.value.slice() : []), e.emit("select-all", w.value);
  }, ce = () => {
    const Ie = Ni(w.value, r.value);
    i.value.forEach((Ve) => {
      const Je = yn(Ve, r.value), He = Ie[Je];
      He && (w.value[He.index] = Ve);
    });
  }, ge = () => {
    var Ie, Ve, Je;
    if (((Ie = i.value) == null ? void 0 : Ie.length) === 0) {
      m.value = !1;
      return;
    }
    let He;
    r.value && (He = Ni(w.value, r.value));
    const Qe = function(me) {
      return He ? !!He[yn(me, r.value)] : w.value.includes(me);
    };
    let At = !0, P = 0, he = 0;
    for (let me = 0, Ne = (i.value || []).length; me < Ne; me++) {
      const G = (Je = (Ve = e == null ? void 0 : e.store) == null ? void 0 : Ve.states) == null ? void 0 : Je.rowKey.value, ue = me + he, T = i.value[me], L = A.value && A.value.call(null, T, ue);
      if (Qe(T))
        P++;
      else if (!A.value || L) {
        At = !1;
        break;
      }
      he += _e(yn(T, G));
    }
    P === 0 && (At = !1), m.value = At;
  }, _e = (Ie) => {
    var Ve;
    if (!e || !e.store)
      return 0;
    const { treeData: Je } = e.store.states;
    let He = 0;
    const Qe = (Ve = Je.value[Ie]) == null ? void 0 : Ve.children;
    return Qe && (He += Qe.length, Qe.forEach((At) => {
      He += _e(At);
    })), He;
  }, je = (Ie, Ve) => {
    Array.isArray(Ie) || (Ie = [Ie]);
    const Je = {};
    return Ie.forEach((He) => {
      C.value[He.id] = Ve, Je[He.columnKey || He.id] = Ve;
    }), Je;
  }, Te = (Ie, Ve, Je) => {
    O.value && O.value !== Ie && (O.value.order = null), O.value = Ie, N.value = Ve, B.value = Je;
  }, Ze = () => {
    let Ie = x(s);
    Object.keys(C.value).forEach((Ve) => {
      const Je = C.value[Ve];
      if (!Je || Je.length === 0)
        return;
      const He = Im({
        columns: u.value
      }, Ve);
      He && He.filterMethod && (Ie = Ie.filter((Qe) => Je.some((At) => He.filterMethod.call(null, At, Qe, He))));
    }), k.value = Ie;
  }, Le = () => {
    i.value = qR(k.value, {
      sortingColumn: O.value,
      sortProp: N.value,
      sortOrder: B.value
    });
  }, Ke = (Ie = void 0) => {
    Ie && Ie.filter || Ze(), Le();
  }, ct = (Ie) => {
    const { tableHeaderRef: Ve } = e.refs;
    if (!Ve)
      return;
    const Je = Object.assign({}, Ve.filterPanels), He = Object.keys(Je);
    if (He.length)
      if (typeof Ie == "string" && (Ie = [Ie]), Array.isArray(Ie)) {
        const Qe = Ie.map((At) => jR({
          columns: u.value
        }, At));
        He.forEach((At) => {
          const P = Qe.find((he) => he.id === At);
          P && (P.filteredValue = []);
        }), e.store.commit("filterChange", {
          column: Qe,
          values: [],
          silent: !0,
          multi: !0
        });
      } else
        He.forEach((Qe) => {
          const At = u.value.find((P) => P.id === Qe);
          At && (At.filteredValue = []);
        }), C.value = {}, e.store.commit("filterChange", {
          column: {},
          values: [],
          silent: !0
        });
  }, nt = () => {
    O.value && (Te(null, null, null), e.store.commit("changeSortCondition", {
      silent: !0
    }));
  }, {
    setExpandRowKeys: Et,
    toggleRowExpansion: yt,
    updateExpandRows: Nt,
    states: ot,
    isRowExpanded: bt
  } = KR({
    data: i,
    rowKey: r
  }), {
    updateTreeExpandKeys: $t,
    toggleTreeExpansion: wt,
    updateTreeData: xt,
    loadOrToggle: lt,
    states: qe
  } = GR({
    data: i,
    rowKey: r
  }), {
    updateCurrentRowData: Rt,
    updateCurrentRow: we,
    setCurrentRowKey: Ue,
    states: at
  } = $R({
    data: i,
    rowKey: r
  });
  return {
    assertRowKey: j,
    updateColumns: X,
    scheduleLayout: z,
    isSelected: U,
    clearSelection: H,
    cleanSelection: re,
    getSelectionRows: fe,
    toggleRowSelection: J,
    _toggleAllSelection: le,
    toggleAllSelection: null,
    updateSelectionByRowKey: ce,
    updateAllSelected: ge,
    updateFilters: je,
    updateCurrentRow: we,
    updateSort: Te,
    execFilter: Ze,
    execSort: Le,
    execQuery: Ke,
    clearFilter: ct,
    clearSort: nt,
    toggleRowExpansion: yt,
    setExpandRowKeysAdapter: (Ie) => {
      Et(Ie), $t(Ie);
    },
    setCurrentRowKey: Ue,
    toggleRowExpansionAdapter: (Ie, Ve) => {
      u.value.some(({ type: He }) => He === "expand") ? yt(Ie, Ve) : wt(Ie, Ve);
    },
    isRowExpanded: bt,
    updateExpandRows: Nt,
    updateCurrentRowData: Rt,
    loadOrToggle: lt,
    updateTreeData: xt,
    states: {
      tableSize: n,
      rowKey: r,
      data: i,
      _data: s,
      isComplex: o,
      _columns: a,
      originColumns: l,
      columns: u,
      fixedColumns: c,
      rightFixedColumns: d,
      leafColumns: h,
      fixedLeafColumns: v,
      rightFixedLeafColumns: y,
      updateOrderFns: b,
      leafColumnsLength: p,
      fixedLeafColumnsLength: f,
      rightFixedLeafColumnsLength: g,
      isAllSelected: m,
      selection: w,
      reserveSelection: _,
      selectOnIndeterminate: S,
      selectable: A,
      filters: C,
      filteredData: k,
      sortingColumn: O,
      sortProp: N,
      sortOrder: B,
      hoverRow: M,
      ...ot,
      ...qe,
      ...at
    }
  };
}
function mc(t, e) {
  return t.map((n) => {
    var r;
    return n.id === e.id ? e : ((r = n.children) != null && r.length && (n.children = mc(n.children, e)), n);
  });
}
function yc(t) {
  t.forEach((e) => {
    var n, r;
    e.no = (n = e.getColumnIndex) == null ? void 0 : n.call(e), (r = e.children) != null && r.length && yc(e.children);
  }), t.sort((e, n) => e.no - n.no);
}
function YR() {
  const t = ht(), e = JR();
  return {
    ns: Fe("table"),
    ...e,
    mutations: {
      setData(o, a) {
        const l = x(o._data) !== a;
        o.data.value = a, o._data.value = a, t.store.execQuery(), t.store.updateCurrentRowData(), t.store.updateExpandRows(), t.store.updateTreeData(t.store.states.defaultExpandAll.value), x(o.reserveSelection) ? (t.store.assertRowKey(), t.store.updateSelectionByRowKey()) : l ? t.store.clearSelection() : t.store.cleanSelection(), t.store.updateAllSelected(), t.$ready && t.store.scheduleLayout();
      },
      insertColumn(o, a, l, u) {
        const c = x(o._columns);
        let d = [];
        l ? (l && !l.children && (l.children = []), l.children.push(a), d = mc(c, l)) : (c.push(a), d = c), yc(d), o._columns.value = d, o.updateOrderFns.push(u), a.type === "selection" && (o.selectable.value = a.selectable, o.reserveSelection.value = a.reserveSelection), t.$ready && (t.store.updateColumns(), t.store.scheduleLayout());
      },
      updateColumnOrder(o, a) {
        var l;
        ((l = a.getColumnIndex) == null ? void 0 : l.call(a)) !== a.no && (yc(o._columns.value), t.$ready && t.store.updateColumns());
      },
      removeColumn(o, a, l, u) {
        const c = x(o._columns) || [];
        if (l)
          l.children.splice(l.children.findIndex((h) => h.id === a.id), 1), rt(() => {
            var h;
            ((h = l.children) == null ? void 0 : h.length) === 0 && delete l.children;
          }), o._columns.value = mc(c, l);
        else {
          const h = c.indexOf(a);
          h > -1 && (c.splice(h, 1), o._columns.value = c);
        }
        const d = o.updateOrderFns.indexOf(u);
        d > -1 && o.updateOrderFns.splice(d, 1), t.$ready && (t.store.updateColumns(), t.store.scheduleLayout());
      },
      sort(o, a) {
        const { prop: l, order: u, init: c } = a;
        if (l) {
          const d = x(o.columns).find((h) => h.property === l);
          d && (d.order = u, t.store.updateSort(d, l, u), t.store.commit("changeSortCondition", { init: c }));
        }
      },
      changeSortCondition(o, a) {
        const { sortingColumn: l, sortProp: u, sortOrder: c } = o, d = x(l), h = x(u), v = x(c);
        v === null && (o.sortingColumn.value = null, o.sortProp.value = null);
        const y = { filter: !0 };
        t.store.execQuery(y), (!a || !(a.silent || a.init)) && t.emit("sort-change", {
          column: d,
          prop: h,
          order: v
        }), t.store.updateTableScrollY();
      },
      filterChange(o, a) {
        const { column: l, values: u, silent: c } = a, d = t.store.updateFilters(l, u);
        t.store.execQuery(), c || t.emit("filter-change", d), t.store.updateTableScrollY();
      },
      toggleAllSelection() {
        t.store.toggleAllSelection();
      },
      rowSelectedChanged(o, a) {
        t.store.toggleRowSelection(a), t.store.updateAllSelected();
      },
      setHoverRow(o, a) {
        o.hoverRow.value = a;
      },
      setCurrentRow(o, a) {
        t.store.updateCurrentRow(a);
      }
    },
    commit: function(o, ...a) {
      const l = t.store.mutations;
      if (l[o])
        l[o].apply(t, [t.store.states].concat(a));
      else
        throw new Error(`Action not found: ${o}`);
    },
    updateTableScrollY: function() {
      rt(() => t.layout.updateScrollY.apply(t.layout));
    }
  };
}
const fo = {
  rowKey: "rowKey",
  defaultExpandAll: "defaultExpandAll",
  selectOnIndeterminate: "selectOnIndeterminate",
  indent: "indent",
  lazy: "lazy",
  data: "data",
  ["treeProps.hasChildren"]: {
    key: "lazyColumnIdentifier",
    default: "hasChildren"
  },
  ["treeProps.children"]: {
    key: "childrenColumnName",
    default: "children"
  }
};
function QR(t, e) {
  if (!t)
    throw new Error("Table is required.");
  const n = YR();
  return n.toggleAllSelection = Yr(n._toggleAllSelection, 10), Object.keys(fo).forEach((r) => {
    Bm(Dm(e, r), r, n);
  }), ZR(n, e), n;
}
function ZR(t, e) {
  Object.keys(fo).forEach((n) => {
    ke(() => Dm(e, n), (r) => {
      Bm(r, n, t);
    });
  });
}
function Bm(t, e, n) {
  let r = t, i = fo[e];
  typeof fo[e] == "object" && (i = i.key, r = r || fo[e].default), n.states[i].value = r;
}
function Dm(t, e) {
  if (e.includes(".")) {
    const n = e.split(".");
    let r = t;
    return n.forEach((i) => {
      r = r[i];
    }), r;
  } else
    return t[e];
}
class XR {
  constructor(e) {
    this.observers = [], this.table = null, this.store = null, this.columns = [], this.fit = !0, this.showHeader = !0, this.height = $(null), this.scrollX = $(!1), this.scrollY = $(!1), this.bodyWidth = $(null), this.fixedWidth = $(null), this.rightFixedWidth = $(null), this.gutterWidth = 0;
    for (const n in e)
      Tr(e, n) && (on(this[n]) ? this[n].value = e[n] : this[n] = e[n]);
    if (!this.table)
      throw new Error("Table is required for Table Layout");
    if (!this.store)
      throw new Error("Store is required for Table Layout");
  }
  updateScrollY() {
    if (this.height.value === null)
      return !1;
    const n = this.table.refs.scrollBarRef;
    if (this.table.vnode.el && (n != null && n.wrapRef)) {
      let r = !0;
      const i = this.scrollY.value;
      return r = n.wrapRef.scrollHeight > n.wrapRef.clientHeight, this.scrollY.value = r, i !== r;
    }
    return !1;
  }
  setHeight(e, n = "height") {
    if (!St)
      return;
    const r = this.table.vnode.el;
    if (e = HR(e), this.height.value = Number(e), !r && (e || e === 0))
      return rt(() => this.setHeight(e, n));
    typeof e == "number" ? (r.style[n] = `${e}px`, this.updateElsHeight()) : typeof e == "string" && (r.style[n] = e, this.updateElsHeight());
  }
  setMaxHeight(e) {
    this.setHeight(e, "max-height");
  }
  getFlattenColumns() {
    const e = [];
    return this.table.store.states.columns.value.forEach((r) => {
      r.isColumnGroup ? e.push.apply(e, r.columns) : e.push(r);
    }), e;
  }
  updateElsHeight() {
    this.updateScrollY(), this.notifyObservers("scrollable");
  }
  headerDisplayNone(e) {
    if (!e)
      return !0;
    let n = e;
    for (; n.tagName !== "DIV"; ) {
      if (getComputedStyle(n).display === "none")
        return !0;
      n = n.parentElement;
    }
    return !1;
  }
  updateColumnsWidth() {
    if (!St)
      return;
    const e = this.fit, n = this.table.vnode.el.clientWidth;
    let r = 0;
    const i = this.getFlattenColumns(), s = i.filter((l) => typeof l.width != "number");
    if (i.forEach((l) => {
      typeof l.width == "number" && l.realWidth && (l.realWidth = null);
    }), s.length > 0 && e) {
      if (i.forEach((l) => {
        r += Number(l.width || l.minWidth || 80);
      }), r <= n) {
        this.scrollX.value = !1;
        const l = n - r;
        if (s.length === 1)
          s[0].realWidth = Number(s[0].minWidth || 80) + l;
        else {
          const u = s.reduce((h, v) => h + Number(v.minWidth || 80), 0), c = l / u;
          let d = 0;
          s.forEach((h, v) => {
            if (v === 0)
              return;
            const y = Math.floor(Number(h.minWidth || 80) * c);
            d += y, h.realWidth = Number(h.minWidth || 80) + y;
          }), s[0].realWidth = Number(s[0].minWidth || 80) + l - d;
        }
      } else
        this.scrollX.value = !0, s.forEach((l) => {
          l.realWidth = Number(l.minWidth);
        });
      this.bodyWidth.value = Math.max(r, n), this.table.state.resizeState.value.width = this.bodyWidth.value;
    } else
      i.forEach((l) => {
        !l.width && !l.minWidth ? l.realWidth = 80 : l.realWidth = Number(l.width || l.minWidth), r += l.realWidth;
      }), this.scrollX.value = r > n, this.bodyWidth.value = r;
    const o = this.store.states.fixedColumns.value;
    if (o.length > 0) {
      let l = 0;
      o.forEach((u) => {
        l += Number(u.realWidth || u.width);
      }), this.fixedWidth.value = l;
    }
    const a = this.store.states.rightFixedColumns.value;
    if (a.length > 0) {
      let l = 0;
      a.forEach((u) => {
        l += Number(u.realWidth || u.width);
      }), this.rightFixedWidth.value = l;
    }
    this.notifyObservers("columns");
  }
  addObserver(e) {
    this.observers.push(e);
  }
  removeObserver(e) {
    const n = this.observers.indexOf(e);
    n !== -1 && this.observers.splice(n, 1);
  }
  notifyObservers(e) {
    this.observers.forEach((r) => {
      var i, s;
      switch (e) {
        case "columns":
          (i = r.state) == null || i.onColumnsChange(this);
          break;
        case "scrollable":
          (s = r.state) == null || s.onScrollableChange(this);
          break;
        default:
          throw new Error(`Table Layout don't have event ${e}.`);
      }
    });
  }
}
const { CheckboxGroup: eP } = Fi, tP = be({
  name: "ElTableFilterPanel",
  components: {
    ElCheckbox: Fi,
    ElCheckboxGroup: eP,
    ElScrollbar: Wd,
    ElTooltip: Ql,
    ElIcon: _t,
    ArrowDown: Od,
    ArrowUp: sg
  },
  directives: { ClickOutside: Zg },
  props: {
    placement: {
      type: String,
      default: "bottom-start"
    },
    store: {
      type: Object
    },
    column: {
      type: Object
    },
    upDataColumn: {
      type: Function
    }
  },
  setup(t) {
    const e = ht(), { t: n } = or(), r = Fe("table-filter"), i = e == null ? void 0 : e.parent;
    i.filterPanels.value[t.column.id] || (i.filterPanels.value[t.column.id] = e);
    const s = $(!1), o = $(null), a = F(() => t.column && t.column.filters), l = F({
      get: () => {
        var w;
        return (((w = t.column) == null ? void 0 : w.filteredValue) || [])[0];
      },
      set: (w) => {
        u.value && (typeof w < "u" && w !== null ? u.value.splice(0, 1, w) : u.value.splice(0, 1));
      }
    }), u = F({
      get() {
        return t.column ? t.column.filteredValue || [] : [];
      },
      set(w) {
        t.column && t.upDataColumn("filteredValue", w);
      }
    }), c = F(() => t.column ? t.column.filterMultiple : !0), d = (w) => w.value === l.value, h = () => {
      s.value = !1;
    }, v = (w) => {
      w.stopPropagation(), s.value = !s.value;
    }, y = () => {
      s.value = !1;
    }, b = () => {
      g(u.value), h();
    }, p = () => {
      u.value = [], g(u.value), h();
    }, f = (w) => {
      l.value = w, g(typeof w < "u" && w !== null ? u.value : []), h();
    }, g = (w) => {
      t.store.commit("filterChange", {
        column: t.column,
        values: w
      }), t.store.updateAllSelected();
    };
    ke(s, (w) => {
      t.column && t.upDataColumn("filterOpened", w);
    }, {
      immediate: !0
    });
    const m = F(() => {
      var w, _;
      return (_ = (w = o.value) == null ? void 0 : w.popperRef) == null ? void 0 : _.contentRef;
    });
    return {
      tooltipVisible: s,
      multiple: c,
      filteredValue: u,
      filterValue: l,
      filters: a,
      handleConfirm: b,
      handleReset: p,
      handleSelect: f,
      isActive: d,
      t: n,
      ns: r,
      showFilterPanel: v,
      hideFilterPanel: y,
      popperPaneRef: m,
      tooltip: o
    };
  }
}), nP = { key: 0 }, rP = ["disabled"], iP = ["label", "onClick"];
function sP(t, e, n, r, i, s) {
  const o = Mt("el-checkbox"), a = Mt("el-checkbox-group"), l = Mt("el-scrollbar"), u = Mt("arrow-up"), c = Mt("arrow-down"), d = Mt("el-icon"), h = Mt("el-tooltip"), v = ud("click-outside");
  return V(), Ae(h, {
    ref: "tooltip",
    visible: t.tooltipVisible,
    offset: 0,
    placement: t.placement,
    "show-arrow": !1,
    "stop-popper-mouse-event": !1,
    teleported: "",
    effect: "light",
    pure: "",
    "popper-class": t.ns.b(),
    persistent: ""
  }, {
    content: de(() => [
      t.multiple ? (V(), se("div", nP, [
        ae("div", {
          class: ee(t.ns.e("content"))
        }, [
          ve(l, {
            "wrap-class": t.ns.e("wrap")
          }, {
            default: de(() => [
              ve(a, {
                modelValue: t.filteredValue,
                "onUpdate:modelValue": e[0] || (e[0] = (y) => t.filteredValue = y),
                class: ee(t.ns.e("checkbox-group"))
              }, {
                default: de(() => [
                  (V(!0), se(Ft, null, qn(t.filters, (y) => (V(), Ae(o, {
                    key: y.value,
                    label: y.value
                  }, {
                    default: de(() => [
                      cn(st(y.text), 1)
                    ]),
                    _: 2
                  }, 1032, ["label"]))), 128))
                ]),
                _: 1
              }, 8, ["modelValue", "class"])
            ]),
            _: 1
          }, 8, ["wrap-class"])
        ], 2),
        ae("div", {
          class: ee(t.ns.e("bottom"))
        }, [
          ae("button", {
            class: ee({ [t.ns.is("disabled")]: t.filteredValue.length === 0 }),
            disabled: t.filteredValue.length === 0,
            type: "button",
            onClick: e[1] || (e[1] = (...y) => t.handleConfirm && t.handleConfirm(...y))
          }, st(t.t("el.table.confirmFilter")), 11, rP),
          ae("button", {
            type: "button",
            onClick: e[2] || (e[2] = (...y) => t.handleReset && t.handleReset(...y))
          }, st(t.t("el.table.resetFilter")), 1)
        ], 2)
      ])) : (V(), se("ul", {
        key: 1,
        class: ee(t.ns.e("list"))
      }, [
        ae("li", {
          class: ee([
            t.ns.e("list-item"),
            {
              [t.ns.is("active")]: t.filterValue === void 0 || t.filterValue === null
            }
          ]),
          onClick: e[3] || (e[3] = (y) => t.handleSelect(null))
        }, st(t.t("el.table.clearFilter")), 3),
        (V(!0), se(Ft, null, qn(t.filters, (y) => (V(), se("li", {
          key: y.value,
          class: ee([t.ns.e("list-item"), t.ns.is("active", t.isActive(y))]),
          label: y.value,
          onClick: (b) => t.handleSelect(y.value)
        }, st(y.text), 11, iP))), 128))
      ], 2))
    ]),
    default: de(() => [
      Dt((V(), se("span", {
        class: ee([
          `${t.ns.namespace.value}-table__column-filter-trigger`,
          `${t.ns.namespace.value}-none-outline`
        ]),
        onClick: e[4] || (e[4] = (...y) => t.showFilterPanel && t.showFilterPanel(...y))
      }, [
        ve(d, null, {
          default: de(() => [
            t.column.filterOpened ? (V(), Ae(u, { key: 0 })) : (V(), Ae(c, { key: 1 }))
          ]),
          _: 1
        })
      ], 2)), [
        [v, t.hideFilterPanel, t.popperPaneRef]
      ])
    ]),
    _: 1
  }, 8, ["visible", "placement", "popper-class"]);
}
var oP = /* @__PURE__ */ Ge(tP, [["render", sP], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/table/src/filter-panel.vue"]]);
function Mm(t) {
  const e = ht();
  ld(() => {
    n.value.addObserver(e);
  }), Ct(() => {
    r(n.value), i(n.value);
  }), Ml(() => {
    r(n.value), i(n.value);
  }), Wo(() => {
    n.value.removeObserver(e);
  });
  const n = F(() => {
    const s = t.layout;
    if (!s)
      throw new Error("Can not find table layout.");
    return s;
  }), r = (s) => {
    var o;
    const a = ((o = t.vnode.el) == null ? void 0 : o.querySelectorAll("colgroup > col")) || [];
    if (!a.length)
      return;
    const l = s.getFlattenColumns(), u = {};
    l.forEach((c) => {
      u[c.id] = c;
    });
    for (let c = 0, d = a.length; c < d; c++) {
      const h = a[c], v = h.getAttribute("name"), y = u[v];
      y && h.setAttribute("width", y.realWidth || y.width);
    }
  }, i = (s) => {
    var o, a;
    const l = ((o = t.vnode.el) == null ? void 0 : o.querySelectorAll("colgroup > col[name=gutter]")) || [];
    for (let c = 0, d = l.length; c < d; c++)
      l[c].setAttribute("width", s.scrollY.value ? s.gutterWidth : "0");
    const u = ((a = t.vnode.el) == null ? void 0 : a.querySelectorAll("th.gutter")) || [];
    for (let c = 0, d = u.length; c < d; c++) {
      const h = u[c];
      h.style.width = s.scrollY.value ? `${s.gutterWidth}px` : "0", h.style.display = s.scrollY.value ? "" : "none";
    }
  };
  return {
    tableLayout: n.value,
    onColumnsChange: r,
    onScrollableChange: i
  };
}
const Dr = Symbol("ElTable");
function aP(t, e) {
  const n = ht(), r = tt(Dr), i = (b) => {
    b.stopPropagation();
  }, s = (b, p) => {
    !p.filters && p.sortable ? y(b, p, !1) : p.filterable && !p.sortable && i(b), r == null || r.emit("header-click", p, b);
  }, o = (b, p) => {
    r == null || r.emit("header-contextmenu", p, b);
  }, a = $(null), l = $(!1), u = $({}), c = (b, p) => {
    if (St && !(p.children && p.children.length > 0) && a.value && t.border) {
      l.value = !0;
      const f = r;
      e("set-drag-visible", !0);
      const m = (f == null ? void 0 : f.vnode.el).getBoundingClientRect().left, w = n.vnode.el.querySelector(`th.${p.id}`), _ = w.getBoundingClientRect(), S = _.left - m + 30;
      Ao(w, "noclick"), u.value = {
        startMouseLeft: b.clientX,
        startLeft: _.right - m,
        startColumnLeft: _.left - m,
        tableLeft: m
      };
      const A = f == null ? void 0 : f.refs.resizeProxy;
      A.style.left = `${u.value.startLeft}px`, document.onselectstart = function() {
        return !1;
      }, document.ondragstart = function() {
        return !1;
      };
      const C = (O) => {
        const N = O.clientX - u.value.startMouseLeft, B = u.value.startLeft + N;
        A.style.left = `${Math.max(S, B)}px`;
      }, k = () => {
        if (l.value) {
          const { startColumnLeft: O, startLeft: N } = u.value, M = Number.parseInt(A.style.left, 10) - O;
          p.width = p.realWidth = M, f == null || f.emit("header-dragend", p.width, N - O, p, b), requestAnimationFrame(() => {
            t.store.scheduleLayout(!1, !0);
          }), document.body.style.cursor = "", l.value = !1, a.value = null, u.value = {}, e("set-drag-visible", !1);
        }
        document.removeEventListener("mousemove", C), document.removeEventListener("mouseup", k), document.onselectstart = null, document.ondragstart = null, setTimeout(() => {
          Er(w, "noclick");
        }, 0);
      };
      document.addEventListener("mousemove", C), document.addEventListener("mouseup", k);
    }
  }, d = (b, p) => {
    if (p.children && p.children.length > 0)
      return;
    const f = b.target;
    if (!ji(f))
      return;
    const g = f == null ? void 0 : f.closest("th");
    if (!(!p || !p.resizable) && !l.value && t.border) {
      const m = g.getBoundingClientRect(), w = document.body.style;
      m.width > 12 && m.right - b.pageX < 8 ? (w.cursor = "col-resize", Ba(g, "is-sortable") && (g.style.cursor = "col-resize"), a.value = p) : l.value || (w.cursor = "", Ba(g, "is-sortable") && (g.style.cursor = "pointer"), a.value = null);
    }
  }, h = () => {
    St && (document.body.style.cursor = "");
  }, v = ({ order: b, sortOrders: p }) => {
    if (b === "")
      return p[0];
    const f = p.indexOf(b || null);
    return p[f > p.length - 2 ? 0 : f + 1];
  }, y = (b, p, f) => {
    var g;
    b.stopPropagation();
    const m = p.order === f ? null : f || v(p), w = (g = b.target) == null ? void 0 : g.closest("th");
    if (w && Ba(w, "noclick")) {
      Er(w, "noclick");
      return;
    }
    if (!p.sortable)
      return;
    const _ = t.store.states;
    let S = _.sortProp.value, A;
    const C = _.sortingColumn.value;
    (C !== p || C === p && C.order === null) && (C && (C.order = null), _.sortingColumn.value = p, S = p.property), m ? A = p.order = m : A = p.order = null, _.sortProp.value = S, _.sortOrder.value = A, r == null || r.store.commit("changeSortCondition");
  };
  return {
    handleHeaderClick: s,
    handleHeaderContextMenu: o,
    handleMouseDown: c,
    handleMouseMove: d,
    handleMouseOut: h,
    handleSortClick: y,
    handleFilterClick: i
  };
}
function lP(t) {
  const e = tt(Dr), n = Fe("table");
  return {
    getHeaderRowStyle: (a) => {
      const l = e == null ? void 0 : e.props.headerRowStyle;
      return typeof l == "function" ? l.call(null, { rowIndex: a }) : l;
    },
    getHeaderRowClass: (a) => {
      const l = [], u = e == null ? void 0 : e.props.headerRowClassName;
      return typeof u == "string" ? l.push(u) : typeof u == "function" && l.push(u.call(null, { rowIndex: a })), l.join(" ");
    },
    getHeaderCellStyle: (a, l, u, c) => {
      var d;
      let h = (d = e == null ? void 0 : e.props.headerCellStyle) != null ? d : {};
      typeof h == "function" && (h = h.call(null, {
        rowIndex: a,
        columnIndex: l,
        row: u,
        column: c
      }));
      const v = Zd(l, c.fixed, t.store, u);
      return Ps(v, "left"), Ps(v, "right"), Object.assign({}, h, v);
    },
    getHeaderCellClass: (a, l, u, c) => {
      const d = Qd(n.b(), l, c.fixed, t.store, u), h = [
        c.id,
        c.order,
        c.headerAlign,
        c.className,
        c.labelClassName,
        ...d
      ];
      c.children || h.push("is-leaf"), c.sortable && h.push("is-sortable");
      const v = e == null ? void 0 : e.props.headerCellClassName;
      return typeof v == "string" ? h.push(v) : typeof v == "function" && h.push(v.call(null, {
        rowIndex: a,
        columnIndex: l,
        row: u,
        column: c
      })), h.push(n.e("cell")), h.filter((y) => !!y).join(" ");
    }
  };
}
const Lm = (t) => {
  const e = [];
  return t.forEach((n) => {
    n.children ? (e.push(n), e.push.apply(e, Lm(n.children))) : e.push(n);
  }), e;
}, uP = (t) => {
  let e = 1;
  const n = (s, o) => {
    if (o && (s.level = o.level + 1, e < s.level && (e = s.level)), s.children) {
      let a = 0;
      s.children.forEach((l) => {
        n(l, s), a += l.colSpan;
      }), s.colSpan = a;
    } else
      s.colSpan = 1;
  };
  t.forEach((s) => {
    s.level = 1, n(s, void 0);
  });
  const r = [];
  for (let s = 0; s < e; s++)
    r.push([]);
  return Lm(t).forEach((s) => {
    s.children ? (s.rowSpan = 1, s.children.forEach((o) => o.isSubColumn = !0)) : s.rowSpan = e - s.level + 1, r[s.level - 1].push(s);
  }), r;
};
function cP(t) {
  const e = tt(Dr), n = F(() => uP(t.store.states.originColumns.value));
  return {
    isGroup: F(() => {
      const s = n.value.length > 1;
      return s && e && (e.state.isGroup.value = !0), s;
    }),
    toggleAllSelection: (s) => {
      s.stopPropagation(), e == null || e.store.commit("toggleAllSelection");
    },
    columnRows: n
  };
}
var dP = be({
  name: "ElTableHeader",
  components: {
    ElCheckbox: Fi
  },
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: !0,
      type: Object
    },
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => ({
        prop: "",
        order: ""
      })
    }
  },
  setup(t, { emit: e }) {
    const n = ht(), r = tt(Dr), i = Fe("table"), s = $({}), { onColumnsChange: o, onScrollableChange: a } = Mm(r);
    Ct(async () => {
      await rt(), await rt();
      const { prop: S, order: A } = t.defaultSort;
      r == null || r.store.commit("sort", { prop: S, order: A, init: !0 });
    });
    const {
      handleHeaderClick: l,
      handleHeaderContextMenu: u,
      handleMouseDown: c,
      handleMouseMove: d,
      handleMouseOut: h,
      handleSortClick: v,
      handleFilterClick: y
    } = aP(t, e), {
      getHeaderRowStyle: b,
      getHeaderRowClass: p,
      getHeaderCellStyle: f,
      getHeaderCellClass: g
    } = lP(t), { isGroup: m, toggleAllSelection: w, columnRows: _ } = cP(t);
    return n.state = {
      onColumnsChange: o,
      onScrollableChange: a
    }, n.filterPanels = s, {
      ns: i,
      filterPanels: s,
      onColumnsChange: o,
      onScrollableChange: a,
      columnRows: _,
      getHeaderRowClass: p,
      getHeaderRowStyle: b,
      getHeaderCellClass: g,
      getHeaderCellStyle: f,
      handleHeaderClick: l,
      handleHeaderContextMenu: u,
      handleMouseDown: c,
      handleMouseMove: d,
      handleMouseOut: h,
      handleSortClick: v,
      handleFilterClick: y,
      isGroup: m,
      toggleAllSelection: w
    };
  },
  render() {
    const {
      ns: t,
      isGroup: e,
      columnRows: n,
      getHeaderCellStyle: r,
      getHeaderCellClass: i,
      getHeaderRowClass: s,
      getHeaderRowStyle: o,
      handleHeaderClick: a,
      handleHeaderContextMenu: l,
      handleMouseDown: u,
      handleMouseMove: c,
      handleSortClick: d,
      handleMouseOut: h,
      store: v,
      $parent: y
    } = this;
    let b = 1;
    return et("thead", {
      class: { [t.is("group")]: e }
    }, n.map((p, f) => et("tr", {
      class: s(f),
      key: f,
      style: o(f)
    }, p.map((g, m) => (g.rowSpan > b && (b = g.rowSpan), et("th", {
      class: i(f, m, p, g),
      colspan: g.colSpan,
      key: `${g.id}-thead`,
      rowspan: g.rowSpan,
      style: r(f, m, p, g),
      onClick: (w) => a(w, g),
      onContextmenu: (w) => l(w, g),
      onMousedown: (w) => u(w, g),
      onMousemove: (w) => c(w, g),
      onMouseout: h
    }, [
      et("div", {
        class: [
          "cell",
          g.filteredValue && g.filteredValue.length > 0 ? "highlight" : ""
        ]
      }, [
        g.renderHeader ? g.renderHeader({
          column: g,
          $index: m,
          store: v,
          _self: y
        }) : g.label,
        g.sortable && et("span", {
          onClick: (w) => d(w, g),
          class: "caret-wrapper"
        }, [
          et("i", {
            onClick: (w) => d(w, g, "ascending"),
            class: "sort-caret ascending"
          }),
          et("i", {
            onClick: (w) => d(w, g, "descending"),
            class: "sort-caret descending"
          })
        ]),
        g.filterable && et(oP, {
          store: v,
          placement: g.filterPlacement || "bottom-start",
          column: g,
          upDataColumn: (w, _) => {
            g[w] = _;
          }
        })
      ])
    ]))))));
  }
});
function fP(t) {
  const e = tt(Dr), n = $(""), r = $(et("div")), { nextZIndex: i } = ql(), s = (y, b, p) => {
    var f;
    const g = e, m = Cu(y);
    let w;
    const _ = (f = g == null ? void 0 : g.vnode.el) == null ? void 0 : f.dataset.prefix;
    m && (w = ap({
      columns: t.store.states.columns.value
    }, m, _), w && (g == null || g.emit(`cell-${p}`, b, w, m, y))), g == null || g.emit(`row-${p}`, b, w, y);
  }, o = (y, b) => {
    s(y, b, "dblclick");
  }, a = (y, b) => {
    t.store.commit("setCurrentRow", b), s(y, b, "click");
  }, l = (y, b) => {
    s(y, b, "contextmenu");
  }, u = Yr((y) => {
    t.store.commit("setHoverRow", y);
  }, 30), c = Yr(() => {
    t.store.commit("setHoverRow", null);
  }, 30), d = (y) => {
    const b = window.getComputedStyle(y, null), p = Number.parseInt(b.paddingLeft, 10) || 0, f = Number.parseInt(b.paddingRight, 10) || 0, g = Number.parseInt(b.paddingTop, 10) || 0, m = Number.parseInt(b.paddingBottom, 10) || 0;
    return {
      left: p,
      right: f,
      top: g,
      bottom: m
    };
  };
  return {
    handleDoubleClick: o,
    handleClick: a,
    handleContextMenu: l,
    handleMouseEnter: u,
    handleMouseLeave: c,
    handleCellMouseEnter: (y, b, p) => {
      var f;
      const g = e, m = Cu(y), w = (f = g == null ? void 0 : g.vnode.el) == null ? void 0 : f.dataset.prefix;
      if (m) {
        const z = ap({
          columns: t.store.states.columns.value
        }, m, w), U = g.hoverState = { cell: m, column: z, row: b };
        g == null || g.emit("cell-mouse-enter", U.row, U.column, U.cell, y);
      }
      if (!p)
        return;
      const _ = y.target.querySelector(".cell");
      if (!(Ba(_, `${w}-tooltip`) && _.childNodes.length))
        return;
      const S = document.createRange();
      S.setStart(_, 0), S.setEnd(_, _.childNodes.length);
      let A = S.getBoundingClientRect().width, C = S.getBoundingClientRect().height;
      A - Math.floor(A) < 1e-3 && (A = Math.floor(A)), C - Math.floor(C) < 1e-3 && (C = Math.floor(C));
      const { top: N, left: B, right: M, bottom: j } = d(_), q = B + M, X = N + j;
      (A + q > _.offsetWidth || C + X > _.offsetHeight || _.scrollWidth > _.offsetWidth) && WR(e == null ? void 0 : e.refs.tableWrapper, m, m.innerText || m.textContent, i, p);
    },
    handleCellMouseLeave: (y) => {
      if (!Cu(y))
        return;
      const p = e == null ? void 0 : e.hoverState;
      e == null || e.emit("cell-mouse-leave", p == null ? void 0 : p.row, p == null ? void 0 : p.column, p == null ? void 0 : p.cell, y);
    },
    tooltipContent: n,
    tooltipTrigger: r
  };
}
function hP(t) {
  const e = tt(Dr), n = Fe("table");
  return {
    getRowStyle: (u, c) => {
      const d = e == null ? void 0 : e.props.rowStyle;
      return typeof d == "function" ? d.call(null, {
        row: u,
        rowIndex: c
      }) : d || null;
    },
    getRowClass: (u, c) => {
      const d = [n.e("row")];
      e != null && e.props.highlightCurrentRow && u === t.store.states.currentRow.value && d.push("current-row"), t.stripe && c % 2 === 1 && d.push(n.em("row", "striped"));
      const h = e == null ? void 0 : e.props.rowClassName;
      return typeof h == "string" ? d.push(h) : typeof h == "function" && d.push(h.call(null, {
        row: u,
        rowIndex: c
      })), d;
    },
    getCellStyle: (u, c, d, h) => {
      const v = e == null ? void 0 : e.props.cellStyle;
      let y = v ?? {};
      typeof v == "function" && (y = v.call(null, {
        rowIndex: u,
        columnIndex: c,
        row: d,
        column: h
      }));
      const b = Zd(c, t == null ? void 0 : t.fixed, t.store);
      return Ps(b, "left"), Ps(b, "right"), Object.assign({}, y, b);
    },
    getCellClass: (u, c, d, h, v) => {
      const y = Qd(n.b(), c, t == null ? void 0 : t.fixed, t.store, void 0, v), b = [h.id, h.align, h.className, ...y], p = e == null ? void 0 : e.props.cellClassName;
      return typeof p == "string" ? b.push(p) : typeof p == "function" && b.push(p.call(null, {
        rowIndex: u,
        columnIndex: c,
        row: d,
        column: h
      })), b.push(n.e("cell")), b.filter((f) => !!f).join(" ");
    },
    getSpan: (u, c, d, h) => {
      let v = 1, y = 1;
      const b = e == null ? void 0 : e.props.spanMethod;
      if (typeof b == "function") {
        const p = b({
          row: u,
          column: c,
          rowIndex: d,
          columnIndex: h
        });
        Array.isArray(p) ? (v = p[0], y = p[1]) : typeof p == "object" && (v = p.rowspan, y = p.colspan);
      }
      return { rowspan: v, colspan: y };
    },
    getColspanRealWidth: (u, c, d) => {
      if (c < 1)
        return u[d].realWidth;
      const h = u.map(({ realWidth: v, width: y }) => v || y).slice(d, d + c);
      return Number(h.reduce((v, y) => Number(v) + Number(y), -1));
    }
  };
}
function pP(t) {
  const e = tt(Dr), n = Fe("table"), {
    handleDoubleClick: r,
    handleClick: i,
    handleContextMenu: s,
    handleMouseEnter: o,
    handleMouseLeave: a,
    handleCellMouseEnter: l,
    handleCellMouseLeave: u,
    tooltipContent: c,
    tooltipTrigger: d
  } = fP(t), {
    getRowStyle: h,
    getRowClass: v,
    getCellStyle: y,
    getCellClass: b,
    getSpan: p,
    getColspanRealWidth: f
  } = hP(t), g = F(() => t.store.states.columns.value.findIndex(({ type: A }) => A === "default")), m = (A, C) => {
    const k = e.props.rowKey;
    return k ? yn(A, k) : C;
  }, w = (A, C, k, O = !1) => {
    const { tooltipEffect: N, tooltipOptions: B, store: M } = t, { indent: j, columns: q } = M.states, X = v(A, C);
    let z = !0;
    return k && (X.push(n.em("row", `level-${k.level}`)), z = k.display), et("tr", {
      style: [z ? null : {
        display: "none"
      }, h(A, C)],
      class: X,
      key: m(A, C),
      onDblclick: (H) => r(H, A),
      onClick: (H) => i(H, A),
      onContextmenu: (H) => s(H, A),
      onMouseenter: () => o(C),
      onMouseleave: a
    }, q.value.map((H, re) => {
      const { rowspan: fe, colspan: J } = p(A, H, C, re);
      if (!fe || !J)
        return null;
      const le = Object.assign({}, H);
      le.realWidth = f(q.value, J, re);
      const ce = {
        store: t.store,
        _self: t.context || e,
        column: le,
        row: A,
        $index: C,
        cellIndex: re,
        expanded: O
      };
      re === g.value && k && (ce.treeNode = {
        indent: k.level * j.value,
        level: k.level
      }, typeof k.expanded == "boolean" && (ce.treeNode.expanded = k.expanded, "loading" in k && (ce.treeNode.loading = k.loading), "noLazyChildren" in k && (ce.treeNode.noLazyChildren = k.noLazyChildren)));
      const ge = `${C},${re}`, _e = le.columnKey || le.rawColumnKey || "", je = _(re, H, ce), Te = H.showOverflowTooltip && tg({
        effect: N
      }, B, H.showOverflowTooltip);
      return et("td", {
        style: y(C, re, A, H),
        class: b(C, re, A, H, J - 1),
        key: `${_e}${ge}`,
        rowspan: fe,
        colspan: J,
        onMouseenter: (Ze) => l(Ze, A, Te),
        onMouseleave: u
      }, [je]);
    }));
  }, _ = (A, C, k) => C.renderCell(k);
  return {
    wrappedRowRender: (A, C) => {
      const k = t.store, { isRowExpanded: O, assertRowKey: N } = k, { treeData: B, lazyTreeNodeMap: M, childrenColumnName: j, rowKey: q } = k.states, X = k.states.columns.value;
      if (X.some(({ type: U }) => U === "expand")) {
        const U = O(A), H = w(A, C, void 0, U), re = e.renderExpanded;
        return U ? re ? [
          [
            H,
            et("tr", {
              key: `expanded-row__${H.key}`
            }, [
              et("td", {
                colspan: X.length,
                class: `${n.e("cell")} ${n.e("expanded-cell")}`
              }, [re({ row: A, $index: C, store: k, expanded: U })])
            ])
          ]
        ] : (console.error("[Element Error]renderExpanded is required."), H) : [[H]];
      } else if (Object.keys(B.value).length) {
        N();
        const U = yn(A, q.value);
        let H = B.value[U], re = null;
        H && (re = {
          expanded: H.expanded,
          level: H.level,
          display: !0
        }, typeof H.lazy == "boolean" && (typeof H.loaded == "boolean" && H.loaded && (re.noLazyChildren = !(H.children && H.children.length)), re.loading = H.loading));
        const fe = [w(A, C, re)];
        if (H) {
          let J = 0;
          const le = (ge, _e) => {
            ge && ge.length && _e && ge.forEach((je) => {
              const Te = {
                display: _e.display && _e.expanded,
                level: _e.level + 1,
                expanded: !1,
                noLazyChildren: !1,
                loading: !1
              }, Ze = yn(je, q.value);
              if (Ze == null)
                throw new Error("For nested data item, row-key is required.");
              if (H = { ...B.value[Ze] }, H && (Te.expanded = H.expanded, H.level = H.level || Te.level, H.display = !!(H.expanded && Te.display), typeof H.lazy == "boolean" && (typeof H.loaded == "boolean" && H.loaded && (Te.noLazyChildren = !(H.children && H.children.length)), Te.loading = H.loading)), J++, fe.push(w(je, C + J, Te)), H) {
                const Le = M.value[Ze] || je[j.value];
                le(Le, H);
              }
            });
          };
          H.display = !0;
          const ce = M.value[U] || A[j.value];
          le(ce, H);
        }
        return fe;
      } else
        return w(A, C, void 0);
    },
    tooltipContent: c,
    tooltipTrigger: d
  };
}
const vP = {
  store: {
    required: !0,
    type: Object
  },
  stripe: Boolean,
  tooltipEffect: String,
  tooltipOptions: {
    type: Object
  },
  context: {
    default: () => ({}),
    type: Object
  },
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  fixed: {
    type: String,
    default: ""
  },
  highlight: Boolean
};
var gP = be({
  name: "ElTableBody",
  props: vP,
  setup(t) {
    const e = ht(), n = tt(Dr), r = Fe("table"), { wrappedRowRender: i, tooltipContent: s, tooltipTrigger: o } = pP(t), { onColumnsChange: a, onScrollableChange: l } = Mm(n);
    return ke(t.store.states.hoverRow, (u, c) => {
      !t.store.states.isComplex.value || !St || e2(() => {
        const d = e == null ? void 0 : e.vnode.el, h = Array.from((d == null ? void 0 : d.children) || []).filter((b) => b == null ? void 0 : b.classList.contains(`${r.e("row")}`)), v = h[c], y = h[u];
        v && Er(v, "hover-row"), y && Ao(y, "hover-row");
      });
    }), Wo(() => {
      var u;
      (u = Fr) == null || u();
    }), {
      ns: r,
      onColumnsChange: a,
      onScrollableChange: l,
      wrappedRowRender: i,
      tooltipContent: s,
      tooltipTrigger: o
    };
  },
  render() {
    const { wrappedRowRender: t, store: e } = this, n = e.states.data.value || [];
    return et("tbody", { tabIndex: -1 }, [
      n.reduce((r, i) => r.concat(t(i, r.length)), [])
    ]);
  }
});
function mP() {
  const t = tt(Dr), e = t == null ? void 0 : t.store, n = F(() => e.states.fixedLeafColumnsLength.value), r = F(() => e.states.rightFixedColumns.value.length), i = F(() => e.states.columns.value.length), s = F(() => e.states.fixedColumns.value.length), o = F(() => e.states.rightFixedColumns.value.length);
  return {
    leftFixedLeafCount: n,
    rightFixedLeafCount: r,
    columnsCount: i,
    leftFixedCount: s,
    rightFixedCount: o,
    columns: e.states.columns
  };
}
function yP(t) {
  const { columns: e } = mP(), n = Fe("table");
  return {
    getCellClasses: (s, o) => {
      const a = s[o], l = [
        n.e("cell"),
        a.id,
        a.align,
        a.labelClassName,
        ...Qd(n.b(), o, a.fixed, t.store)
      ];
      return a.className && l.push(a.className), a.children || l.push(n.is("leaf")), l;
    },
    getCellStyles: (s, o) => {
      const a = Zd(o, s.fixed, t.store);
      return Ps(a, "left"), Ps(a, "right"), a;
    },
    columns: e
  };
}
var bP = be({
  name: "ElTableFooter",
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: !0,
      type: Object
    },
    summaryMethod: Function,
    sumText: String,
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => ({
        prop: "",
        order: ""
      })
    }
  },
  setup(t) {
    const { getCellClasses: e, getCellStyles: n, columns: r } = yP(t);
    return {
      ns: Fe("table"),
      getCellClasses: e,
      getCellStyles: n,
      columns: r
    };
  },
  render() {
    const { columns: t, getCellStyles: e, getCellClasses: n, summaryMethod: r, sumText: i } = this, s = this.store.states.data.value;
    let o = [];
    return r ? o = r({
      columns: t,
      data: s
    }) : t.forEach((a, l) => {
      if (l === 0) {
        o[l] = i;
        return;
      }
      const u = s.map((v) => Number(v[a.property])), c = [];
      let d = !0;
      u.forEach((v) => {
        if (!Number.isNaN(+v)) {
          d = !1;
          const y = `${v}`.split(".")[1];
          c.push(y ? y.length : 0);
        }
      });
      const h = Math.max.apply(null, c);
      d ? o[l] = "" : o[l] = u.reduce((v, y) => {
        const b = Number(y);
        return Number.isNaN(+b) ? v : Number.parseFloat((v + y).toFixed(Math.min(h, 20)));
      }, 0);
    }), et(et("tfoot", [
      et("tr", {}, [
        ...t.map((a, l) => et("td", {
          key: l,
          colspan: a.colSpan,
          rowspan: a.rowSpan,
          class: n(t, l),
          style: e(a, l)
        }, [
          et("div", {
            class: ["cell", a.labelClassName]
          }, [o[l]])
        ]))
      ])
    ]));
  }
});
function wP(t) {
  return {
    setCurrentRow: (c) => {
      t.commit("setCurrentRow", c);
    },
    getSelectionRows: () => t.getSelectionRows(),
    toggleRowSelection: (c, d) => {
      t.toggleRowSelection(c, d, !1), t.updateAllSelected();
    },
    clearSelection: () => {
      t.clearSelection();
    },
    clearFilter: (c) => {
      t.clearFilter(c);
    },
    toggleAllSelection: () => {
      t.commit("toggleAllSelection");
    },
    toggleRowExpansion: (c, d) => {
      t.toggleRowExpansionAdapter(c, d);
    },
    clearSort: () => {
      t.clearSort();
    },
    sort: (c, d) => {
      t.commit("sort", { prop: c, order: d });
    }
  };
}
function _P(t, e, n, r) {
  const i = $(!1), s = $(null), o = $(!1), a = (H) => {
    o.value = H;
  }, l = $({
    width: null,
    height: null,
    headerHeight: null
  }), u = $(!1), c = {
    display: "inline-block",
    verticalAlign: "middle"
  }, d = $(), h = $(0), v = $(0), y = $(0), b = $(0), p = $(0);
  oo(() => {
    e.setHeight(t.height);
  }), oo(() => {
    e.setMaxHeight(t.maxHeight);
  }), ke(() => [t.currentRowKey, n.states.rowKey], ([H, re]) => {
    !x(re) || !x(H) || n.setCurrentRowKey(`${H}`);
  }, {
    immediate: !0
  }), ke(() => t.data, (H) => {
    r.store.commit("setData", H);
  }, {
    immediate: !0,
    deep: !0
  }), oo(() => {
    t.expandRowKeys && n.setExpandRowKeysAdapter(t.expandRowKeys);
  });
  const f = () => {
    r.store.commit("setHoverRow", null), r.hoverState && (r.hoverState = null);
  }, g = (H, re) => {
    const { pixelX: fe, pixelY: J } = re;
    Math.abs(fe) >= Math.abs(J) && (r.refs.bodyWrapper.scrollLeft += re.pixelX / 5);
  }, m = F(() => t.height || t.maxHeight || n.states.fixedColumns.value.length > 0 || n.states.rightFixedColumns.value.length > 0), w = F(() => ({
    width: e.bodyWidth.value ? `${e.bodyWidth.value}px` : ""
  })), _ = () => {
    m.value && e.updateElsHeight(), e.updateColumnsWidth(), requestAnimationFrame(k);
  };
  Ct(async () => {
    await rt(), n.updateColumns(), O(), requestAnimationFrame(_);
    const H = r.vnode.el, re = r.refs.headerWrapper;
    t.flexible && H && H.parentElement && (H.parentElement.style.minWidth = "0"), l.value = {
      width: d.value = H.offsetWidth,
      height: H.offsetHeight,
      headerHeight: t.showHeader && re ? re.offsetHeight : null
    }, n.states.columns.value.forEach((fe) => {
      fe.filteredValue && fe.filteredValue.length && r.store.commit("filterChange", {
        column: fe,
        values: fe.filteredValue,
        silent: !0
      });
    }), r.$ready = !0;
  });
  const S = (H, re) => {
    if (!H)
      return;
    const fe = Array.from(H.classList).filter((J) => !J.startsWith("is-scrolling-"));
    fe.push(e.scrollX.value ? re : "is-scrolling-none"), H.className = fe.join(" ");
  }, A = (H) => {
    const { tableWrapper: re } = r.refs;
    S(re, H);
  }, C = (H) => {
    const { tableWrapper: re } = r.refs;
    return !!(re && re.classList.contains(H));
  }, k = function() {
    if (!r.refs.scrollBarRef)
      return;
    if (!e.scrollX.value) {
      const _e = "is-scrolling-none";
      C(_e) || A(_e);
      return;
    }
    const H = r.refs.scrollBarRef.wrapRef;
    if (!H)
      return;
    const { scrollLeft: re, offsetWidth: fe, scrollWidth: J } = H, { headerWrapper: le, footerWrapper: ce } = r.refs;
    le && (le.scrollLeft = re), ce && (ce.scrollLeft = re);
    const ge = J - fe - 1;
    re >= ge ? A("is-scrolling-right") : A(re === 0 ? "is-scrolling-left" : "is-scrolling-middle");
  }, O = () => {
    r.refs.scrollBarRef && (r.refs.scrollBarRef.wrapRef && bn(r.refs.scrollBarRef.wrapRef, "scroll", k, {
      passive: !0
    }), t.fit ? As(r.vnode.el, N) : bn(window, "resize", N), As(r.refs.bodyWrapper, () => {
      var H, re;
      N(), (re = (H = r.refs) == null ? void 0 : H.scrollBarRef) == null || re.update();
    }));
  }, N = () => {
    var H, re, fe, J;
    const le = r.vnode.el;
    if (!r.$ready || !le)
      return;
    let ce = !1;
    const {
      width: ge,
      height: _e,
      headerHeight: je
    } = l.value, Te = d.value = le.offsetWidth;
    ge !== Te && (ce = !0);
    const Ze = le.offsetHeight;
    (t.height || m.value) && _e !== Ze && (ce = !0);
    const Le = t.tableLayout === "fixed" ? r.refs.headerWrapper : (H = r.refs.tableHeaderRef) == null ? void 0 : H.$el;
    t.showHeader && (Le == null ? void 0 : Le.offsetHeight) !== je && (ce = !0), h.value = ((re = r.refs.tableWrapper) == null ? void 0 : re.scrollHeight) || 0, y.value = (Le == null ? void 0 : Le.scrollHeight) || 0, b.value = ((fe = r.refs.footerWrapper) == null ? void 0 : fe.offsetHeight) || 0, p.value = ((J = r.refs.appendWrapper) == null ? void 0 : J.offsetHeight) || 0, v.value = h.value - y.value - b.value - p.value, ce && (l.value = {
      width: Te,
      height: Ze,
      headerHeight: t.showHeader && (Le == null ? void 0 : Le.offsetHeight) || 0
    }, _());
  }, B = Pr(), M = F(() => {
    const { bodyWidth: H, scrollY: re, gutterWidth: fe } = e;
    return H.value ? `${H.value - (re.value ? fe : 0)}px` : "";
  }), j = F(() => t.maxHeight ? "fixed" : t.tableLayout), q = F(() => {
    if (t.data && t.data.length)
      return null;
    let H = "100%";
    t.height && v.value && (H = `${v.value}px`);
    const re = d.value;
    return {
      width: re ? `${re}px` : "",
      height: H
    };
  }), X = F(() => t.height ? {
    height: Number.isNaN(Number(t.height)) ? t.height : `${t.height}px`
  } : t.maxHeight ? {
    maxHeight: Number.isNaN(Number(t.maxHeight)) ? t.maxHeight : `${t.maxHeight}px`
  } : {}), z = F(() => t.height ? {
    height: "100%"
  } : t.maxHeight ? Number.isNaN(Number(t.maxHeight)) ? {
    maxHeight: `calc(${t.maxHeight} - ${y.value + b.value}px)`
  } : {
    maxHeight: `${t.maxHeight - y.value - b.value}px`
  } : {});
  return {
    isHidden: i,
    renderExpanded: s,
    setDragVisible: a,
    isGroup: u,
    handleMouseLeave: f,
    handleHeaderFooterMousewheel: g,
    tableSize: B,
    emptyBlockStyle: q,
    handleFixedMousewheel: (H, re) => {
      const fe = r.refs.bodyWrapper;
      if (Math.abs(re.spinY) > 0) {
        const J = fe.scrollTop;
        re.pixelY < 0 && J !== 0 && H.preventDefault(), re.pixelY > 0 && fe.scrollHeight - fe.clientHeight > J && H.preventDefault(), fe.scrollTop += Math.ceil(re.pixelY / 5);
      } else
        fe.scrollLeft += Math.ceil(re.pixelX / 5);
    },
    resizeProxyVisible: o,
    bodyWidth: M,
    resizeState: l,
    doLayout: _,
    tableBodyStyles: w,
    tableLayout: j,
    scrollbarViewStyle: c,
    tableInnerStyle: X,
    scrollbarStyle: z
  };
}
function SP(t) {
  const e = $(), n = () => {
    const i = t.vnode.el.querySelector(".hidden-columns"), s = { childList: !0, subtree: !0 }, o = t.store.states.updateOrderFns;
    e.value = new MutationObserver(() => {
      o.forEach((a) => a());
    }), e.value.observe(i, s);
  };
  Ct(() => {
    n();
  }), Wo(() => {
    var r;
    (r = e.value) == null || r.disconnect();
  });
}
var EP = {
  data: {
    type: Array,
    default: () => []
  },
  size: Rr,
  width: [String, Number],
  height: [String, Number],
  maxHeight: [String, Number],
  fit: {
    type: Boolean,
    default: !0
  },
  stripe: Boolean,
  border: Boolean,
  rowKey: [String, Function],
  showHeader: {
    type: Boolean,
    default: !0
  },
  showSummary: Boolean,
  sumText: String,
  summaryMethod: Function,
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  cellClassName: [String, Function],
  cellStyle: [Object, Function],
  headerRowClassName: [String, Function],
  headerRowStyle: [Object, Function],
  headerCellClassName: [String, Function],
  headerCellStyle: [Object, Function],
  highlightCurrentRow: Boolean,
  currentRowKey: [String, Number],
  emptyText: String,
  expandRowKeys: Array,
  defaultExpandAll: Boolean,
  defaultSort: Object,
  tooltipEffect: String,
  tooltipOptions: Object,
  spanMethod: Function,
  selectOnIndeterminate: {
    type: Boolean,
    default: !0
  },
  indent: {
    type: Number,
    default: 16
  },
  treeProps: {
    type: Object,
    default: () => ({
      hasChildren: "hasChildren",
      children: "children"
    })
  },
  lazy: Boolean,
  load: Function,
  style: {
    type: Object,
    default: () => ({})
  },
  className: {
    type: String,
    default: ""
  },
  tableLayout: {
    type: String,
    default: "fixed"
  },
  scrollbarAlwaysOn: {
    type: Boolean,
    default: !1
  },
  flexible: Boolean,
  showOverflowTooltip: [Boolean, Object]
};
function zm(t) {
  const e = t.tableLayout === "auto";
  let n = t.columns || [];
  e && n.every((i) => i.width === void 0) && (n = []);
  const r = (i) => {
    const s = {
      key: `${t.tableLayout}_${i.id}`,
      style: {},
      name: void 0
    };
    return e ? s.style = {
      width: `${i.width}px`
    } : s.name = i.id, s;
  };
  return et("colgroup", {}, n.map((i) => et("col", r(i))));
}
zm.props = ["columns", "tableLayout"];
const xP = () => {
  const t = $(), e = (s, o) => {
    const a = t.value;
    a && a.scrollTo(s, o);
  }, n = (s, o) => {
    const a = t.value;
    a && mt(o) && ["Top", "Left"].includes(s) && a[`setScroll${s}`](o);
  };
  return {
    scrollBarRef: t,
    scrollTo: e,
    setScrollTop: (s) => n("Top", s),
    setScrollLeft: (s) => n("Left", s)
  };
};
let AP = 1;
const kP = be({
  name: "ElTable",
  directives: {
    Mousewheel: BI
  },
  components: {
    TableHeader: dP,
    TableBody: gP,
    TableFooter: bP,
    ElScrollbar: Wd,
    hColgroup: zm
  },
  props: EP,
  emits: [
    "select",
    "select-all",
    "selection-change",
    "cell-mouse-enter",
    "cell-mouse-leave",
    "cell-contextmenu",
    "cell-click",
    "cell-dblclick",
    "row-click",
    "row-contextmenu",
    "row-dblclick",
    "header-click",
    "header-contextmenu",
    "sort-change",
    "filter-change",
    "current-change",
    "header-dragend",
    "expand-change"
  ],
  setup(t) {
    const { t: e } = or(), n = Fe("table"), r = ht();
    qt(Dr, r);
    const i = QR(r, t);
    r.store = i;
    const s = new XR({
      store: r.store,
      table: r,
      fit: t.fit,
      showHeader: t.showHeader
    });
    r.layout = s;
    const o = F(() => (i.states.data.value || []).length === 0), {
      setCurrentRow: a,
      getSelectionRows: l,
      toggleRowSelection: u,
      clearSelection: c,
      clearFilter: d,
      toggleAllSelection: h,
      toggleRowExpansion: v,
      clearSort: y,
      sort: b
    } = wP(i), {
      isHidden: p,
      renderExpanded: f,
      setDragVisible: g,
      isGroup: m,
      handleMouseLeave: w,
      handleHeaderFooterMousewheel: _,
      tableSize: S,
      emptyBlockStyle: A,
      handleFixedMousewheel: C,
      resizeProxyVisible: k,
      bodyWidth: O,
      resizeState: N,
      doLayout: B,
      tableBodyStyles: M,
      tableLayout: j,
      scrollbarViewStyle: q,
      tableInnerStyle: X,
      scrollbarStyle: z
    } = _P(t, s, i, r), { scrollBarRef: U, scrollTo: H, setScrollLeft: re, setScrollTop: fe } = xP(), J = Yr(B, 50), le = `${n.namespace.value}-table_${AP++}`;
    r.tableId = le, r.state = {
      isGroup: m,
      resizeState: N,
      doLayout: B,
      debouncedUpdateLayout: J
    };
    const ce = F(() => t.sumText || e("el.table.sumText")), ge = F(() => t.emptyText || e("el.table.emptyText"));
    return SP(r), {
      ns: n,
      layout: s,
      store: i,
      handleHeaderFooterMousewheel: _,
      handleMouseLeave: w,
      tableId: le,
      tableSize: S,
      isHidden: p,
      isEmpty: o,
      renderExpanded: f,
      resizeProxyVisible: k,
      resizeState: N,
      isGroup: m,
      bodyWidth: O,
      tableBodyStyles: M,
      emptyBlockStyle: A,
      debouncedUpdateLayout: J,
      handleFixedMousewheel: C,
      setCurrentRow: a,
      getSelectionRows: l,
      toggleRowSelection: u,
      clearSelection: c,
      clearFilter: d,
      toggleAllSelection: h,
      toggleRowExpansion: v,
      clearSort: y,
      doLayout: B,
      sort: b,
      t: e,
      setDragVisible: g,
      context: r,
      computedSumText: ce,
      computedEmptyText: ge,
      tableLayout: j,
      scrollbarViewStyle: q,
      tableInnerStyle: X,
      scrollbarStyle: z,
      scrollBarRef: U,
      scrollTo: H,
      setScrollLeft: re,
      setScrollTop: fe
    };
  }
}), CP = ["data-prefix"], TP = {
  ref: "hiddenColumns",
  class: "hidden-columns"
};
function OP(t, e, n, r, i, s) {
  const o = Mt("hColgroup"), a = Mt("table-header"), l = Mt("table-body"), u = Mt("table-footer"), c = Mt("el-scrollbar"), d = ud("mousewheel");
  return V(), se("div", {
    ref: "tableWrapper",
    class: ee([
      {
        [t.ns.m("fit")]: t.fit,
        [t.ns.m("striped")]: t.stripe,
        [t.ns.m("border")]: t.border || t.isGroup,
        [t.ns.m("hidden")]: t.isHidden,
        [t.ns.m("group")]: t.isGroup,
        [t.ns.m("fluid-height")]: t.maxHeight,
        [t.ns.m("scrollable-x")]: t.layout.scrollX.value,
        [t.ns.m("scrollable-y")]: t.layout.scrollY.value,
        [t.ns.m("enable-row-hover")]: !t.store.states.isComplex.value,
        [t.ns.m("enable-row-transition")]: (t.store.states.data.value || []).length !== 0 && (t.store.states.data.value || []).length < 100,
        "has-footer": t.showSummary
      },
      t.ns.m(t.tableSize),
      t.className,
      t.ns.b(),
      t.ns.m(`layout-${t.tableLayout}`)
    ]),
    style: it(t.style),
    "data-prefix": t.ns.namespace.value,
    onMouseleave: e[0] || (e[0] = (...h) => t.handleMouseLeave && t.handleMouseLeave(...h))
  }, [
    ae("div", {
      class: ee(t.ns.e("inner-wrapper")),
      style: it(t.tableInnerStyle)
    }, [
      ae("div", TP, [
        Me(t.$slots, "default")
      ], 512),
      t.showHeader && t.tableLayout === "fixed" ? Dt((V(), se("div", {
        key: 0,
        ref: "headerWrapper",
        class: ee(t.ns.e("header-wrapper"))
      }, [
        ae("table", {
          ref: "tableHeader",
          class: ee(t.ns.e("header")),
          style: it(t.tableBodyStyles),
          border: "0",
          cellpadding: "0",
          cellspacing: "0"
        }, [
          ve(o, {
            columns: t.store.states.columns.value,
            "table-layout": t.tableLayout
          }, null, 8, ["columns", "table-layout"]),
          ve(a, {
            ref: "tableHeaderRef",
            border: t.border,
            "default-sort": t.defaultSort,
            store: t.store,
            onSetDragVisible: t.setDragVisible
          }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"])
        ], 6)
      ], 2)), [
        [d, t.handleHeaderFooterMousewheel]
      ]) : ye("v-if", !0),
      ae("div", {
        ref: "bodyWrapper",
        class: ee(t.ns.e("body-wrapper"))
      }, [
        ve(c, {
          ref: "scrollBarRef",
          "view-style": t.scrollbarViewStyle,
          "wrap-style": t.scrollbarStyle,
          always: t.scrollbarAlwaysOn
        }, {
          default: de(() => [
            ae("table", {
              ref: "tableBody",
              class: ee(t.ns.e("body")),
              cellspacing: "0",
              cellpadding: "0",
              border: "0",
              style: it({
                width: t.bodyWidth,
                tableLayout: t.tableLayout
              })
            }, [
              ve(o, {
                columns: t.store.states.columns.value,
                "table-layout": t.tableLayout
              }, null, 8, ["columns", "table-layout"]),
              t.showHeader && t.tableLayout === "auto" ? (V(), Ae(a, {
                key: 0,
                ref: "tableHeaderRef",
                class: ee(t.ns.e("body-header")),
                border: t.border,
                "default-sort": t.defaultSort,
                store: t.store,
                onSetDragVisible: t.setDragVisible
              }, null, 8, ["class", "border", "default-sort", "store", "onSetDragVisible"])) : ye("v-if", !0),
              ve(l, {
                context: t.context,
                highlight: t.highlightCurrentRow,
                "row-class-name": t.rowClassName,
                "tooltip-effect": t.tooltipEffect,
                "tooltip-options": t.tooltipOptions,
                "row-style": t.rowStyle,
                store: t.store,
                stripe: t.stripe
              }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "tooltip-options", "row-style", "store", "stripe"]),
              t.showSummary && t.tableLayout === "auto" ? (V(), Ae(u, {
                key: 1,
                class: ee(t.ns.e("body-footer")),
                border: t.border,
                "default-sort": t.defaultSort,
                store: t.store,
                "sum-text": t.computedSumText,
                "summary-method": t.summaryMethod
              }, null, 8, ["class", "border", "default-sort", "store", "sum-text", "summary-method"])) : ye("v-if", !0)
            ], 6),
            t.isEmpty ? (V(), se("div", {
              key: 0,
              ref: "emptyBlock",
              style: it(t.emptyBlockStyle),
              class: ee(t.ns.e("empty-block"))
            }, [
              ae("span", {
                class: ee(t.ns.e("empty-text"))
              }, [
                Me(t.$slots, "empty", {}, () => [
                  cn(st(t.computedEmptyText), 1)
                ])
              ], 2)
            ], 6)) : ye("v-if", !0),
            t.$slots.append ? (V(), se("div", {
              key: 1,
              ref: "appendWrapper",
              class: ee(t.ns.e("append-wrapper"))
            }, [
              Me(t.$slots, "append")
            ], 2)) : ye("v-if", !0)
          ]),
          _: 3
        }, 8, ["view-style", "wrap-style", "always"])
      ], 2),
      t.showSummary && t.tableLayout === "fixed" ? Dt((V(), se("div", {
        key: 1,
        ref: "footerWrapper",
        class: ee(t.ns.e("footer-wrapper"))
      }, [
        ae("table", {
          class: ee(t.ns.e("footer")),
          cellspacing: "0",
          cellpadding: "0",
          border: "0",
          style: it(t.tableBodyStyles)
        }, [
          ve(o, {
            columns: t.store.states.columns.value,
            "table-layout": t.tableLayout
          }, null, 8, ["columns", "table-layout"]),
          ve(u, {
            border: t.border,
            "default-sort": t.defaultSort,
            store: t.store,
            "sum-text": t.computedSumText,
            "summary-method": t.summaryMethod
          }, null, 8, ["border", "default-sort", "store", "sum-text", "summary-method"])
        ], 6)
      ], 2)), [
        [Jn, !t.isEmpty],
        [d, t.handleHeaderFooterMousewheel]
      ]) : ye("v-if", !0),
      t.border || t.isGroup ? (V(), se("div", {
        key: 2,
        class: ee(t.ns.e("border-left-patch"))
      }, null, 2)) : ye("v-if", !0)
    ], 6),
    Dt(ae("div", {
      ref: "resizeProxy",
      class: ee(t.ns.e("column-resize-proxy"))
    }, null, 2), [
      [Jn, t.resizeProxyVisible]
    ])
  ], 46, CP);
}
var IP = /* @__PURE__ */ Ge(kP, [["render", OP], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/table/src/table.vue"]]);
const NP = {
  selection: "table-column--selection",
  expand: "table__expand-column"
}, RP = {
  default: {
    order: ""
  },
  selection: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  expand: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  index: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  }
}, PP = (t) => NP[t] || "", BP = {
  selection: {
    renderHeader({ store: t, column: e }) {
      function n() {
        return t.states.data.value && t.states.data.value.length === 0;
      }
      return et(Fi, {
        disabled: n(),
        size: t.states.tableSize.value,
        indeterminate: t.states.selection.value.length > 0 && !t.states.isAllSelected.value,
        "onUpdate:modelValue": t.toggleAllSelection,
        modelValue: t.states.isAllSelected.value,
        ariaLabel: e.label
      });
    },
    renderCell({
      row: t,
      column: e,
      store: n,
      $index: r
    }) {
      return et(Fi, {
        disabled: e.selectable ? !e.selectable.call(null, t, r) : !1,
        size: n.states.tableSize.value,
        onChange: () => {
          n.commit("rowSelectedChanged", t);
        },
        onClick: (i) => i.stopPropagation(),
        modelValue: n.isSelected(t),
        ariaLabel: e.label
      });
    },
    sortable: !1,
    resizable: !1
  },
  index: {
    renderHeader({ column: t }) {
      return t.label || "#";
    },
    renderCell({
      column: t,
      $index: e
    }) {
      let n = e + 1;
      const r = t.index;
      return typeof r == "number" ? n = e + r : typeof r == "function" && (n = r(e)), et("div", {}, [n]);
    },
    sortable: !1
  },
  expand: {
    renderHeader({ column: t }) {
      return t.label || "";
    },
    renderCell({
      row: t,
      store: e,
      expanded: n
    }) {
      const { ns: r } = e, i = [r.e("expand-icon")];
      return n && i.push(r.em("expand-icon", "expanded")), et("div", {
        class: i,
        onClick: function(o) {
          o.stopPropagation(), e.toggleRowExpansion(t);
        }
      }, {
        default: () => [
          et(_t, null, {
            default: () => [et(Id)]
          })
        ]
      });
    },
    sortable: !1,
    resizable: !1
  }
};
function DP({
  row: t,
  column: e,
  $index: n
}) {
  var r;
  const i = e.property, s = i && Rx(t, i).value;
  return e && e.formatter ? e.formatter(t, e, s, n) : ((r = s == null ? void 0 : s.toString) == null ? void 0 : r.call(s)) || "";
}
function MP({
  row: t,
  treeNode: e,
  store: n
}, r = !1) {
  const { ns: i } = n;
  if (!e)
    return r ? [
      et("span", {
        class: i.e("placeholder")
      })
    ] : null;
  const s = [], o = function(a) {
    a.stopPropagation(), !e.loading && n.loadOrToggle(t);
  };
  if (e.indent && s.push(et("span", {
    class: i.e("indent"),
    style: { "padding-left": `${e.indent}px` }
  })), typeof e.expanded == "boolean" && !e.noLazyChildren) {
    const a = [
      i.e("expand-icon"),
      e.expanded ? i.em("expand-icon", "expanded") : ""
    ];
    let l = Id;
    e.loading && (l = Kl), s.push(et("div", {
      class: a,
      onClick: o
    }, {
      default: () => [
        et(_t, { class: { [i.is("loading")]: e.loading } }, {
          default: () => [et(l)]
        })
      ]
    }));
  } else
    s.push(et("span", {
      class: i.e("placeholder")
    }));
  return s;
}
function cp(t, e) {
  return t.reduce((n, r) => (n[r] = r, n), e);
}
function LP(t, e) {
  const n = ht();
  return {
    registerComplexWatchers: () => {
      const s = ["fixed"], o = {
        realWidth: "width",
        realMinWidth: "minWidth"
      }, a = cp(s, o);
      Object.keys(a).forEach((l) => {
        const u = o[l];
        Tr(e, u) && ke(() => e[u], (c) => {
          let d = c;
          u === "width" && l === "realWidth" && (d = Yd(c)), u === "minWidth" && l === "realMinWidth" && (d = Nm(c)), n.columnConfig.value[u] = d, n.columnConfig.value[l] = d;
          const h = u === "fixed";
          t.value.store.scheduleLayout(h);
        });
      });
    },
    registerNormalWatchers: () => {
      const s = [
        "label",
        "filters",
        "filterMultiple",
        "filteredValue",
        "sortable",
        "index",
        "formatter",
        "className",
        "labelClassName",
        "showOverflowTooltip"
      ], o = {
        property: "prop",
        align: "realAlign",
        headerAlign: "realHeaderAlign"
      }, a = cp(s, o);
      Object.keys(a).forEach((l) => {
        const u = o[l];
        Tr(e, u) && ke(() => e[u], (c) => {
          n.columnConfig.value[l] = c;
        });
      });
    }
  };
}
function zP(t, e, n) {
  const r = ht(), i = $(""), s = $(!1), o = $(), a = $(), l = Fe("table");
  oo(() => {
    o.value = t.align ? `is-${t.align}` : null, o.value;
  }), oo(() => {
    a.value = t.headerAlign ? `is-${t.headerAlign}` : o.value, a.value;
  });
  const u = F(() => {
    let w = r.vnode.vParent || r.parent;
    for (; w && !w.tableId && !w.columnId; )
      w = w.vnode.vParent || w.parent;
    return w;
  }), c = F(() => {
    const { store: w } = r.parent;
    if (!w)
      return !1;
    const { treeData: _ } = w.states, S = _.value;
    return S && Object.keys(S).length > 0;
  }), d = $(Yd(t.width)), h = $(Nm(t.minWidth)), v = (w) => (d.value && (w.width = d.value), h.value && (w.minWidth = h.value), !d.value && h.value && (w.width = void 0), w.minWidth || (w.minWidth = 80), w.realWidth = Number(w.width === void 0 ? w.minWidth : w.width), w), y = (w) => {
    const _ = w.type, S = BP[_] || {};
    Object.keys(S).forEach((C) => {
      const k = S[C];
      C !== "className" && k !== void 0 && (w[C] = k);
    });
    const A = PP(_);
    if (A) {
      const C = `${x(l.namespace)}-${A}`;
      w.className = w.className ? `${w.className} ${C}` : C;
    }
    return w;
  }, b = (w) => {
    Array.isArray(w) ? w.forEach((S) => _(S)) : _(w);
    function _(S) {
      var A;
      ((A = S == null ? void 0 : S.type) == null ? void 0 : A.name) === "ElTableColumn" && (S.vParent = r);
    }
  };
  return {
    columnId: i,
    realAlign: o,
    isSubColumn: s,
    realHeaderAlign: a,
    columnOrTableParent: u,
    setColumnWidth: v,
    setColumnForcedProps: y,
    setColumnRenders: (w) => {
      t.renderHeader ? Vt("TableColumn", "Comparing to render-header, scoped-slot header is easier to use. We recommend users to use scoped-slot header.") : w.type !== "selection" && (w.renderHeader = (S) => {
        r.columnConfig.value.label;
        const A = e.header;
        return A ? A(S) : w.label;
      });
      let _ = w.renderCell;
      return w.type === "expand" ? (w.renderCell = (S) => et("div", {
        class: "cell"
      }, [_(S)]), n.value.renderExpanded = (S) => e.default ? e.default(S) : e.default) : (_ = _ || DP, w.renderCell = (S) => {
        let A = null;
        if (e.default) {
          const M = e.default(S);
          A = M.some((j) => j.type !== vv) ? M : _(S);
        } else
          A = _(S);
        const { columns: C } = n.value.store.states, k = C.value.findIndex((M) => M.type === "default"), O = c.value && S.cellIndex === k, N = MP(S, O), B = {
          class: "cell",
          style: {}
        };
        return w.showOverflowTooltip && (B.class = `${B.class} ${x(l.namespace)}-tooltip`, B.style = {
          width: `${(S.column.realWidth || Number(S.column.width)) - 1}px`
        }), b(A), et("div", B, [N, A]);
      }), w;
    },
    getPropsData: (...w) => w.reduce((_, S) => (Array.isArray(S) && S.forEach((A) => {
      _[A] = t[A];
    }), _), {}),
    getColumnElIndex: (w, _) => Array.prototype.indexOf.call(w, _),
    updateColumnOrder: () => {
      n.value.store.commit("updateColumnOrder", r.columnConfig.value);
    }
  };
}
var jP = {
  type: {
    type: String,
    default: "default"
  },
  label: String,
  className: String,
  labelClassName: String,
  property: String,
  prop: String,
  width: {
    type: [String, Number],
    default: ""
  },
  minWidth: {
    type: [String, Number],
    default: ""
  },
  renderHeader: Function,
  sortable: {
    type: [Boolean, String],
    default: !1
  },
  sortMethod: Function,
  sortBy: [String, Function, Array],
  resizable: {
    type: Boolean,
    default: !0
  },
  columnKey: String,
  align: String,
  headerAlign: String,
  showOverflowTooltip: {
    type: [Boolean, Object],
    default: void 0
  },
  fixed: [Boolean, String],
  formatter: Function,
  selectable: Function,
  reserveSelection: Boolean,
  filterMethod: Function,
  filteredValue: Array,
  filters: Array,
  filterPlacement: String,
  filterMultiple: {
    type: Boolean,
    default: !0
  },
  index: [Number, Function],
  sortOrders: {
    type: Array,
    default: () => ["ascending", "descending", null],
    validator: (t) => t.every((e) => ["ascending", "descending", null].includes(e))
  }
};
let FP = 1;
var jm = be({
  name: "ElTableColumn",
  components: {
    ElCheckbox: Fi
  },
  props: jP,
  setup(t, { slots: e }) {
    const n = ht(), r = $({}), i = F(() => {
      let m = n.parent;
      for (; m && !m.tableId; )
        m = m.parent;
      return m;
    }), { registerNormalWatchers: s, registerComplexWatchers: o } = LP(i, t), {
      columnId: a,
      isSubColumn: l,
      realHeaderAlign: u,
      columnOrTableParent: c,
      setColumnWidth: d,
      setColumnForcedProps: h,
      setColumnRenders: v,
      getPropsData: y,
      getColumnElIndex: b,
      realAlign: p,
      updateColumnOrder: f
    } = zP(t, e, i), g = c.value;
    a.value = `${g.tableId || g.columnId}_column_${FP++}`, ld(() => {
      l.value = i.value !== g;
      const m = t.type || "default", w = t.sortable === "" ? !0 : t.sortable, _ = Sr(t.showOverflowTooltip) ? g.props.showOverflowTooltip : t.showOverflowTooltip, S = {
        ...RP[m],
        id: a.value,
        type: m,
        property: t.prop || t.property,
        align: p,
        headerAlign: u,
        showOverflowTooltip: _,
        filterable: t.filters || t.filterMethod,
        filteredValue: [],
        filterPlacement: "",
        isColumnGroup: !1,
        isSubColumn: !1,
        filterOpened: !1,
        sortable: w,
        index: t.index,
        rawColumnKey: n.vnode.key
      };
      let N = y([
        "columnKey",
        "label",
        "className",
        "labelClassName",
        "type",
        "renderHeader",
        "formatter",
        "fixed",
        "resizable"
      ], ["sortMethod", "sortBy", "sortOrders"], ["selectable", "reserveSelection"], [
        "filterMethod",
        "filters",
        "filterMultiple",
        "filterOpened",
        "filteredValue",
        "filterPlacement"
      ]);
      N = FR(S, N), N = UR(v, d, h)(N), r.value = N, s(), o();
    }), Ct(() => {
      var m;
      const w = c.value, _ = l.value ? w.vnode.el.children : (m = w.refs.hiddenColumns) == null ? void 0 : m.children, S = () => b(_ || [], n.vnode.el);
      r.value.getColumnIndex = S, S() > -1 && i.value.store.commit("insertColumn", r.value, l.value ? w.columnConfig.value : null, f);
    }), En(() => {
      i.value.store.commit("removeColumn", r.value, l.value ? g.columnConfig.value : null, f);
    }), n.columnId = a.value, n.columnConfig = r;
  },
  render() {
    var t, e, n;
    try {
      const r = (e = (t = this.$slots).default) == null ? void 0 : e.call(t, {
        row: {},
        column: {},
        $index: -1
      }), i = [];
      if (Array.isArray(r))
        for (const o of r)
          ((n = o.type) == null ? void 0 : n.name) === "ElTableColumn" || o.shapeFlag & 2 ? i.push(o) : o.type === Ft && Array.isArray(o.children) && o.children.forEach((a) => {
            (a == null ? void 0 : a.patchFlag) !== 1024 && !Gt(a == null ? void 0 : a.children) && i.push(a);
          });
      return et("div", i);
    } catch {
      return et("div", []);
    }
  }
});
const HP = nn(IP, {
  TableColumn: jm
}), UP = sr(jm), ws = "$treeNodeId", dp = function(t, e) {
  !e || e[ws] || Object.defineProperty(e, ws, {
    value: t.id,
    enumerable: !1,
    configurable: !1,
    writable: !1
  });
}, Xd = function(t, e) {
  return t ? e[t] : e[ws];
}, bc = (t, e, n) => {
  const r = t.value.currentNode;
  n();
  const i = t.value.currentNode;
  r !== i && e("current-change", i ? i.data : null, i);
}, wc = (t) => {
  let e = !0, n = !0, r = !0;
  for (let i = 0, s = t.length; i < s; i++) {
    const o = t[i];
    (o.checked !== !0 || o.indeterminate) && (e = !1, o.disabled || (r = !1)), (o.checked !== !1 || o.indeterminate) && (n = !1);
  }
  return { all: e, none: n, allWithoutDisable: r, half: !e && !n };
}, Ua = function(t) {
  if (t.childNodes.length === 0 || t.loading)
    return;
  const { all: e, none: n, half: r } = wc(t.childNodes);
  e ? (t.checked = !0, t.indeterminate = !1) : r ? (t.checked = !1, t.indeterminate = !0) : n && (t.checked = !1, t.indeterminate = !1);
  const i = t.parent;
  !i || i.level === 0 || t.store.checkStrictly || Ua(i);
}, Sa = function(t, e) {
  const n = t.store.props, r = t.data || {}, i = n[e];
  if (typeof i == "function")
    return i(r, t);
  if (typeof i == "string")
    return r[i];
  if (typeof i > "u") {
    const s = r[e];
    return s === void 0 ? "" : s;
  }
};
let VP = 0, _c = class Va {
  constructor(e) {
    this.id = VP++, this.text = null, this.checked = !1, this.indeterminate = !1, this.data = null, this.expanded = !1, this.parent = null, this.visible = !0, this.isCurrent = !1, this.canFocus = !1;
    for (const n in e)
      Tr(e, n) && (this[n] = e[n]);
    this.level = 0, this.loaded = !1, this.childNodes = [], this.loading = !1, this.parent && (this.level = this.parent.level + 1);
  }
  initialize() {
    const e = this.store;
    if (!e)
      throw new Error("[Node]store is required!");
    e.registerNode(this);
    const n = e.props;
    if (n && typeof n.isLeaf < "u") {
      const s = Sa(this, "isLeaf");
      typeof s == "boolean" && (this.isLeafByUser = s);
    }
    if (e.lazy !== !0 && this.data ? (this.setData(this.data), e.defaultExpandAll && (this.expanded = !0, this.canFocus = !0)) : this.level > 0 && e.lazy && e.defaultExpandAll && this.expand(), Array.isArray(this.data) || dp(this, this.data), !this.data)
      return;
    const r = e.defaultExpandedKeys, i = e.key;
    i && r && r.includes(this.key) && this.expand(null, e.autoExpandParent), i && e.currentNodeKey !== void 0 && this.key === e.currentNodeKey && (e.currentNode = this, e.currentNode.isCurrent = !0), e.lazy && e._initDefaultCheckedNode(this), this.updateLeafState(), this.parent && (this.level === 1 || this.parent.expanded === !0) && (this.canFocus = !0);
  }
  setData(e) {
    Array.isArray(e) || dp(this, e), this.data = e, this.childNodes = [];
    let n;
    this.level === 0 && Array.isArray(this.data) ? n = this.data : n = Sa(this, "children") || [];
    for (let r = 0, i = n.length; r < i; r++)
      this.insertChild({ data: n[r] });
  }
  get label() {
    return Sa(this, "label");
  }
  get key() {
    const e = this.store.key;
    return this.data ? this.data[e] : null;
  }
  get disabled() {
    return Sa(this, "disabled");
  }
  get nextSibling() {
    const e = this.parent;
    if (e) {
      const n = e.childNodes.indexOf(this);
      if (n > -1)
        return e.childNodes[n + 1];
    }
    return null;
  }
  get previousSibling() {
    const e = this.parent;
    if (e) {
      const n = e.childNodes.indexOf(this);
      if (n > -1)
        return n > 0 ? e.childNodes[n - 1] : null;
    }
    return null;
  }
  contains(e, n = !0) {
    return (this.childNodes || []).some((r) => r === e || n && r.contains(e));
  }
  remove() {
    const e = this.parent;
    e && e.removeChild(this);
  }
  insertChild(e, n, r) {
    if (!e)
      throw new Error("InsertChild error: child is required.");
    if (!(e instanceof Va)) {
      if (!r) {
        const i = this.getChildren(!0);
        i.includes(e.data) || (typeof n > "u" || n < 0 ? i.push(e.data) : i.splice(n, 0, e.data));
      }
      Object.assign(e, {
        parent: this,
        store: this.store
      }), e = Bn(new Va(e)), e instanceof Va && e.initialize();
    }
    e.level = this.level + 1, typeof n > "u" || n < 0 ? this.childNodes.push(e) : this.childNodes.splice(n, 0, e), this.updateLeafState();
  }
  insertBefore(e, n) {
    let r;
    n && (r = this.childNodes.indexOf(n)), this.insertChild(e, r);
  }
  insertAfter(e, n) {
    let r;
    n && (r = this.childNodes.indexOf(n), r !== -1 && (r += 1)), this.insertChild(e, r);
  }
  removeChild(e) {
    const n = this.getChildren() || [], r = n.indexOf(e.data);
    r > -1 && n.splice(r, 1);
    const i = this.childNodes.indexOf(e);
    i > -1 && (this.store && this.store.deregisterNode(e), e.parent = null, this.childNodes.splice(i, 1)), this.updateLeafState();
  }
  removeChildByData(e) {
    let n = null;
    for (let r = 0; r < this.childNodes.length; r++)
      if (this.childNodes[r].data === e) {
        n = this.childNodes[r];
        break;
      }
    n && this.removeChild(n);
  }
  expand(e, n) {
    const r = () => {
      if (n) {
        let i = this.parent;
        for (; i.level > 0; )
          i.expanded = !0, i = i.parent;
      }
      this.expanded = !0, e && e(), this.childNodes.forEach((i) => {
        i.canFocus = !0;
      });
    };
    this.shouldLoadData() ? this.loadData((i) => {
      Array.isArray(i) && (this.checked ? this.setChecked(!0, !0) : this.store.checkStrictly || Ua(this), r());
    }) : r();
  }
  doCreateChildren(e, n = {}) {
    e.forEach((r) => {
      this.insertChild(Object.assign({ data: r }, n), void 0, !0);
    });
  }
  collapse() {
    this.expanded = !1, this.childNodes.forEach((e) => {
      e.canFocus = !1;
    });
  }
  shouldLoadData() {
    return this.store.lazy === !0 && this.store.load && !this.loaded;
  }
  updateLeafState() {
    if (this.store.lazy === !0 && this.loaded !== !0 && typeof this.isLeafByUser < "u") {
      this.isLeaf = this.isLeafByUser;
      return;
    }
    const e = this.childNodes;
    if (!this.store.lazy || this.store.lazy === !0 && this.loaded === !0) {
      this.isLeaf = !e || e.length === 0;
      return;
    }
    this.isLeaf = !1;
  }
  setChecked(e, n, r, i) {
    if (this.indeterminate = e === "half", this.checked = e === !0, this.store.checkStrictly)
      return;
    if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
      const { all: o, allWithoutDisable: a } = wc(this.childNodes);
      !this.isLeaf && !o && a && (this.checked = !1, e = !1);
      const l = () => {
        if (n) {
          const u = this.childNodes;
          for (let h = 0, v = u.length; h < v; h++) {
            const y = u[h];
            i = i || e !== !1;
            const b = y.disabled ? y.checked : i;
            y.setChecked(b, n, !0, i);
          }
          const { half: c, all: d } = wc(u);
          d || (this.checked = d, this.indeterminate = c);
        }
      };
      if (this.shouldLoadData()) {
        this.loadData(() => {
          l(), Ua(this);
        }, {
          checked: e !== !1
        });
        return;
      } else
        l();
    }
    const s = this.parent;
    !s || s.level === 0 || r || Ua(s);
  }
  getChildren(e = !1) {
    if (this.level === 0)
      return this.data;
    const n = this.data;
    if (!n)
      return null;
    const r = this.store.props;
    let i = "children";
    return r && (i = r.children || "children"), n[i] === void 0 && (n[i] = null), e && !n[i] && (n[i] = []), n[i];
  }
  updateChildren() {
    const e = this.getChildren() || [], n = this.childNodes.map((s) => s.data), r = {}, i = [];
    e.forEach((s, o) => {
      const a = s[ws];
      !!a && n.findIndex((u) => u[ws] === a) >= 0 ? r[a] = { index: o, data: s } : i.push({ index: o, data: s });
    }), this.store.lazy || n.forEach((s) => {
      r[s[ws]] || this.removeChildByData(s);
    }), i.forEach(({ index: s, data: o }) => {
      this.insertChild({ data: o }, s);
    }), this.updateLeafState();
  }
  loadData(e, n = {}) {
    if (this.store.lazy === !0 && this.store.load && !this.loaded && (!this.loading || Object.keys(n).length)) {
      this.loading = !0;
      const r = (i) => {
        this.childNodes = [], this.doCreateChildren(i, n), this.loaded = !0, this.loading = !1, this.updateLeafState(), e && e.call(this, i);
      };
      this.store.load(this, r);
    } else
      e && e.call(this);
  }
};
class WP {
  constructor(e) {
    this.currentNode = null, this.currentNodeKey = null;
    for (const n in e)
      Tr(e, n) && (this[n] = e[n]);
    this.nodesMap = {};
  }
  initialize() {
    if (this.root = new _c({
      data: this.data,
      store: this
    }), this.root.initialize(), this.lazy && this.load) {
      const e = this.load;
      e(this.root, (n) => {
        this.root.doCreateChildren(n), this._initDefaultCheckedNodes();
      });
    } else
      this._initDefaultCheckedNodes();
  }
  filter(e) {
    const n = this.filterNodeMethod, r = this.lazy, i = function(s) {
      const o = s.root ? s.root.childNodes : s.childNodes;
      if (o.forEach((a) => {
        a.visible = n.call(a, e, a.data, a), i(a);
      }), !s.visible && o.length) {
        let a = !0;
        a = !o.some((l) => l.visible), s.root ? s.root.visible = a === !1 : s.visible = a === !1;
      }
      e && s.visible && !s.isLeaf && !r && s.expand();
    };
    i(this);
  }
  setData(e) {
    e !== this.root.data ? (this.root.setData(e), this._initDefaultCheckedNodes()) : this.root.updateChildren();
  }
  getNode(e) {
    if (e instanceof _c)
      return e;
    const n = wn(e) ? Xd(this.key, e) : e;
    return this.nodesMap[n] || null;
  }
  insertBefore(e, n) {
    const r = this.getNode(n);
    r.parent.insertBefore({ data: e }, r);
  }
  insertAfter(e, n) {
    const r = this.getNode(n);
    r.parent.insertAfter({ data: e }, r);
  }
  remove(e) {
    const n = this.getNode(e);
    n && n.parent && (n === this.currentNode && (this.currentNode = null), n.parent.removeChild(n));
  }
  append(e, n) {
    const r = n ? this.getNode(n) : this.root;
    r && r.insertChild({ data: e });
  }
  _initDefaultCheckedNodes() {
    const e = this.defaultCheckedKeys || [], n = this.nodesMap;
    e.forEach((r) => {
      const i = n[r];
      i && i.setChecked(!0, !this.checkStrictly);
    });
  }
  _initDefaultCheckedNode(e) {
    (this.defaultCheckedKeys || []).includes(e.key) && e.setChecked(!0, !this.checkStrictly);
  }
  setDefaultCheckedKey(e) {
    e !== this.defaultCheckedKeys && (this.defaultCheckedKeys = e, this._initDefaultCheckedNodes());
  }
  registerNode(e) {
    const n = this.key;
    !e || !e.data || (n ? e.key !== void 0 && (this.nodesMap[e.key] = e) : this.nodesMap[e.id] = e);
  }
  deregisterNode(e) {
    !this.key || !e || !e.data || (e.childNodes.forEach((r) => {
      this.deregisterNode(r);
    }), delete this.nodesMap[e.key]);
  }
  getCheckedNodes(e = !1, n = !1) {
    const r = [], i = function(s) {
      (s.root ? s.root.childNodes : s.childNodes).forEach((a) => {
        (a.checked || n && a.indeterminate) && (!e || e && a.isLeaf) && r.push(a.data), i(a);
      });
    };
    return i(this), r;
  }
  getCheckedKeys(e = !1) {
    return this.getCheckedNodes(e).map((n) => (n || {})[this.key]);
  }
  getHalfCheckedNodes() {
    const e = [], n = function(r) {
      (r.root ? r.root.childNodes : r.childNodes).forEach((s) => {
        s.indeterminate && e.push(s.data), n(s);
      });
    };
    return n(this), e;
  }
  getHalfCheckedKeys() {
    return this.getHalfCheckedNodes().map((e) => (e || {})[this.key]);
  }
  _getAllNodes() {
    const e = [], n = this.nodesMap;
    for (const r in n)
      Tr(n, r) && e.push(n[r]);
    return e;
  }
  updateChildren(e, n) {
    const r = this.nodesMap[e];
    if (!r)
      return;
    const i = r.childNodes;
    for (let s = i.length - 1; s >= 0; s--) {
      const o = i[s];
      this.remove(o.data);
    }
    for (let s = 0, o = n.length; s < o; s++) {
      const a = n[s];
      this.append(a, r.data);
    }
  }
  _setCheckedKeys(e, n = !1, r) {
    const i = this._getAllNodes().sort((a, l) => l.level - a.level), s = /* @__PURE__ */ Object.create(null), o = Object.keys(r);
    i.forEach((a) => a.setChecked(!1, !1));
    for (let a = 0, l = i.length; a < l; a++) {
      const u = i[a], c = u.data[e].toString();
      if (!o.includes(c)) {
        u.checked && !s[c] && u.setChecked(!1, !1);
        continue;
      }
      let h = u.parent;
      for (; h && h.level > 0; )
        s[h.data[e]] = !0, h = h.parent;
      if (u.isLeaf || this.checkStrictly) {
        u.setChecked(!0, !1);
        continue;
      }
      if (u.setChecked(!0, !0), n) {
        u.setChecked(!1, !1);
        const v = function(y) {
          y.childNodes.forEach((p) => {
            p.isLeaf || p.setChecked(!1, !1), v(p);
          });
        };
        v(u);
      }
    }
  }
  setCheckedNodes(e, n = !1) {
    const r = this.key, i = {};
    e.forEach((s) => {
      i[(s || {})[r]] = !0;
    }), this._setCheckedKeys(r, n, i);
  }
  setCheckedKeys(e, n = !1) {
    this.defaultCheckedKeys = e;
    const r = this.key, i = {};
    e.forEach((s) => {
      i[s] = !0;
    }), this._setCheckedKeys(r, n, i);
  }
  setDefaultExpandedKeys(e) {
    e = e || [], this.defaultExpandedKeys = e, e.forEach((n) => {
      const r = this.getNode(n);
      r && r.expand(null, this.autoExpandParent);
    });
  }
  setChecked(e, n, r) {
    const i = this.getNode(e);
    i && i.setChecked(!!n, r);
  }
  getCurrentNode() {
    return this.currentNode;
  }
  setCurrentNode(e) {
    const n = this.currentNode;
    n && (n.isCurrent = !1), this.currentNode = e, this.currentNode.isCurrent = !0;
  }
  setUserCurrentNode(e, n = !0) {
    const r = e[this.key], i = this.nodesMap[r];
    this.setCurrentNode(i), n && this.currentNode.level > 1 && this.currentNode.parent.expand(null, !0);
  }
  setCurrentNodeKey(e, n = !0) {
    if (e == null) {
      this.currentNode && (this.currentNode.isCurrent = !1), this.currentNode = null;
      return;
    }
    const r = this.getNode(e);
    r && (this.setCurrentNode(r), n && this.currentNode.level > 1 && this.currentNode.parent.expand(null, !0));
  }
}
const KP = be({
  name: "ElTreeNodeContent",
  props: {
    node: {
      type: Object,
      required: !0
    },
    renderContent: Function
  },
  setup(t) {
    const e = Fe("tree"), n = tt("NodeInstance"), r = tt("RootTree");
    return () => {
      const i = t.node, { data: s, store: o } = i;
      return t.renderContent ? t.renderContent(et, { _self: n, node: i, data: s, store: o }) : r.ctx.slots.default ? r.ctx.slots.default({ node: i, data: s }) : et("span", { class: e.be("node", "label") }, [i.label]);
    };
  }
});
var $P = /* @__PURE__ */ Ge(KP, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node-content.vue"]]);
function Fm(t) {
  const e = tt("TreeNodeMap", null), n = {
    treeNodeExpand: (r) => {
      t.node !== r && t.node.collapse();
    },
    children: []
  };
  return e && e.children.push(n), qt("TreeNodeMap", n), {
    broadcastExpanded: (r) => {
      if (t.accordion)
        for (const i of n.children)
          i.treeNodeExpand(r);
    }
  };
}
const Hm = Symbol("dragEvents");
function GP({ props: t, ctx: e, el$: n, dropIndicator$: r, store: i }) {
  const s = Fe("tree"), o = $({
    showDropIndicator: !1,
    draggingNode: null,
    dropNode: null,
    allowDrop: !0,
    dropType: null
  });
  return qt(Hm, {
    treeNodeDragStart: ({ event: c, treeNode: d }) => {
      if (typeof t.allowDrag == "function" && !t.allowDrag(d.node))
        return c.preventDefault(), !1;
      c.dataTransfer.effectAllowed = "move";
      try {
        c.dataTransfer.setData("text/plain", "");
      } catch {
      }
      o.value.draggingNode = d, e.emit("node-drag-start", d.node, c);
    },
    treeNodeDragOver: ({ event: c, treeNode: d }) => {
      const h = d, v = o.value.dropNode;
      v && v.node.id !== h.node.id && Er(v.$el, s.is("drop-inner"));
      const y = o.value.draggingNode;
      if (!y || !h)
        return;
      let b = !0, p = !0, f = !0, g = !0;
      typeof t.allowDrop == "function" && (b = t.allowDrop(y.node, h.node, "prev"), g = p = t.allowDrop(y.node, h.node, "inner"), f = t.allowDrop(y.node, h.node, "next")), c.dataTransfer.dropEffect = p || b || f ? "move" : "none", (b || p || f) && (v == null ? void 0 : v.node.id) !== h.node.id && (v && e.emit("node-drag-leave", y.node, v.node, c), e.emit("node-drag-enter", y.node, h.node, c)), (b || p || f) && (o.value.dropNode = h), h.node.nextSibling === y.node && (f = !1), h.node.previousSibling === y.node && (b = !1), h.node.contains(y.node, !1) && (p = !1), (y.node === h.node || y.node.contains(h.node)) && (b = !1, p = !1, f = !1);
      const m = h.$el.querySelector(`.${s.be("node", "content")}`).getBoundingClientRect(), w = n.value.getBoundingClientRect();
      let _;
      const S = b ? p ? 0.25 : f ? 0.45 : 1 : -1, A = f ? p ? 0.75 : b ? 0.55 : 0 : 1;
      let C = -9999;
      const k = c.clientY - m.top;
      k < m.height * S ? _ = "before" : k > m.height * A ? _ = "after" : p ? _ = "inner" : _ = "none";
      const O = h.$el.querySelector(`.${s.be("node", "expand-icon")}`).getBoundingClientRect(), N = r.value;
      _ === "before" ? C = O.top - w.top : _ === "after" && (C = O.bottom - w.top), N.style.top = `${C}px`, N.style.left = `${O.right - w.left}px`, _ === "inner" ? Ao(h.$el, s.is("drop-inner")) : Er(h.$el, s.is("drop-inner")), o.value.showDropIndicator = _ === "before" || _ === "after", o.value.allowDrop = o.value.showDropIndicator || g, o.value.dropType = _, e.emit("node-drag-over", y.node, h.node, c);
    },
    treeNodeDragEnd: (c) => {
      const { draggingNode: d, dropType: h, dropNode: v } = o.value;
      if (c.preventDefault(), c.dataTransfer.dropEffect = "move", d && v) {
        const y = { data: d.node.data };
        h !== "none" && d.node.remove(), h === "before" ? v.node.parent.insertBefore(y, v.node) : h === "after" ? v.node.parent.insertAfter(y, v.node) : h === "inner" && v.node.insertChild(y), h !== "none" && i.value.registerNode(y), Er(v.$el, s.is("drop-inner")), e.emit("node-drag-end", d.node, v.node, h, c), h !== "none" && e.emit("node-drop", d.node, v.node, h, c);
      }
      d && !v && e.emit("node-drag-end", d.node, null, h, c), o.value.showDropIndicator = !1, o.value.draggingNode = null, o.value.dropNode = null, o.value.allowDrop = !0;
    }
  }), {
    dragState: o
  };
}
const qP = be({
  name: "ElTreeNode",
  components: {
    ElCollapseTransition: C4,
    ElCheckbox: Fi,
    NodeContent: $P,
    ElIcon: _t,
    Loading: Kl
  },
  props: {
    node: {
      type: _c,
      default: () => ({})
    },
    props: {
      type: Object,
      default: () => ({})
    },
    accordion: Boolean,
    renderContent: Function,
    renderAfterExpand: Boolean,
    showCheckbox: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["node-expand"],
  setup(t, e) {
    const n = Fe("tree"), { broadcastExpanded: r } = Fm(t), i = tt("RootTree"), s = $(!1), o = $(!1), a = $(null), l = $(null), u = $(null), c = tt(Hm), d = ht();
    qt("NodeInstance", d), i || Vt("Tree", "Can not find node's tree."), t.node.expanded && (s.value = !0, o.value = !0);
    const h = i.props.props.children || "children";
    ke(() => {
      const k = t.node.data[h];
      return k && [...k];
    }, () => {
      t.node.updateChildren();
    }), ke(() => t.node.indeterminate, (k) => {
      b(t.node.checked, k);
    }), ke(() => t.node.checked, (k) => {
      b(k, t.node.indeterminate);
    }), ke(() => t.node.expanded, (k) => {
      rt(() => s.value = k), k && (o.value = !0);
    });
    const v = (k) => Xd(i.props.nodeKey, k.data), y = (k) => {
      const O = t.props.class;
      if (!O)
        return {};
      let N;
      if (gn(O)) {
        const { data: B } = k;
        N = O(B, k);
      } else
        N = O;
      return Gt(N) ? { [N]: !0 } : N;
    }, b = (k, O) => {
      (a.value !== k || l.value !== O) && i.ctx.emit("check-change", t.node.data, k, O), a.value = k, l.value = O;
    }, p = (k) => {
      bc(i.store, i.ctx.emit, () => i.store.value.setCurrentNode(t.node)), i.currentNode.value = t.node, i.props.expandOnClickNode && g(), i.props.checkOnClickNode && !t.node.disabled && m(null, {
        target: { checked: !t.node.checked }
      }), i.ctx.emit("node-click", t.node.data, t.node, d, k);
    }, f = (k) => {
      i.instance.vnode.props.onNodeContextmenu && (k.stopPropagation(), k.preventDefault()), i.ctx.emit("node-contextmenu", k, t.node.data, t.node, d);
    }, g = () => {
      t.node.isLeaf || (s.value ? (i.ctx.emit("node-collapse", t.node.data, t.node, d), t.node.collapse()) : (t.node.expand(), e.emit("node-expand", t.node.data, t.node, d)));
    }, m = (k, O) => {
      t.node.setChecked(O.target.checked, !i.props.checkStrictly), rt(() => {
        const N = i.store.value;
        i.ctx.emit("check", t.node.data, {
          checkedNodes: N.getCheckedNodes(),
          checkedKeys: N.getCheckedKeys(),
          halfCheckedNodes: N.getHalfCheckedNodes(),
          halfCheckedKeys: N.getHalfCheckedKeys()
        });
      });
    };
    return {
      ns: n,
      node$: u,
      tree: i,
      expanded: s,
      childNodeRendered: o,
      oldChecked: a,
      oldIndeterminate: l,
      getNodeKey: v,
      getNodeClass: y,
      handleSelectChange: b,
      handleClick: p,
      handleContextMenu: f,
      handleExpandIconClick: g,
      handleCheckChange: m,
      handleChildNodeExpand: (k, O, N) => {
        r(O), i.ctx.emit("node-expand", k, O, N);
      },
      handleDragStart: (k) => {
        i.props.draggable && c.treeNodeDragStart({ event: k, treeNode: t });
      },
      handleDragOver: (k) => {
        k.preventDefault(), i.props.draggable && c.treeNodeDragOver({
          event: k,
          treeNode: { $el: u.value, node: t.node }
        });
      },
      handleDrop: (k) => {
        k.preventDefault();
      },
      handleDragEnd: (k) => {
        i.props.draggable && c.treeNodeDragEnd(k);
      },
      CaretRight: gA
    };
  }
}), JP = ["aria-expanded", "aria-disabled", "aria-checked", "draggable", "data-key"], YP = ["aria-expanded"];
function QP(t, e, n, r, i, s) {
  const o = Mt("el-icon"), a = Mt("el-checkbox"), l = Mt("loading"), u = Mt("node-content"), c = Mt("el-tree-node"), d = Mt("el-collapse-transition");
  return Dt((V(), se("div", {
    ref: "node$",
    class: ee([
      t.ns.b("node"),
      t.ns.is("expanded", t.expanded),
      t.ns.is("current", t.node.isCurrent),
      t.ns.is("hidden", !t.node.visible),
      t.ns.is("focusable", !t.node.disabled),
      t.ns.is("checked", !t.node.disabled && t.node.checked),
      t.getNodeClass(t.node)
    ]),
    role: "treeitem",
    tabindex: "-1",
    "aria-expanded": t.expanded,
    "aria-disabled": t.node.disabled,
    "aria-checked": t.node.checked,
    draggable: t.tree.props.draggable,
    "data-key": t.getNodeKey(t.node),
    onClick: e[1] || (e[1] = ft((...h) => t.handleClick && t.handleClick(...h), ["stop"])),
    onContextmenu: e[2] || (e[2] = (...h) => t.handleContextMenu && t.handleContextMenu(...h)),
    onDragstart: e[3] || (e[3] = ft((...h) => t.handleDragStart && t.handleDragStart(...h), ["stop"])),
    onDragover: e[4] || (e[4] = ft((...h) => t.handleDragOver && t.handleDragOver(...h), ["stop"])),
    onDragend: e[5] || (e[5] = ft((...h) => t.handleDragEnd && t.handleDragEnd(...h), ["stop"])),
    onDrop: e[6] || (e[6] = ft((...h) => t.handleDrop && t.handleDrop(...h), ["stop"]))
  }, [
    ae("div", {
      class: ee(t.ns.be("node", "content")),
      style: it({ paddingLeft: (t.node.level - 1) * t.tree.props.indent + "px" })
    }, [
      t.tree.props.icon || t.CaretRight ? (V(), Ae(o, {
        key: 0,
        class: ee([
          t.ns.be("node", "expand-icon"),
          t.ns.is("leaf", t.node.isLeaf),
          {
            expanded: !t.node.isLeaf && t.expanded
          }
        ]),
        onClick: ft(t.handleExpandIconClick, ["stop"])
      }, {
        default: de(() => [
          (V(), Ae(Nn(t.tree.props.icon || t.CaretRight)))
        ]),
        _: 1
      }, 8, ["class", "onClick"])) : ye("v-if", !0),
      t.showCheckbox ? (V(), Ae(a, {
        key: 1,
        "model-value": t.node.checked,
        indeterminate: t.node.indeterminate,
        disabled: !!t.node.disabled,
        onClick: e[0] || (e[0] = ft(() => {
        }, ["stop"])),
        onChange: t.handleCheckChange
      }, null, 8, ["model-value", "indeterminate", "disabled", "onChange"])) : ye("v-if", !0),
      t.node.loading ? (V(), Ae(o, {
        key: 2,
        class: ee([t.ns.be("node", "loading-icon"), t.ns.is("loading")])
      }, {
        default: de(() => [
          ve(l)
        ]),
        _: 1
      }, 8, ["class"])) : ye("v-if", !0),
      ve(u, {
        node: t.node,
        "render-content": t.renderContent
      }, null, 8, ["node", "render-content"])
    ], 6),
    ve(d, null, {
      default: de(() => [
        !t.renderAfterExpand || t.childNodeRendered ? Dt((V(), se("div", {
          key: 0,
          class: ee(t.ns.be("node", "children")),
          role: "group",
          "aria-expanded": t.expanded
        }, [
          (V(!0), se(Ft, null, qn(t.node.childNodes, (h) => (V(), Ae(c, {
            key: t.getNodeKey(h),
            "render-content": t.renderContent,
            "render-after-expand": t.renderAfterExpand,
            "show-checkbox": t.showCheckbox,
            node: h,
            accordion: t.accordion,
            props: t.props,
            onNodeExpand: t.handleChildNodeExpand
          }, null, 8, ["render-content", "render-after-expand", "show-checkbox", "node", "accordion", "props", "onNodeExpand"]))), 128))
        ], 10, YP)), [
          [Jn, t.expanded]
        ]) : ye("v-if", !0)
      ]),
      _: 1
    })
  ], 42, JP)), [
    [Jn, t.node.visible]
  ]);
}
var ZP = /* @__PURE__ */ Ge(qP, [["render", QP], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node.vue"]]);
function XP({ el$: t }, e) {
  const n = Fe("tree"), r = zn([]), i = zn([]);
  Ct(() => {
    o();
  }), Ml(() => {
    r.value = Array.from(t.value.querySelectorAll("[role=treeitem]")), i.value = Array.from(t.value.querySelectorAll("input[type=checkbox]"));
  }), ke(i, (a) => {
    a.forEach((l) => {
      l.setAttribute("tabindex", "-1");
    });
  }), bn(t, "keydown", (a) => {
    const l = a.target;
    if (!l.className.includes(n.b("node")))
      return;
    const u = a.code;
    r.value = Array.from(t.value.querySelectorAll(`.${n.is("focusable")}[role=treeitem]`));
    const c = r.value.indexOf(l);
    let d;
    if ([sn.up, sn.down].includes(u)) {
      if (a.preventDefault(), u === sn.up) {
        d = c === -1 ? 0 : c !== 0 ? c - 1 : r.value.length - 1;
        const v = d;
        for (; !e.value.getNode(r.value[d].dataset.key).canFocus; ) {
          if (d--, d === v) {
            d = -1;
            break;
          }
          d < 0 && (d = r.value.length - 1);
        }
      } else {
        d = c === -1 ? 0 : c < r.value.length - 1 ? c + 1 : 0;
        const v = d;
        for (; !e.value.getNode(r.value[d].dataset.key).canFocus; ) {
          if (d++, d === v) {
            d = -1;
            break;
          }
          d >= r.value.length && (d = 0);
        }
      }
      d !== -1 && r.value[d].focus();
    }
    [sn.left, sn.right].includes(u) && (a.preventDefault(), l.click());
    const h = l.querySelector('[type="checkbox"]');
    [sn.enter, sn.space].includes(u) && h && (a.preventDefault(), h.click());
  });
  const o = () => {
    var a;
    r.value = Array.from(t.value.querySelectorAll(`.${n.is("focusable")}[role=treeitem]`)), i.value = Array.from(t.value.querySelectorAll("input[type=checkbox]"));
    const l = t.value.querySelectorAll(`.${n.is("checked")}[role=treeitem]`);
    if (l.length) {
      l[0].setAttribute("tabindex", "0");
      return;
    }
    (a = r.value[0]) == null || a.setAttribute("tabindex", "0");
  };
}
const e3 = be({
  name: "ElTree",
  components: { ElTreeNode: ZP },
  props: {
    data: {
      type: Array,
      default: () => []
    },
    emptyText: {
      type: String
    },
    renderAfterExpand: {
      type: Boolean,
      default: !0
    },
    nodeKey: String,
    checkStrictly: Boolean,
    defaultExpandAll: Boolean,
    expandOnClickNode: {
      type: Boolean,
      default: !0
    },
    checkOnClickNode: Boolean,
    checkDescendants: {
      type: Boolean,
      default: !1
    },
    autoExpandParent: {
      type: Boolean,
      default: !0
    },
    defaultCheckedKeys: Array,
    defaultExpandedKeys: Array,
    currentNodeKey: [String, Number],
    renderContent: Function,
    showCheckbox: {
      type: Boolean,
      default: !1
    },
    draggable: {
      type: Boolean,
      default: !1
    },
    allowDrag: Function,
    allowDrop: Function,
    props: {
      type: Object,
      default: () => ({
        children: "children",
        label: "label",
        disabled: "disabled"
      })
    },
    lazy: {
      type: Boolean,
      default: !1
    },
    highlightCurrent: Boolean,
    load: Function,
    filterNodeMethod: Function,
    accordion: Boolean,
    indent: {
      type: Number,
      default: 18
    },
    icon: {
      type: bi
    }
  },
  emits: [
    "check-change",
    "current-change",
    "node-click",
    "node-contextmenu",
    "node-collapse",
    "node-expand",
    "check",
    "node-drag-start",
    "node-drag-end",
    "node-drop",
    "node-drag-leave",
    "node-drag-enter",
    "node-drag-over"
  ],
  setup(t, e) {
    const { t: n } = or(), r = Fe("tree"), i = $(new WP({
      key: t.nodeKey,
      data: t.data,
      lazy: t.lazy,
      props: t.props,
      load: t.load,
      currentNodeKey: t.currentNodeKey,
      checkStrictly: t.checkStrictly,
      checkDescendants: t.checkDescendants,
      defaultCheckedKeys: t.defaultCheckedKeys,
      defaultExpandedKeys: t.defaultExpandedKeys,
      autoExpandParent: t.autoExpandParent,
      defaultExpandAll: t.defaultExpandAll,
      filterNodeMethod: t.filterNodeMethod
    }));
    i.value.initialize();
    const s = $(i.value.root), o = $(null), a = $(null), l = $(null), { broadcastExpanded: u } = Fm(t), { dragState: c } = GP({
      props: t,
      ctx: e,
      el$: a,
      dropIndicator$: l,
      store: i
    });
    XP({ el$: a }, i);
    const d = F(() => {
      const { childNodes: z } = s.value;
      return !z || z.length === 0 || z.every(({ visible: U }) => !U);
    });
    ke(() => t.currentNodeKey, (z) => {
      i.value.setCurrentNodeKey(z);
    }), ke(() => t.defaultCheckedKeys, (z) => {
      i.value.setDefaultCheckedKey(z);
    }), ke(() => t.defaultExpandedKeys, (z) => {
      i.value.setDefaultExpandedKeys(z);
    }), ke(() => t.data, (z) => {
      i.value.setData(z);
    }, { deep: !0 }), ke(() => t.checkStrictly, (z) => {
      i.value.checkStrictly = z;
    });
    const h = (z) => {
      if (!t.filterNodeMethod)
        throw new Error("[Tree] filterNodeMethod is required when filter");
      i.value.filter(z);
    }, v = (z) => Xd(t.nodeKey, z.data), y = (z) => {
      if (!t.nodeKey)
        throw new Error("[Tree] nodeKey is required in getNodePath");
      const U = i.value.getNode(z);
      if (!U)
        return [];
      const H = [U.data];
      let re = U.parent;
      for (; re && re !== s.value; )
        H.push(re.data), re = re.parent;
      return H.reverse();
    }, b = (z, U) => i.value.getCheckedNodes(z, U), p = (z) => i.value.getCheckedKeys(z), f = () => {
      const z = i.value.getCurrentNode();
      return z ? z.data : null;
    }, g = () => {
      if (!t.nodeKey)
        throw new Error("[Tree] nodeKey is required in getCurrentKey");
      const z = f();
      return z ? z[t.nodeKey] : null;
    }, m = (z, U) => {
      if (!t.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCheckedNodes");
      i.value.setCheckedNodes(z, U);
    }, w = (z, U) => {
      if (!t.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCheckedKeys");
      i.value.setCheckedKeys(z, U);
    }, _ = (z, U, H) => {
      i.value.setChecked(z, U, H);
    }, S = () => i.value.getHalfCheckedNodes(), A = () => i.value.getHalfCheckedKeys(), C = (z, U = !0) => {
      if (!t.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCurrentNode");
      bc(i, e.emit, () => i.value.setUserCurrentNode(z, U));
    }, k = (z, U = !0) => {
      if (!t.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCurrentKey");
      bc(i, e.emit, () => i.value.setCurrentNodeKey(z, U));
    }, O = (z) => i.value.getNode(z), N = (z) => {
      i.value.remove(z);
    }, B = (z, U) => {
      i.value.append(z, U);
    }, M = (z, U) => {
      i.value.insertBefore(z, U);
    }, j = (z, U) => {
      i.value.insertAfter(z, U);
    }, q = (z, U, H) => {
      u(U), e.emit("node-expand", z, U, H);
    }, X = (z, U) => {
      if (!t.nodeKey)
        throw new Error("[Tree] nodeKey is required in updateKeyChild");
      i.value.updateChildren(z, U);
    };
    return qt("RootTree", {
      ctx: e,
      props: t,
      store: i,
      root: s,
      currentNode: o,
      instance: ht()
    }), qt(Oo, void 0), {
      ns: r,
      store: i,
      root: s,
      currentNode: o,
      dragState: c,
      el$: a,
      dropIndicator$: l,
      isEmpty: d,
      filter: h,
      getNodeKey: v,
      getNodePath: y,
      getCheckedNodes: b,
      getCheckedKeys: p,
      getCurrentNode: f,
      getCurrentKey: g,
      setCheckedNodes: m,
      setCheckedKeys: w,
      setChecked: _,
      getHalfCheckedNodes: S,
      getHalfCheckedKeys: A,
      setCurrentNode: C,
      setCurrentKey: k,
      t: n,
      getNode: O,
      remove: N,
      append: B,
      insertBefore: M,
      insertAfter: j,
      handleNodeExpand: q,
      updateKeyChildren: X
    };
  }
});
function t3(t, e, n, r, i, s) {
  const o = Mt("el-tree-node");
  return V(), se("div", {
    ref: "el$",
    class: ee([
      t.ns.b(),
      t.ns.is("dragging", !!t.dragState.draggingNode),
      t.ns.is("drop-not-allow", !t.dragState.allowDrop),
      t.ns.is("drop-inner", t.dragState.dropType === "inner"),
      { [t.ns.m("highlight-current")]: t.highlightCurrent }
    ]),
    role: "tree"
  }, [
    (V(!0), se(Ft, null, qn(t.root.childNodes, (a) => (V(), Ae(o, {
      key: t.getNodeKey(a),
      node: a,
      props: t.props,
      accordion: t.accordion,
      "render-after-expand": t.renderAfterExpand,
      "show-checkbox": t.showCheckbox,
      "render-content": t.renderContent,
      onNodeExpand: t.handleNodeExpand
    }, null, 8, ["node", "props", "accordion", "render-after-expand", "show-checkbox", "render-content", "onNodeExpand"]))), 128)),
    t.isEmpty ? (V(), se("div", {
      key: 0,
      class: ee(t.ns.e("empty-block"))
    }, [
      Me(t.$slots, "empty", {}, () => {
        var a;
        return [
          ae("span", {
            class: ee(t.ns.e("empty-text"))
          }, st((a = t.emptyText) != null ? a : t.t("el.tree.emptyText")), 3)
        ];
      })
    ], 2)) : ye("v-if", !0),
    Dt(ae("div", {
      ref: "dropIndicator$",
      class: ee(t.ns.e("drop-indicator"))
    }, null, 2), [
      [Jn, t.dragState.showDropIndicator]
    ])
  ], 2);
}
var Wa = /* @__PURE__ */ Ge(e3, [["render", t3], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree.vue"]]);
Wa.install = (t) => {
  t.component(Wa.name, Wa);
};
const n3 = Wa, r3 = n3, Um = Symbol("uploadContextKey"), i3 = "ElUpload";
class s3 extends Error {
  constructor(e, n, r, i) {
    super(e), this.name = "UploadAjaxError", this.status = n, this.method = r, this.url = i;
  }
}
function fp(t, e, n) {
  let r;
  return n.response ? r = `${n.response.error || n.response}` : n.responseText ? r = `${n.responseText}` : r = `fail to ${e.method} ${t} ${n.status}`, new s3(r, n.status, e.method, t);
}
function o3(t) {
  const e = t.responseText || t.response;
  if (!e)
    return e;
  try {
    return JSON.parse(e);
  } catch {
    return e;
  }
}
const a3 = (t) => {
  typeof XMLHttpRequest > "u" && qi(i3, "XMLHttpRequest is undefined");
  const e = new XMLHttpRequest(), n = t.action;
  e.upload && e.upload.addEventListener("progress", (s) => {
    const o = s;
    o.percent = s.total > 0 ? s.loaded / s.total * 100 : 0, t.onProgress(o);
  });
  const r = new FormData();
  if (t.data)
    for (const [s, o] of Object.entries(t.data))
      Or(o) && o.length ? r.append(s, ...o) : r.append(s, o);
  r.append(t.filename, t.file, t.file.name), e.addEventListener("error", () => {
    t.onError(fp(n, t, e));
  }), e.addEventListener("load", () => {
    if (e.status < 200 || e.status >= 300)
      return t.onError(fp(n, t, e));
    t.onSuccess(o3(e));
  }), e.open(t.method, n, !0), t.withCredentials && "withCredentials" in e && (e.withCredentials = !0);
  const i = t.headers || {};
  if (i instanceof Headers)
    i.forEach((s, o) => e.setRequestHeader(o, s));
  else
    for (const [s, o] of Object.entries(i))
      er(o) || e.setRequestHeader(s, String(o));
  return e.send(r), e;
}, Vm = ["text", "picture", "picture-card"];
let l3 = 1;
const Sc = () => Date.now() + l3++, Wm = ut({
  action: {
    type: String,
    default: "#"
  },
  headers: {
    type: Be(Object)
  },
  method: {
    type: String,
    default: "post"
  },
  data: {
    type: Be([Object, Function, Promise]),
    default: () => Cs({})
  },
  multiple: {
    type: Boolean,
    default: !1
  },
  name: {
    type: String,
    default: "file"
  },
  drag: {
    type: Boolean,
    default: !1
  },
  withCredentials: Boolean,
  showFileList: {
    type: Boolean,
    default: !0
  },
  accept: {
    type: String,
    default: ""
  },
  fileList: {
    type: Be(Array),
    default: () => Cs([])
  },
  autoUpload: {
    type: Boolean,
    default: !0
  },
  listType: {
    type: String,
    values: Vm,
    default: "text"
  },
  httpRequest: {
    type: Be(Function),
    default: a3
  },
  disabled: Boolean,
  limit: Number
}), u3 = ut({
  ...Wm,
  beforeUpload: {
    type: Be(Function),
    default: en
  },
  beforeRemove: {
    type: Be(Function)
  },
  onRemove: {
    type: Be(Function),
    default: en
  },
  onChange: {
    type: Be(Function),
    default: en
  },
  onPreview: {
    type: Be(Function),
    default: en
  },
  onSuccess: {
    type: Be(Function),
    default: en
  },
  onProgress: {
    type: Be(Function),
    default: en
  },
  onError: {
    type: Be(Function),
    default: en
  },
  onExceed: {
    type: Be(Function),
    default: en
  }
}), c3 = ut({
  files: {
    type: Be(Array),
    default: () => Cs([])
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  handlePreview: {
    type: Be(Function),
    default: en
  },
  listType: {
    type: String,
    values: Vm,
    default: "text"
  }
}), d3 = {
  remove: (t) => !!t
}, f3 = ["onKeydown"], h3 = ["src"], p3 = ["onClick"], v3 = ["title"], g3 = ["onClick"], m3 = ["onClick"], y3 = be({
  name: "ElUploadList"
}), b3 = /* @__PURE__ */ be({
  ...y3,
  props: c3,
  emits: d3,
  setup(t, { emit: e }) {
    const n = t, { t: r } = or(), i = Fe("upload"), s = Fe("icon"), o = Fe("list"), a = Br(), l = $(!1), u = F(() => [
      i.b("list"),
      i.bm("list", n.listType),
      i.is("disabled", n.disabled)
    ]), c = (d) => {
      e("remove", d);
    };
    return (d, h) => (V(), Ae(X0, {
      tag: "ul",
      class: ee(x(u)),
      name: x(o).b()
    }, {
      default: de(() => [
        (V(!0), se(Ft, null, qn(d.files, (v) => (V(), se("li", {
          key: v.uid || v.name,
          class: ee([
            x(i).be("list", "item"),
            x(i).is(v.status),
            { focusing: l.value }
          ]),
          tabindex: "0",
          onKeydown: vn((y) => !x(a) && c(v), ["delete"]),
          onFocus: h[0] || (h[0] = (y) => l.value = !0),
          onBlur: h[1] || (h[1] = (y) => l.value = !1),
          onClick: h[2] || (h[2] = (y) => l.value = !1)
        }, [
          Me(d.$slots, "default", { file: v }, () => [
            d.listType === "picture" || v.status !== "uploading" && d.listType === "picture-card" ? (V(), se("img", {
              key: 0,
              class: ee(x(i).be("list", "item-thumbnail")),
              src: v.url,
              alt: ""
            }, null, 10, h3)) : ye("v-if", !0),
            v.status === "uploading" || d.listType !== "picture-card" ? (V(), se("div", {
              key: 1,
              class: ee(x(i).be("list", "item-info"))
            }, [
              ae("a", {
                class: ee(x(i).be("list", "item-name")),
                onClick: ft((y) => d.handlePreview(v), ["prevent"])
              }, [
                ve(x(_t), {
                  class: ee(x(s).m("document"))
                }, {
                  default: de(() => [
                    ve(x(JA))
                  ]),
                  _: 1
                }, 8, ["class"]),
                ae("span", {
                  class: ee(x(i).be("list", "item-file-name")),
                  title: v.name
                }, st(v.name), 11, v3)
              ], 10, p3),
              v.status === "uploading" ? (V(), Ae(x(Tm), {
                key: 0,
                type: d.listType === "picture-card" ? "circle" : "line",
                "stroke-width": d.listType === "picture-card" ? 6 : 2,
                percentage: Number(v.percentage),
                style: it(d.listType === "picture-card" ? "" : "margin-top: 0.5rem")
              }, null, 8, ["type", "stroke-width", "percentage", "style"])) : ye("v-if", !0)
            ], 2)) : ye("v-if", !0),
            ae("label", {
              class: ee(x(i).be("list", "item-status-label"))
            }, [
              d.listType === "text" ? (V(), Ae(x(_t), {
                key: 0,
                class: ee([x(s).m("upload-success"), x(s).m("circle-check")])
              }, {
                default: de(() => [
                  ve(x(Nd))
                ]),
                _: 1
              }, 8, ["class"])) : ["picture-card", "picture"].includes(d.listType) ? (V(), Ae(x(_t), {
                key: 1,
                class: ee([x(s).m("upload-success"), x(s).m("check")])
              }, {
                default: de(() => [
                  ve(x(og))
                ]),
                _: 1
              }, 8, ["class"])) : ye("v-if", !0)
            ], 2),
            x(a) ? ye("v-if", !0) : (V(), Ae(x(_t), {
              key: 2,
              class: ee(x(s).m("close")),
              onClick: (y) => c(v)
            }, {
              default: de(() => [
                ve(x(ko))
              ]),
              _: 2
            }, 1032, ["class", "onClick"])),
            ye(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"),
            ye(" This is a bug which needs to be fixed "),
            ye(" TODO: Fix the incorrect navigation interaction "),
            x(a) ? ye("v-if", !0) : (V(), se("i", {
              key: 3,
              class: ee(x(s).m("close-tip"))
            }, st(x(r)("el.upload.deleteTip")), 3)),
            d.listType === "picture-card" ? (V(), se("span", {
              key: 4,
              class: ee(x(i).be("list", "item-actions"))
            }, [
              ae("span", {
                class: ee(x(i).be("list", "item-preview")),
                onClick: (y) => d.handlePreview(v)
              }, [
                ve(x(_t), {
                  class: ee(x(s).m("zoom-in"))
                }, {
                  default: de(() => [
                    ve(x(cg))
                  ]),
                  _: 1
                }, 8, ["class"])
              ], 10, g3),
              x(a) ? ye("v-if", !0) : (V(), se("span", {
                key: 0,
                class: ee(x(i).be("list", "item-delete")),
                onClick: (y) => c(v)
              }, [
                ve(x(_t), {
                  class: ee(x(s).m("delete"))
                }, {
                  default: de(() => [
                    ve(x(ag))
                  ]),
                  _: 1
                }, 8, ["class"])
              ], 10, m3))
            ], 2)) : ye("v-if", !0)
          ])
        ], 42, f3))), 128)),
        Me(d.$slots, "append")
      ]),
      _: 3
    }, 8, ["class", "name"]));
  }
});
var hp = /* @__PURE__ */ Ge(b3, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-list.vue"]]);
const w3 = ut({
  disabled: {
    type: Boolean,
    default: !1
  }
}), _3 = {
  file: (t) => Or(t)
}, S3 = ["onDrop", "onDragover"], Km = "ElUploadDrag", E3 = be({
  name: Km
}), x3 = /* @__PURE__ */ be({
  ...E3,
  props: w3,
  emits: _3,
  setup(t, { emit: e }) {
    const n = tt(Um);
    n || qi(Km, "usage: <el-upload><el-upload-dragger /></el-upload>");
    const r = Fe("upload"), i = $(!1), s = Br(), o = (l) => {
      if (s.value)
        return;
      i.value = !1, l.stopPropagation();
      const u = Array.from(l.dataTransfer.files), c = n.accept.value;
      if (!c) {
        e("file", u);
        return;
      }
      const d = u.filter((h) => {
        const { type: v, name: y } = h, b = y.includes(".") ? `.${y.split(".").pop()}` : "", p = v.replace(/\/.*$/, "");
        return c.split(",").map((f) => f.trim()).filter((f) => f).some((f) => f.startsWith(".") ? b === f : /\/\*$/.test(f) ? p === f.replace(/\/\*$/, "") : /^[^/]+\/[^/]+$/.test(f) ? v === f : !1);
      });
      e("file", d);
    }, a = () => {
      s.value || (i.value = !0);
    };
    return (l, u) => (V(), se("div", {
      class: ee([x(r).b("dragger"), x(r).is("dragover", i.value)]),
      onDrop: ft(o, ["prevent"]),
      onDragover: ft(a, ["prevent"]),
      onDragleave: u[0] || (u[0] = ft((c) => i.value = !1, ["prevent"]))
    }, [
      Me(l.$slots, "default")
    ], 42, S3));
  }
});
var A3 = /* @__PURE__ */ Ge(x3, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-dragger.vue"]]);
const k3 = ut({
  ...Wm,
  beforeUpload: {
    type: Be(Function),
    default: en
  },
  onRemove: {
    type: Be(Function),
    default: en
  },
  onStart: {
    type: Be(Function),
    default: en
  },
  onSuccess: {
    type: Be(Function),
    default: en
  },
  onProgress: {
    type: Be(Function),
    default: en
  },
  onError: {
    type: Be(Function),
    default: en
  },
  onExceed: {
    type: Be(Function),
    default: en
  }
}), C3 = ["onKeydown"], T3 = ["name", "multiple", "accept"], O3 = be({
  name: "ElUploadContent",
  inheritAttrs: !1
}), I3 = /* @__PURE__ */ be({
  ...O3,
  props: k3,
  setup(t, { expose: e }) {
    const n = t, r = Fe("upload"), i = Br(), s = zn({}), o = zn(), a = (b) => {
      if (b.length === 0)
        return;
      const { autoUpload: p, limit: f, fileList: g, multiple: m, onStart: w, onExceed: _ } = n;
      if (f && g.length + b.length > f) {
        _(b, g);
        return;
      }
      m || (b = b.slice(0, 1));
      for (const S of b) {
        const A = S;
        A.uid = Sc(), w(A), p && l(A);
      }
    }, l = async (b) => {
      if (o.value.value = "", !n.beforeUpload)
        return c(b);
      let p, f = {};
      try {
        const m = n.data, w = n.beforeUpload(b);
        f = $f(n.data) ? bh(n.data) : n.data, p = await w, $f(n.data) && ll(m, f) && (f = bh(n.data));
      } catch {
        p = !1;
      }
      if (p === !1) {
        n.onRemove(b);
        return;
      }
      let g = b;
      p instanceof Blob && (p instanceof File ? g = p : g = new File([p], b.name, {
        type: b.type
      })), c(Object.assign(g, {
        uid: b.uid
      }), f);
    }, u = async (b, p) => gn(b) ? b(p) : b, c = async (b, p) => {
      const {
        headers: f,
        data: g,
        method: m,
        withCredentials: w,
        name: _,
        action: S,
        onProgress: A,
        onSuccess: C,
        onError: k,
        httpRequest: O
      } = n;
      try {
        p = await u(p ?? g, b);
      } catch {
        n.onRemove(b);
        return;
      }
      const { uid: N } = b, B = {
        headers: f || {},
        withCredentials: w,
        file: b,
        data: p,
        method: m,
        filename: _,
        action: S,
        onProgress: (j) => {
          A(j, b);
        },
        onSuccess: (j) => {
          C(j, b), delete s.value[N];
        },
        onError: (j) => {
          k(j, b), delete s.value[N];
        }
      }, M = O(B);
      s.value[N] = M, M instanceof Promise && M.then(B.onSuccess, B.onError);
    }, d = (b) => {
      const p = b.target.files;
      p && a(Array.from(p));
    }, h = () => {
      i.value || (o.value.value = "", o.value.click());
    }, v = () => {
      h();
    };
    return e({
      abort: (b) => {
        Nx(s.value).filter(b ? ([f]) => String(b.uid) === f : () => !0).forEach(([f, g]) => {
          g instanceof XMLHttpRequest && g.abort(), delete s.value[f];
        });
      },
      upload: l
    }), (b, p) => (V(), se("div", {
      class: ee([x(r).b(), x(r).m(b.listType), x(r).is("drag", b.drag)]),
      tabindex: "0",
      onClick: h,
      onKeydown: vn(ft(v, ["self"]), ["enter", "space"])
    }, [
      b.drag ? (V(), Ae(A3, {
        key: 0,
        disabled: x(i),
        onFile: a
      }, {
        default: de(() => [
          Me(b.$slots, "default")
        ]),
        _: 3
      }, 8, ["disabled"])) : Me(b.$slots, "default", { key: 1 }),
      ae("input", {
        ref_key: "inputRef",
        ref: o,
        class: ee(x(r).e("input")),
        name: b.name,
        multiple: b.multiple,
        accept: b.accept,
        type: "file",
        onChange: d,
        onClick: p[0] || (p[0] = ft(() => {
        }, ["stop"]))
      }, null, 42, T3)
    ], 42, C3));
  }
});
var pp = /* @__PURE__ */ Ge(I3, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-content.vue"]]);
const vp = "ElUpload", gp = (t) => {
  var e;
  (e = t.url) != null && e.startsWith("blob:") && URL.revokeObjectURL(t.url);
}, N3 = (t, e) => {
  const n = _b(t, "fileList", void 0, { passive: !0 }), r = (h) => n.value.find((v) => v.uid === h.uid);
  function i(h) {
    var v;
    (v = e.value) == null || v.abort(h);
  }
  function s(h = ["ready", "uploading", "success", "fail"]) {
    n.value = n.value.filter((v) => !h.includes(v.status));
  }
  const o = (h, v) => {
    const y = r(v);
    y && (console.error(h), y.status = "fail", n.value.splice(n.value.indexOf(y), 1), t.onError(h, y, n.value), t.onChange(y, n.value));
  }, a = (h, v) => {
    const y = r(v);
    y && (t.onProgress(h, y, n.value), y.status = "uploading", y.percentage = Math.round(h.percent));
  }, l = (h, v) => {
    const y = r(v);
    y && (y.status = "success", y.response = h, t.onSuccess(h, y, n.value), t.onChange(y, n.value));
  }, u = (h) => {
    er(h.uid) && (h.uid = Sc());
    const v = {
      name: h.name,
      percentage: 0,
      status: "ready",
      size: h.size,
      raw: h,
      uid: h.uid
    };
    if (t.listType === "picture-card" || t.listType === "picture")
      try {
        v.url = URL.createObjectURL(h);
      } catch (y) {
        Vt(vp, y.message), t.onError(y, v, n.value);
      }
    n.value = [...n.value, v], t.onChange(v, n.value);
  }, c = async (h) => {
    const v = h instanceof File ? r(h) : h;
    v || qi(vp, "file to be removed not found");
    const y = (b) => {
      i(b);
      const p = n.value;
      p.splice(p.indexOf(b), 1), t.onRemove(b, p), gp(b);
    };
    t.beforeRemove ? await t.beforeRemove(v, n.value) !== !1 && y(v) : y(v);
  };
  function d() {
    n.value.filter(({ status: h }) => h === "ready").forEach(({ raw: h }) => {
      var v;
      return h && ((v = e.value) == null ? void 0 : v.upload(h));
    });
  }
  return ke(() => t.listType, (h) => {
    h !== "picture-card" && h !== "picture" || (n.value = n.value.map((v) => {
      const { raw: y, url: b } = v;
      if (!b && y)
        try {
          v.url = URL.createObjectURL(y);
        } catch (p) {
          t.onError(p, v, n.value);
        }
      return v;
    }));
  }), ke(n, (h) => {
    for (const v of h)
      v.uid || (v.uid = Sc()), v.status || (v.status = "success");
  }, { immediate: !0, deep: !0 }), {
    uploadFiles: n,
    abort: i,
    clearFiles: s,
    handleError: o,
    handleProgress: a,
    handleStart: u,
    handleSuccess: l,
    handleRemove: c,
    submit: d,
    revokeFileObjectURL: gp
  };
}, R3 = be({
  name: "ElUpload"
}), P3 = /* @__PURE__ */ be({
  ...R3,
  props: u3,
  setup(t, { expose: e }) {
    const n = t, r = Br(), i = zn(), {
      abort: s,
      submit: o,
      clearFiles: a,
      uploadFiles: l,
      handleStart: u,
      handleError: c,
      handleRemove: d,
      handleSuccess: h,
      handleProgress: v,
      revokeFileObjectURL: y
    } = N3(n, i), b = F(() => n.listType === "picture-card"), p = F(() => ({
      ...n,
      fileList: l.value,
      onStart: u,
      onProgress: v,
      onSuccess: h,
      onError: c,
      onRemove: d
    }));
    return En(() => {
      l.value.forEach(y);
    }), qt(Um, {
      accept: Cn(n, "accept")
    }), e({
      abort: s,
      submit: o,
      clearFiles: a,
      handleStart: u,
      handleRemove: d
    }), (f, g) => (V(), se("div", null, [
      x(b) && f.showFileList ? (V(), Ae(hp, {
        key: 0,
        disabled: x(r),
        "list-type": f.listType,
        files: x(l),
        "handle-preview": f.onPreview,
        onRemove: x(d)
      }, qu({
        append: de(() => [
          ve(pp, Gn({
            ref_key: "uploadRef",
            ref: i
          }, x(p)), {
            default: de(() => [
              f.$slots.trigger ? Me(f.$slots, "trigger", { key: 0 }) : ye("v-if", !0),
              !f.$slots.trigger && f.$slots.default ? Me(f.$slots, "default", { key: 1 }) : ye("v-if", !0)
            ]),
            _: 3
          }, 16)
        ]),
        _: 2
      }, [
        f.$slots.file ? {
          name: "default",
          fn: de(({ file: m }) => [
            Me(f.$slots, "file", { file: m })
          ])
        } : void 0
      ]), 1032, ["disabled", "list-type", "files", "handle-preview", "onRemove"])) : ye("v-if", !0),
      !x(b) || x(b) && !f.showFileList ? (V(), Ae(pp, Gn({
        key: 1,
        ref_key: "uploadRef",
        ref: i
      }, x(p)), {
        default: de(() => [
          f.$slots.trigger ? Me(f.$slots, "trigger", { key: 0 }) : ye("v-if", !0),
          !f.$slots.trigger && f.$slots.default ? Me(f.$slots, "default", { key: 1 }) : ye("v-if", !0)
        ]),
        _: 3
      }, 16)) : ye("v-if", !0),
      f.$slots.trigger ? Me(f.$slots, "default", { key: 2 }) : ye("v-if", !0),
      Me(f.$slots, "tip"),
      !x(b) && f.showFileList ? (V(), Ae(hp, {
        key: 3,
        disabled: x(r),
        "list-type": f.listType,
        files: x(l),
        "handle-preview": f.onPreview,
        onRemove: x(d)
      }, qu({ _: 2 }, [
        f.$slots.file ? {
          name: "default",
          fn: de(({ file: m }) => [
            Me(f.$slots, "file", { file: m })
          ])
        } : void 0
      ]), 1032, ["disabled", "list-type", "files", "handle-preview", "onRemove"])) : ye("v-if", !0)
    ]));
  }
});
var B3 = /* @__PURE__ */ Ge(P3, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload.vue"]]);
const D3 = nn(B3);
function M3(t) {
  let e;
  const n = $(!1), r = Bn({
    ...t,
    originalPosition: "",
    originalOverflow: "",
    visible: !1
  });
  function i(h) {
    r.text = h;
  }
  function s() {
    const h = r.parent, v = d.ns;
    if (!h.vLoadingAddClassList) {
      let y = h.getAttribute("loading-number");
      y = Number.parseInt(y) - 1, y ? h.setAttribute("loading-number", y.toString()) : (Er(h, v.bm("parent", "relative")), h.removeAttribute("loading-number")), Er(h, v.bm("parent", "hidden"));
    }
    o(), c.unmount();
  }
  function o() {
    var h, v;
    (v = (h = d.$el) == null ? void 0 : h.parentNode) == null || v.removeChild(d.$el);
  }
  function a() {
    var h;
    t.beforeClose && !t.beforeClose() || (n.value = !0, clearTimeout(e), e = window.setTimeout(l, 400), r.visible = !1, (h = t.closed) == null || h.call(t));
  }
  function l() {
    if (!n.value)
      return;
    const h = r.parent;
    n.value = !1, h.vLoadingAddClassList = void 0, s();
  }
  const u = be({
    name: "ElLoading",
    setup(h, { expose: v }) {
      const { ns: y, zIndex: b } = ET("loading");
      return v({
        ns: y,
        zIndex: b
      }), () => {
        const p = r.spinner || r.svg, f = et("svg", {
          class: "circular",
          viewBox: r.svgViewBox ? r.svgViewBox : "0 0 50 50",
          ...p ? { innerHTML: p } : {}
        }, [
          et("circle", {
            class: "path",
            cx: "25",
            cy: "25",
            r: "20",
            fill: "none"
          })
        ]), g = r.text ? et("p", { class: y.b("text") }, [r.text]) : void 0;
        return et(mr, {
          name: y.b("fade"),
          onAfterLeave: l
        }, {
          default: de(() => [
            Dt(ve("div", {
              style: {
                backgroundColor: r.background || ""
              },
              class: [
                y.b("mask"),
                r.customClass,
                r.fullscreen ? "is-fullscreen" : ""
              ]
            }, [
              et("div", {
                class: y.b("spinner")
              }, [f, g])
            ]), [[Jn, r.visible]])
          ])
        });
      };
    }
  }), c = eb(u), d = c.mount(document.createElement("div"));
  return {
    ...hn(r),
    setText: i,
    removeElLoadingChild: o,
    close: a,
    handleAfterLeave: l,
    vm: d,
    get $el() {
      return d.$el;
    }
  };
}
let Ea;
const L3 = function(t = {}) {
  if (!St)
    return;
  const e = z3(t);
  if (e.fullscreen && Ea)
    return Ea;
  const n = M3({
    ...e,
    closed: () => {
      var i;
      (i = e.closed) == null || i.call(e), e.fullscreen && (Ea = void 0);
    }
  });
  j3(e, e.parent, n), mp(e, e.parent, n), e.parent.vLoadingAddClassList = () => mp(e, e.parent, n);
  let r = e.parent.getAttribute("loading-number");
  return r ? r = `${Number.parseInt(r) + 1}` : r = "1", e.parent.setAttribute("loading-number", r), e.parent.appendChild(n.$el), rt(() => n.visible.value = e.visible), e.fullscreen && (Ea = n), n;
}, z3 = (t) => {
  var e, n, r, i;
  let s;
  return Gt(t.target) ? s = (e = document.querySelector(t.target)) != null ? e : document.body : s = t.target || document.body, {
    parent: s === document.body || t.body ? document.body : s,
    background: t.background || "",
    svg: t.svg || "",
    svgViewBox: t.svgViewBox || "",
    spinner: t.spinner || !1,
    text: t.text || "",
    fullscreen: s === document.body && ((n = t.fullscreen) != null ? n : !0),
    lock: (r = t.lock) != null ? r : !1,
    customClass: t.customClass || "",
    visible: (i = t.visible) != null ? i : !0,
    target: s
  };
}, j3 = async (t, e, n) => {
  const { nextZIndex: r } = n.vm.zIndex || n.vm._.exposed.zIndex, i = {};
  if (t.fullscreen)
    n.originalPosition.value = fs(document.body, "position"), n.originalOverflow.value = fs(document.body, "overflow"), i.zIndex = r();
  else if (t.parent === document.body) {
    n.originalPosition.value = fs(document.body, "position"), await rt();
    for (const s of ["top", "left"]) {
      const o = s === "top" ? "scrollTop" : "scrollLeft";
      i[s] = `${t.target.getBoundingClientRect()[s] + document.body[o] + document.documentElement[o] - Number.parseInt(fs(document.body, `margin-${s}`), 10)}px`;
    }
    for (const s of ["height", "width"])
      i[s] = `${t.target.getBoundingClientRect()[s]}px`;
  } else
    n.originalPosition.value = fs(e, "position");
  for (const [s, o] of Object.entries(i))
    n.$el.style[s] = o;
}, mp = (t, e, n) => {
  const r = n.vm.ns || n.vm._.exposed.ns;
  ["absolute", "fixed", "sticky"].includes(n.originalPosition.value) ? Er(e, r.bm("parent", "relative")) : Ao(e, r.bm("parent", "relative")), t.fullscreen && t.lock ? Ao(e, r.bm("parent", "hidden")) : Er(e, r.bm("parent", "hidden"));
}, Ec = Symbol("ElLoading"), yp = (t, e) => {
  var n, r, i, s;
  const o = e.instance, a = (h) => wn(e.value) ? e.value[h] : void 0, l = (h) => {
    const v = Gt(h) && (o == null ? void 0 : o[h]) || h;
    return v && $(v);
  }, u = (h) => l(a(h) || t.getAttribute(`element-loading-${Ob(h)}`)), c = (n = a("fullscreen")) != null ? n : e.modifiers.fullscreen, d = {
    text: u("text"),
    svg: u("svg"),
    svgViewBox: u("svgViewBox"),
    spinner: u("spinner"),
    background: u("background"),
    customClass: u("customClass"),
    fullscreen: c,
    target: (r = a("target")) != null ? r : c ? void 0 : t,
    body: (i = a("body")) != null ? i : e.modifiers.body,
    lock: (s = a("lock")) != null ? s : e.modifiers.lock
  };
  t[Ec] = {
    options: d,
    instance: L3(d)
  };
}, F3 = (t, e) => {
  for (const n of Object.keys(e))
    on(e[n]) && (e[n].value = t[n]);
}, H3 = {
  mounted(t, e) {
    e.value && yp(t, e);
  },
  updated(t, e) {
    const n = t[Ec];
    e.oldValue !== e.value && (e.value && !e.oldValue ? yp(t, e) : e.value && e.oldValue ? wn(e.value) && F3(e.value, n.options) : n == null || n.instance.close());
  },
  unmounted(t) {
    var e;
    (e = t[Ec]) == null || e.instance.close();
  }
};
const Qi = (t, e) => {
  const n = t.__vccOpts || t;
  for (const [r, i] of e)
    n[r] = i;
  return n;
}, U3 = { id: "left" }, V3 = ["title"], W3 = { id: "right" }, K3 = {
  __name: "Titlebar",
  props: {
    backdrop: {
      default: !1,
      type: Boolean
    },
    title: {
      default: "Reader",
      type: String
    }
  },
  setup(t) {
    const e = t;
    let n = !1;
    const r = (s, o) => s.length > o ? `${s.substr(0, o - 3)}...` : s, i = () => {
      if (n)
        document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitCancelFullScreen ? document.webkitCancelFullScreen() : document.msExitFullscreen && document.msExitFullscreen(), n = !1;
      else {
        const s = document.documentElement, o = s.requestFullScreen || s.webkitRequestFullScreen || s.mozRequestFullScreen || s.msRequestFullscreen;
        typeof o < "u" && o && o.call(s), n = !0;
      }
    };
    return (s, o) => {
      const a = Yi, l = F4;
      return V(), Ae(l, {
        height: "40px",
        class: ee({ backdrop: e.backdrop })
      }, {
        default: de(() => [
          ae("span", U3, [
            Me(s.$slots, "default", {}, void 0, !0)
          ]),
          ae("span", {
            id: "center",
            title: e.title
          }, st(r(e.title, 15)), 9, V3),
          ae("span", W3, [
            ve(a, {
              size: "small",
              icon: x(lg),
              circle: "",
              onClick: i
            }, null, 8, ["icon"])
          ])
        ]),
        _: 3
      }, 8, ["class"]);
    };
  }
}, $m = /* @__PURE__ */ Qi(K3, [["__scopeId", "data-v-ea5e85e1"]]);
var xc = {}, $3 = {
  get exports() {
    return xc;
  },
  set exports(t) {
    xc = t;
  }
};
(function(t, e) {
  (function(n, r) {
    r();
  })(mn, function() {
    function n(u, c) {
      return typeof c > "u" ? c = { autoBom: !1 } : typeof c != "object" && (console.warn("Deprecated: Expected third argument to be a object"), c = { autoBom: !c }), c.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(u.type) ? new Blob(["\uFEFF", u], { type: u.type }) : u;
    }
    function r(u, c, d) {
      var h = new XMLHttpRequest();
      h.open("GET", u), h.responseType = "blob", h.onload = function() {
        l(h.response, c, d);
      }, h.onerror = function() {
        console.error("could not download file");
      }, h.send();
    }
    function i(u) {
      var c = new XMLHttpRequest();
      c.open("HEAD", u, !1);
      try {
        c.send();
      } catch {
      }
      return 200 <= c.status && 299 >= c.status;
    }
    function s(u) {
      try {
        u.dispatchEvent(new MouseEvent("click"));
      } catch {
        var c = document.createEvent("MouseEvents");
        c.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), u.dispatchEvent(c);
      }
    }
    var o = typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof mn == "object" && mn.global === mn ? mn : void 0, a = o.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), l = o.saveAs || (typeof window != "object" || window !== o ? function() {
    } : "download" in HTMLAnchorElement.prototype && !a ? function(u, c, d) {
      var h = o.URL || o.webkitURL, v = document.createElement("a");
      c = c || u.name || "download", v.download = c, v.rel = "noopener", typeof u == "string" ? (v.href = u, v.origin === location.origin ? s(v) : i(v.href) ? r(u, c, d) : s(v, v.target = "_blank")) : (v.href = h.createObjectURL(u), setTimeout(function() {
        h.revokeObjectURL(v.href);
      }, 4e4), setTimeout(function() {
        s(v);
      }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(u, c, d) {
      if (c = c || u.name || "download", typeof u != "string")
        navigator.msSaveOrOpenBlob(n(u, d), c);
      else if (i(u))
        r(u, c, d);
      else {
        var h = document.createElement("a");
        h.href = u, h.target = "_blank", setTimeout(function() {
          s(h);
        });
      }
    } : function(u, c, d, h) {
      if (h = h || open("", "_blank"), h && (h.document.title = h.document.body.innerText = "downloading..."), typeof u == "string")
        return r(u, c, d);
      var v = u.type === "application/octet-stream", y = /constructor/i.test(o.HTMLElement) || o.safari, b = /CriOS\/[\d]+/.test(navigator.userAgent);
      if ((b || v && y || a) && typeof FileReader < "u") {
        var p = new FileReader();
        p.onloadend = function() {
          var m = p.result;
          m = b ? m : m.replace(/^data:[^;]*;/, "data:attachment/file;"), h ? h.location.href = m : location = m, h = null;
        }, p.readAsDataURL(u);
      } else {
        var f = o.URL || o.webkitURL, g = f.createObjectURL(u);
        h ? h.location = g : location.href = g, h = null, setTimeout(function() {
          f.revokeObjectURL(g);
        }, 4e4);
      }
    });
    o.saveAs = l.saveAs = l, t.exports = l;
  });
})($3);
const G3 = xc, Ut = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, an = Object.keys, Tn = Array.isArray;
function Pn(t, e) {
  return typeof e != "object" || an(e).forEach(function(n) {
    t[n] = e[n];
  }), t;
}
typeof Promise > "u" || Ut.Promise || (Ut.Promise = Promise);
const No = Object.getPrototypeOf, q3 = {}.hasOwnProperty;
function Yn(t, e) {
  return q3.call(t, e);
}
function Bs(t, e) {
  typeof e == "function" && (e = e(No(t))), (typeof Reflect > "u" ? an : Reflect.ownKeys)(e).forEach((n) => {
    Gr(t, n, e[n]);
  });
}
const Gm = Object.defineProperty;
function Gr(t, e, n, r) {
  Gm(t, e, Pn(n && Yn(n, "get") && typeof n.get == "function" ? { get: n.get, set: n.set, configurable: !0 } : { value: n, configurable: !0, writable: !0 }, r));
}
function _s(t) {
  return { from: function(e) {
    return t.prototype = Object.create(e.prototype), Gr(t.prototype, "constructor", t), { extend: Bs.bind(null, t.prototype) };
  } };
}
const J3 = Object.getOwnPropertyDescriptor;
function ef(t, e) {
  let n;
  return J3(t, e) || (n = No(t)) && ef(n, e);
}
const Y3 = [].slice;
function fl(t, e, n) {
  return Y3.call(t, e, n);
}
function qm(t, e) {
  return e(t);
}
function ro(t) {
  if (!t)
    throw new Error("Assertion Failed");
}
function Jm(t) {
  Ut.setImmediate ? setImmediate(t) : setTimeout(t, 0);
}
function Ym(t, e) {
  return t.reduce((n, r, i) => {
    var s = e(r, i);
    return s && (n[s[0]] = s[1]), n;
  }, {});
}
function qr(t, e) {
  if (Yn(t, e))
    return t[e];
  if (!e)
    return t;
  if (typeof e != "string") {
    for (var n = [], r = 0, i = e.length; r < i; ++r) {
      var s = qr(t, e[r]);
      n.push(s);
    }
    return n;
  }
  var o = e.indexOf(".");
  if (o !== -1) {
    var a = t[e.substr(0, o)];
    return a === void 0 ? void 0 : qr(a, e.substr(o + 1));
  }
}
function vr(t, e, n) {
  if (t && e !== void 0 && (!("isFrozen" in Object) || !Object.isFrozen(t)))
    if (typeof e != "string" && "length" in e) {
      ro(typeof n != "string" && "length" in n);
      for (var r = 0, i = e.length; r < i; ++r)
        vr(t, e[r], n[r]);
    } else {
      var s = e.indexOf(".");
      if (s !== -1) {
        var o = e.substr(0, s), a = e.substr(s + 1);
        if (a === "")
          n === void 0 ? Tn(t) && !isNaN(parseInt(o)) ? t.splice(o, 1) : delete t[o] : t[o] = n;
        else {
          var l = t[o];
          l && Yn(t, o) || (l = t[o] = {}), vr(l, a, n);
        }
      } else
        n === void 0 ? Tn(t) && !isNaN(parseInt(e)) ? t.splice(e, 1) : delete t[e] : t[e] = n;
    }
}
function Qm(t) {
  var e = {};
  for (var n in t)
    Yn(t, n) && (e[n] = t[n]);
  return e;
}
const Q3 = [].concat;
function Zm(t) {
  return Q3.apply([], t);
}
const Xm = "Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(Zm([8, 16, 32, 64].map((t) => ["Int", "Uint", "Float"].map((e) => e + t + "Array")))).filter((t) => Ut[t]), Z3 = Xm.map((t) => Ut[t]);
Ym(Xm, (t) => [t, !0]);
let fi = null;
function na(t) {
  fi = typeof WeakMap < "u" && /* @__PURE__ */ new WeakMap();
  const e = Ac(t);
  return fi = null, e;
}
function Ac(t) {
  if (!t || typeof t != "object")
    return t;
  let e = fi && fi.get(t);
  if (e)
    return e;
  if (Tn(t)) {
    e = [], fi && fi.set(t, e);
    for (var n = 0, r = t.length; n < r; ++n)
      e.push(Ac(t[n]));
  } else if (Z3.indexOf(t.constructor) >= 0)
    e = t;
  else {
    const s = No(t);
    for (var i in e = s === Object.prototype ? {} : Object.create(s), fi && fi.set(t, e), t)
      Yn(t, i) && (e[i] = Ac(t[i]));
  }
  return e;
}
const { toString: X3 } = {};
function kc(t) {
  return X3.call(t).slice(8, -1);
}
const Cc = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", eB = typeof Cc == "symbol" ? function(t) {
  var e;
  return t != null && (e = t[Cc]) && e.apply(t);
} : function() {
  return null;
}, ps = {};
function Wr(t) {
  var e, n, r, i;
  if (arguments.length === 1) {
    if (Tn(t))
      return t.slice();
    if (this === ps && typeof t == "string")
      return [t];
    if (i = eB(t)) {
      for (n = []; !(r = i.next()).done; )
        n.push(r.value);
      return n;
    }
    if (t == null)
      return [t];
    if (typeof (e = t.length) == "number") {
      for (n = new Array(e); e--; )
        n[e] = t[e];
      return n;
    }
    return [t];
  }
  for (e = arguments.length, n = new Array(e); e--; )
    n[e] = arguments[e];
  return n;
}
const tf = typeof Symbol < "u" ? (t) => t[Symbol.toStringTag] === "AsyncFunction" : () => !1;
var Mr = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
function ey(t, e) {
  Mr = t, ty = e;
}
var ty = () => !0;
const tB = !new Error("").stack;
function Zi() {
  if (tB)
    try {
      throw Zi.arguments, new Error();
    } catch (t) {
      return t;
    }
  return new Error();
}
function Tc(t, e) {
  var n = t.stack;
  return n ? (e = e || 0, n.indexOf(t.name) === 0 && (e += (t.name + t.message).split(`
`).length), n.split(`
`).slice(e).filter(ty).map((r) => `
` + r).join("")) : "";
}
var ny = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], nf = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(ny), nB = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
function Ss(t, e) {
  this._e = Zi(), this.name = t, this.message = e;
}
function ry(t, e) {
  return t + ". Errors: " + Object.keys(e).map((n) => e[n].toString()).filter((n, r, i) => i.indexOf(n) === r).join(`
`);
}
function hl(t, e, n, r) {
  this._e = Zi(), this.failures = e, this.failedKeys = r, this.successCount = n, this.message = ry(t, e);
}
function ho(t, e) {
  this._e = Zi(), this.name = "BulkError", this.failures = Object.keys(e).map((n) => e[n]), this.failuresByPos = e, this.message = ry(t, e);
}
_s(Ss).from(Error).extend({ stack: { get: function() {
  return this._stack || (this._stack = this.name + ": " + this.message + Tc(this._e, 2));
} }, toString: function() {
  return this.name + ": " + this.message;
} }), _s(hl).from(Ss), _s(ho).from(Ss);
var rf = nf.reduce((t, e) => (t[e] = e + "Error", t), {});
const rB = Ss;
var Xe = nf.reduce((t, e) => {
  var n = e + "Error";
  function r(i, s) {
    this._e = Zi(), this.name = n, i ? typeof i == "string" ? (this.message = `${i}${s ? `
 ` + s : ""}`, this.inner = s || null) : typeof i == "object" && (this.message = `${i.name} ${i.message}`, this.inner = i) : (this.message = nB[e] || n, this.inner = null);
  }
  return _s(r).from(rB), t[e] = r, t;
}, {});
Xe.Syntax = SyntaxError, Xe.Type = TypeError, Xe.Range = RangeError;
var bp = ny.reduce((t, e) => (t[e + "Error"] = Xe[e], t), {}), Ka = nf.reduce((t, e) => (["Syntax", "Type", "Range"].indexOf(e) === -1 && (t[e + "Error"] = Xe[e]), t), {});
function Lt() {
}
function Ro(t) {
  return t;
}
function iB(t, e) {
  return t == null || t === Ro ? e : function(n) {
    return e(t(n));
  };
}
function Hi(t, e) {
  return function() {
    t.apply(this, arguments), e.apply(this, arguments);
  };
}
function sB(t, e) {
  return t === Lt ? e : function() {
    var n = t.apply(this, arguments);
    n !== void 0 && (arguments[0] = n);
    var r = this.onsuccess, i = this.onerror;
    this.onsuccess = null, this.onerror = null;
    var s = e.apply(this, arguments);
    return r && (this.onsuccess = this.onsuccess ? Hi(r, this.onsuccess) : r), i && (this.onerror = this.onerror ? Hi(i, this.onerror) : i), s !== void 0 ? s : n;
  };
}
function oB(t, e) {
  return t === Lt ? e : function() {
    t.apply(this, arguments);
    var n = this.onsuccess, r = this.onerror;
    this.onsuccess = this.onerror = null, e.apply(this, arguments), n && (this.onsuccess = this.onsuccess ? Hi(n, this.onsuccess) : n), r && (this.onerror = this.onerror ? Hi(r, this.onerror) : r);
  };
}
function aB(t, e) {
  return t === Lt ? e : function(n) {
    var r = t.apply(this, arguments);
    Pn(n, r);
    var i = this.onsuccess, s = this.onerror;
    this.onsuccess = null, this.onerror = null;
    var o = e.apply(this, arguments);
    return i && (this.onsuccess = this.onsuccess ? Hi(i, this.onsuccess) : i), s && (this.onerror = this.onerror ? Hi(s, this.onerror) : s), r === void 0 ? o === void 0 ? void 0 : o : Pn(r, o);
  };
}
function lB(t, e) {
  return t === Lt ? e : function() {
    return e.apply(this, arguments) !== !1 && t.apply(this, arguments);
  };
}
function sf(t, e) {
  return t === Lt ? e : function() {
    var n = t.apply(this, arguments);
    if (n && typeof n.then == "function") {
      for (var r = this, i = arguments.length, s = new Array(i); i--; )
        s[i] = arguments[i];
      return n.then(function() {
        return e.apply(r, s);
      });
    }
    return e.apply(this, arguments);
  };
}
Ka.ModifyError = hl, Ka.DexieError = Ss, Ka.BulkError = ho;
var Po = {};
const iy = 100, [Oc, pl, Ic] = typeof Promise > "u" ? [] : (() => {
  let t = Promise.resolve();
  if (typeof crypto > "u" || !crypto.subtle)
    return [t, No(t), t];
  const e = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
  return [e, No(e), t];
})(), sy = pl && pl.then, $a = Oc && Oc.constructor, of = !!Ic;
var Nc = !1, uB = Ic ? () => {
  Ic.then(xa);
} : Ut.setImmediate ? setImmediate.bind(null, xa) : Ut.MutationObserver ? () => {
  var t = document.createElement("div");
  new MutationObserver(() => {
    xa(), t = null;
  }).observe(t, { attributes: !0 }), t.setAttribute("i", "1");
} : () => {
  setTimeout(xa, 0);
}, po = function(t, e) {
  io.push([t, e]), vl && (uB(), vl = !1);
}, Rc = !0, vl = !0, Di = [], Ga = [], Pc = null, Bc = Ro, Es = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: Sp, pgp: !1, env: {}, finalize: function() {
  this.unhandleds.forEach((t) => {
    try {
      Sp(t[0], t[1]);
    } catch {
    }
  });
} }, $e = Es, io = [], Mi = 0, qa = [];
function ze(t) {
  if (typeof this != "object")
    throw new TypeError("Promises must be constructed via new");
  this._listeners = [], this.onuncatched = Lt, this._lib = !1;
  var e = this._PSD = $e;
  if (Mr && (this._stackHolder = Zi(), this._prev = null, this._numPrev = 0), typeof t != "function") {
    if (t !== Po)
      throw new TypeError("Not a function");
    return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && Mc(this, this._value));
  }
  this._state = null, this._value = null, ++e.ref, ay(this, t);
}
const Dc = { get: function() {
  var t = $e, e = gl;
  function n(r, i) {
    var s = !t.global && (t !== $e || e !== gl);
    const o = s && !Xr();
    var a = new ze((l, u) => {
      af(this, new oy(ml(r, t, s, o), ml(i, t, s, o), l, u, t));
    });
    return Mr && cy(a, this), a;
  }
  return n.prototype = Po, n;
}, set: function(t) {
  Gr(this, "then", t && t.prototype === Po ? Dc : { get: function() {
    return t;
  }, set: Dc.set });
} };
function oy(t, e, n, r, i) {
  this.onFulfilled = typeof t == "function" ? t : null, this.onRejected = typeof e == "function" ? e : null, this.resolve = n, this.reject = r, this.psd = i;
}
function ay(t, e) {
  try {
    e((n) => {
      if (t._state === null) {
        if (n === t)
          throw new TypeError("A promise cannot be resolved with itself.");
        var r = t._lib && ra();
        n && typeof n.then == "function" ? ay(t, (i, s) => {
          n instanceof ze ? n._then(i, s) : n.then(i, s);
        }) : (t._state = !0, t._value = n, ly(t)), r && ia();
      }
    }, Mc.bind(null, t));
  } catch (n) {
    Mc(t, n);
  }
}
function Mc(t, e) {
  if (Ga.push(e), t._state === null) {
    var n = t._lib && ra();
    e = Bc(e), t._state = !1, t._value = e, Mr && e !== null && typeof e == "object" && !e._promise && function(r, i, s) {
      try {
        r.apply(null, s);
      } catch (o) {
        i && i(o);
      }
    }(() => {
      var r = ef(e, "stack");
      e._promise = t, Gr(e, "stack", { get: () => Nc ? r && (r.get ? r.get.apply(e) : r.value) : t.stack });
    }), function(r) {
      Di.some((i) => i._value === r._value) || Di.push(r);
    }(t), ly(t), n && ia();
  }
}
function ly(t) {
  var e = t._listeners;
  t._listeners = [];
  for (var n = 0, r = e.length; n < r; ++n)
    af(t, e[n]);
  var i = t._PSD;
  --i.ref || i.finalize(), Mi === 0 && (++Mi, po(() => {
    --Mi == 0 && lf();
  }, []));
}
function af(t, e) {
  if (t._state !== null) {
    var n = t._state ? e.onFulfilled : e.onRejected;
    if (n === null)
      return (t._state ? e.resolve : e.reject)(t._value);
    ++e.psd.ref, ++Mi, po(cB, [n, t, e]);
  } else
    t._listeners.push(e);
}
function cB(t, e, n) {
  try {
    Pc = e;
    var r, i = e._value;
    e._state ? r = t(i) : (Ga.length && (Ga = []), r = t(i), Ga.indexOf(i) === -1 && function(s) {
      for (var o = Di.length; o; )
        if (Di[--o]._value === s._value)
          return void Di.splice(o, 1);
    }(e)), n.resolve(r);
  } catch (s) {
    n.reject(s);
  } finally {
    Pc = null, --Mi == 0 && lf(), --n.psd.ref || n.psd.finalize();
  }
}
function uy(t, e, n) {
  if (e.length === n)
    return e;
  var r = "";
  if (t._state === !1) {
    var i, s, o = t._value;
    o != null ? (i = o.name || "Error", s = o.message || o, r = Tc(o, 0)) : (i = o, s = ""), e.push(i + (s ? ": " + s : "") + r);
  }
  return Mr && ((r = Tc(t._stackHolder, 2)) && e.indexOf(r) === -1 && e.push(r), t._prev && uy(t._prev, e, n)), e;
}
function cy(t, e) {
  var n = e ? e._numPrev + 1 : 0;
  n < 100 && (t._prev = e, t._numPrev = n);
}
function xa() {
  ra() && ia();
}
function ra() {
  var t = Rc;
  return Rc = !1, vl = !1, t;
}
function ia() {
  var t, e, n;
  do
    for (; io.length > 0; )
      for (t = io, io = [], n = t.length, e = 0; e < n; ++e) {
        var r = t[e];
        r[0].apply(null, r[1]);
      }
  while (io.length > 0);
  Rc = !0, vl = !0;
}
function lf() {
  var t = Di;
  Di = [], t.forEach((r) => {
    r._PSD.onunhandled.call(null, r._value, r);
  });
  for (var e = qa.slice(0), n = e.length; n; )
    e[--n]();
}
function Aa(t) {
  return new ze(Po, !1, t);
}
function Kt(t, e) {
  var n = $e;
  return function() {
    var r = ra(), i = $e;
    try {
      return _i(n, !0), t.apply(this, arguments);
    } catch (s) {
      e && e(s);
    } finally {
      _i(i, !1), r && ia();
    }
  };
}
Bs(ze.prototype, { then: Dc, _then: function(t, e) {
  af(this, new oy(null, null, t, e, $e));
}, catch: function(t) {
  if (arguments.length === 1)
    return this.then(null, t);
  var e = arguments[0], n = arguments[1];
  return typeof e == "function" ? this.then(null, (r) => r instanceof e ? n(r) : Aa(r)) : this.then(null, (r) => r && r.name === e ? n(r) : Aa(r));
}, finally: function(t) {
  return this.then((e) => (t(), e), (e) => (t(), Aa(e)));
}, stack: { get: function() {
  if (this._stack)
    return this._stack;
  try {
    Nc = !0;
    var t = uy(this, [], 20).join(`
From previous: `);
    return this._state !== null && (this._stack = t), t;
  } finally {
    Nc = !1;
  }
} }, timeout: function(t, e) {
  return t < 1 / 0 ? new ze((n, r) => {
    var i = setTimeout(() => r(new Xe.Timeout(e)), t);
    this.then(n, r).finally(clearTimeout.bind(null, i));
  }) : this;
} }), typeof Symbol < "u" && Symbol.toStringTag && Gr(ze.prototype, Symbol.toStringTag, "Dexie.Promise"), Es.env = dy(), Bs(ze, { all: function() {
  var t = Wr.apply(null, arguments).map(ka);
  return new ze(function(e, n) {
    t.length === 0 && e([]);
    var r = t.length;
    t.forEach((i, s) => ze.resolve(i).then((o) => {
      t[s] = o, --r || e(t);
    }, n));
  });
}, resolve: (t) => {
  if (t instanceof ze)
    return t;
  if (t && typeof t.then == "function")
    return new ze((n, r) => {
      t.then(n, r);
    });
  var e = new ze(Po, !0, t);
  return cy(e, Pc), e;
}, reject: Aa, race: function() {
  var t = Wr.apply(null, arguments).map(ka);
  return new ze((e, n) => {
    t.map((r) => ze.resolve(r).then(e, n));
  });
}, PSD: { get: () => $e, set: (t) => $e = t }, totalEchoes: { get: () => gl }, newPSD: wi, usePSD: Vs, scheduler: { get: () => po, set: (t) => {
  po = t;
} }, rejectionMapper: { get: () => Bc, set: (t) => {
  Bc = t;
} }, follow: (t, e) => new ze((n, r) => wi((i, s) => {
  var o = $e;
  o.unhandleds = [], o.onunhandled = s, o.finalize = Hi(function() {
    (function(a) {
      function l() {
        a(), qa.splice(qa.indexOf(l), 1);
      }
      qa.push(l), ++Mi, po(() => {
        --Mi == 0 && lf();
      }, []);
    })(() => {
      this.unhandleds.length === 0 ? i() : s(this.unhandleds[0]);
    });
  }, o.finalize), t();
}, e, n, r)) }), $a && ($a.allSettled && Gr(ze, "allSettled", function() {
  const t = Wr.apply(null, arguments).map(ka);
  return new ze((e) => {
    t.length === 0 && e([]);
    let n = t.length;
    const r = new Array(n);
    t.forEach((i, s) => ze.resolve(i).then((o) => r[s] = { status: "fulfilled", value: o }, (o) => r[s] = { status: "rejected", reason: o }).then(() => --n || e(r)));
  });
}), $a.any && typeof AggregateError < "u" && Gr(ze, "any", function() {
  const t = Wr.apply(null, arguments).map(ka);
  return new ze((e, n) => {
    t.length === 0 && n(new AggregateError([]));
    let r = t.length;
    const i = new Array(r);
    t.forEach((s, o) => ze.resolve(s).then((a) => e(a), (a) => {
      i[o] = a, --r || n(new AggregateError(i));
    }));
  });
}));
const kn = { awaits: 0, echoes: 0, id: 0 };
var dB = 0, Ja = [], Tu = 0, gl = 0, fB = 0;
function wi(t, e, n, r) {
  var i = $e, s = Object.create(i);
  s.parent = i, s.ref = 0, s.global = !1, s.id = ++fB;
  var o = Es.env;
  s.env = of ? { Promise: ze, PromiseProp: { value: ze, configurable: !0, writable: !0 }, all: ze.all, race: ze.race, allSettled: ze.allSettled, any: ze.any, resolve: ze.resolve, reject: ze.reject, nthen: wp(o.nthen, s), gthen: wp(o.gthen, s) } : {}, e && Pn(s, e), ++i.ref, s.finalize = function() {
    --this.parent.ref || this.parent.finalize();
  };
  var a = Vs(s, t, n, r);
  return s.ref === 0 && s.finalize(), a;
}
function Us() {
  return kn.id || (kn.id = ++dB), ++kn.awaits, kn.echoes += iy, kn.id;
}
function Xr() {
  return !!kn.awaits && (--kn.awaits == 0 && (kn.id = 0), kn.echoes = kn.awaits * iy, !0);
}
function ka(t) {
  return kn.echoes && t && t.constructor === $a ? (Us(), t.then((e) => (Xr(), e), (e) => (Xr(), dn(e)))) : t;
}
function hB(t) {
  ++gl, kn.echoes && --kn.echoes != 0 || (kn.echoes = kn.id = 0), Ja.push($e), _i(t, !0);
}
function pB() {
  var t = Ja[Ja.length - 1];
  Ja.pop(), _i(t, !1);
}
function _i(t, e) {
  var n = $e;
  if ((e ? !kn.echoes || Tu++ && t === $e : !Tu || --Tu && t === $e) || fy(e ? hB.bind(null, t) : pB), t !== $e && ($e = t, n === Es && (Es.env = dy()), of)) {
    var r = Es.env.Promise, i = t.env;
    pl.then = i.nthen, r.prototype.then = i.gthen, (n.global || t.global) && (Object.defineProperty(Ut, "Promise", i.PromiseProp), r.all = i.all, r.race = i.race, r.resolve = i.resolve, r.reject = i.reject, i.allSettled && (r.allSettled = i.allSettled), i.any && (r.any = i.any));
  }
}
function dy() {
  var t = Ut.Promise;
  return of ? { Promise: t, PromiseProp: Object.getOwnPropertyDescriptor(Ut, "Promise"), all: t.all, race: t.race, allSettled: t.allSettled, any: t.any, resolve: t.resolve, reject: t.reject, nthen: pl.then, gthen: t.prototype.then } : {};
}
function Vs(t, e, n, r, i) {
  var s = $e;
  try {
    return _i(t, !0), e(n, r, i);
  } finally {
    _i(s, !1);
  }
}
function fy(t) {
  sy.call(Oc, t);
}
function ml(t, e, n, r) {
  return typeof t != "function" ? t : function() {
    var i = $e;
    n && Us(), _i(e, !0);
    try {
      return t.apply(this, arguments);
    } finally {
      _i(i, !1), r && fy(Xr);
    }
  };
}
function wp(t, e) {
  return function(n, r) {
    return t.call(this, ml(n, e), ml(r, e));
  };
}
("" + sy).indexOf("[native code]") === -1 && (Us = Xr = Lt);
const _p = "unhandledrejection";
function Sp(t, e) {
  var n;
  try {
    n = e.onuncatched(t);
  } catch {
  }
  if (n !== !1)
    try {
      var r, i = { promise: e, reason: t };
      if (Ut.document && document.createEvent ? ((r = document.createEvent("Event")).initEvent(_p, !0, !0), Pn(r, i)) : Ut.CustomEvent && Pn(r = new CustomEvent(_p, { detail: i }), i), r && Ut.dispatchEvent && (dispatchEvent(r), !Ut.PromiseRejectionEvent && Ut.onunhandledrejection))
        try {
          Ut.onunhandledrejection(r);
        } catch {
        }
      Mr && r && !r.defaultPrevented && console.warn(`Unhandled rejection: ${t.stack || t}`);
    } catch {
    }
}
var dn = ze.reject;
function Lc(t, e, n, r) {
  if (t.idbdb && (t._state.openComplete || $e.letThrough || t._vip)) {
    var i = t._createTransaction(e, n, t._dbSchema);
    try {
      i.create(), t._state.PR1398_maxLoop = 3;
    } catch (s) {
      return s.name === rf.InvalidState && t.isOpen() && --t._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), t._close(), t.open().then(() => Lc(t, e, n, r))) : dn(s);
    }
    return i._promise(e, (s, o) => wi(() => ($e.trans = i, r(s, o, i)))).then((s) => i._completion.then(() => s));
  }
  if (t._state.openComplete)
    return dn(new Xe.DatabaseClosed(t._state.dbOpenError));
  if (!t._state.isBeingOpened) {
    if (!t._options.autoOpen)
      return dn(new Xe.DatabaseClosed());
    t.open().catch(Lt);
  }
  return t._state.dbReadyPromise.then(() => Lc(t, e, n, r));
}
const Ep = "3.2.4", Ri = String.fromCharCode(65535), zc = -1 / 0, jr = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", hy = "String expected.", vo = [], Xl = typeof navigator < "u" && /(MSIE|Trident|Edge)/.test(navigator.userAgent), vB = Xl, gB = Xl, py = (t) => !/(dexie\.js|dexie\.min\.js)/.test(t), eu = "__dbnames", Ou = "readonly", Iu = "readwrite";
function Ui(t, e) {
  return t ? e ? function() {
    return t.apply(this, arguments) && e.apply(this, arguments);
  } : t : e;
}
const vy = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
function Ca(t) {
  return typeof t != "string" || /\./.test(t) ? (e) => e : (e) => (e[t] === void 0 && t in e && delete (e = na(e))[t], e);
}
class mB {
  _trans(e, n, r) {
    const i = this._tx || $e.trans, s = this.name;
    function o(l, u, c) {
      if (!c.schema[s])
        throw new Xe.NotFound("Table " + s + " not part of transaction");
      return n(c.idbtrans, c);
    }
    const a = ra();
    try {
      return i && i.db === this.db ? i === $e.trans ? i._promise(e, o, r) : wi(() => i._promise(e, o, r), { trans: i, transless: $e.transless || $e }) : Lc(this.db, e, [this.name], o);
    } finally {
      a && ia();
    }
  }
  get(e, n) {
    return e && e.constructor === Object ? this.where(e).first(n) : this._trans("readonly", (r) => this.core.get({ trans: r, key: e }).then((i) => this.hook.reading.fire(i))).then(n);
  }
  where(e) {
    if (typeof e == "string")
      return new this.db.WhereClause(this, e);
    if (Tn(e))
      return new this.db.WhereClause(this, `[${e.join("+")}]`);
    const n = an(e);
    if (n.length === 1)
      return this.where(n[0]).equals(e[n[0]]);
    const r = this.schema.indexes.concat(this.schema.primKey).filter((u) => u.compound && n.every((c) => u.keyPath.indexOf(c) >= 0) && u.keyPath.every((c) => n.indexOf(c) >= 0))[0];
    if (r && this.db._maxKey !== Ri)
      return this.where(r.name).equals(r.keyPath.map((u) => e[u]));
    !r && Mr && console.warn(`The query ${JSON.stringify(e)} on ${this.name} would benefit of a compound index [${n.join("+")}]`);
    const { idxByName: i } = this.schema, s = this.db._deps.indexedDB;
    function o(u, c) {
      try {
        return s.cmp(u, c) === 0;
      } catch {
        return !1;
      }
    }
    const [a, l] = n.reduce(([u, c], d) => {
      const h = i[d], v = e[d];
      return [u || h, u || !h ? Ui(c, h && h.multi ? (y) => {
        const b = qr(y, d);
        return Tn(b) && b.some((p) => o(v, p));
      } : (y) => o(v, qr(y, d))) : c];
    }, [null, null]);
    return a ? this.where(a.name).equals(e[a.keyPath]).filter(l) : r ? this.filter(l) : this.where(n).equals("");
  }
  filter(e) {
    return this.toCollection().and(e);
  }
  count(e) {
    return this.toCollection().count(e);
  }
  offset(e) {
    return this.toCollection().offset(e);
  }
  limit(e) {
    return this.toCollection().limit(e);
  }
  each(e) {
    return this.toCollection().each(e);
  }
  toArray(e) {
    return this.toCollection().toArray(e);
  }
  toCollection() {
    return new this.db.Collection(new this.db.WhereClause(this));
  }
  orderBy(e) {
    return new this.db.Collection(new this.db.WhereClause(this, Tn(e) ? `[${e.join("+")}]` : e));
  }
  reverse() {
    return this.toCollection().reverse();
  }
  mapToClass(e) {
    this.schema.mappedClass = e;
    const n = (r) => {
      if (!r)
        return r;
      const i = Object.create(e.prototype);
      for (var s in r)
        if (Yn(r, s))
          try {
            i[s] = r[s];
          } catch {
          }
      return i;
    };
    return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = n, this.hook("reading", n), e;
  }
  defineClass() {
    return this.mapToClass(function(e) {
      Pn(this, e);
    });
  }
  add(e, n) {
    const { auto: r, keyPath: i } = this.schema.primKey;
    let s = e;
    return i && r && (s = Ca(i)(e)), this._trans("readwrite", (o) => this.core.mutate({ trans: o, type: "add", keys: n != null ? [n] : null, values: [s] })).then((o) => o.numFailures ? ze.reject(o.failures[0]) : o.lastResult).then((o) => {
      if (i)
        try {
          vr(e, i, o);
        } catch {
        }
      return o;
    });
  }
  update(e, n) {
    if (typeof e != "object" || Tn(e))
      return this.where(":id").equals(e).modify(n);
    {
      const r = qr(e, this.schema.primKey.keyPath);
      if (r === void 0)
        return dn(new Xe.InvalidArgument("Given object does not contain its primary key"));
      try {
        typeof n != "function" ? an(n).forEach((i) => {
          vr(e, i, n[i]);
        }) : n(e, { value: e, primKey: r });
      } catch {
      }
      return this.where(":id").equals(r).modify(n);
    }
  }
  put(e, n) {
    const { auto: r, keyPath: i } = this.schema.primKey;
    let s = e;
    return i && r && (s = Ca(i)(e)), this._trans("readwrite", (o) => this.core.mutate({ trans: o, type: "put", values: [s], keys: n != null ? [n] : null })).then((o) => o.numFailures ? ze.reject(o.failures[0]) : o.lastResult).then((o) => {
      if (i)
        try {
          vr(e, i, o);
        } catch {
        }
      return o;
    });
  }
  delete(e) {
    return this._trans("readwrite", (n) => this.core.mutate({ trans: n, type: "delete", keys: [e] })).then((n) => n.numFailures ? ze.reject(n.failures[0]) : void 0);
  }
  clear() {
    return this._trans("readwrite", (e) => this.core.mutate({ trans: e, type: "deleteRange", range: vy })).then((e) => e.numFailures ? ze.reject(e.failures[0]) : void 0);
  }
  bulkGet(e) {
    return this._trans("readonly", (n) => this.core.getMany({ keys: e, trans: n }).then((r) => r.map((i) => this.hook.reading.fire(i))));
  }
  bulkAdd(e, n, r) {
    const i = Array.isArray(n) ? n : void 0, s = (r = r || (i ? void 0 : n)) ? r.allKeys : void 0;
    return this._trans("readwrite", (o) => {
      const { auto: a, keyPath: l } = this.schema.primKey;
      if (l && i)
        throw new Xe.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
      if (i && i.length !== e.length)
        throw new Xe.InvalidArgument("Arguments objects and keys must have the same length");
      const u = e.length;
      let c = l && a ? e.map(Ca(l)) : e;
      return this.core.mutate({ trans: o, type: "add", keys: i, values: c, wantResults: s }).then(({ numFailures: d, results: h, lastResult: v, failures: y }) => {
        if (d === 0)
          return s ? h : v;
        throw new ho(`${this.name}.bulkAdd(): ${d} of ${u} operations failed`, y);
      });
    });
  }
  bulkPut(e, n, r) {
    const i = Array.isArray(n) ? n : void 0, s = (r = r || (i ? void 0 : n)) ? r.allKeys : void 0;
    return this._trans("readwrite", (o) => {
      const { auto: a, keyPath: l } = this.schema.primKey;
      if (l && i)
        throw new Xe.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
      if (i && i.length !== e.length)
        throw new Xe.InvalidArgument("Arguments objects and keys must have the same length");
      const u = e.length;
      let c = l && a ? e.map(Ca(l)) : e;
      return this.core.mutate({ trans: o, type: "put", keys: i, values: c, wantResults: s }).then(({ numFailures: d, results: h, lastResult: v, failures: y }) => {
        if (d === 0)
          return s ? h : v;
        throw new ho(`${this.name}.bulkPut(): ${d} of ${u} operations failed`, y);
      });
    });
  }
  bulkDelete(e) {
    const n = e.length;
    return this._trans("readwrite", (r) => this.core.mutate({ trans: r, type: "delete", keys: e })).then(({ numFailures: r, lastResult: i, failures: s }) => {
      if (r === 0)
        return i;
      throw new ho(`${this.name}.bulkDelete(): ${r} of ${n} operations failed`, s);
    });
  }
}
function go(t) {
  var e = {}, n = function(o, a) {
    if (a) {
      for (var l = arguments.length, u = new Array(l - 1); --l; )
        u[l - 1] = arguments[l];
      return e[o].subscribe.apply(null, u), t;
    }
    if (typeof o == "string")
      return e[o];
  };
  n.addEventType = s;
  for (var r = 1, i = arguments.length; r < i; ++r)
    s(arguments[r]);
  return n;
  function s(o, a, l) {
    if (typeof o != "object") {
      var u;
      a || (a = lB), l || (l = Lt);
      var c = { subscribers: [], fire: l, subscribe: function(d) {
        c.subscribers.indexOf(d) === -1 && (c.subscribers.push(d), c.fire = a(c.fire, d));
      }, unsubscribe: function(d) {
        c.subscribers = c.subscribers.filter(function(h) {
          return h !== d;
        }), c.fire = c.subscribers.reduce(a, l);
      } };
      return e[o] = n[o] = c, c;
    }
    an(u = o).forEach(function(d) {
      var h = u[d];
      if (Tn(h))
        s(d, u[d][0], u[d][1]);
      else {
        if (h !== "asap")
          throw new Xe.InvalidArgument("Invalid event config");
        var v = s(d, Ro, function() {
          for (var y = arguments.length, b = new Array(y); y--; )
            b[y] = arguments[y];
          v.subscribers.forEach(function(p) {
            Jm(function() {
              p.apply(null, b);
            });
          });
        });
      }
    });
  }
}
function Qs(t, e) {
  return _s(e).from({ prototype: t }), e;
}
function is(t, e) {
  return !(t.filter || t.algorithm || t.or) && (e ? t.justLimit : !t.replayFilter);
}
function Nu(t, e) {
  t.filter = Ui(t.filter, e);
}
function Ru(t, e, n) {
  var r = t.replayFilter;
  t.replayFilter = r ? () => Ui(r(), e()) : e, t.justLimit = n && !r;
}
function Ya(t, e) {
  if (t.isPrimKey)
    return e.primaryKey;
  const n = e.getIndexByKeyPath(t.index);
  if (!n)
    throw new Xe.Schema("KeyPath " + t.index + " on object store " + e.name + " is not indexed");
  return n;
}
function xp(t, e, n) {
  const r = Ya(t, e.schema);
  return e.openCursor({ trans: n, values: !t.keysOnly, reverse: t.dir === "prev", unique: !!t.unique, query: { index: r, range: t.range } });
}
function Ta(t, e, n, r) {
  const i = t.replayFilter ? Ui(t.filter, t.replayFilter()) : t.filter;
  if (t.or) {
    const s = {}, o = (a, l, u) => {
      if (!i || i(l, u, (h) => l.stop(h), (h) => l.fail(h))) {
        var c = l.primaryKey, d = "" + c;
        d === "[object ArrayBuffer]" && (d = "" + new Uint8Array(c)), Yn(s, d) || (s[d] = !0, e(a, l, u));
      }
    };
    return Promise.all([t.or._iterate(o, n), Ap(xp(t, r, n), t.algorithm, o, !t.keysOnly && t.valueMapper)]);
  }
  return Ap(xp(t, r, n), Ui(t.algorithm, i), e, !t.keysOnly && t.valueMapper);
}
function Ap(t, e, n, r) {
  var i = Kt(r ? (s, o, a) => n(r(s), o, a) : n);
  return t.then((s) => {
    if (s)
      return s.start(() => {
        var o = () => s.continue();
        e && !e(s, (a) => o = a, (a) => {
          s.stop(a), o = Lt;
        }, (a) => {
          s.fail(a), o = Lt;
        }) || i(s.value, s, (a) => o = a), o();
      });
  });
}
function In(t, e) {
  try {
    const n = kp(t), r = kp(e);
    if (n !== r)
      return n === "Array" ? 1 : r === "Array" ? -1 : n === "binary" ? 1 : r === "binary" ? -1 : n === "string" ? 1 : r === "string" ? -1 : n === "Date" ? 1 : r !== "Date" ? NaN : -1;
    switch (n) {
      case "number":
      case "Date":
      case "string":
        return t > e ? 1 : t < e ? -1 : 0;
      case "binary":
        return function(i, s) {
          const o = i.length, a = s.length, l = o < a ? o : a;
          for (let u = 0; u < l; ++u)
            if (i[u] !== s[u])
              return i[u] < s[u] ? -1 : 1;
          return o === a ? 0 : o < a ? -1 : 1;
        }(Cp(t), Cp(e));
      case "Array":
        return function(i, s) {
          const o = i.length, a = s.length, l = o < a ? o : a;
          for (let u = 0; u < l; ++u) {
            const c = In(i[u], s[u]);
            if (c !== 0)
              return c;
          }
          return o === a ? 0 : o < a ? -1 : 1;
        }(t, e);
    }
  } catch {
  }
  return NaN;
}
function kp(t) {
  const e = typeof t;
  if (e !== "object")
    return e;
  if (ArrayBuffer.isView(t))
    return "binary";
  const n = kc(t);
  return n === "ArrayBuffer" ? "binary" : n;
}
function Cp(t) {
  return t instanceof Uint8Array ? t : ArrayBuffer.isView(t) ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : new Uint8Array(t);
}
class yB {
  _read(e, n) {
    var r = this._ctx;
    return r.error ? r.table._trans(null, dn.bind(null, r.error)) : r.table._trans("readonly", e).then(n);
  }
  _write(e) {
    var n = this._ctx;
    return n.error ? n.table._trans(null, dn.bind(null, n.error)) : n.table._trans("readwrite", e, "locked");
  }
  _addAlgorithm(e) {
    var n = this._ctx;
    n.algorithm = Ui(n.algorithm, e);
  }
  _iterate(e, n) {
    return Ta(this._ctx, e, n, this._ctx.table.core);
  }
  clone(e) {
    var n = Object.create(this.constructor.prototype), r = Object.create(this._ctx);
    return e && Pn(r, e), n._ctx = r, n;
  }
  raw() {
    return this._ctx.valueMapper = null, this;
  }
  each(e) {
    var n = this._ctx;
    return this._read((r) => Ta(n, e, r, n.table.core));
  }
  count(e) {
    return this._read((n) => {
      const r = this._ctx, i = r.table.core;
      if (is(r, !0))
        return i.count({ trans: n, query: { index: Ya(r, i.schema), range: r.range } }).then((o) => Math.min(o, r.limit));
      var s = 0;
      return Ta(r, () => (++s, !1), n, i).then(() => s);
    }).then(e);
  }
  sortBy(e, n) {
    const r = e.split(".").reverse(), i = r[0], s = r.length - 1;
    function o(u, c) {
      return c ? o(u[r[c]], c - 1) : u[i];
    }
    var a = this._ctx.dir === "next" ? 1 : -1;
    function l(u, c) {
      var d = o(u, s), h = o(c, s);
      return d < h ? -a : d > h ? a : 0;
    }
    return this.toArray(function(u) {
      return u.sort(l);
    }).then(n);
  }
  toArray(e) {
    return this._read((n) => {
      var r = this._ctx;
      if (r.dir === "next" && is(r, !0) && r.limit > 0) {
        const { valueMapper: i } = r, s = Ya(r, r.table.core.schema);
        return r.table.core.query({ trans: n, limit: r.limit, values: !0, query: { index: s, range: r.range } }).then(({ result: o }) => i ? o.map(i) : o);
      }
      {
        const i = [];
        return Ta(r, (s) => i.push(s), n, r.table.core).then(() => i);
      }
    }, e);
  }
  offset(e) {
    var n = this._ctx;
    return e <= 0 || (n.offset += e, is(n) ? Ru(n, () => {
      var r = e;
      return (i, s) => r === 0 || (r === 1 ? (--r, !1) : (s(() => {
        i.advance(r), r = 0;
      }), !1));
    }) : Ru(n, () => {
      var r = e;
      return () => --r < 0;
    })), this;
  }
  limit(e) {
    return this._ctx.limit = Math.min(this._ctx.limit, e), Ru(this._ctx, () => {
      var n = e;
      return function(r, i, s) {
        return --n <= 0 && i(s), n >= 0;
      };
    }, !0), this;
  }
  until(e, n) {
    return Nu(this._ctx, function(r, i, s) {
      return !e(r.value) || (i(s), n);
    }), this;
  }
  first(e) {
    return this.limit(1).toArray(function(n) {
      return n[0];
    }).then(e);
  }
  last(e) {
    return this.reverse().first(e);
  }
  filter(e) {
    var n, r;
    return Nu(this._ctx, function(i) {
      return e(i.value);
    }), n = this._ctx, r = e, n.isMatch = Ui(n.isMatch, r), this;
  }
  and(e) {
    return this.filter(e);
  }
  or(e) {
    return new this.db.WhereClause(this._ctx.table, e, this);
  }
  reverse() {
    return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
  }
  desc() {
    return this.reverse();
  }
  eachKey(e) {
    var n = this._ctx;
    return n.keysOnly = !n.isMatch, this.each(function(r, i) {
      e(i.key, i);
    });
  }
  eachUniqueKey(e) {
    return this._ctx.unique = "unique", this.eachKey(e);
  }
  eachPrimaryKey(e) {
    var n = this._ctx;
    return n.keysOnly = !n.isMatch, this.each(function(r, i) {
      e(i.primaryKey, i);
    });
  }
  keys(e) {
    var n = this._ctx;
    n.keysOnly = !n.isMatch;
    var r = [];
    return this.each(function(i, s) {
      r.push(s.key);
    }).then(function() {
      return r;
    }).then(e);
  }
  primaryKeys(e) {
    var n = this._ctx;
    if (n.dir === "next" && is(n, !0) && n.limit > 0)
      return this._read((i) => {
        var s = Ya(n, n.table.core.schema);
        return n.table.core.query({ trans: i, values: !1, limit: n.limit, query: { index: s, range: n.range } });
      }).then(({ result: i }) => i).then(e);
    n.keysOnly = !n.isMatch;
    var r = [];
    return this.each(function(i, s) {
      r.push(s.primaryKey);
    }).then(function() {
      return r;
    }).then(e);
  }
  uniqueKeys(e) {
    return this._ctx.unique = "unique", this.keys(e);
  }
  firstKey(e) {
    return this.limit(1).keys(function(n) {
      return n[0];
    }).then(e);
  }
  lastKey(e) {
    return this.reverse().firstKey(e);
  }
  distinct() {
    var e = this._ctx, n = e.index && e.table.schema.idxByName[e.index];
    if (!n || !n.multi)
      return this;
    var r = {};
    return Nu(this._ctx, function(i) {
      var s = i.primaryKey.toString(), o = Yn(r, s);
      return r[s] = !0, !o;
    }), this;
  }
  modify(e) {
    var n = this._ctx;
    return this._write((r) => {
      var i;
      if (typeof e == "function")
        i = e;
      else {
        var s = an(e), o = s.length;
        i = function(b) {
          for (var p = !1, f = 0; f < o; ++f) {
            var g = s[f], m = e[g];
            qr(b, g) !== m && (vr(b, g, m), p = !0);
          }
          return p;
        };
      }
      const a = n.table.core, { outbound: l, extractKey: u } = a.schema.primaryKey, c = this.db._options.modifyChunkSize || 200, d = [];
      let h = 0;
      const v = [], y = (b, p) => {
        const { failures: f, numFailures: g } = p;
        h += b - g;
        for (let m of an(f))
          d.push(f[m]);
      };
      return this.clone().primaryKeys().then((b) => {
        const p = (f) => {
          const g = Math.min(c, b.length - f);
          return a.getMany({ trans: r, keys: b.slice(f, f + g), cache: "immutable" }).then((m) => {
            const w = [], _ = [], S = l ? [] : null, A = [];
            for (let k = 0; k < g; ++k) {
              const O = m[k], N = { value: na(O), primKey: b[f + k] };
              i.call(N, N.value, N) !== !1 && (N.value == null ? A.push(b[f + k]) : l || In(u(O), u(N.value)) === 0 ? (_.push(N.value), l && S.push(b[f + k])) : (A.push(b[f + k]), w.push(N.value)));
            }
            const C = is(n) && n.limit === 1 / 0 && (typeof e != "function" || e === Pu) && { index: n.index, range: n.range };
            return Promise.resolve(w.length > 0 && a.mutate({ trans: r, type: "add", values: w }).then((k) => {
              for (let O in k.failures)
                A.splice(parseInt(O), 1);
              y(w.length, k);
            })).then(() => (_.length > 0 || C && typeof e == "object") && a.mutate({ trans: r, type: "put", keys: S, values: _, criteria: C, changeSpec: typeof e != "function" && e }).then((k) => y(_.length, k))).then(() => (A.length > 0 || C && e === Pu) && a.mutate({ trans: r, type: "delete", keys: A, criteria: C }).then((k) => y(A.length, k))).then(() => b.length > f + g && p(f + c));
          });
        };
        return p(0).then(() => {
          if (d.length > 0)
            throw new hl("Error modifying one or more objects", d, h, v);
          return b.length;
        });
      });
    });
  }
  delete() {
    var e = this._ctx, n = e.range;
    return is(e) && (e.isPrimKey && !gB || n.type === 3) ? this._write((r) => {
      const { primaryKey: i } = e.table.core.schema, s = n;
      return e.table.core.count({ trans: r, query: { index: i, range: s } }).then((o) => e.table.core.mutate({ trans: r, type: "deleteRange", range: s }).then(({ failures: a, lastResult: l, results: u, numFailures: c }) => {
        if (c)
          throw new hl("Could not delete some values", Object.keys(a).map((d) => a[d]), o - c);
        return o - c;
      }));
    }) : this.modify(Pu);
  }
}
const Pu = (t, e) => e.value = null;
function bB(t, e) {
  return t < e ? -1 : t === e ? 0 : 1;
}
function wB(t, e) {
  return t > e ? -1 : t === e ? 0 : 1;
}
function Kn(t, e, n) {
  var r = t instanceof my ? new t.Collection(t) : t;
  return r._ctx.error = n ? new n(e) : new TypeError(e), r;
}
function ss(t) {
  return new t.Collection(t, () => gy("")).limit(0);
}
function _B(t, e, n, r, i, s) {
  for (var o = Math.min(t.length, r.length), a = -1, l = 0; l < o; ++l) {
    var u = e[l];
    if (u !== r[l])
      return i(t[l], n[l]) < 0 ? t.substr(0, l) + n[l] + n.substr(l + 1) : i(t[l], r[l]) < 0 ? t.substr(0, l) + r[l] + n.substr(l + 1) : a >= 0 ? t.substr(0, a) + e[a] + n.substr(a + 1) : null;
    i(t[l], u) < 0 && (a = l);
  }
  return o < r.length && s === "next" ? t + n.substr(t.length) : o < t.length && s === "prev" ? t.substr(0, n.length) : a < 0 ? null : t.substr(0, a) + r[a] + n.substr(a + 1);
}
function Oa(t, e, n, r) {
  var i, s, o, a, l, u, c, d = n.length;
  if (!n.every((b) => typeof b == "string"))
    return Kn(t, hy);
  function h(b) {
    i = function(f) {
      return f === "next" ? (g) => g.toUpperCase() : (g) => g.toLowerCase();
    }(b), s = function(f) {
      return f === "next" ? (g) => g.toLowerCase() : (g) => g.toUpperCase();
    }(b), o = b === "next" ? bB : wB;
    var p = n.map(function(f) {
      return { lower: s(f), upper: i(f) };
    }).sort(function(f, g) {
      return o(f.lower, g.lower);
    });
    a = p.map(function(f) {
      return f.upper;
    }), l = p.map(function(f) {
      return f.lower;
    }), u = b, c = b === "next" ? "" : r;
  }
  h("next");
  var v = new t.Collection(t, () => di(a[0], l[d - 1] + r));
  v._ondirectionchange = function(b) {
    h(b);
  };
  var y = 0;
  return v._addAlgorithm(function(b, p, f) {
    var g = b.key;
    if (typeof g != "string")
      return !1;
    var m = s(g);
    if (e(m, l, y))
      return !0;
    for (var w = null, _ = y; _ < d; ++_) {
      var S = _B(g, m, a[_], l[_], o, u);
      S === null && w === null ? y = _ + 1 : (w === null || o(w, S) > 0) && (w = S);
    }
    return p(w !== null ? function() {
      b.continue(w + c);
    } : f), !1;
  }), v;
}
function di(t, e, n, r) {
  return { type: 2, lower: t, upper: e, lowerOpen: n, upperOpen: r };
}
function gy(t) {
  return { type: 1, lower: t, upper: t };
}
class my {
  get Collection() {
    return this._ctx.table.db.Collection;
  }
  between(e, n, r, i) {
    r = r !== !1, i = i === !0;
    try {
      return this._cmp(e, n) > 0 || this._cmp(e, n) === 0 && (r || i) && (!r || !i) ? ss(this) : new this.Collection(this, () => di(e, n, !r, !i));
    } catch {
      return Kn(this, jr);
    }
  }
  equals(e) {
    return e == null ? Kn(this, jr) : new this.Collection(this, () => gy(e));
  }
  above(e) {
    return e == null ? Kn(this, jr) : new this.Collection(this, () => di(e, void 0, !0));
  }
  aboveOrEqual(e) {
    return e == null ? Kn(this, jr) : new this.Collection(this, () => di(e, void 0, !1));
  }
  below(e) {
    return e == null ? Kn(this, jr) : new this.Collection(this, () => di(void 0, e, !1, !0));
  }
  belowOrEqual(e) {
    return e == null ? Kn(this, jr) : new this.Collection(this, () => di(void 0, e));
  }
  startsWith(e) {
    return typeof e != "string" ? Kn(this, hy) : this.between(e, e + Ri, !0, !0);
  }
  startsWithIgnoreCase(e) {
    return e === "" ? this.startsWith(e) : Oa(this, (n, r) => n.indexOf(r[0]) === 0, [e], Ri);
  }
  equalsIgnoreCase(e) {
    return Oa(this, (n, r) => n === r[0], [e], "");
  }
  anyOfIgnoreCase() {
    var e = Wr.apply(ps, arguments);
    return e.length === 0 ? ss(this) : Oa(this, (n, r) => r.indexOf(n) !== -1, e, "");
  }
  startsWithAnyOfIgnoreCase() {
    var e = Wr.apply(ps, arguments);
    return e.length === 0 ? ss(this) : Oa(this, (n, r) => r.some((i) => n.indexOf(i) === 0), e, Ri);
  }
  anyOf() {
    const e = Wr.apply(ps, arguments);
    let n = this._cmp;
    try {
      e.sort(n);
    } catch {
      return Kn(this, jr);
    }
    if (e.length === 0)
      return ss(this);
    const r = new this.Collection(this, () => di(e[0], e[e.length - 1]));
    r._ondirectionchange = (s) => {
      n = s === "next" ? this._ascending : this._descending, e.sort(n);
    };
    let i = 0;
    return r._addAlgorithm((s, o, a) => {
      const l = s.key;
      for (; n(l, e[i]) > 0; )
        if (++i, i === e.length)
          return o(a), !1;
      return n(l, e[i]) === 0 || (o(() => {
        s.continue(e[i]);
      }), !1);
    }), r;
  }
  notEqual(e) {
    return this.inAnyRange([[zc, e], [e, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
  }
  noneOf() {
    const e = Wr.apply(ps, arguments);
    if (e.length === 0)
      return new this.Collection(this);
    try {
      e.sort(this._ascending);
    } catch {
      return Kn(this, jr);
    }
    const n = e.reduce((r, i) => r ? r.concat([[r[r.length - 1][1], i]]) : [[zc, i]], null);
    return n.push([e[e.length - 1], this.db._maxKey]), this.inAnyRange(n, { includeLowers: !1, includeUppers: !1 });
  }
  inAnyRange(e, n) {
    const r = this._cmp, i = this._ascending, s = this._descending, o = this._min, a = this._max;
    if (e.length === 0)
      return ss(this);
    if (!e.every((g) => g[0] !== void 0 && g[1] !== void 0 && i(g[0], g[1]) <= 0))
      return Kn(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", Xe.InvalidArgument);
    const l = !n || n.includeLowers !== !1, u = n && n.includeUppers === !0;
    let c, d = i;
    function h(g, m) {
      return d(g[0], m[0]);
    }
    try {
      c = e.reduce(function(g, m) {
        let w = 0, _ = g.length;
        for (; w < _; ++w) {
          const S = g[w];
          if (r(m[0], S[1]) < 0 && r(m[1], S[0]) > 0) {
            S[0] = o(S[0], m[0]), S[1] = a(S[1], m[1]);
            break;
          }
        }
        return w === _ && g.push(m), g;
      }, []), c.sort(h);
    } catch {
      return Kn(this, jr);
    }
    let v = 0;
    const y = u ? (g) => i(g, c[v][1]) > 0 : (g) => i(g, c[v][1]) >= 0, b = l ? (g) => s(g, c[v][0]) > 0 : (g) => s(g, c[v][0]) >= 0;
    let p = y;
    const f = new this.Collection(this, () => di(c[0][0], c[c.length - 1][1], !l, !u));
    return f._ondirectionchange = (g) => {
      g === "next" ? (p = y, d = i) : (p = b, d = s), c.sort(h);
    }, f._addAlgorithm((g, m, w) => {
      for (var _ = g.key; p(_); )
        if (++v, v === c.length)
          return m(w), !1;
      return !!function(S) {
        return !y(S) && !b(S);
      }(_) || (this._cmp(_, c[v][1]) === 0 || this._cmp(_, c[v][0]) === 0 || m(() => {
        d === i ? g.continue(c[v][0]) : g.continue(c[v][1]);
      }), !1);
    }), f;
  }
  startsWithAnyOf() {
    const e = Wr.apply(ps, arguments);
    return e.every((n) => typeof n == "string") ? e.length === 0 ? ss(this) : this.inAnyRange(e.map((n) => [n, n + Ri])) : Kn(this, "startsWithAnyOf() only works with strings");
  }
}
function _r(t) {
  return Kt(function(e) {
    return Bo(e), t(e.target.error), !1;
  });
}
function Bo(t) {
  t.stopPropagation && t.stopPropagation(), t.preventDefault && t.preventDefault();
}
const Do = "storagemutated", hi = "x-storagemutated-1", Si = go(null, Do);
class SB {
  _lock() {
    return ro(!$e.global), ++this._reculock, this._reculock !== 1 || $e.global || ($e.lockOwnerFor = this), this;
  }
  _unlock() {
    if (ro(!$e.global), --this._reculock == 0)
      for ($e.global || ($e.lockOwnerFor = null); this._blockedFuncs.length > 0 && !this._locked(); ) {
        var e = this._blockedFuncs.shift();
        try {
          Vs(e[1], e[0]);
        } catch {
        }
      }
    return this;
  }
  _locked() {
    return this._reculock && $e.lockOwnerFor !== this;
  }
  create(e) {
    if (!this.mode)
      return this;
    const n = this.db.idbdb, r = this.db._state.dbOpenError;
    if (ro(!this.idbtrans), !e && !n)
      switch (r && r.name) {
        case "DatabaseClosedError":
          throw new Xe.DatabaseClosed(r);
        case "MissingAPIError":
          throw new Xe.MissingAPI(r.message, r);
        default:
          throw new Xe.OpenFailed(r);
      }
    if (!this.active)
      throw new Xe.TransactionInactive();
    return ro(this._completion._state === null), (e = this.idbtrans = e || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : n.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }))).onerror = Kt((i) => {
      Bo(i), this._reject(e.error);
    }), e.onabort = Kt((i) => {
      Bo(i), this.active && this._reject(new Xe.Abort(e.error)), this.active = !1, this.on("abort").fire(i);
    }), e.oncomplete = Kt(() => {
      this.active = !1, this._resolve(), "mutatedParts" in e && Si.storagemutated.fire(e.mutatedParts);
    }), this;
  }
  _promise(e, n, r) {
    if (e === "readwrite" && this.mode !== "readwrite")
      return dn(new Xe.ReadOnly("Transaction is readonly"));
    if (!this.active)
      return dn(new Xe.TransactionInactive());
    if (this._locked())
      return new ze((s, o) => {
        this._blockedFuncs.push([() => {
          this._promise(e, n, r).then(s, o);
        }, $e]);
      });
    if (r)
      return wi(() => {
        var s = new ze((o, a) => {
          this._lock();
          const l = n(o, a, this);
          l && l.then && l.then(o, a);
        });
        return s.finally(() => this._unlock()), s._lib = !0, s;
      });
    var i = new ze((s, o) => {
      var a = n(s, o, this);
      a && a.then && a.then(s, o);
    });
    return i._lib = !0, i;
  }
  _root() {
    return this.parent ? this.parent._root() : this;
  }
  waitFor(e) {
    var n = this._root();
    const r = ze.resolve(e);
    if (n._waitingFor)
      n._waitingFor = n._waitingFor.then(() => r);
    else {
      n._waitingFor = r, n._waitingQueue = [];
      var i = n.idbtrans.objectStore(n.storeNames[0]);
      (function o() {
        for (++n._spinCount; n._waitingQueue.length; )
          n._waitingQueue.shift()();
        n._waitingFor && (i.get(-1 / 0).onsuccess = o);
      })();
    }
    var s = n._waitingFor;
    return new ze((o, a) => {
      r.then((l) => n._waitingQueue.push(Kt(o.bind(null, l))), (l) => n._waitingQueue.push(Kt(a.bind(null, l)))).finally(() => {
        n._waitingFor === s && (n._waitingFor = null);
      });
    });
  }
  abort() {
    this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new Xe.Abort()));
  }
  table(e) {
    const n = this._memoizedTables || (this._memoizedTables = {});
    if (Yn(n, e))
      return n[e];
    const r = this.schema[e];
    if (!r)
      throw new Xe.NotFound("Table " + e + " not part of transaction");
    const i = new this.db.Table(e, r, this);
    return i.core = this.db.core.table(e), n[e] = i, i;
  }
}
function jc(t, e, n, r, i, s, o) {
  return { name: t, keyPath: e, unique: n, multi: r, auto: i, compound: s, src: (n && !o ? "&" : "") + (r ? "*" : "") + (i ? "++" : "") + yy(e) };
}
function yy(t) {
  return typeof t == "string" ? t : t ? "[" + [].join.call(t, "+") + "]" : "";
}
function by(t, e, n) {
  return { name: t, primKey: e, indexes: n, mappedClass: null, idxByName: Ym(n, (r) => [r.name, r]) };
}
let Mo = (t) => {
  try {
    return t.only([[]]), Mo = () => [[]], [[]];
  } catch {
    return Mo = () => Ri, Ri;
  }
};
function Fc(t) {
  return t == null ? () => {
  } : typeof t == "string" ? function(e) {
    return e.split(".").length === 1 ? (r) => r[e] : (r) => qr(r, e);
  }(t) : (e) => qr(e, t);
}
function Tp(t) {
  return [].slice.call(t);
}
let EB = 0;
function mo(t) {
  return t == null ? ":id" : typeof t == "string" ? t : `[${t.join("+")}]`;
}
function xB(t, e, n) {
  function r(l) {
    if (l.type === 3)
      return null;
    if (l.type === 4)
      throw new Error("Cannot convert never type to IDBKeyRange");
    const { lower: u, upper: c, lowerOpen: d, upperOpen: h } = l;
    return u === void 0 ? c === void 0 ? null : e.upperBound(c, !!h) : c === void 0 ? e.lowerBound(u, !!d) : e.bound(u, c, !!d, !!h);
  }
  const { schema: i, hasGetAll: s } = function(l, u) {
    const c = Tp(l.objectStoreNames);
    return { schema: { name: l.name, tables: c.map((d) => u.objectStore(d)).map((d) => {
      const { keyPath: h, autoIncrement: v } = d, y = Tn(h), b = h == null, p = {}, f = { name: d.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: b, compound: y, keyPath: h, autoIncrement: v, unique: !0, extractKey: Fc(h) }, indexes: Tp(d.indexNames).map((g) => d.index(g)).map((g) => {
        const { name: m, unique: w, multiEntry: _, keyPath: S } = g, A = { name: m, compound: Tn(S), keyPath: S, unique: w, multiEntry: _, extractKey: Fc(S) };
        return p[mo(S)] = A, A;
      }), getIndexByKeyPath: (g) => p[mo(g)] };
      return p[":id"] = f.primaryKey, h != null && (p[mo(h)] = f.primaryKey), f;
    }) }, hasGetAll: c.length > 0 && "getAll" in u.objectStore(c[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) };
  }(t, n), o = i.tables.map((l) => function(u) {
    const c = u.name;
    return { name: c, schema: u, mutate: function({ trans: d, type: h, keys: v, values: y, range: b }) {
      return new Promise((p, f) => {
        p = Kt(p);
        const g = d.objectStore(c), m = g.keyPath == null, w = h === "put" || h === "add";
        if (!w && h !== "delete" && h !== "deleteRange")
          throw new Error("Invalid operation type: " + h);
        const { length: _ } = v || y || { length: 1 };
        if (v && y && v.length !== y.length)
          throw new Error("Given keys array must have same length as given values array.");
        if (_ === 0)
          return p({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
        let S;
        const A = [], C = [];
        let k = 0;
        const O = (B) => {
          ++k, Bo(B);
        };
        if (h === "deleteRange") {
          if (b.type === 4)
            return p({ numFailures: k, failures: C, results: [], lastResult: void 0 });
          b.type === 3 ? A.push(S = g.clear()) : A.push(S = g.delete(r(b)));
        } else {
          const [B, M] = w ? m ? [y, v] : [y, null] : [v, null];
          if (w)
            for (let j = 0; j < _; ++j)
              A.push(S = M && M[j] !== void 0 ? g[h](B[j], M[j]) : g[h](B[j])), S.onerror = O;
          else
            for (let j = 0; j < _; ++j)
              A.push(S = g[h](B[j])), S.onerror = O;
        }
        const N = (B) => {
          const M = B.target.result;
          A.forEach((j, q) => j.error != null && (C[q] = j.error)), p({ numFailures: k, failures: C, results: h === "delete" ? v : A.map((j) => j.result), lastResult: M });
        };
        S.onerror = (B) => {
          O(B), N(B);
        }, S.onsuccess = N;
      });
    }, getMany: ({ trans: d, keys: h }) => new Promise((v, y) => {
      v = Kt(v);
      const b = d.objectStore(c), p = h.length, f = new Array(p);
      let g, m = 0, w = 0;
      const _ = (A) => {
        const C = A.target;
        f[C._pos] = C.result, ++w === m && v(f);
      }, S = _r(y);
      for (let A = 0; A < p; ++A)
        h[A] != null && (g = b.get(h[A]), g._pos = A, g.onsuccess = _, g.onerror = S, ++m);
      m === 0 && v(f);
    }), get: ({ trans: d, key: h }) => new Promise((v, y) => {
      v = Kt(v);
      const b = d.objectStore(c).get(h);
      b.onsuccess = (p) => v(p.target.result), b.onerror = _r(y);
    }), query: function(d) {
      return (h) => new Promise((v, y) => {
        v = Kt(v);
        const { trans: b, values: p, limit: f, query: g } = h, m = f === 1 / 0 ? void 0 : f, { index: w, range: _ } = g, S = b.objectStore(c), A = w.isPrimaryKey ? S : S.index(w.name), C = r(_);
        if (f === 0)
          return v({ result: [] });
        if (d) {
          const k = p ? A.getAll(C, m) : A.getAllKeys(C, m);
          k.onsuccess = (O) => v({ result: O.target.result }), k.onerror = _r(y);
        } else {
          let k = 0;
          const O = p || !("openKeyCursor" in A) ? A.openCursor(C) : A.openKeyCursor(C), N = [];
          O.onsuccess = (B) => {
            const M = O.result;
            return M ? (N.push(p ? M.value : M.primaryKey), ++k === f ? v({ result: N }) : void M.continue()) : v({ result: N });
          }, O.onerror = _r(y);
        }
      });
    }(s), openCursor: function({ trans: d, values: h, query: v, reverse: y, unique: b }) {
      return new Promise((p, f) => {
        p = Kt(p);
        const { index: g, range: m } = v, w = d.objectStore(c), _ = g.isPrimaryKey ? w : w.index(g.name), S = y ? b ? "prevunique" : "prev" : b ? "nextunique" : "next", A = h || !("openKeyCursor" in _) ? _.openCursor(r(m), S) : _.openKeyCursor(r(m), S);
        A.onerror = _r(f), A.onsuccess = Kt((C) => {
          const k = A.result;
          if (!k)
            return void p(null);
          k.___id = ++EB, k.done = !1;
          const O = k.continue.bind(k);
          let N = k.continuePrimaryKey;
          N && (N = N.bind(k));
          const B = k.advance.bind(k), M = () => {
            throw new Error("Cursor not stopped");
          };
          k.trans = d, k.stop = k.continue = k.continuePrimaryKey = k.advance = () => {
            throw new Error("Cursor not started");
          }, k.fail = Kt(f), k.next = function() {
            let j = 1;
            return this.start(() => j-- ? this.continue() : this.stop()).then(() => this);
          }, k.start = (j) => {
            const q = new Promise((z, U) => {
              z = Kt(z), A.onerror = _r(U), k.fail = U, k.stop = (H) => {
                k.stop = k.continue = k.continuePrimaryKey = k.advance = M, z(H);
              };
            }), X = () => {
              if (A.result)
                try {
                  j();
                } catch (z) {
                  k.fail(z);
                }
              else
                k.done = !0, k.start = () => {
                  throw new Error("Cursor behind last entry");
                }, k.stop();
            };
            return A.onsuccess = Kt((z) => {
              A.onsuccess = X, X();
            }), k.continue = O, k.continuePrimaryKey = N, k.advance = B, X(), q;
          }, p(k);
        }, f);
      });
    }, count({ query: d, trans: h }) {
      const { index: v, range: y } = d;
      return new Promise((b, p) => {
        const f = h.objectStore(c), g = v.isPrimaryKey ? f : f.index(v.name), m = r(y), w = m ? g.count(m) : g.count();
        w.onsuccess = Kt((_) => b(_.target.result)), w.onerror = _r(p);
      });
    } };
  }(l)), a = {};
  return o.forEach((l) => a[l.name] = l), { stack: "dbcore", transaction: t.transaction.bind(t), table(l) {
    if (!a[l])
      throw new Error(`Table '${l}' not found`);
    return a[l];
  }, MIN_KEY: -1 / 0, MAX_KEY: Mo(e), schema: i };
}
function Hc({ _novip: t }, e) {
  const n = e.db, r = function(i, s, { IDBKeyRange: o, indexedDB: a }, l) {
    return { dbcore: function(c, d) {
      return d.reduce((h, { create: v }) => ({ ...h, ...v(h) }), c);
    }(xB(s, o, l), i.dbcore) };
  }(t._middlewares, n, t._deps, e);
  t.core = r.dbcore, t.tables.forEach((i) => {
    const s = i.name;
    t.core.schema.tables.some((o) => o.name === s) && (i.core = t.core.table(s), t[s] instanceof t.Table && (t[s].core = i.core));
  });
}
function yl({ _novip: t }, e, n, r) {
  n.forEach((i) => {
    const s = r[i];
    e.forEach((o) => {
      const a = ef(o, i);
      (!a || "value" in a && a.value === void 0) && (o === t.Transaction.prototype || o instanceof t.Transaction ? Gr(o, i, { get() {
        return this.table(i);
      }, set(l) {
        Gm(this, i, { value: l, writable: !0, configurable: !0, enumerable: !0 });
      } }) : o[i] = new t.Table(i, s));
    });
  });
}
function Uc({ _novip: t }, e) {
  e.forEach((n) => {
    for (let r in n)
      n[r] instanceof t.Table && delete n[r];
  });
}
function AB(t, e) {
  return t._cfg.version - e._cfg.version;
}
function kB(t, e, n, r) {
  const i = t._dbSchema, s = t._createTransaction("readwrite", t._storeNames, i);
  s.create(n), s._completion.catch(r);
  const o = s._reject.bind(s), a = $e.transless || $e;
  wi(() => {
    $e.trans = s, $e.transless = a, e === 0 ? (an(i).forEach((l) => {
      Bu(n, l, i[l].primKey, i[l].indexes);
    }), Hc(t, n), ze.follow(() => t.on.populate.fire(s)).catch(o)) : function({ _novip: l }, u, c, d) {
      const h = [], v = l._versions;
      let y = l._dbSchema = Wc(l, l.idbdb, d), b = !1;
      const p = v.filter((g) => g._cfg.version >= u);
      function f() {
        return h.length ? ze.resolve(h.shift()(c.idbtrans)).then(f) : ze.resolve();
      }
      return p.forEach((g) => {
        h.push(() => {
          const m = y, w = g._cfg.dbschema;
          Kc(l, m, d), Kc(l, w, d), y = l._dbSchema = w;
          const _ = wy(m, w);
          _.add.forEach((A) => {
            Bu(d, A[0], A[1].primKey, A[1].indexes);
          }), _.change.forEach((A) => {
            if (A.recreate)
              throw new Xe.Upgrade("Not yet support for changing primary key");
            {
              const C = d.objectStore(A.name);
              A.add.forEach((k) => Vc(C, k)), A.change.forEach((k) => {
                C.deleteIndex(k.name), Vc(C, k);
              }), A.del.forEach((k) => C.deleteIndex(k));
            }
          });
          const S = g._cfg.contentUpgrade;
          if (S && g._cfg.version > u) {
            Hc(l, d), c._memoizedTables = {}, b = !0;
            let A = Qm(w);
            _.del.forEach((N) => {
              A[N] = m[N];
            }), Uc(l, [l.Transaction.prototype]), yl(l, [l.Transaction.prototype], an(A), A), c.schema = A;
            const C = tf(S);
            let k;
            C && Us();
            const O = ze.follow(() => {
              if (k = S(c), k && C) {
                var N = Xr.bind(null, null);
                k.then(N, N);
              }
            });
            return k && typeof k.then == "function" ? ze.resolve(k) : O.then(() => k);
          }
        }), h.push((m) => {
          (!b || !vB) && function(w, _) {
            [].slice.call(_.db.objectStoreNames).forEach((S) => w[S] == null && _.db.deleteObjectStore(S));
          }(g._cfg.dbschema, m), Uc(l, [l.Transaction.prototype]), yl(l, [l.Transaction.prototype], l._storeNames, l._dbSchema), c.schema = l._dbSchema;
        });
      }), f().then(() => {
        var g, m;
        m = d, an(g = y).forEach((w) => {
          m.db.objectStoreNames.contains(w) || Bu(m, w, g[w].primKey, g[w].indexes);
        });
      });
    }(t, e, s, n).catch(o);
  });
}
function wy(t, e) {
  const n = { del: [], add: [], change: [] };
  let r;
  for (r in t)
    e[r] || n.del.push(r);
  for (r in e) {
    const i = t[r], s = e[r];
    if (i) {
      const o = { name: r, def: s, recreate: !1, del: [], add: [], change: [] };
      if ("" + (i.primKey.keyPath || "") != "" + (s.primKey.keyPath || "") || i.primKey.auto !== s.primKey.auto && !Xl)
        o.recreate = !0, n.change.push(o);
      else {
        const a = i.idxByName, l = s.idxByName;
        let u;
        for (u in a)
          l[u] || o.del.push(u);
        for (u in l) {
          const c = a[u], d = l[u];
          c ? c.src !== d.src && o.change.push(d) : o.add.push(d);
        }
        (o.del.length > 0 || o.add.length > 0 || o.change.length > 0) && n.change.push(o);
      }
    } else
      n.add.push([r, s]);
  }
  return n;
}
function Bu(t, e, n, r) {
  const i = t.db.createObjectStore(e, n.keyPath ? { keyPath: n.keyPath, autoIncrement: n.auto } : { autoIncrement: n.auto });
  return r.forEach((s) => Vc(i, s)), i;
}
function Vc(t, e) {
  t.createIndex(e.name, e.keyPath, { unique: e.unique, multiEntry: e.multi });
}
function Wc(t, e, n) {
  const r = {};
  return fl(e.objectStoreNames, 0).forEach((i) => {
    const s = n.objectStore(i);
    let o = s.keyPath;
    const a = jc(yy(o), o || "", !1, !1, !!s.autoIncrement, o && typeof o != "string", !0), l = [];
    for (let c = 0; c < s.indexNames.length; ++c) {
      const d = s.index(s.indexNames[c]);
      o = d.keyPath;
      var u = jc(d.name, o, !!d.unique, !!d.multiEntry, !1, o && typeof o != "string", !1);
      l.push(u);
    }
    r[i] = by(i, a, l);
  }), r;
}
function Kc({ _novip: t }, e, n) {
  const r = n.db.objectStoreNames;
  for (let i = 0; i < r.length; ++i) {
    const s = r[i], o = n.objectStore(s);
    t._hasGetAll = "getAll" in o;
    for (let a = 0; a < o.indexNames.length; ++a) {
      const l = o.indexNames[a], u = o.index(l).keyPath, c = typeof u == "string" ? u : "[" + fl(u).join("+") + "]";
      if (e[s]) {
        const d = e[s].idxByName[c];
        d && (d.name = l, delete e[s].idxByName[c], e[s].idxByName[l] = d);
      }
    }
  }
  typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && Ut.WorkerGlobalScope && Ut instanceof Ut.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (t._hasGetAll = !1);
}
class CB {
  _parseStoresSpec(e, n) {
    an(e).forEach((r) => {
      if (e[r] !== null) {
        var i = e[r].split(",").map((o, a) => {
          const l = (o = o.trim()).replace(/([&*]|\+\+)/g, ""), u = /^\[/.test(l) ? l.match(/^\[(.*)\]$/)[1].split("+") : l;
          return jc(l, u || null, /\&/.test(o), /\*/.test(o), /\+\+/.test(o), Tn(u), a === 0);
        }), s = i.shift();
        if (s.multi)
          throw new Xe.Schema("Primary key cannot be multi-valued");
        i.forEach((o) => {
          if (o.auto)
            throw new Xe.Schema("Only primary key can be marked as autoIncrement (++)");
          if (!o.keyPath)
            throw new Xe.Schema("Index must have a name and cannot be an empty string");
        }), n[r] = by(r, s, i);
      }
    });
  }
  stores(e) {
    const n = this.db;
    this._cfg.storesSource = this._cfg.storesSource ? Pn(this._cfg.storesSource, e) : e;
    const r = n._versions, i = {};
    let s = {};
    return r.forEach((o) => {
      Pn(i, o._cfg.storesSource), s = o._cfg.dbschema = {}, o._parseStoresSpec(i, s);
    }), n._dbSchema = s, Uc(n, [n._allTables, n, n.Transaction.prototype]), yl(n, [n._allTables, n, n.Transaction.prototype, this._cfg.tables], an(s), s), n._storeNames = an(s), this;
  }
  upgrade(e) {
    return this._cfg.contentUpgrade = sf(this._cfg.contentUpgrade || Lt, e), this;
  }
}
function uf(t, e) {
  let n = t._dbNamesDB;
  return n || (n = t._dbNamesDB = new Li(eu, { addons: [], indexedDB: t, IDBKeyRange: e }), n.version(1).stores({ dbnames: "name" })), n.table("dbnames");
}
function cf(t) {
  return t && typeof t.databases == "function";
}
function $c(t) {
  return wi(function() {
    return $e.letThrough = !0, t();
  });
}
function TB() {
  var t;
  return !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(e) {
    var n = function() {
      return indexedDB.databases().finally(e);
    };
    t = setInterval(n, 100), n();
  }).finally(function() {
    return clearInterval(t);
  }) : Promise.resolve();
}
function OB(t) {
  const e = t._state, { indexedDB: n } = t._deps;
  if (e.isBeingOpened || t.idbdb)
    return e.dbReadyPromise.then(() => e.dbOpenError ? dn(e.dbOpenError) : t);
  Mr && (e.openCanceller._stackHolder = Zi()), e.isBeingOpened = !0, e.dbOpenError = null, e.openComplete = !1;
  const r = e.openCanceller;
  function i() {
    if (e.openCanceller !== r)
      throw new Xe.DatabaseClosed("db.open() was cancelled");
  }
  let s = e.dbReadyResolve, o = null, a = !1;
  return ze.race([r, (typeof navigator > "u" ? ze.resolve() : TB()).then(() => new ze((l, u) => {
    if (i(), !n)
      throw new Xe.MissingAPI();
    const c = t.name, d = e.autoSchema ? n.open(c) : n.open(c, Math.round(10 * t.verno));
    if (!d)
      throw new Xe.MissingAPI();
    d.onerror = _r(u), d.onblocked = Kt(t._fireOnBlocked), d.onupgradeneeded = Kt((h) => {
      if (o = d.transaction, e.autoSchema && !t._options.allowEmptyDB) {
        d.onerror = Bo, o.abort(), d.result.close();
        const y = n.deleteDatabase(c);
        y.onsuccess = y.onerror = Kt(() => {
          u(new Xe.NoSuchDatabase(`Database ${c} doesnt exist`));
        });
      } else {
        o.onerror = _r(u);
        var v = h.oldVersion > Math.pow(2, 62) ? 0 : h.oldVersion;
        a = v < 1, t._novip.idbdb = d.result, kB(t, v / 10, o, u);
      }
    }, u), d.onsuccess = Kt(() => {
      o = null;
      const h = t._novip.idbdb = d.result, v = fl(h.objectStoreNames);
      if (v.length > 0)
        try {
          const b = h.transaction((y = v).length === 1 ? y[0] : y, "readonly");
          e.autoSchema ? function({ _novip: p }, f, g) {
            p.verno = f.version / 10;
            const m = p._dbSchema = Wc(0, f, g);
            p._storeNames = fl(f.objectStoreNames, 0), yl(p, [p._allTables], an(m), m);
          }(t, h, b) : (Kc(t, t._dbSchema, b), function(p, f) {
            const g = wy(Wc(0, p.idbdb, f), p._dbSchema);
            return !(g.add.length || g.change.some((m) => m.add.length || m.change.length));
          }(t, b) || console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.")), Hc(t, b);
        } catch {
        }
      var y;
      vo.push(t), h.onversionchange = Kt((b) => {
        e.vcFired = !0, t.on("versionchange").fire(b);
      }), h.onclose = Kt((b) => {
        t.on("close").fire(b);
      }), a && function({ indexedDB: b, IDBKeyRange: p }, f) {
        !cf(b) && f !== eu && uf(b, p).put({ name: f }).catch(Lt);
      }(t._deps, c), l();
    }, u);
  }))]).then(() => (i(), e.onReadyBeingFired = [], ze.resolve($c(() => t.on.ready.fire(t.vip))).then(function l() {
    if (e.onReadyBeingFired.length > 0) {
      let u = e.onReadyBeingFired.reduce(sf, Lt);
      return e.onReadyBeingFired = [], ze.resolve($c(() => u(t.vip))).then(l);
    }
  }))).finally(() => {
    e.onReadyBeingFired = null, e.isBeingOpened = !1;
  }).then(() => t).catch((l) => {
    e.dbOpenError = l;
    try {
      o && o.abort();
    } catch {
    }
    return r === e.openCanceller && t._close(), dn(l);
  }).finally(() => {
    e.openComplete = !0, s();
  });
}
function Gc(t) {
  var e = (s) => t.next(s), n = i(e), r = i((s) => t.throw(s));
  function i(s) {
    return (o) => {
      var a = s(o), l = a.value;
      return a.done ? l : l && typeof l.then == "function" ? l.then(n, r) : Tn(l) ? Promise.all(l).then(n, r) : n(l);
    };
  }
  return i(e)();
}
function IB(t, e, n) {
  var r = arguments.length;
  if (r < 2)
    throw new Xe.InvalidArgument("Too few arguments");
  for (var i = new Array(r - 1); --r; )
    i[r - 1] = arguments[r];
  return n = i.pop(), [t, Zm(i), n];
}
function _y(t, e, n, r, i) {
  return ze.resolve().then(() => {
    const s = $e.transless || $e, o = t._createTransaction(e, n, t._dbSchema, r), a = { trans: o, transless: s };
    if (r)
      o.idbtrans = r.idbtrans;
    else
      try {
        o.create(), t._state.PR1398_maxLoop = 3;
      } catch (d) {
        return d.name === rf.InvalidState && t.isOpen() && --t._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), t._close(), t.open().then(() => _y(t, e, n, null, i))) : dn(d);
      }
    const l = tf(i);
    let u;
    l && Us();
    const c = ze.follow(() => {
      if (u = i.call(o, o), u)
        if (l) {
          var d = Xr.bind(null, null);
          u.then(d, d);
        } else
          typeof u.next == "function" && typeof u.throw == "function" && (u = Gc(u));
    }, a);
    return (u && typeof u.then == "function" ? ze.resolve(u).then((d) => o.active ? d : dn(new Xe.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"))) : c.then(() => u)).then((d) => (r && o._resolve(), o._completion.then(() => d))).catch((d) => (o._reject(d), dn(d)));
  });
}
function Ia(t, e, n) {
  const r = Tn(t) ? t.slice() : [t];
  for (let i = 0; i < n; ++i)
    r.push(e);
  return r;
}
const NB = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(t) {
  return { ...t, table(e) {
    const n = t.table(e), { schema: r } = n, i = {}, s = [];
    function o(c, d, h) {
      const v = mo(c), y = i[v] = i[v] || [], b = c == null ? 0 : typeof c == "string" ? 1 : c.length, p = d > 0, f = { ...h, isVirtual: p, keyTail: d, keyLength: b, extractKey: Fc(c), unique: !p && h.unique };
      return y.push(f), f.isPrimaryKey || s.push(f), b > 1 && o(b === 2 ? c[0] : c.slice(0, b - 1), d + 1, h), y.sort((g, m) => g.keyTail - m.keyTail), f;
    }
    const a = o(r.primaryKey.keyPath, 0, r.primaryKey);
    i[":id"] = [a];
    for (const c of r.indexes)
      o(c.keyPath, 0, c);
    function l(c) {
      const d = c.query.index;
      return d.isVirtual ? { ...c, query: { index: d, range: (h = c.query.range, v = d.keyTail, { type: h.type === 1 ? 2 : h.type, lower: Ia(h.lower, h.lowerOpen ? t.MAX_KEY : t.MIN_KEY, v), lowerOpen: !0, upper: Ia(h.upper, h.upperOpen ? t.MIN_KEY : t.MAX_KEY, v), upperOpen: !0 }) } } : c;
      var h, v;
    }
    return { ...n, schema: { ...r, primaryKey: a, indexes: s, getIndexByKeyPath: function(c) {
      const d = i[mo(c)];
      return d && d[0];
    } }, count: (c) => n.count(l(c)), query: (c) => n.query(l(c)), openCursor(c) {
      const { keyTail: d, isVirtual: h, keyLength: v } = c.query.index;
      return h ? n.openCursor(l(c)).then((y) => y && function(b) {
        return Object.create(b, { continue: { value: function(f) {
          f != null ? b.continue(Ia(f, c.reverse ? t.MAX_KEY : t.MIN_KEY, d)) : c.unique ? b.continue(b.key.slice(0, v).concat(c.reverse ? t.MIN_KEY : t.MAX_KEY, d)) : b.continue();
        } }, continuePrimaryKey: { value(f, g) {
          b.continuePrimaryKey(Ia(f, t.MAX_KEY, d), g);
        } }, primaryKey: { get: () => b.primaryKey }, key: { get() {
          const f = b.key;
          return v === 1 ? f[0] : f.slice(0, v);
        } }, value: { get: () => b.value } });
      }(y)) : n.openCursor(c);
    } };
  } };
} };
function df(t, e, n, r) {
  return n = n || {}, r = r || "", an(t).forEach((i) => {
    if (Yn(e, i)) {
      var s = t[i], o = e[i];
      if (typeof s == "object" && typeof o == "object" && s && o) {
        const a = kc(s);
        a !== kc(o) ? n[r + i] = e[i] : a === "Object" ? df(s, o, n, r + i + ".") : s !== o && (n[r + i] = e[i]);
      } else
        s !== o && (n[r + i] = e[i]);
    } else
      n[r + i] = void 0;
  }), an(e).forEach((i) => {
    Yn(t, i) || (n[r + i] = e[i]);
  }), n;
}
const RB = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: (t) => ({ ...t, table(e) {
  const n = t.table(e), { primaryKey: r } = n.schema;
  return { ...n, mutate(s) {
    const o = $e.trans, { deleting: a, creating: l, updating: u } = o.table(e).hook;
    switch (s.type) {
      case "add":
        if (l.fire === Lt)
          break;
        return o._promise("readwrite", () => c(s), !0);
      case "put":
        if (l.fire === Lt && u.fire === Lt)
          break;
        return o._promise("readwrite", () => c(s), !0);
      case "delete":
        if (a.fire === Lt)
          break;
        return o._promise("readwrite", () => c(s), !0);
      case "deleteRange":
        if (a.fire === Lt)
          break;
        return o._promise("readwrite", () => function(h) {
          return d(h.trans, h.range, 1e4);
        }(s), !0);
    }
    return n.mutate(s);
    function c(h) {
      const v = $e.trans, y = h.keys || function(b, p) {
        return p.type === "delete" ? p.keys : p.keys || p.values.map(b.extractKey);
      }(r, h);
      if (!y)
        throw new Error("Keys missing");
      return (h = h.type === "add" || h.type === "put" ? { ...h, keys: y } : { ...h }).type !== "delete" && (h.values = [...h.values]), h.keys && (h.keys = [...h.keys]), function(b, p, f) {
        return p.type === "add" ? Promise.resolve([]) : b.getMany({ trans: p.trans, keys: f, cache: "immutable" });
      }(n, h, y).then((b) => {
        const p = y.map((f, g) => {
          const m = b[g], w = { onerror: null, onsuccess: null };
          if (h.type === "delete")
            a.fire.call(w, f, m, v);
          else if (h.type === "add" || m === void 0) {
            const _ = l.fire.call(w, f, h.values[g], v);
            f == null && _ != null && (f = _, h.keys[g] = f, r.outbound || vr(h.values[g], r.keyPath, f));
          } else {
            const _ = df(m, h.values[g]), S = u.fire.call(w, _, f, m, v);
            if (S) {
              const A = h.values[g];
              Object.keys(S).forEach((C) => {
                Yn(A, C) ? A[C] = S[C] : vr(A, C, S[C]);
              });
            }
          }
          return w;
        });
        return n.mutate(h).then(({ failures: f, results: g, numFailures: m, lastResult: w }) => {
          for (let _ = 0; _ < y.length; ++_) {
            const S = g ? g[_] : y[_], A = p[_];
            S == null ? A.onerror && A.onerror(f[_]) : A.onsuccess && A.onsuccess(h.type === "put" && b[_] ? h.values[_] : S);
          }
          return { failures: f, results: g, numFailures: m, lastResult: w };
        }).catch((f) => (p.forEach((g) => g.onerror && g.onerror(f)), Promise.reject(f)));
      });
    }
    function d(h, v, y) {
      return n.query({ trans: h, values: !1, query: { index: r, range: v }, limit: y }).then(({ result: b }) => c({ type: "delete", keys: b, trans: h }).then((p) => p.numFailures > 0 ? Promise.reject(p.failures[0]) : b.length < y ? { failures: [], numFailures: 0, lastResult: void 0 } : d(h, { ...v, lower: b[b.length - 1], lowerOpen: !0 }, y)));
    }
  } };
} }) };
function Sy(t, e, n) {
  try {
    if (!e || e.keys.length < t.length)
      return null;
    const r = [];
    for (let i = 0, s = 0; i < e.keys.length && s < t.length; ++i)
      In(e.keys[i], t[s]) === 0 && (r.push(n ? na(e.values[i]) : e.values[i]), ++s);
    return r.length === t.length ? r : null;
  } catch {
    return null;
  }
}
const PB = { stack: "dbcore", level: -1, create: (t) => ({ table: (e) => {
  const n = t.table(e);
  return { ...n, getMany: (r) => {
    if (!r.cache)
      return n.getMany(r);
    const i = Sy(r.keys, r.trans._cache, r.cache === "clone");
    return i ? ze.resolve(i) : n.getMany(r).then((s) => (r.trans._cache = { keys: r.keys, values: r.cache === "clone" ? na(s) : s }, s));
  }, mutate: (r) => (r.type !== "add" && (r.trans._cache = null), n.mutate(r)) };
} }) };
function ff(t) {
  return !("from" in t);
}
const Vr = function(t, e) {
  if (!this) {
    const n = new Vr();
    return t && "d" in t && Pn(n, t), n;
  }
  Pn(this, arguments.length ? { d: 1, from: t, to: arguments.length > 1 ? e : t } : { d: 0 });
};
function Lo(t, e, n) {
  const r = In(e, n);
  if (isNaN(r))
    return;
  if (r > 0)
    throw RangeError();
  if (ff(t))
    return Pn(t, { from: e, to: n, d: 1 });
  const i = t.l, s = t.r;
  if (In(n, t.from) < 0)
    return i ? Lo(i, e, n) : t.l = { from: e, to: n, d: 1, l: null, r: null }, Op(t);
  if (In(e, t.to) > 0)
    return s ? Lo(s, e, n) : t.r = { from: e, to: n, d: 1, l: null, r: null }, Op(t);
  In(e, t.from) < 0 && (t.from = e, t.l = null, t.d = s ? s.d + 1 : 1), In(n, t.to) > 0 && (t.to = n, t.r = null, t.d = t.l ? t.l.d + 1 : 1);
  const o = !t.r;
  i && !t.l && bl(t, i), s && o && bl(t, s);
}
function bl(t, e) {
  ff(e) || function n(r, { from: i, to: s, l: o, r: a }) {
    Lo(r, i, s), o && n(r, o), a && n(r, a);
  }(t, e);
}
function BB(t, e) {
  const n = qc(e);
  let r = n.next();
  if (r.done)
    return !1;
  let i = r.value;
  const s = qc(t);
  let o = s.next(i.from), a = o.value;
  for (; !r.done && !o.done; ) {
    if (In(a.from, i.to) <= 0 && In(a.to, i.from) >= 0)
      return !0;
    In(i.from, a.from) < 0 ? i = (r = n.next(a.from)).value : a = (o = s.next(i.from)).value;
  }
  return !1;
}
function qc(t) {
  let e = ff(t) ? null : { s: 0, n: t };
  return { next(n) {
    const r = arguments.length > 0;
    for (; e; )
      switch (e.s) {
        case 0:
          if (e.s = 1, r)
            for (; e.n.l && In(n, e.n.from) < 0; )
              e = { up: e, n: e.n.l, s: 1 };
          else
            for (; e.n.l; )
              e = { up: e, n: e.n.l, s: 1 };
        case 1:
          if (e.s = 2, !r || In(n, e.n.to) <= 0)
            return { value: e.n, done: !1 };
        case 2:
          if (e.n.r) {
            e.s = 3, e = { up: e, n: e.n.r, s: 0 };
            continue;
          }
        case 3:
          e = e.up;
      }
    return { done: !0 };
  } };
}
function Op(t) {
  var e, n;
  const r = (((e = t.r) === null || e === void 0 ? void 0 : e.d) || 0) - (((n = t.l) === null || n === void 0 ? void 0 : n.d) || 0), i = r > 1 ? "r" : r < -1 ? "l" : "";
  if (i) {
    const s = i === "r" ? "l" : "r", o = { ...t }, a = t[i];
    t.from = a.from, t.to = a.to, t[i] = a[i], o[i] = a[s], t[s] = o, o.d = Ip(o);
  }
  t.d = Ip(t);
}
function Ip({ r: t, l: e }) {
  return (t ? e ? Math.max(t.d, e.d) : t.d : e ? e.d : 0) + 1;
}
Bs(Vr.prototype, { add(t) {
  return bl(this, t), this;
}, addKey(t) {
  return Lo(this, t, t), this;
}, addKeys(t) {
  return t.forEach((e) => Lo(this, e, e)), this;
}, [Cc]() {
  return qc(this);
} });
const DB = { stack: "dbcore", level: 0, create: (t) => {
  const e = t.schema.name, n = new Vr(t.MIN_KEY, t.MAX_KEY);
  return { ...t, table: (r) => {
    const i = t.table(r), { schema: s } = i, { primaryKey: o } = s, { extractKey: a, outbound: l } = o, u = { ...i, mutate: (h) => {
      const v = h.trans, y = v.mutatedParts || (v.mutatedParts = {}), b = (S) => {
        const A = `idb://${e}/${r}/${S}`;
        return y[A] || (y[A] = new Vr());
      }, p = b(""), f = b(":dels"), { type: g } = h;
      let [m, w] = h.type === "deleteRange" ? [h.range] : h.type === "delete" ? [h.keys] : h.values.length < 50 ? [[], h.values] : [];
      const _ = h.trans._cache;
      return i.mutate(h).then((S) => {
        if (Tn(m)) {
          g !== "delete" && (m = S.results), p.addKeys(m);
          const A = Sy(m, _);
          A || g === "add" || f.addKeys(m), (A || w) && function(C, k, O, N) {
            function B(M) {
              const j = C(M.name || "");
              function q(z) {
                return z != null ? M.extractKey(z) : null;
              }
              const X = (z) => M.multiEntry && Tn(z) ? z.forEach((U) => j.addKey(U)) : j.addKey(z);
              (O || N).forEach((z, U) => {
                const H = O && q(O[U]), re = N && q(N[U]);
                In(H, re) !== 0 && (H != null && X(H), re != null && X(re));
              });
            }
            k.indexes.forEach(B);
          }(b, s, A, w);
        } else if (m) {
          const A = { from: m.lower, to: m.upper };
          f.add(A), p.add(A);
        } else
          p.add(n), f.add(n), s.indexes.forEach((A) => b(A.name).add(n));
        return S;
      });
    } }, c = ({ query: { index: h, range: v } }) => {
      var y, b;
      return [h, new Vr((y = v.lower) !== null && y !== void 0 ? y : t.MIN_KEY, (b = v.upper) !== null && b !== void 0 ? b : t.MAX_KEY)];
    }, d = { get: (h) => [o, new Vr(h.key)], getMany: (h) => [o, new Vr().addKeys(h.keys)], count: c, query: c, openCursor: c };
    return an(d).forEach((h) => {
      u[h] = function(v) {
        const { subscr: y } = $e;
        if (y) {
          const b = (w) => {
            const _ = `idb://${e}/${r}/${w}`;
            return y[_] || (y[_] = new Vr());
          }, p = b(""), f = b(":dels"), [g, m] = d[h](v);
          if (b(g.name || "").add(m), !g.isPrimaryKey) {
            if (h !== "count") {
              const w = h === "query" && l && v.values && i.query({ ...v, values: !1 });
              return i[h].apply(this, arguments).then((_) => {
                if (h === "query") {
                  if (l && v.values)
                    return w.then(({ result: A }) => (p.addKeys(A), _));
                  const S = v.values ? _.result.map(a) : _.result;
                  v.values ? p.addKeys(S) : f.addKeys(S);
                } else if (h === "openCursor") {
                  const S = _, A = v.values;
                  return S && Object.create(S, { key: { get: () => (f.addKey(S.primaryKey), S.key) }, primaryKey: { get() {
                    const C = S.primaryKey;
                    return f.addKey(C), C;
                  } }, value: { get: () => (A && p.addKey(S.primaryKey), S.value) } });
                }
                return _;
              });
            }
            f.add(n);
          }
        }
        return i[h].apply(this, arguments);
      };
    }), u;
  } };
} };
class Li {
  constructor(e, n) {
    this._middlewares = {}, this.verno = 0;
    const r = Li.dependencies;
    this._options = n = { addons: Li.addons, autoOpen: !0, indexedDB: r.indexedDB, IDBKeyRange: r.IDBKeyRange, ...n }, this._deps = { indexedDB: n.indexedDB, IDBKeyRange: n.IDBKeyRange };
    const { addons: i } = n;
    this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
    const s = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: Lt, dbReadyPromise: null, cancelOpen: Lt, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3 };
    var o;
    s.dbReadyPromise = new ze((a) => {
      s.dbReadyResolve = a;
    }), s.openCanceller = new ze((a, l) => {
      s.cancelOpen = l;
    }), this._state = s, this.name = e, this.on = go(this, "populate", "blocked", "versionchange", "close", { ready: [sf, Lt] }), this.on.ready.subscribe = qm(this.on.ready.subscribe, (a) => (l, u) => {
      Li.vip(() => {
        const c = this._state;
        if (c.openComplete)
          c.dbOpenError || ze.resolve().then(l), u && a(l);
        else if (c.onReadyBeingFired)
          c.onReadyBeingFired.push(l), u && a(l);
        else {
          a(l);
          const d = this;
          u || a(function h() {
            d.on.ready.unsubscribe(l), d.on.ready.unsubscribe(h);
          });
        }
      });
    }), this.Collection = (o = this, Qs(yB.prototype, function(a, l) {
      this.db = o;
      let u = vy, c = null;
      if (l)
        try {
          u = l();
        } catch (y) {
          c = y;
        }
      const d = a._ctx, h = d.table, v = h.hook.reading.fire;
      this._ctx = { table: h, index: d.index, isPrimKey: !d.index || h.schema.primKey.keyPath && d.index === h.schema.primKey.name, range: u, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: c, or: d.or, valueMapper: v !== Ro ? v : null };
    })), this.Table = function(a) {
      return Qs(mB.prototype, function(l, u, c) {
        this.db = a, this._tx = c, this.name = l, this.schema = u, this.hook = a._allTables[l] ? a._allTables[l].hook : go(null, { creating: [sB, Lt], reading: [iB, Ro], updating: [aB, Lt], deleting: [oB, Lt] });
      });
    }(this), this.Transaction = function(a) {
      return Qs(SB.prototype, function(l, u, c, d, h) {
        this.db = a, this.mode = l, this.storeNames = u, this.schema = c, this.chromeTransactionDurability = d, this.idbtrans = null, this.on = go(this, "complete", "error", "abort"), this.parent = h || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new ze((v, y) => {
          this._resolve = v, this._reject = y;
        }), this._completion.then(() => {
          this.active = !1, this.on.complete.fire();
        }, (v) => {
          var y = this.active;
          return this.active = !1, this.on.error.fire(v), this.parent ? this.parent._reject(v) : y && this.idbtrans && this.idbtrans.abort(), dn(v);
        });
      });
    }(this), this.Version = function(a) {
      return Qs(CB.prototype, function(l) {
        this.db = a, this._cfg = { version: l, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
      });
    }(this), this.WhereClause = function(a) {
      return Qs(my.prototype, function(l, u, c) {
        this.db = a, this._ctx = { table: l, index: u === ":id" ? null : u, or: c };
        const d = a._deps.indexedDB;
        if (!d)
          throw new Xe.MissingAPI();
        this._cmp = this._ascending = d.cmp.bind(d), this._descending = (h, v) => d.cmp(v, h), this._max = (h, v) => d.cmp(h, v) > 0 ? h : v, this._min = (h, v) => d.cmp(h, v) < 0 ? h : v, this._IDBKeyRange = a._deps.IDBKeyRange;
      });
    }(this), this.on("versionchange", (a) => {
      a.newVersion > 0 ? console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`) : console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`), this.close();
    }), this.on("blocked", (a) => {
      !a.newVersion || a.newVersion < a.oldVersion ? console.warn(`Dexie.delete('${this.name}') was blocked`) : console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${a.oldVersion / 10}`);
    }), this._maxKey = Mo(n.IDBKeyRange), this._createTransaction = (a, l, u, c) => new this.Transaction(a, l, u, this._options.chromeTransactionDurability, c), this._fireOnBlocked = (a) => {
      this.on("blocked").fire(a), vo.filter((l) => l.name === this.name && l !== this && !l._state.vcFired).map((l) => l.on("versionchange").fire(a));
    }, this.use(NB), this.use(RB), this.use(DB), this.use(PB), this.vip = Object.create(this, { _vip: { value: !0 } }), i.forEach((a) => a(this));
  }
  version(e) {
    if (isNaN(e) || e < 0.1)
      throw new Xe.Type("Given version is not a positive number");
    if (e = Math.round(10 * e) / 10, this.idbdb || this._state.isBeingOpened)
      throw new Xe.Schema("Cannot add version when database is open");
    this.verno = Math.max(this.verno, e);
    const n = this._versions;
    var r = n.filter((i) => i._cfg.version === e)[0];
    return r || (r = new this.Version(e), n.push(r), n.sort(AB), r.stores({}), this._state.autoSchema = !1, r);
  }
  _whenReady(e) {
    return this.idbdb && (this._state.openComplete || $e.letThrough || this._vip) ? e() : new ze((n, r) => {
      if (this._state.openComplete)
        return r(new Xe.DatabaseClosed(this._state.dbOpenError));
      if (!this._state.isBeingOpened) {
        if (!this._options.autoOpen)
          return void r(new Xe.DatabaseClosed());
        this.open().catch(Lt);
      }
      this._state.dbReadyPromise.then(n, r);
    }).then(e);
  }
  use({ stack: e, create: n, level: r, name: i }) {
    i && this.unuse({ stack: e, name: i });
    const s = this._middlewares[e] || (this._middlewares[e] = []);
    return s.push({ stack: e, create: n, level: r ?? 10, name: i }), s.sort((o, a) => o.level - a.level), this;
  }
  unuse({ stack: e, name: n, create: r }) {
    return e && this._middlewares[e] && (this._middlewares[e] = this._middlewares[e].filter((i) => r ? i.create !== r : !!n && i.name !== n)), this;
  }
  open() {
    return OB(this);
  }
  _close() {
    const e = this._state, n = vo.indexOf(this);
    if (n >= 0 && vo.splice(n, 1), this.idbdb) {
      try {
        this.idbdb.close();
      } catch {
      }
      this._novip.idbdb = null;
    }
    e.dbReadyPromise = new ze((r) => {
      e.dbReadyResolve = r;
    }), e.openCanceller = new ze((r, i) => {
      e.cancelOpen = i;
    });
  }
  close() {
    this._close();
    const e = this._state;
    this._options.autoOpen = !1, e.dbOpenError = new Xe.DatabaseClosed(), e.isBeingOpened && e.cancelOpen(e.dbOpenError);
  }
  delete() {
    const e = arguments.length > 0, n = this._state;
    return new ze((r, i) => {
      const s = () => {
        this.close();
        var o = this._deps.indexedDB.deleteDatabase(this.name);
        o.onsuccess = Kt(() => {
          (function({ indexedDB: a, IDBKeyRange: l }, u) {
            !cf(a) && u !== eu && uf(a, l).delete(u).catch(Lt);
          })(this._deps, this.name), r();
        }), o.onerror = _r(i), o.onblocked = this._fireOnBlocked;
      };
      if (e)
        throw new Xe.InvalidArgument("Arguments not allowed in db.delete()");
      n.isBeingOpened ? n.dbReadyPromise.then(s) : s();
    });
  }
  backendDB() {
    return this.idbdb;
  }
  isOpen() {
    return this.idbdb !== null;
  }
  hasBeenClosed() {
    const e = this._state.dbOpenError;
    return e && e.name === "DatabaseClosed";
  }
  hasFailed() {
    return this._state.dbOpenError !== null;
  }
  dynamicallyOpened() {
    return this._state.autoSchema;
  }
  get tables() {
    return an(this._allTables).map((e) => this._allTables[e]);
  }
  transaction() {
    const e = IB.apply(this, arguments);
    return this._transaction.apply(this, e);
  }
  _transaction(e, n, r) {
    let i = $e.trans;
    i && i.db === this && e.indexOf("!") === -1 || (i = null);
    const s = e.indexOf("?") !== -1;
    let o, a;
    e = e.replace("!", "").replace("?", "");
    try {
      if (a = n.map((u) => {
        var c = u instanceof this.Table ? u.name : u;
        if (typeof c != "string")
          throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
        return c;
      }), e == "r" || e === Ou)
        o = Ou;
      else {
        if (e != "rw" && e != Iu)
          throw new Xe.InvalidArgument("Invalid transaction mode: " + e);
        o = Iu;
      }
      if (i) {
        if (i.mode === Ou && o === Iu) {
          if (!s)
            throw new Xe.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
          i = null;
        }
        i && a.forEach((u) => {
          if (i && i.storeNames.indexOf(u) === -1) {
            if (!s)
              throw new Xe.SubTransaction("Table " + u + " not included in parent transaction.");
            i = null;
          }
        }), s && i && !i.active && (i = null);
      }
    } catch (u) {
      return i ? i._promise(null, (c, d) => {
        d(u);
      }) : dn(u);
    }
    const l = _y.bind(null, this, o, a, i, r);
    return i ? i._promise(o, l, "lock") : $e.trans ? Vs($e.transless, () => this._whenReady(l)) : this._whenReady(l);
  }
  table(e) {
    if (!Yn(this._allTables, e))
      throw new Xe.InvalidTable(`Table ${e} does not exist`);
    return this._allTables[e];
  }
}
const MB = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable";
class LB {
  constructor(e) {
    this._subscribe = e;
  }
  subscribe(e, n, r) {
    return this._subscribe(e && typeof e != "function" ? e : { next: e, error: n, complete: r });
  }
  [MB]() {
    return this;
  }
}
function Ey(t, e) {
  return an(e).forEach((n) => {
    bl(t[n] || (t[n] = new Vr()), e[n]);
  }), t;
}
function zB(t) {
  let e, n = !1;
  const r = new LB((i) => {
    const s = tf(t);
    let o = !1, a = {}, l = {};
    const u = { get closed() {
      return o;
    }, unsubscribe: () => {
      o = !0, Si.storagemutated.unsubscribe(v);
    } };
    i.start && i.start(u);
    let c = !1, d = !1;
    function h() {
      return an(l).some((b) => a[b] && BB(a[b], l[b]));
    }
    const v = (b) => {
      Ey(a, b), h() && y();
    }, y = () => {
      if (c || o)
        return;
      a = {};
      const b = {}, p = function(f) {
        s && Us();
        const g = () => wi(t, { subscr: f, trans: null }), m = $e.trans ? Vs($e.transless, g) : g();
        return s && m.then(Xr, Xr), m;
      }(b);
      d || (Si(Do, v), d = !0), c = !0, Promise.resolve(p).then((f) => {
        n = !0, e = f, c = !1, o || (h() ? y() : (a = {}, l = b, i.next && i.next(f)));
      }, (f) => {
        c = !1, n = !1, i.error && i.error(f), u.unsubscribe();
      });
    };
    return y(), u;
  });
  return r.hasValue = () => n, r.getValue = () => e, r;
}
let Jc;
try {
  Jc = { indexedDB: Ut.indexedDB || Ut.mozIndexedDB || Ut.webkitIndexedDB || Ut.msIndexedDB, IDBKeyRange: Ut.IDBKeyRange || Ut.webkitIDBKeyRange };
} catch {
  Jc = { indexedDB: null, IDBKeyRange: null };
}
const Ci = Li;
function Qa(t) {
  let e = Kr;
  try {
    Kr = !0, Si.storagemutated.fire(t);
  } finally {
    Kr = e;
  }
}
Bs(Ci, { ...Ka, delete: (t) => new Ci(t, { addons: [] }).delete(), exists: (t) => new Ci(t, { addons: [] }).open().then((e) => (e.close(), !0)).catch("NoSuchDatabaseError", () => !1), getDatabaseNames(t) {
  try {
    return function({ indexedDB: e, IDBKeyRange: n }) {
      return cf(e) ? Promise.resolve(e.databases()).then((r) => r.map((i) => i.name).filter((i) => i !== eu)) : uf(e, n).toCollection().primaryKeys();
    }(Ci.dependencies).then(t);
  } catch {
    return dn(new Xe.MissingAPI());
  }
}, defineClass: () => function(t) {
  Pn(this, t);
}, ignoreTransaction: (t) => $e.trans ? Vs($e.transless, t) : t(), vip: $c, async: function(t) {
  return function() {
    try {
      var e = Gc(t.apply(this, arguments));
      return e && typeof e.then == "function" ? e : ze.resolve(e);
    } catch (n) {
      return dn(n);
    }
  };
}, spawn: function(t, e, n) {
  try {
    var r = Gc(t.apply(n, e || []));
    return r && typeof r.then == "function" ? r : ze.resolve(r);
  } catch (i) {
    return dn(i);
  }
}, currentTransaction: { get: () => $e.trans || null }, waitFor: function(t, e) {
  const n = ze.resolve(typeof t == "function" ? Ci.ignoreTransaction(t) : t).timeout(e || 6e4);
  return $e.trans ? $e.trans.waitFor(n) : n;
}, Promise: ze, debug: { get: () => Mr, set: (t) => {
  ey(t, t === "dexie" ? () => !0 : py);
} }, derive: _s, extend: Pn, props: Bs, override: qm, Events: go, on: Si, liveQuery: zB, extendObservabilitySet: Ey, getByKeyPath: qr, setByKeyPath: vr, delByKeyPath: function(t, e) {
  typeof e == "string" ? vr(t, e, void 0) : "length" in e && [].map.call(e, function(n) {
    vr(t, n, void 0);
  });
}, shallowClone: Qm, deepClone: na, getObjectDiff: df, cmp: In, asap: Jm, minKey: zc, addons: [], connections: vo, errnames: rf, dependencies: Jc, semVer: Ep, version: Ep.split(".").map((t) => parseInt(t)).reduce((t, e, n) => t + e / Math.pow(10, 2 * n)) }), Ci.maxKey = Mo(Ci.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (Si(Do, (t) => {
  if (!Kr) {
    let e;
    Xl ? (e = document.createEvent("CustomEvent"), e.initCustomEvent(hi, !0, !0, t)) : e = new CustomEvent(hi, { detail: t }), Kr = !0, dispatchEvent(e), Kr = !1;
  }
}), addEventListener(hi, ({ detail: t }) => {
  Kr || Qa(t);
}));
let Kr = !1;
if (typeof BroadcastChannel < "u") {
  const t = new BroadcastChannel(hi);
  typeof t.unref == "function" && t.unref(), Si(Do, (e) => {
    Kr || t.postMessage(e);
  }), t.onmessage = (e) => {
    e.data && Qa(e.data);
  };
} else if (typeof self < "u" && typeof navigator < "u") {
  Si(Do, (e) => {
    try {
      Kr || (typeof localStorage < "u" && localStorage.setItem(hi, JSON.stringify({ trig: Math.random(), changedParts: e })), typeof self.clients == "object" && [...self.clients.matchAll({ includeUncontrolled: !0 })].forEach((n) => n.postMessage({ type: hi, changedParts: e })));
    } catch {
    }
  }), typeof addEventListener < "u" && addEventListener("storage", (e) => {
    if (e.key === hi) {
      const n = JSON.parse(e.newValue);
      n && Qa(n.changedParts);
    }
  });
  const t = self.document && navigator.serviceWorker;
  t && t.addEventListener("message", function({ data: e }) {
    e && e.type === hi && Qa(e.changedParts);
  });
}
ze.rejectionMapper = function(t, e) {
  if (!t || t instanceof Ss || t instanceof TypeError || t instanceof SyntaxError || !t.name || !bp[t.name])
    return t;
  var n = new bp[t.name](e || t.message, t);
  return "stack" in t && Gr(n, "stack", { get: function() {
    return this.inner.stack;
  } }), n;
}, ey(Mr, py);
const jB = new Li("library");
jB.version(1).stores({
  books: "++id, name, buffer, md5 ,size"
});
var Np = {}, FB = {
  get exports() {
    return Np;
  },
  set exports(t) {
    Np = t;
  }
};
(function(t, e) {
  (function(n) {
    t.exports = n();
  })(function(n) {
    var r = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    function i(f, g) {
      var m = f[0], w = f[1], _ = f[2], S = f[3];
      m += (w & _ | ~w & S) + g[0] - 680876936 | 0, m = (m << 7 | m >>> 25) + w | 0, S += (m & w | ~m & _) + g[1] - 389564586 | 0, S = (S << 12 | S >>> 20) + m | 0, _ += (S & m | ~S & w) + g[2] + 606105819 | 0, _ = (_ << 17 | _ >>> 15) + S | 0, w += (_ & S | ~_ & m) + g[3] - 1044525330 | 0, w = (w << 22 | w >>> 10) + _ | 0, m += (w & _ | ~w & S) + g[4] - 176418897 | 0, m = (m << 7 | m >>> 25) + w | 0, S += (m & w | ~m & _) + g[5] + 1200080426 | 0, S = (S << 12 | S >>> 20) + m | 0, _ += (S & m | ~S & w) + g[6] - 1473231341 | 0, _ = (_ << 17 | _ >>> 15) + S | 0, w += (_ & S | ~_ & m) + g[7] - 45705983 | 0, w = (w << 22 | w >>> 10) + _ | 0, m += (w & _ | ~w & S) + g[8] + 1770035416 | 0, m = (m << 7 | m >>> 25) + w | 0, S += (m & w | ~m & _) + g[9] - 1958414417 | 0, S = (S << 12 | S >>> 20) + m | 0, _ += (S & m | ~S & w) + g[10] - 42063 | 0, _ = (_ << 17 | _ >>> 15) + S | 0, w += (_ & S | ~_ & m) + g[11] - 1990404162 | 0, w = (w << 22 | w >>> 10) + _ | 0, m += (w & _ | ~w & S) + g[12] + 1804603682 | 0, m = (m << 7 | m >>> 25) + w | 0, S += (m & w | ~m & _) + g[13] - 40341101 | 0, S = (S << 12 | S >>> 20) + m | 0, _ += (S & m | ~S & w) + g[14] - 1502002290 | 0, _ = (_ << 17 | _ >>> 15) + S | 0, w += (_ & S | ~_ & m) + g[15] + 1236535329 | 0, w = (w << 22 | w >>> 10) + _ | 0, m += (w & S | _ & ~S) + g[1] - 165796510 | 0, m = (m << 5 | m >>> 27) + w | 0, S += (m & _ | w & ~_) + g[6] - 1069501632 | 0, S = (S << 9 | S >>> 23) + m | 0, _ += (S & w | m & ~w) + g[11] + 643717713 | 0, _ = (_ << 14 | _ >>> 18) + S | 0, w += (_ & m | S & ~m) + g[0] - 373897302 | 0, w = (w << 20 | w >>> 12) + _ | 0, m += (w & S | _ & ~S) + g[5] - 701558691 | 0, m = (m << 5 | m >>> 27) + w | 0, S += (m & _ | w & ~_) + g[10] + 38016083 | 0, S = (S << 9 | S >>> 23) + m | 0, _ += (S & w | m & ~w) + g[15] - 660478335 | 0, _ = (_ << 14 | _ >>> 18) + S | 0, w += (_ & m | S & ~m) + g[4] - 405537848 | 0, w = (w << 20 | w >>> 12) + _ | 0, m += (w & S | _ & ~S) + g[9] + 568446438 | 0, m = (m << 5 | m >>> 27) + w | 0, S += (m & _ | w & ~_) + g[14] - 1019803690 | 0, S = (S << 9 | S >>> 23) + m | 0, _ += (S & w | m & ~w) + g[3] - 187363961 | 0, _ = (_ << 14 | _ >>> 18) + S | 0, w += (_ & m | S & ~m) + g[8] + 1163531501 | 0, w = (w << 20 | w >>> 12) + _ | 0, m += (w & S | _ & ~S) + g[13] - 1444681467 | 0, m = (m << 5 | m >>> 27) + w | 0, S += (m & _ | w & ~_) + g[2] - 51403784 | 0, S = (S << 9 | S >>> 23) + m | 0, _ += (S & w | m & ~w) + g[7] + 1735328473 | 0, _ = (_ << 14 | _ >>> 18) + S | 0, w += (_ & m | S & ~m) + g[12] - 1926607734 | 0, w = (w << 20 | w >>> 12) + _ | 0, m += (w ^ _ ^ S) + g[5] - 378558 | 0, m = (m << 4 | m >>> 28) + w | 0, S += (m ^ w ^ _) + g[8] - 2022574463 | 0, S = (S << 11 | S >>> 21) + m | 0, _ += (S ^ m ^ w) + g[11] + 1839030562 | 0, _ = (_ << 16 | _ >>> 16) + S | 0, w += (_ ^ S ^ m) + g[14] - 35309556 | 0, w = (w << 23 | w >>> 9) + _ | 0, m += (w ^ _ ^ S) + g[1] - 1530992060 | 0, m = (m << 4 | m >>> 28) + w | 0, S += (m ^ w ^ _) + g[4] + 1272893353 | 0, S = (S << 11 | S >>> 21) + m | 0, _ += (S ^ m ^ w) + g[7] - 155497632 | 0, _ = (_ << 16 | _ >>> 16) + S | 0, w += (_ ^ S ^ m) + g[10] - 1094730640 | 0, w = (w << 23 | w >>> 9) + _ | 0, m += (w ^ _ ^ S) + g[13] + 681279174 | 0, m = (m << 4 | m >>> 28) + w | 0, S += (m ^ w ^ _) + g[0] - 358537222 | 0, S = (S << 11 | S >>> 21) + m | 0, _ += (S ^ m ^ w) + g[3] - 722521979 | 0, _ = (_ << 16 | _ >>> 16) + S | 0, w += (_ ^ S ^ m) + g[6] + 76029189 | 0, w = (w << 23 | w >>> 9) + _ | 0, m += (w ^ _ ^ S) + g[9] - 640364487 | 0, m = (m << 4 | m >>> 28) + w | 0, S += (m ^ w ^ _) + g[12] - 421815835 | 0, S = (S << 11 | S >>> 21) + m | 0, _ += (S ^ m ^ w) + g[15] + 530742520 | 0, _ = (_ << 16 | _ >>> 16) + S | 0, w += (_ ^ S ^ m) + g[2] - 995338651 | 0, w = (w << 23 | w >>> 9) + _ | 0, m += (_ ^ (w | ~S)) + g[0] - 198630844 | 0, m = (m << 6 | m >>> 26) + w | 0, S += (w ^ (m | ~_)) + g[7] + 1126891415 | 0, S = (S << 10 | S >>> 22) + m | 0, _ += (m ^ (S | ~w)) + g[14] - 1416354905 | 0, _ = (_ << 15 | _ >>> 17) + S | 0, w += (S ^ (_ | ~m)) + g[5] - 57434055 | 0, w = (w << 21 | w >>> 11) + _ | 0, m += (_ ^ (w | ~S)) + g[12] + 1700485571 | 0, m = (m << 6 | m >>> 26) + w | 0, S += (w ^ (m | ~_)) + g[3] - 1894986606 | 0, S = (S << 10 | S >>> 22) + m | 0, _ += (m ^ (S | ~w)) + g[10] - 1051523 | 0, _ = (_ << 15 | _ >>> 17) + S | 0, w += (S ^ (_ | ~m)) + g[1] - 2054922799 | 0, w = (w << 21 | w >>> 11) + _ | 0, m += (_ ^ (w | ~S)) + g[8] + 1873313359 | 0, m = (m << 6 | m >>> 26) + w | 0, S += (w ^ (m | ~_)) + g[15] - 30611744 | 0, S = (S << 10 | S >>> 22) + m | 0, _ += (m ^ (S | ~w)) + g[6] - 1560198380 | 0, _ = (_ << 15 | _ >>> 17) + S | 0, w += (S ^ (_ | ~m)) + g[13] + 1309151649 | 0, w = (w << 21 | w >>> 11) + _ | 0, m += (_ ^ (w | ~S)) + g[4] - 145523070 | 0, m = (m << 6 | m >>> 26) + w | 0, S += (w ^ (m | ~_)) + g[11] - 1120210379 | 0, S = (S << 10 | S >>> 22) + m | 0, _ += (m ^ (S | ~w)) + g[2] + 718787259 | 0, _ = (_ << 15 | _ >>> 17) + S | 0, w += (S ^ (_ | ~m)) + g[9] - 343485551 | 0, w = (w << 21 | w >>> 11) + _ | 0, f[0] = m + f[0] | 0, f[1] = w + f[1] | 0, f[2] = _ + f[2] | 0, f[3] = S + f[3] | 0;
    }
    function s(f) {
      var g = [], m;
      for (m = 0; m < 64; m += 4)
        g[m >> 2] = f.charCodeAt(m) + (f.charCodeAt(m + 1) << 8) + (f.charCodeAt(m + 2) << 16) + (f.charCodeAt(m + 3) << 24);
      return g;
    }
    function o(f) {
      var g = [], m;
      for (m = 0; m < 64; m += 4)
        g[m >> 2] = f[m] + (f[m + 1] << 8) + (f[m + 2] << 16) + (f[m + 3] << 24);
      return g;
    }
    function a(f) {
      var g = f.length, m = [1732584193, -271733879, -1732584194, 271733878], w, _, S, A, C, k;
      for (w = 64; w <= g; w += 64)
        i(m, s(f.substring(w - 64, w)));
      for (f = f.substring(w - 64), _ = f.length, S = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], w = 0; w < _; w += 1)
        S[w >> 2] |= f.charCodeAt(w) << (w % 4 << 3);
      if (S[w >> 2] |= 128 << (w % 4 << 3), w > 55)
        for (i(m, S), w = 0; w < 16; w += 1)
          S[w] = 0;
      return A = g * 8, A = A.toString(16).match(/(.*?)(.{0,8})$/), C = parseInt(A[2], 16), k = parseInt(A[1], 16) || 0, S[14] = C, S[15] = k, i(m, S), m;
    }
    function l(f) {
      var g = f.length, m = [1732584193, -271733879, -1732584194, 271733878], w, _, S, A, C, k;
      for (w = 64; w <= g; w += 64)
        i(m, o(f.subarray(w - 64, w)));
      for (f = w - 64 < g ? f.subarray(w - 64) : new Uint8Array(0), _ = f.length, S = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], w = 0; w < _; w += 1)
        S[w >> 2] |= f[w] << (w % 4 << 3);
      if (S[w >> 2] |= 128 << (w % 4 << 3), w > 55)
        for (i(m, S), w = 0; w < 16; w += 1)
          S[w] = 0;
      return A = g * 8, A = A.toString(16).match(/(.*?)(.{0,8})$/), C = parseInt(A[2], 16), k = parseInt(A[1], 16) || 0, S[14] = C, S[15] = k, i(m, S), m;
    }
    function u(f) {
      var g = "", m;
      for (m = 0; m < 4; m += 1)
        g += r[f >> m * 8 + 4 & 15] + r[f >> m * 8 & 15];
      return g;
    }
    function c(f) {
      var g;
      for (g = 0; g < f.length; g += 1)
        f[g] = u(f[g]);
      return f.join("");
    }
    c(a("hello")), typeof ArrayBuffer < "u" && !ArrayBuffer.prototype.slice && function() {
      function f(g, m) {
        return g = g | 0 || 0, g < 0 ? Math.max(g + m, 0) : Math.min(g, m);
      }
      ArrayBuffer.prototype.slice = function(g, m) {
        var w = this.byteLength, _ = f(g, w), S = w, A, C, k, O;
        return m !== n && (S = f(m, w)), _ > S ? new ArrayBuffer(0) : (A = S - _, C = new ArrayBuffer(A), k = new Uint8Array(C), O = new Uint8Array(this, _, A), k.set(O), C);
      };
    }();
    function d(f) {
      return /[\u0080-\uFFFF]/.test(f) && (f = unescape(encodeURIComponent(f))), f;
    }
    function h(f, g) {
      var m = f.length, w = new ArrayBuffer(m), _ = new Uint8Array(w), S;
      for (S = 0; S < m; S += 1)
        _[S] = f.charCodeAt(S);
      return g ? _ : w;
    }
    function v(f) {
      return String.fromCharCode.apply(null, new Uint8Array(f));
    }
    function y(f, g, m) {
      var w = new Uint8Array(f.byteLength + g.byteLength);
      return w.set(new Uint8Array(f)), w.set(new Uint8Array(g), f.byteLength), m ? w : w.buffer;
    }
    function b(f) {
      var g = [], m = f.length, w;
      for (w = 0; w < m - 1; w += 2)
        g.push(parseInt(f.substr(w, 2), 16));
      return String.fromCharCode.apply(String, g);
    }
    function p() {
      this.reset();
    }
    return p.prototype.append = function(f) {
      return this.appendBinary(d(f)), this;
    }, p.prototype.appendBinary = function(f) {
      this._buff += f, this._length += f.length;
      var g = this._buff.length, m;
      for (m = 64; m <= g; m += 64)
        i(this._hash, s(this._buff.substring(m - 64, m)));
      return this._buff = this._buff.substring(m - 64), this;
    }, p.prototype.end = function(f) {
      var g = this._buff, m = g.length, w, _ = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], S;
      for (w = 0; w < m; w += 1)
        _[w >> 2] |= g.charCodeAt(w) << (w % 4 << 3);
      return this._finish(_, m), S = c(this._hash), f && (S = b(S)), this.reset(), S;
    }, p.prototype.reset = function() {
      return this._buff = "", this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this;
    }, p.prototype.getState = function() {
      return {
        buff: this._buff,
        length: this._length,
        hash: this._hash.slice()
      };
    }, p.prototype.setState = function(f) {
      return this._buff = f.buff, this._length = f.length, this._hash = f.hash, this;
    }, p.prototype.destroy = function() {
      delete this._hash, delete this._buff, delete this._length;
    }, p.prototype._finish = function(f, g) {
      var m = g, w, _, S;
      if (f[m >> 2] |= 128 << (m % 4 << 3), m > 55)
        for (i(this._hash, f), m = 0; m < 16; m += 1)
          f[m] = 0;
      w = this._length * 8, w = w.toString(16).match(/(.*?)(.{0,8})$/), _ = parseInt(w[2], 16), S = parseInt(w[1], 16) || 0, f[14] = _, f[15] = S, i(this._hash, f);
    }, p.hash = function(f, g) {
      return p.hashBinary(d(f), g);
    }, p.hashBinary = function(f, g) {
      var m = a(f), w = c(m);
      return g ? b(w) : w;
    }, p.ArrayBuffer = function() {
      this.reset();
    }, p.ArrayBuffer.prototype.append = function(f) {
      var g = y(this._buff.buffer, f, !0), m = g.length, w;
      for (this._length += f.byteLength, w = 64; w <= m; w += 64)
        i(this._hash, o(g.subarray(w - 64, w)));
      return this._buff = w - 64 < m ? new Uint8Array(g.buffer.slice(w - 64)) : new Uint8Array(0), this;
    }, p.ArrayBuffer.prototype.end = function(f) {
      var g = this._buff, m = g.length, w = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], _, S;
      for (_ = 0; _ < m; _ += 1)
        w[_ >> 2] |= g[_] << (_ % 4 << 3);
      return this._finish(w, m), S = c(this._hash), f && (S = b(S)), this.reset(), S;
    }, p.ArrayBuffer.prototype.reset = function() {
      return this._buff = new Uint8Array(0), this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this;
    }, p.ArrayBuffer.prototype.getState = function() {
      var f = p.prototype.getState.call(this);
      return f.buff = v(f.buff), f;
    }, p.ArrayBuffer.prototype.setState = function(f) {
      return f.buff = h(f.buff, !0), p.prototype.setState.call(this, f);
    }, p.ArrayBuffer.prototype.destroy = p.prototype.destroy, p.ArrayBuffer.prototype._finish = p.prototype._finish, p.ArrayBuffer.hash = function(f, g) {
      var m = l(new Uint8Array(f)), w = c(m);
      return g ? b(w) : w;
    }, p;
  });
})(FB);
/*!
  * pinia v2.0.23
  * (c) 2022 Eduardo San Martin Morote
  * @license MIT
  */
let so;
const wl = (t) => so = t, HB = process.env.NODE_ENV !== "production" ? Symbol("pinia") : (
  /* istanbul ignore next */
  Symbol()
);
function Vi(t) {
  return t && typeof t == "object" && Object.prototype.toString.call(t) === "[object Object]" && typeof t.toJSON != "function";
}
var yo;
(function(t) {
  t.direct = "direct", t.patchObject = "patch object", t.patchFunction = "patch function";
})(yo || (yo = {}));
const hf = typeof window < "u", Du = (process.env.NODE_ENV !== "production" || !1) && process.env.NODE_ENV !== "test" && hf;
function xy(t, e) {
  for (const n in e) {
    const r = e[n];
    if (!(n in t))
      continue;
    const i = t[n];
    Vi(i) && Vi(r) && !on(r) && !Ll(r) ? t[n] = xy(i, r) : t[n] = r;
  }
  return t;
}
const Ay = () => {
};
function Rp(t, e, n, r = Ay) {
  t.push(e);
  const i = () => {
    const s = t.indexOf(e);
    s > -1 && (t.splice(s, 1), r());
  };
  return !n && ht() && Wo(i), i;
}
function os(t, ...e) {
  t.slice().forEach((n) => {
    n(...e);
  });
}
function Yc(t, e) {
  t instanceof Map && e instanceof Map && e.forEach((n, r) => t.set(r, n)), t instanceof Set && e instanceof Set && e.forEach(t.add, t);
  for (const n in e) {
    if (!e.hasOwnProperty(n))
      continue;
    const r = e[n], i = t[n];
    Vi(i) && Vi(r) && t.hasOwnProperty(n) && !on(r) && !Ll(r) ? t[n] = Yc(i, r) : t[n] = r;
  }
  return t;
}
const UB = process.env.NODE_ENV !== "production" ? Symbol("pinia:skipHydration") : (
  /* istanbul ignore next */
  Symbol()
);
function VB(t) {
  return !Vi(t) || !t.hasOwnProperty(UB);
}
const { assign: dr } = Object;
function Pp(t) {
  return !!(on(t) && t.effect);
}
function Bp(t, e, n, r) {
  const { state: i, actions: s, getters: o } = e, a = n.state.value[t];
  let l;
  function u() {
    !a && (process.env.NODE_ENV === "production" || !r) && (n.state.value[t] = i ? i() : {});
    const c = process.env.NODE_ENV !== "production" && r ? (
      // use ref() to unwrap refs inside state TODO: check if this is still necessary
      hn($(i ? i() : {}).value)
    ) : hn(n.state.value[t]);
    return dr(c, s, Object.keys(o || {}).reduce((d, h) => (process.env.NODE_ENV !== "production" && h in c && console.warn(`[🍍]: A getter cannot have the same name as another state property. Rename one of them. Found with "${h}" in store "${t}".`), d[h] = Ur(F(() => {
      wl(n);
      const v = n._s.get(t);
      return o[h].call(v, v);
    })), d), {}));
  }
  return l = Qc(t, u, e, n, r, !0), l.$reset = function() {
    const d = i ? i() : {};
    this.$patch((h) => {
      dr(h, d);
    });
  }, l;
}
function Qc(t, e, n = {}, r, i, s) {
  let o;
  const a = dr({ actions: {} }, n);
  if (process.env.NODE_ENV !== "production" && !r._e.active)
    throw new Error("Pinia destroyed");
  const l = {
    deep: !0
    // flush: 'post',
  };
  process.env.NODE_ENV !== "production" && !tb && (l.onTrigger = (k) => {
    u ? v = k : u == !1 && !A._hotUpdating && (Array.isArray(v) ? v.push(k) : console.error("🍍 debuggerEvents should be an array. This is most likely an internal Pinia bug."));
  });
  let u, c, d = Ur([]), h = Ur([]), v;
  const y = r.state.value[t];
  !s && !y && (process.env.NODE_ENV === "production" || !i) && (r.state.value[t] = {});
  const b = $({});
  let p;
  function f(k) {
    let O;
    u = c = !1, process.env.NODE_ENV !== "production" && (v = []), typeof k == "function" ? (k(r.state.value[t]), O = {
      type: yo.patchFunction,
      storeId: t,
      events: v
    }) : (Yc(r.state.value[t], k), O = {
      type: yo.patchObject,
      payload: k,
      storeId: t,
      events: v
    });
    const N = p = Symbol();
    rt().then(() => {
      p === N && (u = !0);
    }), c = !0, os(d, O, r.state.value[t]);
  }
  const g = process.env.NODE_ENV !== "production" ? () => {
    throw new Error(`🍍: Store "${t}" is built using the setup syntax and does not implement $reset().`);
  } : Ay;
  function m() {
    o.stop(), d = [], h = [], r._s.delete(t);
  }
  function w(k, O) {
    return function() {
      wl(r);
      const N = Array.from(arguments), B = [], M = [];
      function j(z) {
        B.push(z);
      }
      function q(z) {
        M.push(z);
      }
      os(h, {
        args: N,
        name: k,
        store: A,
        after: j,
        onError: q
      });
      let X;
      try {
        X = O.apply(this && this.$id === t ? this : A, N);
      } catch (z) {
        throw os(M, z), z;
      }
      return X instanceof Promise ? X.then((z) => (os(B, z), z)).catch((z) => (os(M, z), Promise.reject(z))) : (os(B, X), X);
    };
  }
  const _ = /* @__PURE__ */ Ur({
    actions: {},
    getters: {},
    state: [],
    hotState: b
  }), S = {
    _p: r,
    // _s: scope,
    $id: t,
    $onAction: Rp.bind(null, h),
    $patch: f,
    $reset: g,
    $subscribe(k, O = {}) {
      const N = Rp(d, k, O.detached, () => B()), B = o.run(() => ke(() => r.state.value[t], (M) => {
        (O.flush === "sync" ? c : u) && k({
          storeId: t,
          type: yo.direct,
          events: v
        }, M);
      }, dr({}, l, O)));
      return N;
    },
    $dispose: m
  }, A = Bn(process.env.NODE_ENV !== "production" || Du ? dr(
    {
      _hmrPayload: _,
      _customProperties: Ur(/* @__PURE__ */ new Set())
      // devtools custom properties
    },
    S
    // must be added later
    // setupStore
  ) : S);
  r._s.set(t, A);
  const C = r._e.run(() => (o = yv(), o.run(() => e())));
  for (const k in C) {
    const O = C[k];
    if (on(O) && !Pp(O) || Ll(O))
      process.env.NODE_ENV !== "production" && i ? ha(b.value, k, Cn(C, k)) : s || (y && VB(O) && (on(O) ? O.value = y[k] : Yc(O, y[k])), r.state.value[t][k] = O), process.env.NODE_ENV !== "production" && _.state.push(k);
    else if (typeof O == "function") {
      const N = process.env.NODE_ENV !== "production" && i ? O : w(k, O);
      C[k] = N, process.env.NODE_ENV !== "production" && (_.actions[k] = O), a.actions[k] = O;
    } else
      process.env.NODE_ENV !== "production" && Pp(O) && (_.getters[k] = s ? (
        // @ts-expect-error
        n.getters[k]
      ) : O, hf && (C._getters || // @ts-expect-error: same
      (C._getters = Ur([]))).push(k));
  }
  if (dr(A, C), dr(yi(A), C), Object.defineProperty(A, "$state", {
    get: () => process.env.NODE_ENV !== "production" && i ? b.value : r.state.value[t],
    set: (k) => {
      if (process.env.NODE_ENV !== "production" && i)
        throw new Error("cannot set hotState");
      f((O) => {
        dr(O, k);
      });
    }
  }), process.env.NODE_ENV !== "production" && (A._hotUpdate = Ur((k) => {
    A._hotUpdating = !0, k._hmrPayload.state.forEach((O) => {
      if (O in A.$state) {
        const N = k.$state[O], B = A.$state[O];
        typeof N == "object" && Vi(N) && Vi(B) ? xy(N, B) : k.$state[O] = B;
      }
      ha(A, O, Cn(k.$state, O));
    }), Object.keys(A.$state).forEach((O) => {
      O in k.$state || fu(A, O);
    }), u = !1, c = !1, r.state.value[t] = Cn(k._hmrPayload, "hotState"), c = !0, rt().then(() => {
      u = !0;
    });
    for (const O in k._hmrPayload.actions) {
      const N = k[O];
      ha(A, O, w(O, N));
    }
    for (const O in k._hmrPayload.getters) {
      const N = k._hmrPayload.getters[O], B = s ? (
        // special handling of options api
        F(() => (wl(r), N.call(A, A)))
      ) : N;
      ha(A, O, B);
    }
    Object.keys(A._hmrPayload.getters).forEach((O) => {
      O in k._hmrPayload.getters || fu(A, O);
    }), Object.keys(A._hmrPayload.actions).forEach((O) => {
      O in k._hmrPayload.actions || fu(A, O);
    }), A._hmrPayload = k._hmrPayload, A._getters = k._getters, A._hotUpdating = !1;
  })), Du) {
    const k = {
      writable: !0,
      configurable: !0,
      // avoid warning on devtools trying to display this property
      enumerable: !1
    };
    ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach((O) => {
      Object.defineProperty(A, O, {
        value: A[O],
        ...k
      });
    });
  }
  return r._p.forEach((k) => {
    if (Du) {
      const O = o.run(() => k({
        store: A,
        app: r._a,
        pinia: r,
        options: a
      }));
      Object.keys(O || {}).forEach((N) => A._customProperties.add(N)), dr(A, O);
    } else
      dr(A, o.run(() => k({
        store: A,
        app: r._a,
        pinia: r,
        options: a
      })));
  }), process.env.NODE_ENV !== "production" && A.$state && typeof A.$state == "object" && typeof A.$state.constructor == "function" && !A.$state.constructor.toString().includes("[native code]") && console.warn(`[🍍]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${A.$id}".`), y && s && n.hydrate && n.hydrate(A.$state, y), u = !0, c = !0, A;
}
function WB(t, e, n) {
  let r, i;
  const s = typeof e == "function";
  typeof t == "string" ? (r = t, i = s ? n : e) : (i = t, r = t.id);
  function o(a, l) {
    const u = ht();
    if (a = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    (process.env.NODE_ENV === "test" && so && so._testing ? null : a) || u && tt(HB), a && wl(a), process.env.NODE_ENV !== "production" && !so)
      throw new Error(`[🍍]: getActivePinia was called with no active Pinia. Did you forget to install pinia?
	const pinia = createPinia()
	app.use(pinia)
This will fail in production.`);
    a = so, a._s.has(r) || (s ? Qc(r, e, i, a) : Bp(r, i, a), process.env.NODE_ENV !== "production" && (o._pinia = a));
    const c = a._s.get(r);
    if (process.env.NODE_ENV !== "production" && l) {
      const d = "__hot:" + r, h = s ? Qc(d, e, i, a, !0) : Bp(d, dr({}, i), a, !0);
      l._hotUpdate(h), delete a.state.value[d], a._s.delete(d);
    }
    if (process.env.NODE_ENV !== "production" && hf && u && u.proxy && // avoid adding stores that are just built for hot module replacement
    !l) {
      const d = u.proxy, h = "_pStores" in d ? d._pStores : d._pStores = {};
      h[r] = c;
    }
    return c;
  }
  return o.$id = r, o;
}
function KB(t) {
  {
    t = yi(t);
    const e = {};
    for (const n in t) {
      const r = t[n];
      (on(r) || Ll(r)) && (e[n] = // ---
      Cn(t, n));
    }
    return e;
  }
}
const $B = [
  {
    date: "2018-10-20T16:00:00+00:00",
    creator: "陈浩基",
    creatorFileAs: "陈浩基",
    UUID: "DB108833-1D43-4711-A2D0-240E07B37352",
    language: "zh",
    title: "13.67",
    "calibre:timestamp": "2019-09-20T03:57:38.859000+00:00",
    "calibre:title_sort": "13.67",
    cover: "cover",
    id: "54a785173f1a484c02e53418730b24b5",
    coverPath: "/books/cover/13.67.jpg",
    url: "13.67.epub",
    bgColorFromCover: "#076184",
    size: 435507,
    from: "url",
    coverBase64: "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"
  }
], Ws = WB("reader", {
  state: () => ({
    theme: "default",
    flow: "paginated",
    font: "",
    lineSpacing: 1.5,
    fontSize: 100,
    bookList: $B
  }),
  actions: {
    setTheme(t) {
      this.theme = t;
    },
    reset() {
      this.theme = "default", this.flow = "paginated", this.font = "", this.lineSpacing = 1.5, this.fontSize = 100;
    },
    setBook(t, e) {
      const n = this.bookList.findIndex((r) => r.id === t);
      n > -1 && (this.bookList[n] = e);
    },
    addBook() {
    },
    delBook(t) {
      const e = this.bookList.findIndex((n) => t === n.id);
      e > -1 && this.bookList.splice(e, 1);
    }
  },
  persist: !0
});
const GB = { class: "image-slot" }, qB = { key: 0 }, JB = { key: 1 }, YB = { key: 2 }, QB = ["title"], ZB = { key: 3 }, XB = { key: 4 }, eD = { key: 5 }, tD = { key: 6 }, nD = {
  __name: "Home",
  props: {
    useMin: {
      type: Boolean,
      default: !1
    },
    maxCols: {
      type: Number,
      // Maximum number of colums. Default: Infinite
      default: 1 / 0
    }
  },
  emits: ["update:currentBook"],
  setup(t, { emit: e }) {
    const n = Ws();
    console.log("Imported Books: ", n.bookList.length);
    const r = n.bookList.sort((j, q) => j.lastOpen && q.lastOpen ? q.lastOpen - j.lastOpen : 1);
    console.log("Books: ", r);
    const { saveAs: i } = G3, s = $(null), o = $(null), a = Bn({
      maxColWidth: 280,
      gap: 32
    });
    let l = [];
    const { maxColWidth: u, gap: c } = hn(a), d = t, { useMin: h, maxCols: v } = d;
    Ct(async () => {
      r.length && (p(), f(), window.addEventListener("resize", A));
    }), En(() => {
      window.removeEventListener("resize", A);
    });
    const y = (j, q) => j.length > q ? `${j.substr(0, q - 3)}...` : j, b = (j) => {
      const q = new Date(j), X = q.getFullYear(), z = q.getMonth() + 1, U = q.getDay();
      return `${X}-${z}-${U}`;
    }, p = () => {
      l = s.value.children, l.length !== 0 && (o.value.$el.style.position = "relative", Array.prototype.forEach.call(l, (j) => {
        j.style.position = "absolute", j.style.maxWidth = `${u.value}px`, j.style.transition = "top 0.2s ease, left 0.2s ease, right 0.2s ease, buttom 0.2s ease";
      }));
    }, f = () => {
      if (l.length === 0)
        return;
      let { cols: j, wSpace: q } = S();
      q = Math.floor(q / 2), Array.prototype.forEach.call(l, (X, z) => {
        const U = g(j, z), H = U.index * m() + q;
        X.style.left = `${H}px`, X.style.top = `${U.height + U.top}px`, U.height += U.top + X.getBoundingClientRect().height, U.top = c.value;
      }), o.value.$el.style.height = `${_(j).height}px`;
    }, g = (j, q) => h ? w(j) : j[q % j.length], m = () => l[0].getBoundingClientRect().width + c.value, w = (j) => {
      let q = j[0];
      return j.forEach((X) => {
        X.height < q.height && (q = X);
      }), q;
    }, _ = (j) => {
      let q = j[0];
      return j.forEach((X) => {
        X.height > q.height && (q = X);
      }), q;
    }, S = () => {
      const { width: j } = o.value.$el.getBoundingClientRect();
      let q = Math.floor(j / m()) || 1;
      const X = [];
      v && q > v && (q = v);
      for (let U = 0; U < q; U += 1)
        X[U] = {
          height: 0,
          top: 0,
          index: U
        };
      const z = j - q * m() + c.value;
      return {
        cols: X,
        wSpace: z
      };
    }, A = () => {
      setTimeout(f(), 200);
    }, C = (j) => j / 1024 / 1024 > 1 ? parseFloat(j / 1024 / 1024 + "").toFixed(2) + "Mb" : parseInt(j / 1024 + "") + "Kb", k = (j) => {
      i("/books/" + j, j);
    }, O = e, N = (j) => {
      O("update:currentBook", j);
    }, B = async (j) => {
      const { raw: q, name: X, size: z } = j, U = new FileReader();
      U.onerror = (H) => {
        console.log(H);
      }, U.onloadend = (H) => {
        console.log(U), O("update:currentBook", U.result);
      }, U.readAsArrayBuffer(q);
    }, M = (j) => {
      n.delBook(j);
    };
    return (j, q) => {
      const X = Yi, z = D3, U = _t, H = pN, re = K4, fe = ta, J = jI, le = Em, ce = Sm;
      return V(), Ae(ce, { direction: "vertical" }, {
        default: de(() => [
          ve($m, {
            backdrop: "",
            shadow: ""
          }, {
            default: de(() => [
              ve(z, {
                "auto-upload": !1,
                accept: ".epub",
                "on-change": B,
                multiple: !1,
                "show-file-list": !1
              }, {
                default: de(() => [
                  ve(X, {
                    size: "small",
                    icon: x(ug),
                    circle: "",
                    title: "Add To Library"
                  }, null, 8, ["icon"])
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          ve(le, {
            class: "main",
            ref_key: "main",
            ref: o
          }, {
            default: de(() => [
              ae("div", {
                class: "grid",
                ref_key: "grid",
                ref: s
              }, [
                (V(!0), se(Ft, null, qn(x(r), (ge, _e) => (V(), se("div", { key: _e }, [
                  ve(J, {
                    onClick: (je) => N(ge),
                    ref_for: !0,
                    ref: "card",
                    shadow: "hover",
                    class: "box-card",
                    "body-style": { padding: "0px" }
                  }, {
                    default: de(() => [
                      ve(H, {
                        lazy: !0,
                        src: "data:image/png;base64," + ge.coverBase64,
                        fit: "fill",
                        class: "el-image"
                      }, {
                        error: de(() => [
                          ae("div", GB, [
                            ve(U, null, {
                              default: de(() => [
                                ve(x(Vk))
                              ]),
                              _: 1
                            })
                          ])
                        ]),
                        _: 2
                      }, 1032, ["src"]),
                      ve(fe, {
                        trigger: "hover",
                        placement: "right"
                      }, {
                        reference: de(() => [
                          ae("div", {
                            class: "title",
                            style: it({
                              background: ge.bgColorFromCover ? ge.bgColorFromCover : "#6d6d6d"
                            })
                          }, st(y(ge.title, 12)), 5)
                        ]),
                        default: de(() => [
                          ae("div", null, [
                            ae("p", null, [
                              ve(X, {
                                type: "primary",
                                round: "",
                                icon: x(tk),
                                onClick: (je) => k(ge.url)
                              }, {
                                default: de(() => [
                                  cn("Download")
                                ]),
                                _: 2
                              }, 1032, ["icon", "onClick"])
                            ]),
                            ae("p", null, [
                              ve(X, {
                                type: "primary",
                                round: "",
                                icon: x(ag),
                                onClick: (je) => M(ge.id)
                              }, {
                                default: de(() => [
                                  cn("Delete")
                                ]),
                                _: 2
                              }, 1032, ["icon", "onClick"])
                            ]),
                            ve(re),
                            ge.title ? (V(), se("p", qB, "Title: " + st(ge.title), 1)) : ye("", !0),
                            ge.creator ? (V(), se("p", JB, "Creator: " + st(ge.creator), 1)) : ye("", !0),
                            ge.description ? (V(), se("p", YB, [
                              cn(" Description: "),
                              ae("span", {
                                title: ge.description
                              }, st(y(ge.description, 30)), 9, QB)
                            ])) : ye("", !0),
                            ge.publisher ? (V(), se("p", ZB, "Publisher: " + st(ge.publisher), 1)) : ye("", !0),
                            ge.date ? (V(), se("p", XB, " Pub Date: " + st(b(ge.date) || b(ge.publishDate)), 1)) : ye("", !0),
                            ge.language ? (V(), se("p", eD, "Language: " + st(ge.language), 1)) : ye("", !0),
                            ge.size ? (V(), se("p", tD, "File Size: " + st(C(ge.size)), 1)) : ye("", !0)
                          ])
                        ]),
                        _: 2
                      }, 1024)
                    ]),
                    _: 2
                  }, 1032, ["onClick"])
                ]))), 128))
              ], 512)
            ]),
            _: 1
          }, 512)
        ]),
        _: 1
      });
    };
  }
}, rD = /* @__PURE__ */ Qi(nD, [["__scopeId", "data-v-e5f46eca"]]);
var _l = {}, iD = {
  get exports() {
    return _l;
  },
  set exports(t) {
    _l = t;
  }
}, Zc = {}, sD = {
  get exports() {
    return Zc;
  },
  set exports(t) {
    Zc = t;
  }
}, oD = void 0, ky = function(t) {
  return t !== oD && t !== null;
}, aD = ky, lD = {
  object: !0,
  function: !0,
  undefined: !0
  /* document.all */
}, uD = function(t) {
  return aD(t) ? hasOwnProperty.call(lD, typeof t) : !1;
}, cD = uD, dD = function(t) {
  if (!cD(t))
    return !1;
  try {
    return t.constructor ? t.constructor.prototype === t : !1;
  } catch {
    return !1;
  }
}, fD = dD, hD = function(t) {
  if (typeof t != "function" || !hasOwnProperty.call(t, "length"))
    return !1;
  try {
    if (typeof t.length != "number" || typeof t.call != "function" || typeof t.apply != "function")
      return !1;
  } catch {
    return !1;
  }
  return !fD(t);
}, pD = hD, vD = /^\s*class[\s{/}]/, gD = Function.prototype.toString, mD = function(t) {
  return !(!pD(t) || vD.test(gD.call(t)));
}, yD = function() {
  var t = Object.assign, e;
  return typeof t != "function" ? !1 : (e = { foo: "raz" }, t(e, { bar: "dwa" }, { trzy: "trzy" }), e.foo + e.bar + e.trzy === "razdwatrzy");
}, Mu, Dp;
function bD() {
  return Dp || (Dp = 1, Mu = function() {
    try {
      return Object.keys("primitive"), !0;
    } catch {
      return !1;
    }
  }), Mu;
}
var wD = function() {
}, _D = wD(), pf = function(t) {
  return t !== _D && t !== null;
}, Lu, Mp;
function SD() {
  if (Mp)
    return Lu;
  Mp = 1;
  var t = pf, e = Object.keys;
  return Lu = function(n) {
    return e(t(n) ? Object(n) : n);
  }, Lu;
}
var zu, Lp;
function ED() {
  return Lp || (Lp = 1, zu = bD()() ? Object.keys : SD()), zu;
}
var ju, zp;
function xD() {
  if (zp)
    return ju;
  zp = 1;
  var t = pf;
  return ju = function(e) {
    if (!t(e))
      throw new TypeError("Cannot use null or undefined");
    return e;
  }, ju;
}
var Fu, jp;
function AD() {
  if (jp)
    return Fu;
  jp = 1;
  var t = ED(), e = xD(), n = Math.max;
  return Fu = function(r, i) {
    var s, o, a = n(arguments.length, 2), l;
    for (r = Object(e(r)), l = function(u) {
      try {
        r[u] = i[u];
      } catch (c) {
        s || (s = c);
      }
    }, o = 1; o < a; ++o)
      i = arguments[o], t(i).forEach(l);
    if (s !== void 0)
      throw s;
    return r;
  }, Fu;
}
var kD = yD() ? Object.assign : AD(), CD = pf, TD = Array.prototype.forEach, OD = Object.create, ID = function(t, e) {
  var n;
  for (n in t)
    e[n] = t[n];
}, ND = function(t) {
  var e = OD(null);
  return TD.call(arguments, function(n) {
    CD(n) && ID(Object(n), e);
  }), e;
}, Hu = "razdwatrzy", RD = function() {
  return typeof Hu.contains != "function" ? !1 : Hu.contains("dwa") === !0 && Hu.contains("foo") === !1;
}, Uu, Fp;
function PD() {
  if (Fp)
    return Uu;
  Fp = 1;
  var t = String.prototype.indexOf;
  return Uu = function(e) {
    return t.call(this, e, arguments[1]) > -1;
  }, Uu;
}
var BD = RD() ? String.prototype.contains : PD(), Za = ky, Hp = mD, Cy = kD, Ty = ND, bo = BD, DD = sD.exports = function(t, e) {
  var n, r, i, s, o;
  return arguments.length < 2 || typeof t != "string" ? (s = e, e = t, t = null) : s = arguments[2], Za(t) ? (n = bo.call(t, "c"), r = bo.call(t, "e"), i = bo.call(t, "w")) : (n = i = !0, r = !1), o = { value: e, configurable: n, enumerable: r, writable: i }, s ? Cy(Ty(s), o) : o;
};
DD.gs = function(t, e, n) {
  var r, i, s, o;
  return typeof t != "string" ? (s = n, n = e, e = t, t = null) : s = arguments[3], Za(e) ? Hp(e) ? Za(n) ? Hp(n) || (s = n, n = void 0) : n = void 0 : (s = e, e = n = void 0) : e = void 0, Za(t) ? (r = bo.call(t, "c"), i = bo.call(t, "e")) : (r = !0, i = !1), o = { get: e, set: n, configurable: r, enumerable: i }, s ? Cy(Ty(s), o) : o;
};
var MD = function(t) {
  if (typeof t != "function")
    throw new TypeError(t + " is not a function");
  return t;
};
(function(t, e) {
  var n = Zc, r = MD, i = Function.prototype.apply, s = Function.prototype.call, o = Object.create, a = Object.defineProperty, l = Object.defineProperties, u = Object.prototype.hasOwnProperty, c = { configurable: !0, enumerable: !1, writable: !0 }, d, h, v, y, b, p, f;
  d = function(g, m) {
    var w;
    return r(m), u.call(this, "__ee__") ? w = this.__ee__ : (w = c.value = o(null), a(this, "__ee__", c), c.value = null), w[g] ? typeof w[g] == "object" ? w[g].push(m) : w[g] = [w[g], m] : w[g] = m, this;
  }, h = function(g, m) {
    var w, _;
    return r(m), _ = this, d.call(this, g, w = function() {
      v.call(_, g, w), i.call(m, this, arguments);
    }), w.__eeOnceListener__ = m, this;
  }, v = function(g, m) {
    var w, _, S, A;
    if (r(m), !u.call(this, "__ee__"))
      return this;
    if (w = this.__ee__, !w[g])
      return this;
    if (_ = w[g], typeof _ == "object")
      for (A = 0; S = _[A]; ++A)
        (S === m || S.__eeOnceListener__ === m) && (_.length === 2 ? w[g] = _[A ? 0 : 1] : _.splice(A, 1));
    else
      (_ === m || _.__eeOnceListener__ === m) && delete w[g];
    return this;
  }, y = function(g) {
    var m, w, _, S, A;
    if (u.call(this, "__ee__") && (S = this.__ee__[g], !!S))
      if (typeof S == "object") {
        for (w = arguments.length, A = new Array(w - 1), m = 1; m < w; ++m)
          A[m - 1] = arguments[m];
        for (S = S.slice(), m = 0; _ = S[m]; ++m)
          i.call(_, this, A);
      } else
        switch (arguments.length) {
          case 1:
            s.call(S, this);
            break;
          case 2:
            s.call(S, this, arguments[1]);
            break;
          case 3:
            s.call(S, this, arguments[1], arguments[2]);
            break;
          default:
            for (w = arguments.length, A = new Array(w - 1), m = 1; m < w; ++m)
              A[m - 1] = arguments[m];
            i.call(S, this, A);
        }
  }, b = {
    on: d,
    once: h,
    off: v,
    emit: y
  }, p = {
    on: n(d),
    once: n(h),
    off: n(v),
    emit: n(y)
  }, f = l({}, p), t.exports = e = function(g) {
    return g == null ? o(f) : l(Object(g), p);
  }, e.methods = b;
})(iD, _l);
const Lr = _l;
var xi = {}, Ai = {};
function LD(t, e, n) {
  if (n === void 0 && (n = Array.prototype), t && typeof n.find == "function")
    return n.find.call(t, e);
  for (var r = 0; r < t.length; r++)
    if (Object.prototype.hasOwnProperty.call(t, r)) {
      var i = t[r];
      if (e.call(void 0, i, r, t))
        return i;
    }
}
function vf(t, e) {
  return e === void 0 && (e = Object), e && typeof e.freeze == "function" ? e.freeze(t) : t;
}
var Oy = vf({
  /**
   * `text/html`, the only mime type that triggers treating an XML document as HTML.
   *
   * @see DOMParser.SupportedType.isHTML
   * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/HTML Wikipedia
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
   * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
   */
  HTML: "text/html",
  /**
   * Helper method to check a mime type if it indicates an HTML document
   *
   * @param {string} [value]
   * @returns {boolean}
   *
   * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/HTML Wikipedia
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
   * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
  isHTML: function(t) {
    return t === Oy.HTML;
  },
  /**
   * `application/xml`, the standard mime type for XML documents.
   *
   * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
   * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
   * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
   */
  XML_APPLICATION: "application/xml",
  /**
   * `text/html`, an alias for `application/xml`.
   *
   * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
   * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
   */
  XML_TEXT: "text/xml",
  /**
   * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
   * but is parsed as an XML document.
   *
   * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
   * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
   */
  XML_XHTML_APPLICATION: "application/xhtml+xml",
  /**
   * `image/svg+xml`,
   *
   * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
   * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
   * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
   */
  XML_SVG_IMAGE: "image/svg+xml"
}), Iy = vf({
  /**
   * The XHTML namespace.
   *
   * @see http://www.w3.org/1999/xhtml
   */
  HTML: "http://www.w3.org/1999/xhtml",
  /**
   * Checks if `uri` equals `NAMESPACE.HTML`.
   *
   * @param {string} [uri]
   *
   * @see NAMESPACE.HTML
   */
  isHTML: function(t) {
    return t === Iy.HTML;
  },
  /**
   * The SVG namespace.
   *
   * @see http://www.w3.org/2000/svg
   */
  SVG: "http://www.w3.org/2000/svg",
  /**
   * The `xml:` namespace.
   *
   * @see http://www.w3.org/XML/1998/namespace
   */
  XML: "http://www.w3.org/XML/1998/namespace",
  /**
   * The `xmlns:` namespace
   *
   * @see https://www.w3.org/2000/xmlns/
   */
  XMLNS: "http://www.w3.org/2000/xmlns/"
});
Ai.find = LD;
Ai.freeze = vf;
Ai.MIME_TYPE = Oy;
Ai.NAMESPACE = Iy;
var Ny = Ai, Ar = Ny.find, zo = Ny.NAMESPACE;
function zD(t) {
  return t !== "";
}
function jD(t) {
  return t ? t.split(/[\t\n\f\r ]+/).filter(zD) : [];
}
function FD(t, e) {
  return t.hasOwnProperty(e) || (t[e] = !0), t;
}
function Up(t) {
  if (!t)
    return [];
  var e = jD(t);
  return Object.keys(e.reduce(FD, {}));
}
function HD(t) {
  return function(e) {
    return t && t.indexOf(e) !== -1;
  };
}
function sa(t, e) {
  for (var n in t)
    Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
}
function Un(t, e) {
  var n = t.prototype;
  if (!(n instanceof e)) {
    let r = function() {
    };
    r.prototype = e.prototype, r = new r(), sa(n, r), t.prototype = n = r;
  }
  n.constructor != t && (typeof t != "function" && console.error("unknown Class:" + t), n.constructor = t);
}
var Vn = {}, gr = Vn.ELEMENT_NODE = 1, Ds = Vn.ATTRIBUTE_NODE = 2, Sl = Vn.TEXT_NODE = 3, Ry = Vn.CDATA_SECTION_NODE = 4, Py = Vn.ENTITY_REFERENCE_NODE = 5, UD = Vn.ENTITY_NODE = 6, By = Vn.PROCESSING_INSTRUCTION_NODE = 7, Dy = Vn.COMMENT_NODE = 8, My = Vn.DOCUMENT_NODE = 9, Ly = Vn.DOCUMENT_TYPE_NODE = 10, ei = Vn.DOCUMENT_FRAGMENT_NODE = 11, VD = Vn.NOTATION_NODE = 12, On = {}, pn = {};
On.INDEX_SIZE_ERR = (pn[1] = "Index size error", 1);
On.DOMSTRING_SIZE_ERR = (pn[2] = "DOMString size error", 2);
var Ln = On.HIERARCHY_REQUEST_ERR = (pn[3] = "Hierarchy request error", 3);
On.WRONG_DOCUMENT_ERR = (pn[4] = "Wrong document", 4);
On.INVALID_CHARACTER_ERR = (pn[5] = "Invalid character", 5);
On.NO_DATA_ALLOWED_ERR = (pn[6] = "No data allowed", 6);
On.NO_MODIFICATION_ALLOWED_ERR = (pn[7] = "No modification allowed", 7);
var zy = On.NOT_FOUND_ERR = (pn[8] = "Not found", 8);
On.NOT_SUPPORTED_ERR = (pn[9] = "Not supported", 9);
var Vp = On.INUSE_ATTRIBUTE_ERR = (pn[10] = "Attribute in use", 10);
On.INVALID_STATE_ERR = (pn[11] = "Invalid state", 11);
On.SYNTAX_ERR = (pn[12] = "Syntax error", 12);
On.INVALID_MODIFICATION_ERR = (pn[13] = "Invalid modification", 13);
On.NAMESPACE_ERR = (pn[14] = "Invalid namespace", 14);
On.INVALID_ACCESS_ERR = (pn[15] = "Invalid access", 15);
function tn(t, e) {
  if (e instanceof Error)
    var n = e;
  else
    n = this, Error.call(this, pn[t]), this.message = pn[t], Error.captureStackTrace && Error.captureStackTrace(this, tn);
  return n.code = t, e && (this.message = this.message + ": " + e), n;
}
tn.prototype = Error.prototype;
sa(On, tn);
function Jr() {
}
Jr.prototype = {
  /**
   * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
   * @standard level1
   */
  length: 0,
  /**
   * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
   * @standard level1
   * @param index  unsigned long
   *   Index into the collection.
   * @return Node
   * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
   */
  item: function(t) {
    return this[t] || null;
  },
  toString: function(t, e) {
    for (var n = [], r = 0; r < this.length; r++)
      bs(this[r], n, t, e);
    return n.join("");
  },
  /**
   * @private
   * @param {function (Node):boolean} predicate
   * @returns {Node[]}
   */
  filter: function(t) {
    return Array.prototype.filter.call(this, t);
  },
  /**
   * @private
   * @param {Node} item
   * @returns {number}
   */
  indexOf: function(t) {
    return Array.prototype.indexOf.call(this, t);
  }
};
function Ms(t, e) {
  this._node = t, this._refresh = e, gf(this);
}
function gf(t) {
  var e = t._node._inc || t._node.ownerDocument._inc;
  if (t._inc != e) {
    var n = t._refresh(t._node);
    Yy(t, "length", n.length), sa(n, t), t._inc = e;
  }
}
Ms.prototype.item = function(t) {
  return gf(this), this[t];
};
Un(Ms, Jr);
function El() {
}
function jy(t, e) {
  for (var n = t.length; n--; )
    if (t[n] === e)
      return n;
}
function Wp(t, e, n, r) {
  if (r ? e[jy(e, r)] = n : e[e.length++] = n, t) {
    n.ownerElement = t;
    var i = t.ownerDocument;
    i && (r && Uy(i, t, r), WD(i, t, n));
  }
}
function Kp(t, e, n) {
  var r = jy(e, n);
  if (r >= 0) {
    for (var i = e.length - 1; r < i; )
      e[r] = e[++r];
    if (e.length = i, t) {
      var s = t.ownerDocument;
      s && (Uy(s, t, n), n.ownerElement = null);
    }
  } else
    throw new tn(zy, new Error(t.tagName + "@" + n));
}
El.prototype = {
  length: 0,
  item: Jr.prototype.item,
  getNamedItem: function(t) {
    for (var e = this.length; e--; ) {
      var n = this[e];
      if (n.nodeName == t)
        return n;
    }
  },
  setNamedItem: function(t) {
    var e = t.ownerElement;
    if (e && e != this._ownerElement)
      throw new tn(Vp);
    var n = this.getNamedItem(t.nodeName);
    return Wp(this._ownerElement, this, t, n), n;
  },
  /* returns Node */
  setNamedItemNS: function(t) {
    var e = t.ownerElement, n;
    if (e && e != this._ownerElement)
      throw new tn(Vp);
    return n = this.getNamedItemNS(t.namespaceURI, t.localName), Wp(this._ownerElement, this, t, n), n;
  },
  /* returns Node */
  removeNamedItem: function(t) {
    var e = this.getNamedItem(t);
    return Kp(this._ownerElement, this, e), e;
  },
  // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
  //for level2
  removeNamedItemNS: function(t, e) {
    var n = this.getNamedItemNS(t, e);
    return Kp(this._ownerElement, this, n), n;
  },
  getNamedItemNS: function(t, e) {
    for (var n = this.length; n--; ) {
      var r = this[n];
      if (r.localName == e && r.namespaceURI == t)
        return r;
    }
    return null;
  }
};
function Fy() {
}
Fy.prototype = {
  /**
   * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
   * The different implementations fairly diverged in what kind of features were reported.
   * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
   *
   * @deprecated It is deprecated and modern browsers return true in all cases.
   *
   * @param {string} feature
   * @param {string} [version]
   * @returns {boolean} always true
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
   * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
   */
  hasFeature: function(t, e) {
    return !0;
  },
  /**
   * Creates an XML Document object of the specified type with its document element.
   *
   * __It behaves slightly different from the description in the living standard__:
   * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
   * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
   * - this implementation is not validating names or qualified names
   *   (when parsing XML strings, the SAX parser takes care of that)
   *
   * @param {string|null} namespaceURI
   * @param {string} qualifiedName
   * @param {DocumentType=null} doctype
   * @returns {Document}
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
   * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
   *
   * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
   * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
   * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
   */
  createDocument: function(t, e, n) {
    var r = new oa();
    if (r.implementation = this, r.childNodes = new Jr(), r.doctype = n || null, n && r.appendChild(n), e) {
      var i = r.createElementNS(t, e);
      r.appendChild(i);
    }
    return r;
  },
  /**
   * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
   *
   * __This behavior is slightly different from the in the specs__:
   * - this implementation is not validating names or qualified names
   *   (when parsing XML strings, the SAX parser takes care of that)
   *
   * @param {string} qualifiedName
   * @param {string} [publicId]
   * @param {string} [systemId]
   * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
   * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
   * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
   *
   * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
   * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
   * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
   */
  createDocumentType: function(t, e, n) {
    var r = new tu();
    return r.name = t, r.nodeName = t, r.publicId = e || "", r.systemId = n || "", r;
  }
};
function It() {
}
It.prototype = {
  firstChild: null,
  lastChild: null,
  previousSibling: null,
  nextSibling: null,
  attributes: null,
  parentNode: null,
  childNodes: null,
  ownerDocument: null,
  nodeValue: null,
  namespaceURI: null,
  prefix: null,
  localName: null,
  // Modified in DOM Level 2:
  insertBefore: function(t, e) {
    return xl(this, t, e);
  },
  replaceChild: function(t, e) {
    xl(this, t, e, Wy), e && this.removeChild(e);
  },
  removeChild: function(t) {
    return Vy(this, t);
  },
  appendChild: function(t) {
    return this.insertBefore(t, null);
  },
  hasChildNodes: function() {
    return this.firstChild != null;
  },
  cloneNode: function(t) {
    return Xc(this.ownerDocument || this, this, t);
  },
  // Modified in DOM Level 2:
  normalize: function() {
    for (var t = this.firstChild; t; ) {
      var e = t.nextSibling;
      e && e.nodeType == Sl && t.nodeType == Sl ? (this.removeChild(e), t.appendData(e.data)) : (t.normalize(), t = e);
    }
  },
  // Introduced in DOM Level 2:
  isSupported: function(t, e) {
    return this.ownerDocument.implementation.hasFeature(t, e);
  },
  // Introduced in DOM Level 2:
  hasAttributes: function() {
    return this.attributes.length > 0;
  },
  /**
   * Look up the prefix associated to the given namespace URI, starting from this node.
   * **The default namespace declarations are ignored by this method.**
   * See Namespace Prefix Lookup for details on the algorithm used by this method.
   *
   * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
   *
   * @param {string | null} namespaceURI
   * @returns {string | null}
   * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
   * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
   * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
   * @see https://github.com/xmldom/xmldom/issues/322
   */
  lookupPrefix: function(t) {
    for (var e = this; e; ) {
      var n = e._nsMap;
      if (n) {
        for (var r in n)
          if (Object.prototype.hasOwnProperty.call(n, r) && n[r] === t)
            return r;
      }
      e = e.nodeType == Ds ? e.ownerDocument : e.parentNode;
    }
    return null;
  },
  // Introduced in DOM Level 3:
  lookupNamespaceURI: function(t) {
    for (var e = this; e; ) {
      var n = e._nsMap;
      if (n && t in n && Object.prototype.hasOwnProperty.call(n, t))
        return n[t];
      e = e.nodeType == Ds ? e.ownerDocument : e.parentNode;
    }
    return null;
  },
  // Introduced in DOM Level 3:
  isDefaultNamespace: function(t) {
    var e = this.lookupPrefix(t);
    return e == null;
  }
};
function Hy(t) {
  return t == "<" && "&lt;" || t == ">" && "&gt;" || t == "&" && "&amp;" || t == '"' && "&quot;" || "&#" + t.charCodeAt() + ";";
}
sa(Vn, It);
sa(Vn, It.prototype);
function jo(t, e) {
  if (e(t))
    return !0;
  if (t = t.firstChild)
    do
      if (jo(t, e))
        return !0;
    while (t = t.nextSibling);
}
function oa() {
  this.ownerDocument = this;
}
function WD(t, e, n) {
  t && t._inc++;
  var r = n.namespaceURI;
  r === zo.XMLNS && (e._nsMap[n.prefix ? n.localName : ""] = n.value);
}
function Uy(t, e, n, r) {
  t && t._inc++;
  var i = n.namespaceURI;
  i === zo.XMLNS && delete e._nsMap[n.prefix ? n.localName : ""];
}
function mf(t, e, n) {
  if (t && t._inc) {
    t._inc++;
    var r = e.childNodes;
    if (n)
      r[r.length++] = n;
    else {
      for (var i = e.firstChild, s = 0; i; )
        r[s++] = i, i = i.nextSibling;
      r.length = s, delete r[r.length];
    }
  }
}
function Vy(t, e) {
  var n = e.previousSibling, r = e.nextSibling;
  return n ? n.nextSibling = r : t.firstChild = r, r ? r.previousSibling = n : t.lastChild = n, e.parentNode = null, e.previousSibling = null, e.nextSibling = null, mf(t.ownerDocument, t), e;
}
function KD(t) {
  return t && (t.nodeType === It.DOCUMENT_NODE || t.nodeType === It.DOCUMENT_FRAGMENT_NODE || t.nodeType === It.ELEMENT_NODE);
}
function $D(t) {
  return t && (kr(t) || yf(t) || ti(t) || t.nodeType === It.DOCUMENT_FRAGMENT_NODE || t.nodeType === It.COMMENT_NODE || t.nodeType === It.PROCESSING_INSTRUCTION_NODE);
}
function ti(t) {
  return t && t.nodeType === It.DOCUMENT_TYPE_NODE;
}
function kr(t) {
  return t && t.nodeType === It.ELEMENT_NODE;
}
function yf(t) {
  return t && t.nodeType === It.TEXT_NODE;
}
function $p(t, e) {
  var n = t.childNodes || [];
  if (Ar(n, kr) || ti(e))
    return !1;
  var r = Ar(n, ti);
  return !(e && r && n.indexOf(r) > n.indexOf(e));
}
function Gp(t, e) {
  var n = t.childNodes || [];
  function r(s) {
    return kr(s) && s !== e;
  }
  if (Ar(n, r))
    return !1;
  var i = Ar(n, ti);
  return !(e && i && n.indexOf(i) > n.indexOf(e));
}
function GD(t, e, n) {
  if (!KD(t))
    throw new tn(Ln, "Unexpected parent node type " + t.nodeType);
  if (n && n.parentNode !== t)
    throw new tn(zy, "child not in parent");
  if (
    // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
    !$D(e) || // 5. If either `node` is a Text node and `parent` is a document,
    // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
    // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
    // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
    ti(e) && t.nodeType !== It.DOCUMENT_NODE
  )
    throw new tn(
      Ln,
      "Unexpected node type " + e.nodeType + " for parent node type " + t.nodeType
    );
}
function qD(t, e, n) {
  var r = t.childNodes || [], i = e.childNodes || [];
  if (e.nodeType === It.DOCUMENT_FRAGMENT_NODE) {
    var s = i.filter(kr);
    if (s.length > 1 || Ar(i, yf))
      throw new tn(Ln, "More than one element or text in fragment");
    if (s.length === 1 && !$p(t, n))
      throw new tn(Ln, "Element in fragment can not be inserted before doctype");
  }
  if (kr(e) && !$p(t, n))
    throw new tn(Ln, "Only one element can be added and only after doctype");
  if (ti(e)) {
    if (Ar(r, ti))
      throw new tn(Ln, "Only one doctype is allowed");
    var o = Ar(r, kr);
    if (n && r.indexOf(o) < r.indexOf(n))
      throw new tn(Ln, "Doctype can only be inserted before an element");
    if (!n && o)
      throw new tn(Ln, "Doctype can not be appended since element is present");
  }
}
function Wy(t, e, n) {
  var r = t.childNodes || [], i = e.childNodes || [];
  if (e.nodeType === It.DOCUMENT_FRAGMENT_NODE) {
    var s = i.filter(kr);
    if (s.length > 1 || Ar(i, yf))
      throw new tn(Ln, "More than one element or text in fragment");
    if (s.length === 1 && !Gp(t, n))
      throw new tn(Ln, "Element in fragment can not be inserted before doctype");
  }
  if (kr(e) && !Gp(t, n))
    throw new tn(Ln, "Only one element can be added and only after doctype");
  if (ti(e)) {
    if (Ar(r, function(l) {
      return ti(l) && l !== n;
    }))
      throw new tn(Ln, "Only one doctype is allowed");
    var o = Ar(r, kr);
    if (n && r.indexOf(o) < r.indexOf(n))
      throw new tn(Ln, "Doctype can only be inserted before an element");
  }
}
function xl(t, e, n, r) {
  GD(t, e, n), t.nodeType === It.DOCUMENT_NODE && (r || qD)(t, e, n);
  var i = e.parentNode;
  if (i && i.removeChild(e), e.nodeType === ei) {
    var s = e.firstChild;
    if (s == null)
      return e;
    var o = e.lastChild;
  } else
    s = o = e;
  var a = n ? n.previousSibling : t.lastChild;
  s.previousSibling = a, o.nextSibling = n, a ? a.nextSibling = s : t.firstChild = s, n == null ? t.lastChild = o : n.previousSibling = o;
  do
    s.parentNode = t;
  while (s !== o && (s = s.nextSibling));
  return mf(t.ownerDocument || t, t), e.nodeType == ei && (e.firstChild = e.lastChild = null), e;
}
function JD(t, e) {
  return e.parentNode && e.parentNode.removeChild(e), e.parentNode = t, e.previousSibling = t.lastChild, e.nextSibling = null, e.previousSibling ? e.previousSibling.nextSibling = e : t.firstChild = e, t.lastChild = e, mf(t.ownerDocument, t, e), e;
}
oa.prototype = {
  //implementation : null,
  nodeName: "#document",
  nodeType: My,
  /**
   * The DocumentType node of the document.
   *
   * @readonly
   * @type DocumentType
   */
  doctype: null,
  documentElement: null,
  _inc: 1,
  insertBefore: function(t, e) {
    if (t.nodeType == ei) {
      for (var n = t.firstChild; n; ) {
        var r = n.nextSibling;
        this.insertBefore(n, e), n = r;
      }
      return t;
    }
    return xl(this, t, e), t.ownerDocument = this, this.documentElement === null && t.nodeType === gr && (this.documentElement = t), t;
  },
  removeChild: function(t) {
    return this.documentElement == t && (this.documentElement = null), Vy(this, t);
  },
  replaceChild: function(t, e) {
    xl(this, t, e, Wy), t.ownerDocument = this, e && this.removeChild(e), kr(t) && (this.documentElement = t);
  },
  // Introduced in DOM Level 2:
  importNode: function(t, e) {
    return Jy(this, t, e);
  },
  // Introduced in DOM Level 2:
  getElementById: function(t) {
    var e = null;
    return jo(this.documentElement, function(n) {
      if (n.nodeType == gr && n.getAttribute("id") == t)
        return e = n, !0;
    }), e;
  },
  /**
   * The `getElementsByClassName` method of `Document` interface returns an array-like object
   * of all child elements which have **all** of the given class name(s).
   *
   * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
   *
   *
   * Warning: This is a live LiveNodeList.
   * Changes in the DOM will reflect in the array as the changes occur.
   * If an element selected by this array no longer qualifies for the selector,
   * it will automatically be removed. Be aware of this for iteration purposes.
   *
   * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
   * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
   */
  getElementsByClassName: function(t) {
    var e = Up(t);
    return new Ms(this, function(n) {
      var r = [];
      return e.length > 0 && jo(n.documentElement, function(i) {
        if (i !== n && i.nodeType === gr) {
          var s = i.getAttribute("class");
          if (s) {
            var o = t === s;
            if (!o) {
              var a = Up(s);
              o = e.every(HD(a));
            }
            o && r.push(i);
          }
        }
      }), r;
    });
  },
  //document factory method:
  createElement: function(t) {
    var e = new Wi();
    e.ownerDocument = this, e.nodeName = t, e.tagName = t, e.localName = t, e.childNodes = new Jr();
    var n = e.attributes = new El();
    return n._ownerElement = e, e;
  },
  createDocumentFragment: function() {
    var t = new nu();
    return t.ownerDocument = this, t.childNodes = new Jr(), t;
  },
  createTextNode: function(t) {
    var e = new bf();
    return e.ownerDocument = this, e.appendData(t), e;
  },
  createComment: function(t) {
    var e = new wf();
    return e.ownerDocument = this, e.appendData(t), e;
  },
  createCDATASection: function(t) {
    var e = new _f();
    return e.ownerDocument = this, e.appendData(t), e;
  },
  createProcessingInstruction: function(t, e) {
    var n = new Ef();
    return n.ownerDocument = this, n.tagName = n.target = t, n.nodeValue = n.data = e, n;
  },
  createAttribute: function(t) {
    var e = new Al();
    return e.ownerDocument = this, e.name = t, e.nodeName = t, e.localName = t, e.specified = !0, e;
  },
  createEntityReference: function(t) {
    var e = new Sf();
    return e.ownerDocument = this, e.nodeName = t, e;
  },
  // Introduced in DOM Level 2:
  createElementNS: function(t, e) {
    var n = new Wi(), r = e.split(":"), i = n.attributes = new El();
    return n.childNodes = new Jr(), n.ownerDocument = this, n.nodeName = e, n.tagName = e, n.namespaceURI = t, r.length == 2 ? (n.prefix = r[0], n.localName = r[1]) : n.localName = e, i._ownerElement = n, n;
  },
  // Introduced in DOM Level 2:
  createAttributeNS: function(t, e) {
    var n = new Al(), r = e.split(":");
    return n.ownerDocument = this, n.nodeName = e, n.name = e, n.namespaceURI = t, n.specified = !0, r.length == 2 ? (n.prefix = r[0], n.localName = r[1]) : n.localName = e, n;
  }
};
Un(oa, It);
function Wi() {
  this._nsMap = {};
}
Wi.prototype = {
  nodeType: gr,
  hasAttribute: function(t) {
    return this.getAttributeNode(t) != null;
  },
  getAttribute: function(t) {
    var e = this.getAttributeNode(t);
    return e && e.value || "";
  },
  getAttributeNode: function(t) {
    return this.attributes.getNamedItem(t);
  },
  setAttribute: function(t, e) {
    var n = this.ownerDocument.createAttribute(t);
    n.value = n.nodeValue = "" + e, this.setAttributeNode(n);
  },
  removeAttribute: function(t) {
    var e = this.getAttributeNode(t);
    e && this.removeAttributeNode(e);
  },
  //four real opeartion method
  appendChild: function(t) {
    return t.nodeType === ei ? this.insertBefore(t, null) : JD(this, t);
  },
  setAttributeNode: function(t) {
    return this.attributes.setNamedItem(t);
  },
  setAttributeNodeNS: function(t) {
    return this.attributes.setNamedItemNS(t);
  },
  removeAttributeNode: function(t) {
    return this.attributes.removeNamedItem(t.nodeName);
  },
  //get real attribute name,and remove it by removeAttributeNode
  removeAttributeNS: function(t, e) {
    var n = this.getAttributeNodeNS(t, e);
    n && this.removeAttributeNode(n);
  },
  hasAttributeNS: function(t, e) {
    return this.getAttributeNodeNS(t, e) != null;
  },
  getAttributeNS: function(t, e) {
    var n = this.getAttributeNodeNS(t, e);
    return n && n.value || "";
  },
  setAttributeNS: function(t, e, n) {
    var r = this.ownerDocument.createAttributeNS(t, e);
    r.value = r.nodeValue = "" + n, this.setAttributeNode(r);
  },
  getAttributeNodeNS: function(t, e) {
    return this.attributes.getNamedItemNS(t, e);
  },
  getElementsByTagName: function(t) {
    return new Ms(this, function(e) {
      var n = [];
      return jo(e, function(r) {
        r !== e && r.nodeType == gr && (t === "*" || r.tagName == t) && n.push(r);
      }), n;
    });
  },
  getElementsByTagNameNS: function(t, e) {
    return new Ms(this, function(n) {
      var r = [];
      return jo(n, function(i) {
        i !== n && i.nodeType === gr && (t === "*" || i.namespaceURI === t) && (e === "*" || i.localName == e) && r.push(i);
      }), r;
    });
  }
};
oa.prototype.getElementsByTagName = Wi.prototype.getElementsByTagName;
oa.prototype.getElementsByTagNameNS = Wi.prototype.getElementsByTagNameNS;
Un(Wi, It);
function Al() {
}
Al.prototype.nodeType = Ds;
Un(Al, It);
function aa() {
}
aa.prototype = {
  data: "",
  substringData: function(t, e) {
    return this.data.substring(t, t + e);
  },
  appendData: function(t) {
    t = this.data + t, this.nodeValue = this.data = t, this.length = t.length;
  },
  insertData: function(t, e) {
    this.replaceData(t, 0, e);
  },
  appendChild: function(t) {
    throw new Error(pn[Ln]);
  },
  deleteData: function(t, e) {
    this.replaceData(t, e, "");
  },
  replaceData: function(t, e, n) {
    var r = this.data.substring(0, t), i = this.data.substring(t + e);
    n = r + n + i, this.nodeValue = this.data = n, this.length = n.length;
  }
};
Un(aa, It);
function bf() {
}
bf.prototype = {
  nodeName: "#text",
  nodeType: Sl,
  splitText: function(t) {
    var e = this.data, n = e.substring(t);
    e = e.substring(0, t), this.data = this.nodeValue = e, this.length = e.length;
    var r = this.ownerDocument.createTextNode(n);
    return this.parentNode && this.parentNode.insertBefore(r, this.nextSibling), r;
  }
};
Un(bf, aa);
function wf() {
}
wf.prototype = {
  nodeName: "#comment",
  nodeType: Dy
};
Un(wf, aa);
function _f() {
}
_f.prototype = {
  nodeName: "#cdata-section",
  nodeType: Ry
};
Un(_f, aa);
function tu() {
}
tu.prototype.nodeType = Ly;
Un(tu, It);
function Ky() {
}
Ky.prototype.nodeType = VD;
Un(Ky, It);
function $y() {
}
$y.prototype.nodeType = UD;
Un($y, It);
function Sf() {
}
Sf.prototype.nodeType = Py;
Un(Sf, It);
function nu() {
}
nu.prototype.nodeName = "#document-fragment";
nu.prototype.nodeType = ei;
Un(nu, It);
function Ef() {
}
Ef.prototype.nodeType = By;
Un(Ef, It);
function Gy() {
}
Gy.prototype.serializeToString = function(t, e, n) {
  return qy.call(t, e, n);
};
It.prototype.toString = qy;
function qy(t, e) {
  var n = [], r = this.nodeType == 9 && this.documentElement || this, i = r.prefix, s = r.namespaceURI;
  if (s && i == null) {
    var i = r.lookupPrefix(s);
    if (i == null)
      var o = [
        { namespace: s, prefix: null }
        //{namespace:uri,prefix:''}
      ];
  }
  return bs(this, n, t, e, o), n.join("");
}
function qp(t, e, n) {
  var r = t.prefix || "", i = t.namespaceURI;
  if (!i || r === "xml" && i === zo.XML || i === zo.XMLNS)
    return !1;
  for (var s = n.length; s--; ) {
    var o = n[s];
    if (o.prefix === r)
      return o.namespace !== i;
  }
  return !0;
}
function Vu(t, e, n) {
  t.push(" ", e, '="', n.replace(/[<&"]/g, Hy), '"');
}
function bs(t, e, n, r, i) {
  if (i || (i = []), r)
    if (t = r(t), t) {
      if (typeof t == "string") {
        e.push(t);
        return;
      }
    } else
      return;
  switch (t.nodeType) {
    case gr:
      var s = t.attributes, o = s.length, f = t.firstChild, a = t.tagName;
      n = zo.isHTML(t.namespaceURI) || n;
      var l = a;
      if (!n && !t.prefix && t.namespaceURI) {
        for (var u, c = 0; c < s.length; c++)
          if (s.item(c).name === "xmlns") {
            u = s.item(c).value;
            break;
          }
        if (!u)
          for (var d = i.length - 1; d >= 0; d--) {
            var h = i[d];
            if (h.prefix === "" && h.namespace === t.namespaceURI) {
              u = h.namespace;
              break;
            }
          }
        if (u !== t.namespaceURI)
          for (var d = i.length - 1; d >= 0; d--) {
            var h = i[d];
            if (h.namespace === t.namespaceURI) {
              h.prefix && (l = h.prefix + ":" + a);
              break;
            }
          }
      }
      e.push("<", l);
      for (var v = 0; v < o; v++) {
        var y = s.item(v);
        y.prefix == "xmlns" ? i.push({ prefix: y.localName, namespace: y.value }) : y.nodeName == "xmlns" && i.push({ prefix: "", namespace: y.value });
      }
      for (var v = 0; v < o; v++) {
        var y = s.item(v);
        if (qp(y, n, i)) {
          var b = y.prefix || "", p = y.namespaceURI;
          Vu(e, b ? "xmlns:" + b : "xmlns", p), i.push({ prefix: b, namespace: p });
        }
        bs(y, e, n, r, i);
      }
      if (a === l && qp(t, n, i)) {
        var b = t.prefix || "", p = t.namespaceURI;
        Vu(e, b ? "xmlns:" + b : "xmlns", p), i.push({ prefix: b, namespace: p });
      }
      if (f || n && !/^(?:meta|link|img|br|hr|input)$/i.test(a)) {
        if (e.push(">"), n && /^script$/i.test(a))
          for (; f; )
            f.data ? e.push(f.data) : bs(f, e, n, r, i.slice()), f = f.nextSibling;
        else
          for (; f; )
            bs(f, e, n, r, i.slice()), f = f.nextSibling;
        e.push("</", l, ">");
      } else
        e.push("/>");
      return;
    case My:
    case ei:
      for (var f = t.firstChild; f; )
        bs(f, e, n, r, i.slice()), f = f.nextSibling;
      return;
    case Ds:
      return Vu(e, t.name, t.value);
    case Sl:
      return e.push(
        t.data.replace(/[<&]/g, Hy).replace(/]]>/g, "]]&gt;")
      );
    case Ry:
      return e.push("<![CDATA[", t.data, "]]>");
    case Dy:
      return e.push("<!--", t.data, "-->");
    case Ly:
      var g = t.publicId, m = t.systemId;
      if (e.push("<!DOCTYPE ", t.name), g)
        e.push(" PUBLIC ", g), m && m != "." && e.push(" ", m), e.push(">");
      else if (m && m != ".")
        e.push(" SYSTEM ", m, ">");
      else {
        var w = t.internalSubset;
        w && e.push(" [", w, "]"), e.push(">");
      }
      return;
    case By:
      return e.push("<?", t.target, " ", t.data, "?>");
    case Py:
      return e.push("&", t.nodeName, ";");
    default:
      e.push("??", t.nodeName);
  }
}
function Jy(t, e, n) {
  var r;
  switch (e.nodeType) {
    case gr:
      r = e.cloneNode(!1), r.ownerDocument = t;
    case ei:
      break;
    case Ds:
      n = !0;
      break;
  }
  if (r || (r = e.cloneNode(!1)), r.ownerDocument = t, r.parentNode = null, n)
    for (var i = e.firstChild; i; )
      r.appendChild(Jy(t, i, n)), i = i.nextSibling;
  return r;
}
function Xc(t, e, n) {
  var r = new e.constructor();
  for (var i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      var s = e[i];
      typeof s != "object" && s != r[i] && (r[i] = s);
    }
  switch (e.childNodes && (r.childNodes = new Jr()), r.ownerDocument = t, r.nodeType) {
    case gr:
      var o = e.attributes, a = r.attributes = new El(), l = o.length;
      a._ownerElement = r;
      for (var u = 0; u < l; u++)
        r.setAttributeNode(Xc(t, o.item(u), !0));
      break;
    case Ds:
      n = !0;
  }
  if (n)
    for (var c = e.firstChild; c; )
      r.appendChild(Xc(t, c, n)), c = c.nextSibling;
  return r;
}
function Yy(t, e, n) {
  t[e] = n;
}
try {
  if (Object.defineProperty) {
    let t = function(e) {
      switch (e.nodeType) {
        case gr:
        case ei:
          var n = [];
          for (e = e.firstChild; e; )
            e.nodeType !== 7 && e.nodeType !== 8 && n.push(t(e)), e = e.nextSibling;
          return n.join("");
        default:
          return e.nodeValue;
      }
    };
    Object.defineProperty(Ms.prototype, "length", {
      get: function() {
        return gf(this), this.$$length;
      }
    }), Object.defineProperty(It.prototype, "textContent", {
      get: function() {
        return t(this);
      },
      set: function(e) {
        switch (this.nodeType) {
          case gr:
          case ei:
            for (; this.firstChild; )
              this.removeChild(this.firstChild);
            (e || String(e)) && this.appendChild(this.ownerDocument.createTextNode(e));
            break;
          default:
            this.data = e, this.value = e, this.nodeValue = e;
        }
      }
    }), Yy = function(e, n, r) {
      e["$$" + n] = r;
    };
  }
} catch {
}
xi.DocumentType = tu;
xi.DOMException = tn;
xi.DOMImplementation = Fy;
xi.Element = Wi;
xi.Node = It;
xi.NodeList = Jr;
xi.XMLSerializer = Gy;
var la = {}, Qy = {};
(function(t) {
  var e = Ai.freeze;
  t.XML_ENTITIES = e({ amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' }), t.HTML_ENTITIES = e({
    lt: "<",
    gt: ">",
    amp: "&",
    quot: '"',
    apos: "'",
    Agrave: "À",
    Aacute: "Á",
    Acirc: "Â",
    Atilde: "Ã",
    Auml: "Ä",
    Aring: "Å",
    AElig: "Æ",
    Ccedil: "Ç",
    Egrave: "È",
    Eacute: "É",
    Ecirc: "Ê",
    Euml: "Ë",
    Igrave: "Ì",
    Iacute: "Í",
    Icirc: "Î",
    Iuml: "Ï",
    ETH: "Ð",
    Ntilde: "Ñ",
    Ograve: "Ò",
    Oacute: "Ó",
    Ocirc: "Ô",
    Otilde: "Õ",
    Ouml: "Ö",
    Oslash: "Ø",
    Ugrave: "Ù",
    Uacute: "Ú",
    Ucirc: "Û",
    Uuml: "Ü",
    Yacute: "Ý",
    THORN: "Þ",
    szlig: "ß",
    agrave: "à",
    aacute: "á",
    acirc: "â",
    atilde: "ã",
    auml: "ä",
    aring: "å",
    aelig: "æ",
    ccedil: "ç",
    egrave: "è",
    eacute: "é",
    ecirc: "ê",
    euml: "ë",
    igrave: "ì",
    iacute: "í",
    icirc: "î",
    iuml: "ï",
    eth: "ð",
    ntilde: "ñ",
    ograve: "ò",
    oacute: "ó",
    ocirc: "ô",
    otilde: "õ",
    ouml: "ö",
    oslash: "ø",
    ugrave: "ù",
    uacute: "ú",
    ucirc: "û",
    uuml: "ü",
    yacute: "ý",
    thorn: "þ",
    yuml: "ÿ",
    nbsp: " ",
    iexcl: "¡",
    cent: "¢",
    pound: "£",
    curren: "¤",
    yen: "¥",
    brvbar: "¦",
    sect: "§",
    uml: "¨",
    copy: "©",
    ordf: "ª",
    laquo: "«",
    not: "¬",
    shy: "­­",
    reg: "®",
    macr: "¯",
    deg: "°",
    plusmn: "±",
    sup2: "²",
    sup3: "³",
    acute: "´",
    micro: "µ",
    para: "¶",
    middot: "·",
    cedil: "¸",
    sup1: "¹",
    ordm: "º",
    raquo: "»",
    frac14: "¼",
    frac12: "½",
    frac34: "¾",
    iquest: "¿",
    times: "×",
    divide: "÷",
    forall: "∀",
    part: "∂",
    exist: "∃",
    empty: "∅",
    nabla: "∇",
    isin: "∈",
    notin: "∉",
    ni: "∋",
    prod: "∏",
    sum: "∑",
    minus: "−",
    lowast: "∗",
    radic: "√",
    prop: "∝",
    infin: "∞",
    ang: "∠",
    and: "∧",
    or: "∨",
    cap: "∩",
    cup: "∪",
    int: "∫",
    there4: "∴",
    sim: "∼",
    cong: "≅",
    asymp: "≈",
    ne: "≠",
    equiv: "≡",
    le: "≤",
    ge: "≥",
    sub: "⊂",
    sup: "⊃",
    nsub: "⊄",
    sube: "⊆",
    supe: "⊇",
    oplus: "⊕",
    otimes: "⊗",
    perp: "⊥",
    sdot: "⋅",
    Alpha: "Α",
    Beta: "Β",
    Gamma: "Γ",
    Delta: "Δ",
    Epsilon: "Ε",
    Zeta: "Ζ",
    Eta: "Η",
    Theta: "Θ",
    Iota: "Ι",
    Kappa: "Κ",
    Lambda: "Λ",
    Mu: "Μ",
    Nu: "Ν",
    Xi: "Ξ",
    Omicron: "Ο",
    Pi: "Π",
    Rho: "Ρ",
    Sigma: "Σ",
    Tau: "Τ",
    Upsilon: "Υ",
    Phi: "Φ",
    Chi: "Χ",
    Psi: "Ψ",
    Omega: "Ω",
    alpha: "α",
    beta: "β",
    gamma: "γ",
    delta: "δ",
    epsilon: "ε",
    zeta: "ζ",
    eta: "η",
    theta: "θ",
    iota: "ι",
    kappa: "κ",
    lambda: "λ",
    mu: "μ",
    nu: "ν",
    xi: "ξ",
    omicron: "ο",
    pi: "π",
    rho: "ρ",
    sigmaf: "ς",
    sigma: "σ",
    tau: "τ",
    upsilon: "υ",
    phi: "φ",
    chi: "χ",
    psi: "ψ",
    omega: "ω",
    thetasym: "ϑ",
    upsih: "ϒ",
    piv: "ϖ",
    OElig: "Œ",
    oelig: "œ",
    Scaron: "Š",
    scaron: "š",
    Yuml: "Ÿ",
    fnof: "ƒ",
    circ: "ˆ",
    tilde: "˜",
    ensp: " ",
    emsp: " ",
    thinsp: " ",
    zwnj: "‌",
    zwj: "‍",
    lrm: "‎",
    rlm: "‏",
    ndash: "–",
    mdash: "—",
    lsquo: "‘",
    rsquo: "’",
    sbquo: "‚",
    ldquo: "“",
    rdquo: "”",
    bdquo: "„",
    dagger: "†",
    Dagger: "‡",
    bull: "•",
    hellip: "…",
    permil: "‰",
    prime: "′",
    Prime: "″",
    lsaquo: "‹",
    rsaquo: "›",
    oline: "‾",
    euro: "€",
    trade: "™",
    larr: "←",
    uarr: "↑",
    rarr: "→",
    darr: "↓",
    harr: "↔",
    crarr: "↵",
    lceil: "⌈",
    rceil: "⌉",
    lfloor: "⌊",
    rfloor: "⌋",
    loz: "◊",
    spades: "♠",
    clubs: "♣",
    hearts: "♥",
    diams: "♦"
  }), t.entityMap = t.HTML_ENTITIES;
})(Qy);
var xf = {}, Fo = Ai.NAMESPACE, ed = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, Jp = new RegExp("[\\-\\.0-9" + ed.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"), Yp = new RegExp("^" + ed.source + Jp.source + "*(?::" + ed.source + Jp.source + "*)?$"), Zs = 0, li = 1, as = 2, Xs = 3, ls = 4, us = 5, eo = 6, Na = 7;
function Ls(t, e) {
  this.message = t, this.locator = e, Error.captureStackTrace && Error.captureStackTrace(this, Ls);
}
Ls.prototype = new Error();
Ls.prototype.name = Ls.name;
function Zy() {
}
Zy.prototype = {
  parse: function(t, e, n) {
    var r = this.domBuilder;
    r.startDocument(), Xy(e, e = {}), YD(
      t,
      e,
      n,
      r,
      this.errorHandler
    ), r.endDocument();
  }
};
function YD(t, e, n, r, i) {
  function s(X) {
    if (X > 65535) {
      X -= 65536;
      var z = 55296 + (X >> 10), U = 56320 + (X & 1023);
      return String.fromCharCode(z, U);
    } else
      return String.fromCharCode(X);
  }
  function o(X) {
    var z = X.slice(1, -1);
    return z in n ? n[z] : z.charAt(0) === "#" ? s(parseInt(z.substr(1).replace("x", "0x"))) : (i.error("entity not found:" + X), X);
  }
  function a(X) {
    if (X > b) {
      var z = t.substring(b, X).replace(/&#?\w+;/g, o);
      h && l(b), r.characters(z, 0, X - b), b = X;
    }
  }
  function l(X, z) {
    for (; X >= c && (z = d.exec(t)); )
      u = z.index, c = u + z[0].length, h.lineNumber++;
    h.columnNumber = X - u + 1;
  }
  for (var u = 0, c = 0, d = /.*(?:\r\n?|\n)|.*$/g, h = r.locator, v = [{ currentNSMap: e }], y = {}, b = 0; ; ) {
    try {
      var p = t.indexOf("<", b);
      if (p < 0) {
        if (!t.substr(b).match(/^\s*$/)) {
          var f = r.doc, g = f.createTextNode(t.substr(b));
          f.appendChild(g), r.currentElement = g;
        }
        return;
      }
      switch (p > b && a(p), t.charAt(p + 1)) {
        case "/":
          var N = t.indexOf(">", p + 3), m = t.substring(p + 2, N).replace(/[ \t\n\r]+$/g, ""), w = v.pop();
          N < 0 ? (m = t.substring(p + 2).replace(/[\s<].*/, ""), i.error("end tag name: " + m + " is not complete:" + w.tagName), N = p + 1 + m.length) : m.match(/\s</) && (m = m.replace(/[\s<].*/, ""), i.error("end tag name: " + m + " maybe not complete"), N = p + 1 + m.length);
          var _ = w.localNSMap, S = w.tagName == m, A = S || w.tagName && w.tagName.toLowerCase() == m.toLowerCase();
          if (A) {
            if (r.endElement(w.uri, w.localName, m), _)
              for (var C in _)
                Object.prototype.hasOwnProperty.call(_, C) && r.endPrefixMapping(C);
            S || i.fatalError("end tag name: " + m + " is not match the current start tagName:" + w.tagName);
          } else
            v.push(w);
          N++;
          break;
        case "?":
          h && l(p), N = t8(t, p, r);
          break;
        case "!":
          h && l(p), N = e8(t, p, r, i);
          break;
        default:
          h && l(p);
          var k = new e0(), O = v[v.length - 1].currentNSMap, N = QD(t, p, k, O, o, i), B = k.length;
          if (!k.closed && XD(t, N, k.tagName, y) && (k.closed = !0, n.nbsp || i.warning("unclosed xml attribute")), h && B) {
            for (var M = Qp(h, {}), j = 0; j < B; j++) {
              var q = k[j];
              l(q.offset), q.locator = Qp(h, {});
            }
            r.locator = M, Zp(k, r, O) && v.push(k), r.locator = h;
          } else
            Zp(k, r, O) && v.push(k);
          Fo.isHTML(k.uri) && !k.closed ? N = ZD(t, N, k.tagName, o, r) : N++;
      }
    } catch (X) {
      if (X instanceof Ls)
        throw X;
      i.error("element parse error: " + X), N = -1;
    }
    N > b ? b = N : a(Math.max(p, b) + 1);
  }
}
function Qp(t, e) {
  return e.lineNumber = t.lineNumber, e.columnNumber = t.columnNumber, e;
}
function QD(t, e, n, r, i, s) {
  function o(h, v, y) {
    n.attributeNames.hasOwnProperty(h) && s.fatalError("Attribute " + h + " redefined"), n.addValue(h, v, y);
  }
  for (var a, l, u = ++e, c = Zs; ; ) {
    var d = t.charAt(u);
    switch (d) {
      case "=":
        if (c === li)
          a = t.slice(e, u), c = Xs;
        else if (c === as)
          c = Xs;
        else
          throw new Error("attribute equal must after attrName");
        break;
      case "'":
      case '"':
        if (c === Xs || c === li)
          if (c === li && (s.warning('attribute value must after "="'), a = t.slice(e, u)), e = u + 1, u = t.indexOf(d, e), u > 0)
            l = t.slice(e, u).replace(/&#?\w+;/g, i), o(a, l, e - 1), c = us;
          else
            throw new Error("attribute value no end '" + d + "' match");
        else if (c == ls)
          l = t.slice(e, u).replace(/&#?\w+;/g, i), o(a, l, e), s.warning('attribute "' + a + '" missed start quot(' + d + ")!!"), e = u + 1, c = us;
        else
          throw new Error('attribute value must after "="');
        break;
      case "/":
        switch (c) {
          case Zs:
            n.setTagName(t.slice(e, u));
          case us:
          case eo:
          case Na:
            c = Na, n.closed = !0;
          case ls:
          case li:
            break;
          case as:
            n.closed = !0;
            break;
          default:
            throw new Error("attribute invalid close char('/')");
        }
        break;
      case "":
        return s.error("unexpected end of input"), c == Zs && n.setTagName(t.slice(e, u)), u;
      case ">":
        switch (c) {
          case Zs:
            n.setTagName(t.slice(e, u));
          case us:
          case eo:
          case Na:
            break;
          case ls:
          case li:
            l = t.slice(e, u), l.slice(-1) === "/" && (n.closed = !0, l = l.slice(0, -1));
          case as:
            c === as && (l = a), c == ls ? (s.warning('attribute "' + l + '" missed quot(")!'), o(a, l.replace(/&#?\w+;/g, i), e)) : ((!Fo.isHTML(r[""]) || !l.match(/^(?:disabled|checked|selected)$/i)) && s.warning('attribute "' + l + '" missed value!! "' + l + '" instead!!'), o(l, l, e));
            break;
          case Xs:
            throw new Error("attribute value missed!!");
        }
        return u;
      case "":
        d = " ";
      default:
        if (d <= " ")
          switch (c) {
            case Zs:
              n.setTagName(t.slice(e, u)), c = eo;
              break;
            case li:
              a = t.slice(e, u), c = as;
              break;
            case ls:
              var l = t.slice(e, u).replace(/&#?\w+;/g, i);
              s.warning('attribute "' + l + '" missed quot(")!!'), o(a, l, e);
            case us:
              c = eo;
              break;
          }
        else
          switch (c) {
            case as:
              n.tagName, (!Fo.isHTML(r[""]) || !a.match(/^(?:disabled|checked|selected)$/i)) && s.warning('attribute "' + a + '" missed value!! "' + a + '" instead2!!'), o(a, a, e), e = u, c = li;
              break;
            case us:
              s.warning('attribute space is required"' + a + '"!!');
            case eo:
              c = li, e = u;
              break;
            case Xs:
              c = ls, e = u;
              break;
            case Na:
              throw new Error("elements closed character '/' and '>' must be connected to");
          }
    }
    u++;
  }
}
function Zp(t, e, n) {
  for (var r = t.tagName, i = null, d = t.length; d--; ) {
    var s = t[d], o = s.qName, a = s.value, h = o.indexOf(":");
    if (h > 0)
      var l = s.prefix = o.slice(0, h), u = o.slice(h + 1), c = l === "xmlns" && u;
    else
      u = o, l = null, c = o === "xmlns" && "";
    s.localName = u, c !== !1 && (i == null && (i = {}, Xy(n, n = {})), n[c] = i[c] = a, s.uri = Fo.XMLNS, e.startPrefixMapping(c, a));
  }
  for (var d = t.length; d--; ) {
    s = t[d];
    var l = s.prefix;
    l && (l === "xml" && (s.uri = Fo.XML), l !== "xmlns" && (s.uri = n[l || ""]));
  }
  var h = r.indexOf(":");
  h > 0 ? (l = t.prefix = r.slice(0, h), u = t.localName = r.slice(h + 1)) : (l = null, u = t.localName = r);
  var v = t.uri = n[l || ""];
  if (e.startElement(v, u, r, t), t.closed) {
    if (e.endElement(v, u, r), i)
      for (l in i)
        Object.prototype.hasOwnProperty.call(i, l) && e.endPrefixMapping(l);
  } else
    return t.currentNSMap = n, t.localNSMap = i, !0;
}
function ZD(t, e, n, r, i) {
  if (/^(?:script|textarea)$/i.test(n)) {
    var s = t.indexOf("</" + n + ">", e), o = t.substring(e + 1, s);
    if (/[&<]/.test(o))
      return /^script$/i.test(n) ? (i.characters(o, 0, o.length), s) : (o = o.replace(/&#?\w+;/g, r), i.characters(o, 0, o.length), s);
  }
  return e + 1;
}
function XD(t, e, n, r) {
  var i = r[n];
  return i == null && (i = t.lastIndexOf("</" + n + ">"), i < e && (i = t.lastIndexOf("</" + n)), r[n] = i), i < e;
}
function Xy(t, e) {
  for (var n in t)
    Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
}
function e8(t, e, n, r) {
  var i = t.charAt(e + 2);
  switch (i) {
    case "-":
      if (t.charAt(e + 3) === "-") {
        var s = t.indexOf("-->", e + 4);
        return s > e ? (n.comment(t, e + 4, s - e - 4), s + 3) : (r.error("Unclosed comment"), -1);
      } else
        return -1;
    default:
      if (t.substr(e + 3, 6) == "CDATA[") {
        var s = t.indexOf("]]>", e + 9);
        return n.startCDATA(), n.characters(t, e + 9, s - e - 9), n.endCDATA(), s + 3;
      }
      var o = n8(t, e), a = o.length;
      if (a > 1 && /!doctype/i.test(o[0][0])) {
        var l = o[1][0], u = !1, c = !1;
        a > 3 && (/^public$/i.test(o[2][0]) ? (u = o[3][0], c = a > 4 && o[4][0]) : /^system$/i.test(o[2][0]) && (c = o[3][0]));
        var d = o[a - 1];
        return n.startDTD(l, u, c), n.endDTD(), d.index + d[0].length;
      }
  }
  return -1;
}
function t8(t, e, n) {
  var r = t.indexOf("?>", e);
  if (r) {
    var i = t.substring(e, r).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
    return i ? (i[0].length, n.processingInstruction(i[1], i[2]), r + 2) : -1;
  }
  return -1;
}
function e0() {
  this.attributeNames = {};
}
e0.prototype = {
  setTagName: function(t) {
    if (!Yp.test(t))
      throw new Error("invalid tagName:" + t);
    this.tagName = t;
  },
  addValue: function(t, e, n) {
    if (!Yp.test(t))
      throw new Error("invalid attribute:" + t);
    this.attributeNames[t] = this.length, this[this.length++] = { qName: t, value: e, offset: n };
  },
  length: 0,
  getLocalName: function(t) {
    return this[t].localName;
  },
  getLocator: function(t) {
    return this[t].locator;
  },
  getQName: function(t) {
    return this[t].qName;
  },
  getURI: function(t) {
    return this[t].uri;
  },
  getValue: function(t) {
    return this[t].value;
  }
  //	,getIndex:function(uri, localName)){
  //		if(localName){
  //
  //		}else{
  //			var qName = uri
  //		}
  //	},
  //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
  //	getType:function(uri,localName){}
  //	getType:function(i){},
};
function n8(t, e) {
  var n, r = [], i = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
  for (i.lastIndex = e, i.exec(t); n = i.exec(t); )
    if (r.push(n), n[1])
      return r;
}
xf.XMLReader = Zy;
xf.ParseError = Ls;
var r8 = Ai, Af = xi, Xp = Qy, t0 = xf, i8 = Af.DOMImplementation, ev = r8.NAMESPACE, s8 = t0.ParseError, o8 = t0.XMLReader;
function n0(t) {
  this.options = t || { locator: {} };
}
n0.prototype.parseFromString = function(t, e) {
  var n = this.options, r = new o8(), i = n.domBuilder || new ua(), s = n.errorHandler, o = n.locator, a = n.xmlns || {}, l = /\/x?html?$/.test(e), u = l ? Xp.HTML_ENTITIES : Xp.XML_ENTITIES;
  return o && i.setDocumentLocator(o), r.errorHandler = a8(s, i, o), r.domBuilder = n.domBuilder || i, l && (a[""] = ev.HTML), a.xml = a.xml || ev.XML, t && typeof t == "string" ? r.parse(t, a, u) : r.errorHandler.error("invalid doc source"), i.doc;
};
function a8(t, e, n) {
  if (!t) {
    if (e instanceof ua)
      return e;
    t = e;
  }
  var r = {}, i = t instanceof Function;
  n = n || {};
  function s(o) {
    var a = t[o];
    !a && i && (a = t.length == 2 ? function(l) {
      t(o, l);
    } : t), r[o] = a && function(l) {
      a("[xmldom " + o + "]	" + l + td(n));
    } || function() {
    };
  }
  return s("warning"), s("error"), s("fatalError"), r;
}
function ua() {
  this.cdata = !1;
}
function cs(t, e) {
  e.lineNumber = t.lineNumber, e.columnNumber = t.columnNumber;
}
ua.prototype = {
  startDocument: function() {
    this.doc = new i8().createDocument(null, null, null), this.locator && (this.doc.documentURI = this.locator.systemId);
  },
  startElement: function(t, e, n, r) {
    var i = this.doc, s = i.createElementNS(t, n || e), o = r.length;
    Ra(this, s), this.currentElement = s, this.locator && cs(this.locator, s);
    for (var a = 0; a < o; a++) {
      var t = r.getURI(a), l = r.getValue(a), n = r.getQName(a), u = i.createAttributeNS(t, n);
      this.locator && cs(r.getLocator(a), u), u.value = u.nodeValue = l, s.setAttributeNode(u);
    }
  },
  endElement: function(t, e, n) {
    var r = this.currentElement;
    r.tagName, this.currentElement = r.parentNode;
  },
  startPrefixMapping: function(t, e) {
  },
  endPrefixMapping: function(t) {
  },
  processingInstruction: function(t, e) {
    var n = this.doc.createProcessingInstruction(t, e);
    this.locator && cs(this.locator, n), Ra(this, n);
  },
  ignorableWhitespace: function(t, e, n) {
  },
  characters: function(t, e, n) {
    if (t = tv.apply(this, arguments), t) {
      if (this.cdata)
        var r = this.doc.createCDATASection(t);
      else
        var r = this.doc.createTextNode(t);
      this.currentElement ? this.currentElement.appendChild(r) : /^\s*$/.test(t) && this.doc.appendChild(r), this.locator && cs(this.locator, r);
    }
  },
  skippedEntity: function(t) {
  },
  endDocument: function() {
    this.doc.normalize();
  },
  setDocumentLocator: function(t) {
    (this.locator = t) && (t.lineNumber = 0);
  },
  //LexicalHandler
  comment: function(t, e, n) {
    t = tv.apply(this, arguments);
    var r = this.doc.createComment(t);
    this.locator && cs(this.locator, r), Ra(this, r);
  },
  startCDATA: function() {
    this.cdata = !0;
  },
  endCDATA: function() {
    this.cdata = !1;
  },
  startDTD: function(t, e, n) {
    var r = this.doc.implementation;
    if (r && r.createDocumentType) {
      var i = r.createDocumentType(t, e, n);
      this.locator && cs(this.locator, i), Ra(this, i), this.doc.doctype = i;
    }
  },
  /**
   * @see org.xml.sax.ErrorHandler
   * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
   */
  warning: function(t) {
    console.warn("[xmldom warning]	" + t, td(this.locator));
  },
  error: function(t) {
    console.error("[xmldom error]	" + t, td(this.locator));
  },
  fatalError: function(t) {
    throw new s8(t, this.locator);
  }
};
function td(t) {
  if (t)
    return `
@` + (t.systemId || "") + "#[line:" + t.lineNumber + ",col:" + t.columnNumber + "]";
}
function tv(t, e, n) {
  return typeof t == "string" ? t.substr(e, n) : t.length >= e + n || e ? new java.lang.String(t, e, n) + "" : t;
}
"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(t) {
  ua.prototype[t] = function() {
    return null;
  };
});
function Ra(t, e) {
  t.currentElement ? t.currentElement.appendChild(e) : t.doc.appendChild(e);
}
la.__DOMHandler = ua;
la.DOMParser = n0;
la.DOMImplementation = Af.DOMImplementation;
la.XMLSerializer = Af.XMLSerializer;
var r0 = la.DOMParser;
const kf = typeof window < "u" ? window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame : !1, l8 = 1, u8 = 3, i0 = typeof URL < "u" ? URL : typeof window < "u" ? window.URL || window.webkitURL || window.mozURL : void 0;
function ru() {
  var t = (/* @__PURE__ */ new Date()).getTime(), e = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(n) {
    var r = (t + Math.random() * 16) % 16 | 0;
    return t = Math.floor(t / 16), (n == "x" ? r : r & 7 | 8).toString(16);
  });
  return e;
}
function c8() {
  return Math.max(
    document.documentElement.clientHeight,
    document.body.scrollHeight,
    document.documentElement.scrollHeight,
    document.body.offsetHeight,
    document.documentElement.offsetHeight
  );
}
function s0(t) {
  return !!(t && t.nodeType == 1);
}
function Yt(t) {
  return !isNaN(parseFloat(t)) && isFinite(t);
}
function o0(t) {
  let e = parseFloat(t);
  return Yt(t) === !1 ? !1 : typeof t == "string" && t.indexOf(".") > -1 ? !0 : Math.floor(e) !== e;
}
function vs(t) {
  var e = ["Webkit", "webkit", "Moz", "O", "ms"], n = ["-webkit-", "-webkit-", "-moz-", "-o-", "-ms-"], r = t.toLowerCase(), i = e.length;
  if (typeof document > "u" || typeof document.body.style[r] < "u")
    return t;
  for (var s = 0; s < i; s++)
    if (typeof document.body.style[n[s] + r] < "u")
      return n[s] + r;
  return t;
}
function a0(t) {
  for (var e = 1, n = arguments.length; e < n; e++) {
    var r = arguments[e];
    for (var i in r)
      t[i] === void 0 && (t[i] = r[i]);
  }
  return t;
}
function Sn(t) {
  var e = [].slice.call(arguments, 1);
  return e.forEach(function(n) {
    n && Object.getOwnPropertyNames(n).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }), t;
}
function d8(t, e, n) {
  var r = zs(t, e, n);
  return e.splice(r, 0, t), r;
}
function zs(t, e, n, r, i) {
  var s = r || 0, o = i || e.length, a = parseInt(s + (o - s) / 2), l;
  return n || (n = function(u, c) {
    if (u > c)
      return 1;
    if (u < c)
      return -1;
    if (u == c)
      return 0;
  }), o - s <= 0 ? a : (l = n(e[a], t), o - s === 1 ? l >= 0 ? a : a + 1 : l === 0 ? a : l === -1 ? zs(t, e, n, a, o) : zs(t, e, n, s, a));
}
function kl(t, e, n, r, i) {
  var s = r || 0, o = i || e.length, a = parseInt(s + (o - s) / 2), l;
  return n || (n = function(u, c) {
    if (u > c)
      return 1;
    if (u < c)
      return -1;
    if (u == c)
      return 0;
  }), o - s <= 0 ? -1 : (l = n(e[a], t), o - s === 1 ? l === 0 ? a : -1 : l === 0 ? a : l === -1 ? kl(t, e, n, a, o) : kl(t, e, n, s, a));
}
function Xa(t) {
  var e = window.getComputedStyle(t), n = ["width", "paddingRight", "paddingLeft", "marginRight", "marginLeft", "borderRightWidth", "borderLeftWidth"], r = ["height", "paddingTop", "paddingBottom", "marginTop", "marginBottom", "borderTopWidth", "borderBottomWidth"], i = 0, s = 0;
  return n.forEach(function(o) {
    i += parseFloat(e[o]) || 0;
  }), r.forEach(function(o) {
    s += parseFloat(e[o]) || 0;
  }), {
    height: s,
    width: i
  };
}
function Cl(t) {
  var e = window.getComputedStyle(t), n = ["paddingRight", "paddingLeft", "marginRight", "marginLeft", "borderRightWidth", "borderLeftWidth"], r = ["paddingTop", "paddingBottom", "marginTop", "marginBottom", "borderTopWidth", "borderBottomWidth"], i = 0, s = 0;
  return n.forEach(function(o) {
    i += parseFloat(e[o]) || 0;
  }), r.forEach(function(o) {
    s += parseFloat(e[o]) || 0;
  }), {
    height: s,
    width: i
  };
}
function nd(t) {
  let e, n = t.ownerDocument;
  if (t.nodeType == Node.TEXT_NODE) {
    let r = n.createRange();
    r.selectNodeContents(t), e = r.getBoundingClientRect();
  } else
    e = t.getBoundingClientRect();
  return e;
}
function Tl() {
  var t = window.innerWidth, e = window.innerHeight;
  return {
    top: 0,
    left: 0,
    right: t,
    bottom: e,
    width: t,
    height: e
  };
}
function Cf(t, e) {
  for (var n = t.parentNode, r = n.childNodes, i, s = -1, o = 0; o < r.length && (i = r[o], i.nodeType === e && s++, i != t); o++)
    ;
  return s;
}
function f8(t) {
  return Cf(t, u8);
}
function l0(t) {
  return Cf(t, l8);
}
function Ho(t) {
  return ["xml", "opf", "ncx"].indexOf(t) > -1;
}
function u0(t, e) {
  return new Blob([t], { type: e });
}
function Ol(t, e) {
  var n, r = u0(t, e);
  return n = i0.createObjectURL(r), n;
}
function c0(t) {
  return i0.revokeObjectURL(t);
}
function rd(t, e) {
  var n, r;
  if (typeof t == "string")
    return n = btoa(t), r = "data:" + e + ";base64," + n, r;
}
function d0(t) {
  return Object.prototype.toString.call(t).slice(8, -1);
}
function Cr(t, e, n) {
  var r, i;
  return typeof DOMParser > "u" || n ? i = r0 : i = DOMParser, t.charCodeAt(0) === 65279 && (t = t.slice(1)), r = new i().parseFromString(t, e), r;
}
function zt(t, e) {
  var n;
  if (!t)
    throw new Error("No Element Provided");
  if (typeof t.querySelector < "u")
    return t.querySelector(e);
  if (n = t.getElementsByTagName(e), n.length)
    return n[0];
}
function ni(t, e) {
  return typeof t.querySelector < "u" ? t.querySelectorAll(e) : t.getElementsByTagName(e);
}
function gs(t, e, n) {
  var r, i;
  if (typeof t.querySelector < "u") {
    e += "[";
    for (var s in n)
      e += s + "~='" + n[s] + "'";
    return e += "]", t.querySelector(e);
  } else if (r = t.getElementsByTagName(e), i = Array.prototype.slice.call(r, 0).filter(function(o) {
    for (var a in n)
      if (o.getAttribute(a) === n[a])
        return !0;
    return !1;
  }), i)
    return i[0];
}
function Il(t, e) {
  var n = t.ownerDocument || t;
  typeof n.createTreeWalker < "u" ? f0(t, e, NodeFilter.SHOW_TEXT) : Tf(t, function(r) {
    r && r.nodeType === 3 && e(r);
  });
}
function f0(t, e, n) {
  var r = document.createTreeWalker(t, n, null, !1);
  let i;
  for (; i = r.nextNode(); )
    e(i);
}
function Tf(t, e) {
  if (e(t))
    return !0;
  if (t = t.firstChild, t)
    do {
      if (Tf(t, e))
        return !0;
      t = t.nextSibling;
    } while (t);
}
function h0(t) {
  return new Promise(function(e, n) {
    var r = new FileReader();
    r.readAsDataURL(t), r.onloadend = function() {
      e(r.result);
    };
  });
}
function vt() {
  this.resolve = null, this.reject = null, this.id = ru(), this.promise = new Promise((t, e) => {
    this.resolve = t, this.reject = e;
  }), Object.freeze(this);
}
function Nl(t, e, n) {
  var r;
  if (typeof t.querySelector < "u" && (r = t.querySelector(`${e}[*|type="${n}"]`)), !r || r.length === 0) {
    r = ni(t, e);
    for (var i = 0; i < r.length; i++)
      if (r[i].getAttributeNS("http://www.idpf.org/2007/ops", "type") === n || r[i].getAttribute("epub:type") === n)
        return r[i];
  } else
    return r;
}
function id(t) {
  for (var e = [], n = t.childNodes, r = 0; r < n.length; r++) {
    let i = n[r];
    i.nodeType === 1 && e.push(i);
  }
  return e;
}
function sd(t) {
  for (var e = [t]; t; t = t.parentNode)
    e.unshift(t);
  return e;
}
function ms(t, e, n) {
  for (var r = [], i = t.childNodes, s = 0; s < i.length; s++) {
    let o = i[s];
    if (o.nodeType === 1 && o.nodeName.toLowerCase() === e) {
      if (n)
        return o;
      r.push(o);
    }
  }
  if (!n)
    return r;
}
function h8(t, e) {
  let n;
  if (!(t === null || e === ""))
    for (n = t.parentNode; n.nodeType === 1; ) {
      if (n.tagName.toLowerCase() === e)
        return n;
      n = n.parentNode;
    }
}
class p0 {
  constructor() {
    this.collapsed = !1, this.commonAncestorContainer = void 0, this.endContainer = void 0, this.endOffset = void 0, this.startContainer = void 0, this.startOffset = void 0;
  }
  setStart(e, n) {
    this.startContainer = e, this.startOffset = n, this.endContainer ? this.commonAncestorContainer = this._commonAncestorContainer() : this.collapse(!0), this._checkCollapsed();
  }
  setEnd(e, n) {
    this.endContainer = e, this.endOffset = n, this.startContainer ? (this.collapsed = !1, this.commonAncestorContainer = this._commonAncestorContainer()) : this.collapse(!1), this._checkCollapsed();
  }
  collapse(e) {
    this.collapsed = !0, e ? (this.endContainer = this.startContainer, this.endOffset = this.startOffset, this.commonAncestorContainer = this.startContainer.parentNode) : (this.startContainer = this.endContainer, this.startOffset = this.endOffset, this.commonAncestorContainer = this.endOffset.parentNode);
  }
  selectNode(e) {
    let n = e.parentNode, r = Array.prototype.indexOf.call(n.childNodes, e);
    this.setStart(n, r), this.setEnd(n, r + 1);
  }
  selectNodeContents(e) {
    e.childNodes[e.childNodes - 1];
    let n = e.nodeType === 3 ? e.textContent.length : parent.childNodes.length;
    this.setStart(e, 0), this.setEnd(e, n);
  }
  _commonAncestorContainer(e, n) {
    var r = sd(e || this.startContainer), i = sd(n || this.endContainer);
    if (r[0] == i[0]) {
      for (var s = 0; s < r.length; s++)
        if (r[s] != i[s])
          return r[s - 1];
    }
  }
  _checkCollapsed() {
    this.startContainer === this.endContainer && this.startOffset === this.endOffset ? this.collapsed = !0 : this.collapsed = !1;
  }
  toString() {
  }
}
const p8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RangeObject: p0,
  blob2base64: h0,
  borders: Cl,
  bounds: Xa,
  createBase64Url: rd,
  createBlob: u0,
  createBlobUrl: Ol,
  defaults: a0,
  defer: vt,
  documentHeight: c8,
  extend: Sn,
  filterChildren: ms,
  findChildren: id,
  getParentByTagName: h8,
  indexOfElementNode: l0,
  indexOfNode: Cf,
  indexOfSorted: kl,
  indexOfTextNode: f8,
  insert: d8,
  isElement: s0,
  isFloat: o0,
  isNumber: Yt,
  isXml: Ho,
  locationOf: zs,
  nodeBounds: nd,
  parents: sd,
  parse: Cr,
  prefixed: vs,
  qs: zt,
  qsa: ni,
  qsp: gs,
  querySelectorByType: Nl,
  requestAnimationFrame: kf,
  revokeBlobUrl: c0,
  sprint: Il,
  treeWalker: f0,
  type: d0,
  uuid: ru,
  walk: Tf,
  windowBounds: Tl
}, Symbol.toStringTag, { value: "Module" }));
if (!v0)
  var v0 = {
    cwd: function() {
      return "/";
    }
  };
function wr(t) {
  if (typeof t != "string")
    throw new TypeError("Path must be a string. Received " + t);
}
function nv(t, e) {
  for (var n = "", r = -1, i = 0, s, o = 0; o <= t.length; ++o) {
    if (o < t.length)
      s = t.charCodeAt(o);
    else {
      if (s === 47)
        break;
      s = 47;
    }
    if (s === 47) {
      if (!(r === o - 1 || i === 1))
        if (r !== o - 1 && i === 2) {
          if (n.length < 2 || n.charCodeAt(n.length - 1) !== 46 || n.charCodeAt(n.length - 2) !== 46) {
            if (n.length > 2) {
              for (var a = n.length - 1, l = a; l >= 0 && n.charCodeAt(l) !== 47; --l)
                ;
              if (l !== a) {
                l === -1 ? n = "" : n = n.slice(0, l), r = o, i = 0;
                continue;
              }
            } else if (n.length === 2 || n.length === 1) {
              n = "", r = o, i = 0;
              continue;
            }
          }
          e && (n.length > 0 ? n += "/.." : n = "..");
        } else
          n.length > 0 ? n += "/" + t.slice(r + 1, o) : n = t.slice(r + 1, o);
      r = o, i = 0;
    } else
      s === 46 && i !== -1 ? ++i : i = -1;
  }
  return n;
}
function v8(t, e) {
  var n = e.dir || e.root, r = e.base || (e.name || "") + (e.ext || "");
  return n ? n === e.root ? n + r : n + t + r : r;
}
var el = {
  // path.resolve([from ...], to)
  resolve: function() {
    for (var e = "", n = !1, r, i = arguments.length - 1; i >= -1 && !n; i--) {
      var s;
      i >= 0 ? s = arguments[i] : (r === void 0 && (r = v0.cwd()), s = r), wr(s), s.length !== 0 && (e = s + "/" + e, n = s.charCodeAt(0) === 47);
    }
    return e = nv(e, !n), n ? e.length > 0 ? "/" + e : "/" : e.length > 0 ? e : ".";
  },
  normalize: function(e) {
    if (wr(e), e.length === 0)
      return ".";
    var n = e.charCodeAt(0) === 47, r = e.charCodeAt(e.length - 1) === 47;
    return e = nv(e, !n), e.length === 0 && !n && (e = "."), e.length > 0 && r && (e += "/"), n ? "/" + e : e;
  },
  isAbsolute: function(e) {
    return wr(e), e.length > 0 && e.charCodeAt(0) === 47;
  },
  join: function() {
    if (arguments.length === 0)
      return ".";
    for (var e, n = 0; n < arguments.length; ++n) {
      var r = arguments[n];
      wr(r), r.length > 0 && (e === void 0 ? e = r : e += "/" + r);
    }
    return e === void 0 ? "." : el.normalize(e);
  },
  relative: function(e, n) {
    if (wr(e), wr(n), e === n || (e = el.resolve(e), n = el.resolve(n), e === n))
      return "";
    for (var r = 1; r < e.length && e.charCodeAt(r) === 47; ++r)
      ;
    for (var i = e.length, s = i - r, o = 1; o < n.length && n.charCodeAt(o) === 47; ++o)
      ;
    for (var a = n.length, l = a - o, u = s < l ? s : l, c = -1, d = 0; d <= u; ++d) {
      if (d === u) {
        if (l > u) {
          if (n.charCodeAt(o + d) === 47)
            return n.slice(o + d + 1);
          if (d === 0)
            return n.slice(o + d);
        } else
          s > u && (e.charCodeAt(r + d) === 47 ? c = d : d === 0 && (c = 0));
        break;
      }
      var h = e.charCodeAt(r + d), v = n.charCodeAt(o + d);
      if (h !== v)
        break;
      h === 47 && (c = d);
    }
    var y = "";
    for (d = r + c + 1; d <= i; ++d)
      (d === i || e.charCodeAt(d) === 47) && (y.length === 0 ? y += ".." : y += "/..");
    return y.length > 0 ? y + n.slice(o + c) : (o += c, n.charCodeAt(o) === 47 && ++o, n.slice(o));
  },
  _makeLong: function(e) {
    return e;
  },
  dirname: function(e) {
    if (wr(e), e.length === 0)
      return ".";
    for (var n = e.charCodeAt(0), r = n === 47, i = -1, s = !0, o = e.length - 1; o >= 1; --o)
      if (n = e.charCodeAt(o), n === 47) {
        if (!s) {
          i = o;
          break;
        }
      } else
        s = !1;
    return i === -1 ? r ? "/" : "." : r && i === 1 ? "//" : e.slice(0, i);
  },
  basename: function(e, n) {
    if (n !== void 0 && typeof n != "string")
      throw new TypeError('"ext" argument must be a string');
    wr(e);
    var r = 0, i = -1, s = !0, o;
    if (n !== void 0 && n.length > 0 && n.length <= e.length) {
      if (n.length === e.length && n === e)
        return "";
      var a = n.length - 1, l = -1;
      for (o = e.length - 1; o >= 0; --o) {
        var u = e.charCodeAt(o);
        if (u === 47) {
          if (!s) {
            r = o + 1;
            break;
          }
        } else
          l === -1 && (s = !1, l = o + 1), a >= 0 && (u === n.charCodeAt(a) ? --a === -1 && (i = o) : (a = -1, i = l));
      }
      return r === i ? i = l : i === -1 && (i = e.length), e.slice(r, i);
    } else {
      for (o = e.length - 1; o >= 0; --o)
        if (e.charCodeAt(o) === 47) {
          if (!s) {
            r = o + 1;
            break;
          }
        } else
          i === -1 && (s = !1, i = o + 1);
      return i === -1 ? "" : e.slice(r, i);
    }
  },
  extname: function(e) {
    wr(e);
    for (var n = -1, r = 0, i = -1, s = !0, o = 0, a = e.length - 1; a >= 0; --a) {
      var l = e.charCodeAt(a);
      if (l === 47) {
        if (!s) {
          r = a + 1;
          break;
        }
        continue;
      }
      i === -1 && (s = !1, i = a + 1), l === 46 ? n === -1 ? n = a : o !== 1 && (o = 1) : n !== -1 && (o = -1);
    }
    return n === -1 || i === -1 || // We saw a non-dot character immediately before the dot
    o === 0 || // The (right-most) trimmed path component is exactly '..'
    o === 1 && n === i - 1 && n === r + 1 ? "" : e.slice(n, i);
  },
  format: function(e) {
    if (e === null || typeof e != "object")
      throw new TypeError(
        'Parameter "pathObject" must be an object, not ' + typeof e
      );
    return v8("/", e);
  },
  parse: function(e) {
    wr(e);
    var n = { root: "", dir: "", base: "", ext: "", name: "" };
    if (e.length === 0)
      return n;
    var r = e.charCodeAt(0), i = r === 47, s;
    i ? (n.root = "/", s = 1) : s = 0;
    for (var o = -1, a = 0, l = -1, u = !0, c = e.length - 1, d = 0; c >= s; --c) {
      if (r = e.charCodeAt(c), r === 47) {
        if (!u) {
          a = c + 1;
          break;
        }
        continue;
      }
      l === -1 && (u = !1, l = c + 1), r === 46 ? o === -1 ? o = c : d !== 1 && (d = 1) : o !== -1 && (d = -1);
    }
    return o === -1 || l === -1 || // We saw a non-dot character immediately before the dot
    d === 0 || // The (right-most) trimmed path component is exactly '..'
    d === 1 && o === l - 1 && o === a + 1 ? l !== -1 && (a === 0 && i ? n.base = n.name = e.slice(1, l) : n.base = n.name = e.slice(a, l)) : (a === 0 && i ? (n.name = e.slice(1, o), n.base = e.slice(1, l)) : (n.name = e.slice(a, o), n.base = e.slice(a, l)), n.ext = e.slice(o, l)), a > 0 ? n.dir = e.slice(0, a - 1) : i && (n.dir = "/"), n;
  },
  sep: "/",
  delimiter: ":",
  posix: null
}, gi = el;
class ri {
  constructor(e) {
    var n, r;
    n = e.indexOf("://"), n > -1 && (e = new URL(e).pathname), r = this.parse(e), this.path = e, this.isDirectory(e) ? this.directory = e : this.directory = r.dir + "/", this.filename = r.base, this.extension = r.ext.slice(1);
  }
  /**
   * Parse the path: https://nodejs.org/api/path.html#path_path_parse_path
   * @param	{string} what
   * @returns {object}
   */
  parse(e) {
    return gi.parse(e);
  }
  /**
   * @param	{string} what
   * @returns {boolean}
   */
  isAbsolute(e) {
    return gi.isAbsolute(e || this.path);
  }
  /**
   * Check if path ends with a directory
   * @param	{string} what
   * @returns {boolean}
   */
  isDirectory(e) {
    return e.charAt(e.length - 1) === "/";
  }
  /**
   * Resolve a path against the directory of the Path
   *
   * https://nodejs.org/api/path.html#path_path_resolve_paths
   * @param	{string} what
   * @returns {string} resolved
   */
  resolve(e) {
    return gi.resolve(this.directory, e);
  }
  /**
   * Resolve a path relative to the directory of the Path
   *
   * https://nodejs.org/api/path.html#path_path_relative_from_to
   * @param	{string} what
   * @returns {string} relative
   */
  relative(e) {
    var n = e && e.indexOf("://") > -1;
    return n ? e : gi.relative(this.directory, e);
  }
  splitPath(e) {
    return this.splitPathRe.exec(e).slice(1);
  }
  /**
   * Return the path string
   * @returns {string} path
   */
  toString() {
    return this.path;
  }
}
class fr {
  constructor(e, n) {
    var r = e.indexOf("://") > -1, i = e, s;
    if (this.Url = void 0, this.href = e, this.protocol = "", this.origin = "", this.hash = "", this.hash = "", this.search = "", this.base = n, !r && n !== !1 && typeof n != "string" && window && window.location && (this.base = window.location.href), r || this.base)
      try {
        this.base ? this.Url = new URL(e, this.base) : this.Url = new URL(e), this.href = this.Url.href, this.protocol = this.Url.protocol, this.origin = this.Url.origin, this.hash = this.Url.hash, this.search = this.Url.search, i = this.Url.pathname + (this.Url.search ? this.Url.search : "");
      } catch {
        this.Url = void 0, this.base && (s = new ri(this.base), i = s.resolve(i));
      }
    this.Path = new ri(i), this.directory = this.Path.directory, this.filename = this.Path.filename, this.extension = this.Path.extension;
  }
  /**
   * @returns {Path}
   */
  path() {
    return this.Path;
  }
  /**
   * Resolves a relative path to a absolute url
   * @param {string} what
   * @returns {string} url
   */
  resolve(e) {
    var n = e.indexOf("://") > -1, r;
    return n ? e : (r = gi.resolve(this.directory, e), this.origin + r);
  }
  /**
   * Resolve a path relative to the url
   * @param {string} what
   * @returns {string} path
   */
  relative(e) {
    return gi.relative(e, this.directory);
  }
  /**
   * @returns {string}
   */
  toString() {
    return this.href;
  }
}
const ds = 1, Xn = 3, g8 = 9;
class gt {
  constructor(e, n, r) {
    var i;
    if (this.str = "", this.base = {}, this.spinePos = 0, this.range = !1, this.path = {}, this.start = null, this.end = null, !(this instanceof gt))
      return new gt(e, n, r);
    if (typeof n == "string" ? this.base = this.parseComponent(n) : typeof n == "object" && n.steps && (this.base = n), i = this.checkType(e), i === "string")
      return this.str = e, Sn(this, this.parse(e));
    if (i === "range")
      return Sn(this, this.fromRange(e, this.base, r));
    if (i === "node")
      return Sn(this, this.fromNode(e, this.base, r));
    if (i === "EpubCFI" && e.path)
      return e;
    if (e)
      throw new TypeError("not a valid argument for EpubCFI");
    return this;
  }
  /**
   * Check the type of constructor input
   * @private
   */
  checkType(e) {
    return this.isCfiString(e) ? "string" : e && typeof e == "object" && (d0(e) === "Range" || typeof e.startContainer < "u") ? "range" : e && typeof e == "object" && typeof e.nodeType < "u" ? "node" : e && typeof e == "object" && e instanceof gt ? "EpubCFI" : !1;
  }
  /**
   * Parse a cfi string to a CFI object representation
   * @param {string} cfiStr
   * @returns {object} cfi
   */
  parse(e) {
    var n = {
      spinePos: -1,
      range: !1,
      base: {},
      path: {},
      start: null,
      end: null
    }, r, i, s;
    return typeof e != "string" ? { spinePos: -1 } : (e.indexOf("epubcfi(") === 0 && e[e.length - 1] === ")" && (e = e.slice(8, e.length - 1)), r = this.getChapterComponent(e), r ? (n.base = this.parseComponent(r), i = this.getPathComponent(e), n.path = this.parseComponent(i), s = this.getRange(e), s && (n.range = !0, n.start = this.parseComponent(s[0]), n.end = this.parseComponent(s[1])), n.spinePos = n.base.steps[1].index, n) : { spinePos: -1 });
  }
  parseComponent(e) {
    var n = {
      steps: [],
      terminal: {
        offset: null,
        assertion: null
      }
    }, r = e.split(":"), i = r[0].split("/"), s;
    return r.length > 1 && (s = r[1], n.terminal = this.parseTerminal(s)), i[0] === "" && i.shift(), n.steps = i.map(function(o) {
      return this.parseStep(o);
    }.bind(this)), n;
  }
  parseStep(e) {
    var n, r, i, s, o;
    if (s = e.match(/\[(.*)\]/), s && s[1] && (o = s[1]), r = parseInt(e), !isNaN(r))
      return r % 2 === 0 ? (n = "element", i = r / 2 - 1) : (n = "text", i = (r - 1) / 2), {
        type: n,
        index: i,
        id: o || null
      };
  }
  parseTerminal(e) {
    var n, r, i = e.match(/\[(.*)\]/);
    return i && i[1] ? (n = parseInt(e.split("[")[0]), r = i[1]) : n = parseInt(e), Yt(n) || (n = null), {
      offset: n,
      assertion: r
    };
  }
  getChapterComponent(e) {
    var n = e.split("!");
    return n[0];
  }
  getPathComponent(e) {
    var n = e.split("!");
    if (n[1])
      return n[1].split(",")[0];
  }
  getRange(e) {
    var n = e.split(",");
    return n.length === 3 ? [
      n[1],
      n[2]
    ] : !1;
  }
  getCharecterOffsetComponent(e) {
    var n = e.split(":");
    return n[1] || "";
  }
  joinSteps(e) {
    return e ? e.map(function(n) {
      var r = "";
      return n.type === "element" && (r += (n.index + 1) * 2), n.type === "text" && (r += 1 + 2 * n.index), n.id && (r += "[" + n.id + "]"), r;
    }).join("/") : "";
  }
  segmentString(e) {
    var n = "/";
    return n += this.joinSteps(e.steps), e.terminal && e.terminal.offset != null && (n += ":" + e.terminal.offset), e.terminal && e.terminal.assertion != null && (n += "[" + e.terminal.assertion + "]"), n;
  }
  /**
   * Convert CFI to a epubcfi(...) string
   * @returns {string} epubcfi
   */
  toString() {
    var e = "epubcfi(";
    return e += this.segmentString(this.base), e += "!", e += this.segmentString(this.path), this.range && this.start && (e += ",", e += this.segmentString(this.start)), this.range && this.end && (e += ",", e += this.segmentString(this.end)), e += ")", e;
  }
  /**
   * Compare which of two CFIs is earlier in the text
   * @returns {number} First is earlier = -1, Second is earlier = 1, They are equal = 0
   */
  compare(e, n) {
    var r, i, s, o;
    if (typeof e == "string" && (e = new gt(e)), typeof n == "string" && (n = new gt(n)), e.spinePos > n.spinePos)
      return 1;
    if (e.spinePos < n.spinePos)
      return -1;
    e.range ? (r = e.path.steps.concat(e.start.steps), s = e.start.terminal) : (r = e.path.steps, s = e.path.terminal), n.range ? (i = n.path.steps.concat(n.start.steps), o = n.start.terminal) : (i = n.path.steps, o = n.path.terminal);
    for (var a = 0; a < r.length; a++) {
      if (!r[a])
        return -1;
      if (!i[a] || r[a].index > i[a].index)
        return 1;
      if (r[a].index < i[a].index)
        return -1;
    }
    return r.length < i.length ? -1 : s.offset > o.offset ? 1 : s.offset < o.offset ? -1 : 0;
  }
  step(e) {
    var n = e.nodeType === Xn ? "text" : "element";
    return {
      id: e.id,
      tagName: e.tagName,
      type: n,
      index: this.position(e)
    };
  }
  filteredStep(e, n) {
    var r = this.filter(e, n), i;
    if (r)
      return i = r.nodeType === Xn ? "text" : "element", {
        id: r.id,
        tagName: r.tagName,
        type: i,
        index: this.filteredPosition(r, n)
      };
  }
  pathTo(e, n, r) {
    for (var i = {
      steps: [],
      terminal: {
        offset: null,
        assertion: null
      }
    }, s = e, o; s && s.parentNode && s.parentNode.nodeType != g8; )
      r ? o = this.filteredStep(s, r) : o = this.step(s), o && i.steps.unshift(o), s = s.parentNode;
    return n != null && n >= 0 && (i.terminal.offset = n, i.steps[i.steps.length - 1].type != "text" && i.steps.push({
      type: "text",
      index: 0
    })), i;
  }
  equalStep(e, n) {
    return !e || !n ? !1 : e.index === n.index && e.id === n.id && e.type === n.type;
  }
  /**
   * Create a CFI object from a Range
   * @param {Range} range
   * @param {string | object} base
   * @param {string} [ignoreClass]
   * @returns {object} cfi
   */
  fromRange(e, n, r) {
    var i = {
      range: !1,
      base: {},
      path: {},
      start: null,
      end: null
    }, s = e.startContainer, o = e.endContainer, a = e.startOffset, l = e.endOffset, u = !1;
    if (r && (u = s.ownerDocument.querySelector("." + r) != null), typeof n == "string" ? (i.base = this.parseComponent(n), i.spinePos = i.base.steps[1].index) : typeof n == "object" && (i.base = n), e.collapsed)
      u && (a = this.patchOffset(s, a, r)), i.path = this.pathTo(s, a, r);
    else {
      i.range = !0, u && (a = this.patchOffset(s, a, r)), i.start = this.pathTo(s, a, r), u && (l = this.patchOffset(o, l, r)), i.end = this.pathTo(o, l, r), i.path = {
        steps: [],
        terminal: null
      };
      var c = i.start.steps.length, d;
      for (d = 0; d < c && this.equalStep(i.start.steps[d], i.end.steps[d]); d++)
        d === c - 1 ? i.start.terminal === i.end.terminal && (i.path.steps.push(i.start.steps[d]), i.range = !1) : i.path.steps.push(i.start.steps[d]);
      i.start.steps = i.start.steps.slice(i.path.steps.length), i.end.steps = i.end.steps.slice(i.path.steps.length);
    }
    return i;
  }
  /**
   * Create a CFI object from a Node
   * @param {Node} anchor
   * @param {string | object} base
   * @param {string} [ignoreClass]
   * @returns {object} cfi
   */
  fromNode(e, n, r) {
    var i = {
      range: !1,
      base: {},
      path: {},
      start: null,
      end: null
    };
    return typeof n == "string" ? (i.base = this.parseComponent(n), i.spinePos = i.base.steps[1].index) : typeof n == "object" && (i.base = n), i.path = this.pathTo(e, null, r), i;
  }
  filter(e, n) {
    var r, i, s, o, a, l = !1;
    return e.nodeType === Xn ? (l = !0, s = e.parentNode, r = e.parentNode.classList.contains(n)) : (l = !1, r = e.classList.contains(n)), r && l ? (o = s.previousSibling, a = s.nextSibling, o && o.nodeType === Xn ? i = o : a && a.nodeType === Xn && (i = a), i || e) : r && !l ? !1 : e;
  }
  patchOffset(e, n, r) {
    if (e.nodeType != Xn)
      throw new Error("Anchor must be a text node");
    var i = e, s = n;
    for (e.parentNode.classList.contains(r) && (i = e.parentNode); i.previousSibling; ) {
      if (i.previousSibling.nodeType === ds)
        if (i.previousSibling.classList.contains(r))
          s += i.previousSibling.textContent.length;
        else
          break;
      else
        s += i.previousSibling.textContent.length;
      i = i.previousSibling;
    }
    return s;
  }
  normalizedMap(e, n, r) {
    var i = {}, s = -1, o, a = e.length, l, u;
    for (o = 0; o < a; o++)
      l = e[o].nodeType, l === ds && e[o].classList.contains(r) && (l = Xn), o > 0 && l === Xn && u === Xn ? i[o] = s : n === l && (s = s + 1, i[o] = s), u = l;
    return i;
  }
  position(e) {
    var n, r;
    return e.nodeType === ds ? (n = e.parentNode.children, n || (n = id(e.parentNode)), r = Array.prototype.indexOf.call(n, e)) : (n = this.textNodes(e.parentNode), r = n.indexOf(e)), r;
  }
  filteredPosition(e, n) {
    var r, i, s;
    return e.nodeType === ds ? (r = e.parentNode.children, s = this.normalizedMap(r, ds, n)) : (r = e.parentNode.childNodes, e.parentNode.classList.contains(n) && (e = e.parentNode, r = e.parentNode.childNodes), s = this.normalizedMap(r, Xn, n)), i = Array.prototype.indexOf.call(r, e), s[i];
  }
  stepsToXpath(e) {
    var n = [".", "*"];
    return e.forEach(function(r) {
      var i = r.index + 1;
      r.id ? n.push("*[position()=" + i + " and @id='" + r.id + "']") : r.type === "text" ? n.push("text()[" + i + "]") : n.push("*[" + i + "]");
    }), n.join("/");
  }
  /*
  
  	To get the last step if needed:
  
  	// Get the terminal step
  	lastStep = steps[steps.length-1];
  	// Get the query string
  	query = this.stepsToQuery(steps);
  	// Find the containing element
  	startContainerParent = doc.querySelector(query);
  	// Find the text node within that element
  	if(startContainerParent && lastStep.type == "text") {
  		container = startContainerParent.childNodes[lastStep.index];
  	}
  	*/
  stepsToQuerySelector(e) {
    var n = ["html"];
    return e.forEach(function(r) {
      var i = r.index + 1;
      r.id ? n.push("#" + r.id) : r.type === "text" || n.push("*:nth-child(" + i + ")");
    }), n.join(">");
  }
  textNodes(e, n) {
    return Array.prototype.slice.call(e.childNodes).filter(function(r) {
      return r.nodeType === Xn ? !0 : !!(n && r.classList.contains(n));
    });
  }
  walkToNode(e, n, r) {
    var i = n || document, s = i.documentElement, o, a, l = e.length, u;
    for (u = 0; u < l && (a = e[u], a.type === "element" ? a.id ? s = i.getElementById(a.id) : (o = s.children || id(s), s = o[a.index]) : a.type === "text" && (s = this.textNodes(s, r)[a.index]), !!s); u++)
      ;
    return s;
  }
  findNode(e, n, r) {
    var i = n || document, s, o;
    return !r && typeof i.evaluate < "u" ? (o = this.stepsToXpath(e), s = i.evaluate(o, i, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue) : r ? s = this.walkToNode(e, i, r) : s = this.walkToNode(e, i), s;
  }
  fixMiss(e, n, r, i) {
    var s = this.findNode(e.slice(0, -1), r, i), o = s.childNodes, a = this.normalizedMap(o, Xn, i), l, u, c = e[e.length - 1].index;
    for (let d in a) {
      if (!a.hasOwnProperty(d))
        return;
      if (a[d] === c)
        if (l = o[d], u = l.textContent.length, n > u)
          n = n - u;
        else {
          l.nodeType === ds ? s = l.childNodes[0] : s = l;
          break;
        }
    }
    return {
      container: s,
      offset: n
    };
  }
  /**
   * Creates a DOM range representing a CFI
   * @param {document} _doc document referenced in the base
   * @param {string} [ignoreClass]
   * @return {Range}
   */
  toRange(e, n) {
    var r = e || document, i, s, o, a, l, u = this, c, d, h = n ? r.querySelector("." + n) != null : !1, v;
    if (typeof r.createRange < "u" ? i = r.createRange() : i = new p0(), u.range ? (s = u.start, c = u.path.steps.concat(s.steps), a = this.findNode(c, r, h ? n : null), o = u.end, d = u.path.steps.concat(o.steps), l = this.findNode(d, r, h ? n : null)) : (s = u.path, c = u.path.steps, a = this.findNode(u.path.steps, r, h ? n : null)), a)
      try {
        s.terminal.offset != null ? i.setStart(a, s.terminal.offset) : i.setStart(a, 0);
      } catch {
        v = this.fixMiss(c, s.terminal.offset, r, h ? n : null), i.setStart(v.container, v.offset);
      }
    else
      return console.log("No startContainer found for", this.toString()), null;
    if (l)
      try {
        o.terminal.offset != null ? i.setEnd(l, o.terminal.offset) : i.setEnd(l, 0);
      } catch {
        v = this.fixMiss(d, u.end.terminal.offset, r, h ? n : null), i.setEnd(v.container, v.offset);
      }
    return i;
  }
  /**
   * Check if a string is wrapped with "epubcfi()"
   * @param {string} str
   * @returns {boolean}
   */
  isCfiString(e) {
    return typeof e == "string" && e.indexOf("epubcfi(") === 0 && e[e.length - 1] === ")";
  }
  generateChapterComponent(e, n, r) {
    var i = parseInt(n), s = (e + 1) * 2, o = "/" + s + "/";
    return o += (i + 1) * 2, r && (o += "[" + r + "]"), o;
  }
  /**
   * Collapse a CFI Range to a single CFI Position
   * @param {boolean} [toStart=false]
   */
  collapse(e) {
    this.range && (this.range = !1, e ? (this.path.steps = this.path.steps.concat(this.start.steps), this.path.terminal = this.start.terminal) : (this.path.steps = this.path.steps.concat(this.end.steps), this.path.terminal = this.end.terminal));
  }
}
class hr {
  constructor(e) {
    this.context = e || this, this.hooks = [];
  }
  /**
   * Adds a function to be run before a hook completes
   * @example this.content.register(function(){...});
   */
  register() {
    for (var e = 0; e < arguments.length; ++e)
      if (typeof arguments[e] == "function")
        this.hooks.push(arguments[e]);
      else
        for (var n = 0; n < arguments[e].length; ++n)
          this.hooks.push(arguments[e][n]);
  }
  /**
   * Removes a function
   * @example this.content.deregister(function(){...});
   */
  deregister(e) {
    let n;
    for (let r = 0; r < this.hooks.length; r++)
      if (n = this.hooks[r], n === e) {
        this.hooks.splice(r, 1);
        break;
      }
  }
  /**
   * Triggers a hook to run all functions
   * @example this.content.trigger(args).then(function(){...});
   */
  trigger() {
    var e = arguments, n = this.context, r = [];
    return this.hooks.forEach(function(i) {
      try {
        var s = i.apply(n, e);
      } catch (o) {
        console.log(o);
      }
      s && typeof s.then == "function" && r.push(s);
    }), Promise.all(r);
  }
  // Adds a function to be run before a hook completes
  list() {
    return this.hooks;
  }
  clear() {
    return this.hooks = [];
  }
}
function g0(t, e) {
  var n, r, i = e.url, s = i.indexOf("://") > -1;
  t && (r = zt(t, "head"), n = zt(r, "base"), n || (n = t.createElement("base"), r.insertBefore(n, r.firstChild)), !s && window && window.location && (i = window.location.origin + i), n.setAttribute("href", i));
}
function m8(t, e) {
  var n, r, i = e.canonical;
  t && (n = zt(t, "head"), r = zt(n, "link[rel='canonical']"), r ? r.setAttribute("href", i) : (r = t.createElement("link"), r.setAttribute("rel", "canonical"), r.setAttribute("href", i), n.appendChild(r)));
}
function y8(t, e) {
  var n, r, i = e.idref;
  t && (n = zt(t, "head"), r = zt(n, "link[property='dc.identifier']"), r ? r.setAttribute("content", i) : (r = t.createElement("meta"), r.setAttribute("name", "dc.identifier"), r.setAttribute("content", i), n.appendChild(r)));
}
function b8(t, e) {
  var n = t.querySelectorAll("a[href]");
  if (n.length)
    for (var r = zt(t.ownerDocument, "base"), i = r ? r.getAttribute("href") : void 0, s = function(a) {
      var l = a.getAttribute("href");
      if (l.indexOf("mailto:") !== 0) {
        var u = l.indexOf("://") > -1;
        if (u)
          a.setAttribute("target", "_blank");
        else {
          var c;
          try {
            c = new fr(l, i);
          } catch {
          }
          a.onclick = function() {
            return c && c.hash ? e(c.Path.path + c.hash) : e(c ? c.Path.path : l), !1;
          };
        }
      }
    }.bind(this), o = 0; o < n.length; o++)
      s(n[o]);
}
function rv(t, e, n) {
  return e.forEach(function(r, i) {
    r && n[i] && (r = r.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), t = t.replace(new RegExp(r, "g"), n[i]));
  }), t;
}
function Uo(t, e, n, r) {
  var i = typeof window < "u" ? window.URL : !1, s = i ? "blob" : "arraybuffer", o = new vt(), a = new XMLHttpRequest(), l = XMLHttpRequest.prototype, u;
  "overrideMimeType" in l || Object.defineProperty(l, "overrideMimeType", {
    value: function() {
    }
  }), n && (a.withCredentials = !0), a.onreadystatechange = d, a.onerror = c, a.open("GET", t, !0);
  for (u in r)
    a.setRequestHeader(u, r[u]);
  e == "json" && a.setRequestHeader("Accept", "application/json"), e || (e = new ri(t).extension), e == "blob" && (a.responseType = s), Ho(e) && a.overrideMimeType("text/xml"), e == "binary" && (a.responseType = "arraybuffer"), a.send();
  function c(h) {
    o.reject(h);
  }
  function d() {
    if (this.readyState === XMLHttpRequest.DONE) {
      var h = !1;
      if ((this.responseType === "" || this.responseType === "document") && (h = this.responseXML), this.status === 200 || this.status === 0 || h) {
        var v;
        if (!this.response && !h)
          return o.reject({
            status: this.status,
            message: "Empty Response",
            stack: new Error().stack
          }), o.promise;
        if (this.status === 403)
          return o.reject({
            status: this.status,
            response: this.response,
            message: "Forbidden",
            stack: new Error().stack
          }), o.promise;
        h ? v = this.responseXML : Ho(e) ? v = Cr(this.response, "text/xml") : e == "xhtml" ? v = Cr(this.response, "application/xhtml+xml") : e == "html" || e == "htm" ? v = Cr(this.response, "text/html") : e == "json" ? v = JSON.parse(this.response) : e == "blob" ? i ? v = this.response : v = new Blob([this.response]) : v = this.response, o.resolve(v);
      } else
        o.reject({
          status: this.status,
          message: this.response,
          stack: new Error().stack
        });
    }
  }
  return o.promise;
}
class w8 {
  constructor(e, n) {
    this.idref = e.idref, this.linear = e.linear === "yes", this.properties = e.properties, this.index = e.index, this.href = e.href, this.url = e.url, this.canonical = e.canonical, this.next = e.next, this.prev = e.prev, this.cfiBase = e.cfiBase, n ? this.hooks = n : (this.hooks = {}, this.hooks.serialize = new hr(this), this.hooks.content = new hr(this)), this.document = void 0, this.contents = void 0, this.output = void 0;
  }
  /**
   * Load the section from its url
   * @param  {method} [_request] a request method to use for loading
   * @return {document} a promise with the xml document
   */
  load(e) {
    var n = e || this.request || Uo, r = new vt(), i = r.promise;
    return this.contents ? r.resolve(this.contents) : n(this.url).then(function(s) {
      return this.document = s, this.contents = s.documentElement, this.hooks.content.trigger(this.document, this);
    }.bind(this)).then(function() {
      r.resolve(this.contents);
    }.bind(this)).catch(function(s) {
      r.reject(s);
    }), i;
  }
  /**
   * Adds a base tag for resolving urls in the section
   * @private
   */
  base() {
    return g0(this.document, this);
  }
  /**
   * Render the contents of a section
   * @param  {method} [_request] a request method to use for loading
   * @return {string} output a serialized XML Document
   */
  render(e) {
    var n = new vt(), r = n.promise;
    return this.output, this.load(e).then(function(i) {
      var s = typeof navigator < "u" && navigator.userAgent || "", o = s.indexOf("Trident") >= 0, a;
      typeof XMLSerializer > "u" || o ? a = r0 : a = XMLSerializer;
      var l = new a();
      return this.output = l.serializeToString(i), this.output;
    }.bind(this)).then(function() {
      return this.hooks.serialize.trigger(this.output, this);
    }.bind(this)).then(function() {
      n.resolve(this.output);
    }.bind(this)).catch(function(i) {
      n.reject(i);
    }), r;
  }
  /**
   * Find a string in a section
   * @param  {string} _query The query string to find
   * @return {object[]} A list of matches, with form {cfi, excerpt}
   */
  find(e) {
    var n = this, r = [], i = e.toLowerCase(), s = function(o) {
      for (var a = o.textContent.toLowerCase(), l = n.document.createRange(), u, c, d = -1, h, v = 150; c != -1; )
        c = a.indexOf(i, d + 1), c != -1 && (l = n.document.createRange(), l.setStart(o, c), l.setEnd(o, c + i.length), u = n.cfiFromRange(l), o.textContent.length < v ? h = o.textContent : (h = o.textContent.substring(c - v / 2, c + v / 2), h = "..." + h + "..."), r.push({
          cfi: u,
          excerpt: h
        })), d = c;
    };
    return Il(n.document, function(o) {
      s(o);
    }), r;
  }
  /**
   * Search a string in multiple sequential Element of the section. If the document.createTreeWalker api is missed(eg: IE8), use `find` as a fallback.
   * @param  {string} _query The query string to search
   * @param  {int} maxSeqEle The maximum number of Element that are combined for search, default value is 5.
   * @return {object[]} A list of matches, with form {cfi, excerpt}
   */
  search(e, n = 5) {
    if (typeof document.createTreeWalker > "u")
      return this.find(e);
    let r = [];
    const i = 150, s = this, o = e.toLowerCase(), a = function(d) {
      const y = d.reduce((b, p) => b + p.textContent, "").toLowerCase().indexOf(o);
      if (y != -1) {
        const p = y + o.length;
        let f = 0, g = 0;
        if (y < d[0].length) {
          let m;
          for (; f < d.length - 1 && (g += d[f].length, !(p <= g)); )
            f += 1;
          let w = d[0], _ = d[f], S = s.document.createRange();
          S.setStart(w, y);
          let A = d.slice(0, f).reduce((k, O) => k + O.textContent.length, 0);
          S.setEnd(_, A > p ? p : p - A), m = s.cfiFromRange(S);
          let C = d.slice(0, f + 1).reduce((k, O) => k + O.textContent, "");
          C.length > i && (C = C.substring(y - i / 2, y + i / 2), C = "..." + C + "..."), r.push({
            cfi: m,
            excerpt: C
          });
        }
      }
    }, l = document.createTreeWalker(s.document, NodeFilter.SHOW_TEXT, null, !1);
    let u, c = [];
    for (; u = l.nextNode(); )
      c.push(u), c.length == n && (a(c.slice(0, n)), c = c.slice(1, n));
    return c.length > 0 && a(c), r;
  }
  /**
  * Reconciles the current chapters layout properties with
  * the global layout properties.
  * @param {object} globalLayout  The global layout settings object, chapter properties string
  * @return {object} layoutProperties Object with layout properties
  */
  reconcileLayoutSettings(e) {
    var n = {
      layout: e.layout,
      spread: e.spread,
      orientation: e.orientation
    };
    return this.properties.forEach(function(r) {
      var i = r.replace("rendition:", ""), s = i.indexOf("-"), o, a;
      s != -1 && (o = i.slice(0, s), a = i.slice(s + 1), n[o] = a);
    }), n;
  }
  /**
   * Get a CFI from a Range in the Section
   * @param  {range} _range
   * @return {string} cfi an EpubCFI string
   */
  cfiFromRange(e) {
    return new gt(e, this.cfiBase).toString();
  }
  /**
   * Get a CFI from an Element in the Section
   * @param  {element} el
   * @return {string} cfi an EpubCFI string
   */
  cfiFromElement(e) {
    return new gt(e, this.cfiBase).toString();
  }
  /**
   * Unload the section document
   */
  unload() {
    this.document = void 0, this.contents = void 0, this.output = void 0;
  }
  destroy() {
    this.unload(), this.hooks.serialize.clear(), this.hooks.content.clear(), this.hooks = void 0, this.idref = void 0, this.linear = void 0, this.properties = void 0, this.index = void 0, this.href = void 0, this.url = void 0, this.next = void 0, this.prev = void 0, this.cfiBase = void 0;
  }
}
class _8 {
  constructor() {
    this.spineItems = [], this.spineByHref = {}, this.spineById = {}, this.hooks = {}, this.hooks.serialize = new hr(), this.hooks.content = new hr(), this.hooks.content.register(g0), this.hooks.content.register(m8), this.hooks.content.register(y8), this.epubcfi = new gt(), this.loaded = !1, this.items = void 0, this.manifest = void 0, this.spineNodeIndex = void 0, this.baseUrl = void 0, this.length = void 0;
  }
  /**
   * Unpack items from a opf into spine items
   * @param  {Packaging} _package
   * @param  {method} resolver URL resolver
   * @param  {method} canonical Resolve canonical url
   */
  unpack(e, n, r) {
    this.items = e.spine, this.manifest = e.manifest, this.spineNodeIndex = e.spineNodeIndex, this.baseUrl = e.baseUrl || e.basePath || "", this.length = this.items.length, this.items.forEach((i, s) => {
      var o = this.manifest[i.idref], a;
      i.index = s, i.cfiBase = this.epubcfi.generateChapterComponent(this.spineNodeIndex, i.index, i.id), i.href && (i.url = n(i.href, !0), i.canonical = r(i.href)), o && (i.href = o.href, i.url = n(i.href, !0), i.canonical = r(i.href), o.properties.length && i.properties.push.apply(i.properties, o.properties)), i.linear === "yes" ? (i.prev = function() {
        let l = i.index;
        for (; l > 0; ) {
          let u = this.get(l - 1);
          if (u && u.linear)
            return u;
          l -= 1;
        }
      }.bind(this), i.next = function() {
        let l = i.index;
        for (; l < this.spineItems.length - 1; ) {
          let u = this.get(l + 1);
          if (u && u.linear)
            return u;
          l += 1;
        }
      }.bind(this)) : (i.prev = function() {
      }, i.next = function() {
      }), a = new w8(i, this.hooks), this.append(a);
    }), this.loaded = !0;
  }
  /**
   * Get an item from the spine
   * @param  {string|number} [target]
   * @return {Section} section
   * @example spine.get();
   * @example spine.get(1);
   * @example spine.get("chap1.html");
   * @example spine.get("#id1234");
   */
  get(e) {
    var n = 0;
    if (typeof e > "u")
      for (; n < this.spineItems.length; ) {
        let r = this.spineItems[n];
        if (r && r.linear)
          break;
        n += 1;
      }
    else
      this.epubcfi.isCfiString(e) ? n = new gt(e).spinePos : typeof e == "number" || isNaN(e) === !1 ? n = e : typeof e == "string" && e.indexOf("#") === 0 ? n = this.spineById[e.substring(1)] : typeof e == "string" && (e = e.split("#")[0], n = this.spineByHref[e] || this.spineByHref[encodeURI(e)]);
    return this.spineItems[n] || null;
  }
  /**
   * Append a Section to the Spine
   * @private
   * @param  {Section} section
   */
  append(e) {
    var n = this.spineItems.length;
    return e.index = n, this.spineItems.push(e), this.spineByHref[decodeURI(e.href)] = n, this.spineByHref[encodeURI(e.href)] = n, this.spineByHref[e.href] = n, this.spineById[e.idref] = n, n;
  }
  /**
   * Prepend a Section to the Spine
   * @private
   * @param  {Section} section
   */
  prepend(e) {
    return this.spineByHref[e.href] = 0, this.spineById[e.idref] = 0, this.spineItems.forEach(function(n, r) {
      n.index = r;
    }), 0;
  }
  // insert(section, index) {
  //
  // };
  /**
   * Remove a Section from the Spine
   * @private
   * @param  {Section} section
   */
  remove(e) {
    var n = this.spineItems.indexOf(e);
    if (n > -1)
      return delete this.spineByHref[e.href], delete this.spineById[e.idref], this.spineItems.splice(n, 1);
  }
  /**
   * Loop over the Sections in the Spine
   * @return {method} forEach
   */
  each() {
    return this.spineItems.forEach.apply(this.spineItems, arguments);
  }
  /**
   * Find the first Section in the Spine
   * @return {Section} first section
   */
  first() {
    let e = 0;
    do {
      let n = this.get(e);
      if (n && n.linear)
        return n;
      e += 1;
    } while (e < this.spineItems.length);
  }
  /**
   * Find the last Section in the Spine
   * @return {Section} last section
   */
  last() {
    let e = this.spineItems.length - 1;
    do {
      let n = this.get(e);
      if (n && n.linear)
        return n;
      e -= 1;
    } while (e >= 0);
  }
  destroy() {
    this.each((e) => e.destroy()), this.spineItems = void 0, this.spineByHref = void 0, this.spineById = void 0, this.hooks.serialize.clear(), this.hooks.content.clear(), this.hooks = void 0, this.epubcfi = void 0, this.loaded = !1, this.items = void 0, this.manifest = void 0, this.spineNodeIndex = void 0, this.baseUrl = void 0, this.length = void 0;
  }
}
class Of {
  constructor(e) {
    this._q = [], this.context = e, this.tick = kf, this.running = !1, this.paused = !1;
  }
  /**
   * Add an item to the queue
   * @return {Promise}
   */
  enqueue() {
    var e, n, r, i = [].shift.call(arguments), s = arguments;
    if (!i)
      throw new Error("No Task Provided");
    return typeof i == "function" ? (e = new vt(), n = e.promise, r = {
      task: i,
      args: s,
      //"context"  : context,
      deferred: e,
      promise: n
    }) : r = {
      promise: i
    }, this._q.push(r), this.paused == !1 && !this.running && this.run(), r.promise;
  }
  /**
   * Run one item
   * @return {Promise}
   */
  dequeue() {
    var e, n, r;
    if (this._q.length && !this.paused) {
      if (e = this._q.shift(), n = e.task, n)
        return r = n.apply(this.context, e.args), r && typeof r.then == "function" ? r.then(function() {
          e.deferred.resolve.apply(this.context, arguments);
        }.bind(this), function() {
          e.deferred.reject.apply(this.context, arguments);
        }.bind(this)) : (e.deferred.resolve.apply(this.context, r), e.promise);
      if (e.promise)
        return e.promise;
    } else
      return e = new vt(), e.deferred.resolve(), e.promise;
  }
  // Run All Immediately
  dump() {
    for (; this._q.length; )
      this.dequeue();
  }
  /**
   * Run all tasks sequentially, at convince
   * @return {Promise}
   */
  run() {
    return this.running || (this.running = !0, this.defered = new vt()), this.tick.call(window, () => {
      this._q.length ? this.dequeue().then(function() {
        this.run();
      }.bind(this)) : (this.defered.resolve(), this.running = void 0);
    }), this.paused == !0 && (this.paused = !1), this.defered.promise;
  }
  /**
   * Flush all, as quickly as possible
   * @return {Promise}
   */
  flush() {
    if (this.running)
      return this.running;
    if (this._q.length)
      return this.running = this.dequeue().then(function() {
        return this.running = void 0, this.flush();
      }.bind(this)), this.running;
  }
  /**
   * Clear all items in wait
   */
  clear() {
    this._q = [];
  }
  /**
   * Get the number of tasks in the queue
   * @return {number} tasks
   */
  length() {
    return this._q.length;
  }
  /**
   * Pause a running queue
   */
  pause() {
    this.paused = !0;
  }
  /**
   * End the queue
   */
  stop() {
    this._q = [], this.running = !1, this.paused = !0;
  }
}
const iu = "0.3", tl = ["keydown", "keyup", "keypressed", "mouseup", "mousedown", "mousemove", "click", "touchend", "touchstart", "touchmove"], Re = {
  BOOK: {
    OPEN_FAILED: "openFailed"
  },
  CONTENTS: {
    EXPAND: "expand",
    RESIZE: "resize",
    SELECTED: "selected",
    SELECTED_RANGE: "selectedRange",
    LINK_CLICKED: "linkClicked"
  },
  LOCATIONS: {
    CHANGED: "changed"
  },
  MANAGERS: {
    RESIZE: "resize",
    RESIZED: "resized",
    ORIENTATION_CHANGE: "orientationchange",
    ADDED: "added",
    SCROLL: "scroll",
    SCROLLED: "scrolled",
    REMOVED: "removed"
  },
  VIEWS: {
    AXIS: "axis",
    WRITING_MODE: "writingMode",
    LOAD_ERROR: "loaderror",
    RENDERED: "rendered",
    RESIZED: "resized",
    DISPLAYED: "displayed",
    SHOWN: "shown",
    HIDDEN: "hidden",
    MARK_CLICKED: "markClicked"
  },
  RENDITION: {
    STARTED: "started",
    ATTACHED: "attached",
    DISPLAYED: "displayed",
    DISPLAY_ERROR: "displayerror",
    RENDERED: "rendered",
    REMOVED: "removed",
    RESIZED: "resized",
    ORIENTATION_CHANGE: "orientationchange",
    LOCATION_CHANGED: "locationChanged",
    RELOCATED: "relocated",
    MARK_CLICKED: "markClicked",
    SELECTED: "selected",
    LAYOUT: "layout"
  },
  LAYOUT: {
    UPDATED: "updated"
  },
  ANNOTATION: {
    ATTACH: "attach",
    DETACH: "detach"
  }
};
class m0 {
  constructor(e, n, r) {
    this.spine = e, this.request = n, this.pause = r || 100, this.q = new Of(this), this.epubcfi = new gt(), this._locations = [], this._locationsWords = [], this.total = 0, this.break = 150, this._current = 0, this._wordCounter = 0, this.currentLocation = "", this._currentCfi = "", this.processingTimeout = void 0;
  }
  /**
   * Load all of sections in the book to generate locations
   * @param  {int} chars how many chars to split on
   * @return {Promise<Array<string>>} locations
   */
  generate(e) {
    return e && (this.break = e), this.q.pause(), this.spine.each(function(n) {
      n.linear && this.q.enqueue(this.process.bind(this), n);
    }.bind(this)), this.q.run().then(function() {
      return this.total = this._locations.length - 1, this._currentCfi && (this.currentLocation = this._currentCfi), this._locations;
    }.bind(this));
  }
  createRange() {
    return {
      startContainer: void 0,
      startOffset: void 0,
      endContainer: void 0,
      endOffset: void 0
    };
  }
  process(e) {
    return e.load(this.request).then(function(n) {
      var r = new vt(), i = this.parse(n, e.cfiBase);
      return this._locations = this._locations.concat(i), e.unload(), this.processingTimeout = setTimeout(() => r.resolve(i), this.pause), r.promise;
    }.bind(this));
  }
  parse(e, n, r) {
    var i = [], s, o = e.ownerDocument, a = zt(o, "body"), l = 0, u, c = r || this.break, d = function(h) {
      var v = h.length, y, b = 0;
      if (h.textContent.trim().length === 0)
        return !1;
      for (l == 0 && (s = this.createRange(), s.startContainer = h, s.startOffset = 0), y = c - l, y > v && (l += v, b = v); b < v; )
        if (y = c - l, l === 0 && (b += 1, s = this.createRange(), s.startContainer = h, s.startOffset = b), b + y >= v)
          l += v - b, b = v;
        else {
          b += y, s.endContainer = h, s.endOffset = b;
          let p = new gt(s, n).toString();
          i.push(p), l = 0;
        }
      u = h;
    };
    if (Il(a, d.bind(this)), s && s.startContainer && u) {
      s.endContainer = u, s.endOffset = u.length;
      let h = new gt(s, n).toString();
      i.push(h), l = 0;
    }
    return i;
  }
  /**
   * Load all of sections in the book to generate locations
   * @param  {string} startCfi start position
   * @param  {int} wordCount how many words to split on
   * @param  {int} count result count
   * @return {object} locations
   */
  generateFromWords(e, n, r) {
    var i = e ? new gt(e) : void 0;
    return this.q.pause(), this._locationsWords = [], this._wordCounter = 0, this.spine.each(function(s) {
      s.linear && (i ? s.index >= i.spinePos && this.q.enqueue(this.processWords.bind(this), s, n, i, r) : this.q.enqueue(this.processWords.bind(this), s, n, i, r));
    }.bind(this)), this.q.run().then(function() {
      return this._currentCfi && (this.currentLocation = this._currentCfi), this._locationsWords;
    }.bind(this));
  }
  processWords(e, n, r, i) {
    return i && this._locationsWords.length >= i ? Promise.resolve() : e.load(this.request).then(function(s) {
      var o = new vt(), a = this.parseWords(s, e, n, r), l = i - this._locationsWords.length;
      return this._locationsWords = this._locationsWords.concat(a.length >= i ? a.slice(0, l) : a), e.unload(), this.processingTimeout = setTimeout(() => o.resolve(a), this.pause), o.promise;
    }.bind(this));
  }
  //http://stackoverflow.com/questions/18679576/counting-words-in-string
  countWords(e) {
    return e = e.replace(/(^\s*)|(\s*$)/gi, ""), e = e.replace(/[ ]{2,}/gi, " "), e = e.replace(/\n /, `
`), e.split(" ").length;
  }
  parseWords(e, n, r, i) {
    var s = n.cfiBase, o = [], a = e.ownerDocument, l = zt(a, "body"), u = r, c = i ? i.spinePos !== n.index : !0, d;
    i && n.index === i.spinePos && (d = i.findNode(i.range ? i.path.steps.concat(i.start.steps) : i.path.steps, e.ownerDocument));
    var h = function(v) {
      if (!c)
        if (v === d)
          c = !0;
        else
          return !1;
      if (v.textContent.length < 10 && v.textContent.trim().length === 0)
        return !1;
      var y = this.countWords(v.textContent), b, p = 0;
      if (y === 0)
        return !1;
      for (b = u - this._wordCounter, b > y && (this._wordCounter += y, p = y); p < y; )
        if (b = u - this._wordCounter, p + b >= y)
          this._wordCounter += y - p, p = y;
        else {
          p += b;
          let f = new gt(v, s);
          o.push({ cfi: f.toString(), wordCount: this._wordCounter }), this._wordCounter = 0;
        }
    };
    return Il(l, h.bind(this)), o;
  }
  /**
   * Get a location from an EpubCFI
   * @param {EpubCFI} cfi
   * @return {number}
   */
  locationFromCfi(e) {
    let n;
    return gt.prototype.isCfiString(e) && (e = new gt(e)), this._locations.length === 0 ? -1 : (n = zs(e, this._locations, this.epubcfi.compare), n > this.total ? this.total : n);
  }
  /**
   * Get a percentage position in locations from an EpubCFI
   * @param {EpubCFI} cfi
   * @return {number}
   */
  percentageFromCfi(e) {
    if (this._locations.length === 0)
      return null;
    var n = this.locationFromCfi(e);
    return this.percentageFromLocation(n);
  }
  /**
   * Get a percentage position from a location index
   * @param {number} location
   * @return {number}
   */
  percentageFromLocation(e) {
    return !e || !this.total ? 0 : e / this.total;
  }
  /**
   * Get an EpubCFI from location index
   * @param {number} loc
   * @return {EpubCFI} cfi
   */
  cfiFromLocation(e) {
    var n = -1;
    return typeof e != "number" && (e = parseInt(e)), e >= 0 && e < this._locations.length && (n = this._locations[e]), n;
  }
  /**
   * Get an EpubCFI from location percentage
   * @param {number} percentage
   * @return {EpubCFI} cfi
   */
  cfiFromPercentage(e) {
    let n;
    if (e > 1 && console.warn("Normalize cfiFromPercentage value to between 0 - 1"), e >= 1) {
      let r = new gt(this._locations[this.total]);
      return r.collapse(), r.toString();
    }
    return n = Math.ceil(this.total * e), this.cfiFromLocation(n);
  }
  /**
   * Load locations from JSON
   * @param {json} locations
   */
  load(e) {
    return typeof e == "string" ? this._locations = JSON.parse(e) : this._locations = e, this.total = this._locations.length - 1, this._locations;
  }
  /**
   * Save locations to JSON
   * @return {json}
   */
  save() {
    return JSON.stringify(this._locations);
  }
  getCurrent() {
    return this._current;
  }
  setCurrent(e) {
    var n;
    if (typeof e == "string")
      this._currentCfi = e;
    else if (typeof e == "number")
      this._current = e;
    else
      return;
    this._locations.length !== 0 && (typeof e == "string" ? (n = this.locationFromCfi(e), this._current = n) : n = e, this.emit(Re.LOCATIONS.CHANGED, {
      percentage: this.percentageFromLocation(n)
    }));
  }
  /**
   * Get the current location
   */
  get currentLocation() {
    return this._current;
  }
  /**
   * Set the current location
   */
  set currentLocation(e) {
    this.setCurrent(e);
  }
  /**
   * Locations length
   */
  length() {
    return this._locations.length;
  }
  destroy() {
    this.spine = void 0, this.request = void 0, this.pause = void 0, this.q.stop(), this.q = void 0, this.epubcfi = void 0, this._locations = void 0, this.total = void 0, this.break = void 0, this._current = void 0, this.currentLocation = void 0, this._currentCfi = void 0, clearTimeout(this.processingTimeout);
  }
}
Lr(m0.prototype);
class S8 {
  constructor(e) {
    this.packagePath = "", this.directory = "", this.encoding = "", e && this.parse(e);
  }
  /**
   * Parse the Container XML
   * @param  {document} containerDocument
   */
  parse(e) {
    var n;
    if (!e)
      throw new Error("Container File Not Found");
    if (n = zt(e, "rootfile"), !n)
      throw new Error("No RootFile Found");
    this.packagePath = n.getAttribute("full-path"), this.directory = gi.dirname(this.packagePath), this.encoding = e.xmlEncoding;
  }
  destroy() {
    this.packagePath = void 0, this.directory = void 0, this.encoding = void 0;
  }
}
class iv {
  constructor(e) {
    this.manifest = {}, this.navPath = "", this.ncxPath = "", this.coverPath = "", this.spineNodeIndex = 0, this.spine = [], this.metadata = {}, e && this.parse(e);
  }
  /**
   * Parse OPF XML
   * @param  {document} packageDocument OPF XML
   * @return {object} parsed package parts
   */
  parse(e) {
    var n, r, i;
    if (!e)
      throw new Error("Package File Not Found");
    if (n = zt(e, "metadata"), !n)
      throw new Error("No Metadata Found");
    if (r = zt(e, "manifest"), !r)
      throw new Error("No Manifest Found");
    if (i = zt(e, "spine"), !i)
      throw new Error("No Spine Found");
    return this.manifest = this.parseManifest(r), this.navPath = this.findNavPath(r), this.ncxPath = this.findNcxPath(r, i), this.coverPath = this.findCoverPath(e), this.spineNodeIndex = l0(i), this.spine = this.parseSpine(i, this.manifest), this.uniqueIdentifier = this.findUniqueIdentifier(e), this.metadata = this.parseMetadata(n), this.metadata.direction = i.getAttribute("page-progression-direction"), {
      metadata: this.metadata,
      spine: this.spine,
      manifest: this.manifest,
      navPath: this.navPath,
      ncxPath: this.ncxPath,
      coverPath: this.coverPath,
      spineNodeIndex: this.spineNodeIndex
    };
  }
  /**
   * Parse Metadata
   * @private
   * @param  {node} xml
   * @return {object} metadata
   */
  parseMetadata(e) {
    var n = {};
    return n.title = this.getElementText(e, "title"), n.creator = this.getElementText(e, "creator"), n.description = this.getElementText(e, "description"), n.pubdate = this.getElementText(e, "date"), n.publisher = this.getElementText(e, "publisher"), n.identifier = this.getElementText(e, "identifier"), n.language = this.getElementText(e, "language"), n.rights = this.getElementText(e, "rights"), n.modified_date = this.getPropertyText(e, "dcterms:modified"), n.layout = this.getPropertyText(e, "rendition:layout"), n.orientation = this.getPropertyText(e, "rendition:orientation"), n.flow = this.getPropertyText(e, "rendition:flow"), n.viewport = this.getPropertyText(e, "rendition:viewport"), n.media_active_class = this.getPropertyText(e, "media:active-class"), n.spread = this.getPropertyText(e, "rendition:spread"), n;
  }
  /**
   * Parse Manifest
   * @private
   * @param  {node} manifestXml
   * @return {object} manifest
   */
  parseManifest(e) {
    var n = {}, r = ni(e, "item"), i = Array.prototype.slice.call(r);
    return i.forEach(function(s) {
      var o = s.getAttribute("id"), a = s.getAttribute("href") || "", l = s.getAttribute("media-type") || "", u = s.getAttribute("media-overlay") || "", c = s.getAttribute("properties") || "";
      n[o] = {
        href: a,
        // "url" : href,
        type: l,
        overlay: u,
        properties: c.length ? c.split(" ") : []
      };
    }), n;
  }
  /**
   * Parse Spine
   * @private
   * @param  {node} spineXml
   * @param  {Packaging.manifest} manifest
   * @return {object} spine
   */
  parseSpine(e, n) {
    var r = [], i = ni(e, "itemref"), s = Array.prototype.slice.call(i);
    return s.forEach(function(o, a) {
      var l = o.getAttribute("idref"), u = o.getAttribute("properties") || "", c = u.length ? u.split(" ") : [], d = {
        id: o.getAttribute("id"),
        idref: l,
        linear: o.getAttribute("linear") || "yes",
        properties: c,
        // "href" : manifest[Id].href,
        // "url" :  manifest[Id].url,
        index: a
        // "cfiBase" : cfiBase
      };
      r.push(d);
    }), r;
  }
  /**
   * Find Unique Identifier
   * @private
   * @param  {node} packageXml
   * @return {string} Unique Identifier text
   */
  findUniqueIdentifier(e) {
    var n = e.documentElement.getAttribute("unique-identifier");
    if (!n)
      return "";
    var r = e.getElementById(n);
    return r && r.localName === "identifier" && r.namespaceURI === "http://purl.org/dc/elements/1.1/" && r.childNodes.length > 0 ? r.childNodes[0].nodeValue.trim() : "";
  }
  /**
   * Find TOC NAV
   * @private
   * @param {element} manifestNode
   * @return {string}
   */
  findNavPath(e) {
    var n = gs(e, "item", { properties: "nav" });
    return n ? n.getAttribute("href") : !1;
  }
  /**
   * Find TOC NCX
   * media-type="application/x-dtbncx+xml" href="toc.ncx"
   * @private
   * @param {element} manifestNode
   * @param {element} spineNode
   * @return {string}
   */
  findNcxPath(e, n) {
    var r = gs(e, "item", { "media-type": "application/x-dtbncx+xml" }), i;
    return r || (i = n.getAttribute("toc"), i && (r = e.querySelector(`#${i}`))), r ? r.getAttribute("href") : !1;
  }
  /**
   * Find the Cover Path
   * <item properties="cover-image" id="ci" href="cover.svg" media-type="image/svg+xml" />
   * Fallback for Epub 2.0
   * @private
   * @param  {node} packageXml
   * @return {string} href
   */
  findCoverPath(e) {
    var n = zt(e, "package");
    n.getAttribute("version");
    var r = gs(e, "item", { properties: "cover-image" });
    if (r)
      return r.getAttribute("href");
    var i = gs(e, "meta", { name: "cover" });
    if (i) {
      var s = i.getAttribute("content"), o = e.getElementById(s);
      return o ? o.getAttribute("href") : "";
    } else
      return !1;
  }
  /**
   * Get text of a namespaced element
   * @private
   * @param  {node} xml
   * @param  {string} tag
   * @return {string} text
   */
  getElementText(e, n) {
    var r = e.getElementsByTagNameNS("http://purl.org/dc/elements/1.1/", n), i;
    return !r || r.length === 0 ? "" : (i = r[0], i.childNodes.length ? i.childNodes[0].nodeValue : "");
  }
  /**
   * Get text by property
   * @private
   * @param  {node} xml
   * @param  {string} property
   * @return {string} text
   */
  getPropertyText(e, n) {
    var r = gs(e, "meta", { property: n });
    return r && r.childNodes.length ? r.childNodes[0].nodeValue : "";
  }
  /**
   * Load JSON Manifest
   * @param  {document} packageDocument OPF XML
   * @return {object} parsed package parts
   */
  load(e) {
    this.metadata = e.metadata;
    let n = e.readingOrder || e.spine;
    return this.spine = n.map((r, i) => (r.index = i, r.linear = r.linear || "yes", r)), e.resources.forEach((r, i) => {
      this.manifest[i] = r, r.rel && r.rel[0] === "cover" && (this.coverPath = r.href);
    }), this.spineNodeIndex = 0, this.toc = e.toc.map((r, i) => (r.label = r.title, r)), {
      metadata: this.metadata,
      spine: this.spine,
      manifest: this.manifest,
      navPath: this.navPath,
      ncxPath: this.ncxPath,
      coverPath: this.coverPath,
      spineNodeIndex: this.spineNodeIndex,
      toc: this.toc
    };
  }
  destroy() {
    this.manifest = void 0, this.navPath = void 0, this.ncxPath = void 0, this.coverPath = void 0, this.spineNodeIndex = void 0, this.spine = void 0, this.metadata = void 0;
  }
}
class Wu {
  constructor(e) {
    this.toc = [], this.tocByHref = {}, this.tocById = {}, this.landmarks = [], this.landmarksByType = {}, this.length = 0, e && this.parse(e);
  }
  /**
   * Parse out the navigation items
   * @param {document} xml navigation html / xhtml / ncx
   */
  parse(e) {
    let n = e.nodeType, r, i;
    n && (r = zt(e, "html"), i = zt(e, "ncx")), n ? r ? (this.toc = this.parseNav(e), this.landmarks = this.parseLandmarks(e)) : i && (this.toc = this.parseNcx(e)) : this.toc = this.load(e), this.length = 0, this.unpack(this.toc);
  }
  /**
   * Unpack navigation items
   * @private
   * @param  {array} toc
   */
  unpack(e) {
    for (var n, r = 0; r < e.length; r++)
      n = e[r], n.href && (this.tocByHref[n.href] = r), n.id && (this.tocById[n.id] = r), this.length++, n.subitems.length && this.unpack(n.subitems);
  }
  /**
   * Get an item from the navigation
   * @param  {string} target
   * @return {object} navItem
   */
  get(e) {
    var n;
    return e ? (e.indexOf("#") === 0 ? n = this.tocById[e.substring(1)] : e in this.tocByHref && (n = this.tocByHref[e]), this.getByIndex(e, n, this.toc)) : this.toc;
  }
  /**
   * Get an item from navigation subitems recursively by index
   * @param  {string} target
   * @param  {number} index
   * @param  {array} navItems
   * @return {object} navItem
   */
  getByIndex(e, n, r) {
    if (r.length === 0)
      return;
    const i = r[n];
    if (i && (e === i.id || e === i.href))
      return i;
    {
      let s;
      for (let o = 0; o < r.length && (s = this.getByIndex(e, n, r[o].subitems), !s); ++o)
        ;
      return s;
    }
  }
  /**
   * Get a landmark by type
   * List of types: https://idpf.github.io/epub-vocabs/structure/
   * @param  {string} type
   * @return {object} landmarkItem
   */
  landmark(e) {
    var n;
    return e ? (n = this.landmarksByType[e], this.landmarks[n]) : this.landmarks;
  }
  /**
   * Parse toc from a Epub > 3.0 Nav
   * @private
   * @param  {document} navHtml
   * @return {array} navigation list
   */
  parseNav(e) {
    var n = Nl(e, "nav", "toc"), r = [];
    if (!n)
      return r;
    let i = ms(n, "ol", !0);
    return i && (r = this.parseNavList(i)), r;
  }
  /**
   * Parses lists in the toc
   * @param  {document} navListHtml
   * @param  {string} parent id
   * @return {array} navigation list
   */
  parseNavList(e, n) {
    const r = [];
    if (!e || !e.children)
      return r;
    for (let i = 0; i < e.children.length; i++) {
      const s = this.navItem(e.children[i], n);
      s && r.push(s);
    }
    return r;
  }
  /**
   * Create a navItem
   * @private
   * @param  {element} item
   * @return {object} navItem
   */
  navItem(e, n) {
    let r = e.getAttribute("id") || void 0, i = ms(e, "a", !0) || ms(e, "span", !0);
    if (!i)
      return;
    let s = i.getAttribute("href") || "";
    r || (r = s);
    let o = i.textContent || "", a = [], l = ms(e, "ol", !0);
    return l && (a = this.parseNavList(l, r)), {
      id: r,
      href: s,
      label: o,
      subitems: a,
      parent: n
    };
  }
  /**
   * Parse landmarks from a Epub > 3.0 Nav
   * @private
   * @param  {document} navHtml
   * @return {array} landmarks list
   */
  parseLandmarks(e) {
    var n = Nl(e, "nav", "landmarks"), r = n ? ni(n, "li") : [], i = r.length, s, o = [], a;
    if (!r || i === 0)
      return o;
    for (s = 0; s < i; ++s)
      a = this.landmarkItem(r[s]), a && (o.push(a), this.landmarksByType[a.type] = s);
    return o;
  }
  /**
   * Create a landmarkItem
   * @private
   * @param  {element} item
   * @return {object} landmarkItem
   */
  landmarkItem(e) {
    let n = ms(e, "a", !0);
    if (!n)
      return;
    let r = n.getAttributeNS("http://www.idpf.org/2007/ops", "type") || void 0, i = n.getAttribute("href") || "", s = n.textContent || "";
    return {
      href: i,
      label: s,
      type: r
    };
  }
  /**
   * Parse from a Epub > 3.0 NC
   * @private
   * @param  {document} navHtml
   * @return {array} navigation list
   */
  parseNcx(e) {
    var n = ni(e, "navPoint"), r = n.length, i, s = {}, o = [], a, l;
    if (!n || r === 0)
      return o;
    for (i = 0; i < r; ++i)
      a = this.ncxItem(n[i]), s[a.id] = a, a.parent ? (l = s[a.parent], l.subitems.push(a)) : o.push(a);
    return o;
  }
  /**
   * Create a ncxItem
   * @private
   * @param  {element} item
   * @return {object} ncxItem
   */
  ncxItem(e) {
    var n = e.getAttribute("id") || !1, r = zt(e, "content"), i = r.getAttribute("src"), s = zt(e, "navLabel"), o = s.textContent ? s.textContent : "", a = [], l = e.parentNode, u;
    return l && (l.nodeName === "navPoint" || l.nodeName.split(":").slice(-1)[0] === "navPoint") && (u = l.getAttribute("id")), {
      id: n,
      href: i,
      label: o,
      subitems: a,
      parent: u
    };
  }
  /**
   * Load Spine Items
   * @param  {object} json the items to be loaded
   * @return {Array} navItems
   */
  load(e) {
    return e.map((n) => (n.label = n.title, n.subitems = n.children ? this.load(n.children) : [], n));
  }
  /**
   * forEach pass through
   * @param  {Function} fn function to run on each item
   * @return {method} forEach loop
   */
  forEach(e) {
    return this.toc.forEach(e);
  }
}
var to = {
  application: {
    ecmascript: ["es", "ecma"],
    javascript: "js",
    ogg: "ogx",
    pdf: "pdf",
    postscript: ["ps", "ai", "eps", "epsi", "epsf", "eps2", "eps3"],
    "rdf+xml": "rdf",
    smil: ["smi", "smil"],
    "xhtml+xml": ["xhtml", "xht"],
    xml: ["xml", "xsl", "xsd", "opf", "ncx"],
    zip: "zip",
    "x-httpd-eruby": "rhtml",
    "x-latex": "latex",
    "x-maker": ["frm", "maker", "frame", "fm", "fb", "book", "fbdoc"],
    "x-object": "o",
    "x-shockwave-flash": ["swf", "swfl"],
    "x-silverlight": "scr",
    "epub+zip": "epub",
    "font-tdpfr": "pfr",
    "inkml+xml": ["ink", "inkml"],
    json: "json",
    "jsonml+json": "jsonml",
    "mathml+xml": "mathml",
    "metalink+xml": "metalink",
    mp4: "mp4s",
    // "oebps-package+xml" : "opf",
    "omdoc+xml": "omdoc",
    oxps: "oxps",
    "vnd.amazon.ebook": "azw",
    widget: "wgt",
    // "x-dtbncx+xml" : "ncx",
    "x-dtbook+xml": "dtb",
    "x-dtbresource+xml": "res",
    "x-font-bdf": "bdf",
    "x-font-ghostscript": "gsf",
    "x-font-linux-psf": "psf",
    "x-font-otf": "otf",
    "x-font-pcf": "pcf",
    "x-font-snf": "snf",
    "x-font-ttf": ["ttf", "ttc"],
    "x-font-type1": ["pfa", "pfb", "pfm", "afm"],
    "x-font-woff": "woff",
    "x-mobipocket-ebook": ["prc", "mobi"],
    "x-mspublisher": "pub",
    "x-nzb": "nzb",
    "x-tgif": "obj",
    "xaml+xml": "xaml",
    "xml-dtd": "dtd",
    "xproc+xml": "xpl",
    "xslt+xml": "xslt",
    "internet-property-stream": "acx",
    "x-compress": "z",
    "x-compressed": "tgz",
    "x-gzip": "gz"
  },
  audio: {
    flac: "flac",
    midi: ["mid", "midi", "kar", "rmi"],
    mpeg: ["mpga", "mpega", "mp2", "mp3", "m4a", "mp2a", "m2a", "m3a"],
    mpegurl: "m3u",
    ogg: ["oga", "ogg", "spx"],
    "x-aiff": ["aif", "aiff", "aifc"],
    "x-ms-wma": "wma",
    "x-wav": "wav",
    adpcm: "adp",
    mp4: "mp4a",
    webm: "weba",
    "x-aac": "aac",
    "x-caf": "caf",
    "x-matroska": "mka",
    "x-pn-realaudio-plugin": "rmp",
    xm: "xm",
    mid: ["mid", "rmi"]
  },
  image: {
    gif: "gif",
    ief: "ief",
    jpeg: ["jpeg", "jpg", "jpe"],
    pcx: "pcx",
    png: "png",
    "svg+xml": ["svg", "svgz"],
    tiff: ["tiff", "tif"],
    "x-icon": "ico",
    bmp: "bmp",
    webp: "webp",
    "x-pict": ["pic", "pct"],
    "x-tga": "tga",
    "cis-cod": "cod"
  },
  text: {
    "cache-manifest": ["manifest", "appcache"],
    css: "css",
    csv: "csv",
    html: ["html", "htm", "shtml", "stm"],
    mathml: "mml",
    plain: ["txt", "text", "brf", "conf", "def", "list", "log", "in", "bas"],
    richtext: "rtx",
    "tab-separated-values": "tsv",
    "x-bibtex": "bib"
  },
  video: {
    mpeg: ["mpeg", "mpg", "mpe", "m1v", "m2v", "mp2", "mpa", "mpv2"],
    mp4: ["mp4", "mp4v", "mpg4"],
    quicktime: ["qt", "mov"],
    ogg: "ogv",
    "vnd.mpegurl": ["mxu", "m4u"],
    "x-flv": "flv",
    "x-la-asf": ["lsf", "lsx"],
    "x-mng": "mng",
    "x-ms-asf": ["asf", "asx", "asr"],
    "x-ms-wm": "wm",
    "x-ms-wmv": "wmv",
    "x-ms-wmx": "wmx",
    "x-ms-wvx": "wvx",
    "x-msvideo": "avi",
    "x-sgi-movie": "movie",
    "x-matroska": ["mpv", "mkv", "mk3d", "mks"],
    "3gpp2": "3g2",
    h261: "h261",
    h263: "h263",
    h264: "h264",
    jpeg: "jpgv",
    jpm: ["jpm", "jpgm"],
    mj2: ["mj2", "mjp2"],
    "vnd.ms-playready.media.pyv": "pyv",
    "vnd.uvvu.mp4": ["uvu", "uvvu"],
    "vnd.vivo": "viv",
    webm: "webm",
    "x-f4v": "f4v",
    "x-m4v": "m4v",
    "x-ms-vob": "vob",
    "x-smv": "smv"
  }
}, E8 = function() {
  var t, e, n, r, i = {};
  for (t in to)
    if (to.hasOwnProperty(t)) {
      for (e in to[t])
        if (to[t].hasOwnProperty(e))
          if (n = to[t][e], typeof n == "string")
            i[n] = t + "/" + e;
          else
            for (r = 0; r < n.length; r++)
              i[n[r]] = t + "/" + e;
    }
  return i;
}(), x8 = "text/plain";
function A8(t) {
  return t && E8[t.split(".").pop().toLowerCase()] || x8;
}
const xs = { lookup: A8 };
class k8 {
  constructor(e, n) {
    this.settings = {
      replacements: n && n.replacements || "base64",
      archive: n && n.archive,
      resolver: n && n.resolver,
      request: n && n.request
    }, this.process(e);
  }
  /**
   * Process resources
   * @param {Manifest} manifest
   */
  process(e) {
    this.manifest = e, this.resources = Object.keys(e).map(function(n) {
      return e[n];
    }), this.replacementUrls = [], this.html = [], this.assets = [], this.css = [], this.urls = [], this.cssUrls = [], this.split(), this.splitUrls();
  }
  /**
   * Split resources by type
   * @private
   */
  split() {
    this.html = this.resources.filter(function(e) {
      if (e.type === "application/xhtml+xml" || e.type === "text/html")
        return !0;
    }), this.assets = this.resources.filter(function(e) {
      if (e.type !== "application/xhtml+xml" && e.type !== "text/html")
        return !0;
    }), this.css = this.resources.filter(function(e) {
      if (e.type === "text/css")
        return !0;
    });
  }
  /**
   * Convert split resources into Urls
   * @private
   */
  splitUrls() {
    this.urls = this.assets.map(function(e) {
      return e.href;
    }.bind(this)), this.cssUrls = this.css.map(function(e) {
      return e.href;
    });
  }
  /**
   * Create a url to a resource
   * @param {string} url
   * @return {Promise<string>} Promise resolves with url string
   */
  createUrl(e) {
    var n = new fr(e), r = xs.lookup(n.filename);
    return this.settings.archive ? this.settings.archive.createUrl(e, { base64: this.settings.replacements === "base64" }) : this.settings.replacements === "base64" ? this.settings.request(e, "blob").then((i) => h0(i)).then((i) => rd(i, r)) : this.settings.request(e, "blob").then((i) => Ol(i, r));
  }
  /**
   * Create blob urls for all the assets
   * @return {Promise}         returns replacement urls
   */
  replacements() {
    if (this.settings.replacements === "none")
      return new Promise(function(n) {
        n(this.urls);
      }.bind(this));
    var e = this.urls.map((n) => {
      var r = this.settings.resolver(n);
      return this.createUrl(r).catch((i) => (console.error(i), null));
    });
    return Promise.all(e).then((n) => (this.replacementUrls = n.filter((r) => typeof r == "string"), n));
  }
  /**
   * Replace URLs in CSS resources
   * @private
   * @param  {Archive} [archive]
   * @param  {method} [resolver]
   * @return {Promise}
   */
  replaceCss(e, n) {
    var r = [];
    return e = e || this.settings.archive, n = n || this.settings.resolver, this.cssUrls.forEach(function(i) {
      var s = this.createCssFile(i, e, n).then(function(o) {
        var a = this.urls.indexOf(i);
        a > -1 && (this.replacementUrls[a] = o);
      }.bind(this));
      r.push(s);
    }.bind(this)), Promise.all(r);
  }
  /**
   * Create a new CSS file with the replaced URLs
   * @private
   * @param  {string} href the original css file
   * @return {Promise}  returns a BlobUrl to the new CSS file or a data url
   */
  createCssFile(e) {
    var n;
    if (gi.isAbsolute(e))
      return new Promise(function(o) {
        o();
      });
    var r = this.settings.resolver(e), i;
    this.settings.archive ? i = this.settings.archive.getText(r) : i = this.settings.request(r, "text");
    var s = this.urls.map((o) => {
      var a = this.settings.resolver(o), l = new ri(r).relative(a);
      return l;
    });
    return i ? i.then((o) => (o = rv(o, s, this.replacementUrls), this.settings.replacements === "base64" ? n = rd(o, "text/css") : n = Ol(o, "text/css"), n), (o) => new Promise(function(a) {
      a();
    })) : new Promise(function(o) {
      o();
    });
  }
  /**
   * Resolve all resources URLs relative to an absolute URL
   * @param  {string} absolute to be resolved to
   * @param  {resolver} [resolver]
   * @return {string[]} array with relative Urls
   */
  relativeTo(e, n) {
    return n = n || this.settings.resolver, this.urls.map(function(r) {
      var i = n(r), s = new ri(e).relative(i);
      return s;
    }.bind(this));
  }
  /**
   * Get a URL for a resource
   * @param  {string} path
   * @return {string} url
   */
  get(e) {
    var n = this.urls.indexOf(e);
    if (n !== -1)
      return this.replacementUrls.length ? new Promise(function(r, i) {
        r(this.replacementUrls[n]);
      }.bind(this)) : this.createUrl(e);
  }
  /**
   * Substitute urls in content, with replacements,
   * relative to a url if provided
   * @param  {string} content
   * @param  {string} [url]   url to resolve to
   * @return {string}         content with urls substituted
   */
  substitute(e, n) {
    var r;
    return n ? r = this.relativeTo(n) : r = this.urls, rv(e, r, this.replacementUrls);
  }
  destroy() {
    this.settings = void 0, this.manifest = void 0, this.resources = void 0, this.replacementUrls = void 0, this.html = void 0, this.assets = void 0, this.css = void 0, this.urls = void 0, this.cssUrls = void 0;
  }
}
class Ku {
  constructor(e) {
    this.pages = [], this.locations = [], this.epubcfi = new gt(), this.firstPage = 0, this.lastPage = 0, this.totalPages = 0, this.toc = void 0, this.ncx = void 0, e && (this.pageList = this.parse(e)), this.pageList && this.pageList.length && this.process(this.pageList);
  }
  /**
   * Parse PageList Xml
   * @param  {document} xml
   */
  parse(e) {
    var n = zt(e, "html"), r = zt(e, "ncx");
    if (n)
      return this.parseNav(e);
    if (r)
      return this.parseNcx(e);
  }
  /**
   * Parse a Nav PageList
   * @private
   * @param  {node} navHtml
   * @return {PageList.item[]} list
   */
  parseNav(e) {
    var n = Nl(e, "nav", "page-list"), r = n ? ni(n, "li") : [], i = r.length, s, o = [], a;
    if (!r || i === 0)
      return o;
    for (s = 0; s < i; ++s)
      a = this.item(r[s]), o.push(a);
    return o;
  }
  parseNcx(e) {
    var n = [], r = 0, i, s, o, a = 0;
    if (s = zt(e, "pageList"), !s || (o = ni(s, "pageTarget"), a = o.length, !o || o.length === 0))
      return n;
    for (r = 0; r < a; ++r)
      i = this.ncxItem(o[r]), n.push(i);
    return n;
  }
  ncxItem(e) {
    var n = zt(e, "navLabel"), r = zt(n, "text"), i = r.textContent, s = zt(e, "content"), o = s.getAttribute("src"), a = parseInt(i, 10);
    return {
      href: o,
      page: a
    };
  }
  /**
   * Page List Item
   * @private
   * @param  {node} item
   * @return {object} pageListItem
   */
  item(e) {
    var n = zt(e, "a"), r = n.getAttribute("href") || "", i = n.textContent || "", s = parseInt(i), o = r.indexOf("epubcfi"), a, l, u;
    return o != -1 ? (a = r.split("#"), l = a[0], u = a.length > 1 ? a[1] : !1, {
      cfi: u,
      href: r,
      packageUrl: l,
      page: s
    }) : {
      href: r,
      page: s
    };
  }
  /**
   * Process pageList items
   * @private
   * @param  {array} pageList
   */
  process(e) {
    e.forEach(function(n) {
      this.pages.push(n.page), n.cfi && this.locations.push(n.cfi);
    }, this), this.firstPage = parseInt(this.pages[0]), this.lastPage = parseInt(this.pages[this.pages.length - 1]), this.totalPages = this.lastPage - this.firstPage;
  }
  /**
   * Get a PageList result from a EpubCFI
   * @param  {string} cfi EpubCFI String
   * @return {number} page
   */
  pageFromCfi(e) {
    var n = -1;
    if (this.locations.length === 0)
      return -1;
    var r = kl(e, this.locations, this.epubcfi.compare);
    return r != -1 ? n = this.pages[r] : (r = zs(e, this.locations, this.epubcfi.compare), n = r - 1 >= 0 ? this.pages[r - 1] : this.pages[0], n !== void 0 || (n = -1)), n;
  }
  /**
   * Get an EpubCFI from a Page List Item
   * @param  {string | number} pg
   * @return {string} cfi
   */
  cfiFromPage(e) {
    var n = -1;
    typeof e != "number" && (e = parseInt(e));
    var r = this.pages.indexOf(e);
    return r != -1 && (n = this.locations[r]), n;
  }
  /**
   * Get a Page from Book percentage
   * @param  {number} percent
   * @return {number} page
   */
  pageFromPercentage(e) {
    var n = Math.round(this.totalPages * e);
    return n;
  }
  /**
   * Returns a value between 0 - 1 corresponding to the location of a page
   * @param  {number} pg the page
   * @return {number} percentage
   */
  percentageFromPage(e) {
    var n = (e - this.firstPage) / this.totalPages;
    return Math.round(n * 1e3) / 1e3;
  }
  /**
   * Returns a value between 0 - 1 corresponding to the location of a cfi
   * @param  {string} cfi EpubCFI String
   * @return {number} percentage
   */
  percentageFromCfi(e) {
    var n = this.pageFromCfi(e), r = this.percentageFromPage(n);
    return r;
  }
  /**
   * Destroy
   */
  destroy() {
    this.pages = void 0, this.locations = void 0, this.epubcfi = void 0, this.pageList = void 0, this.toc = void 0, this.ncx = void 0;
  }
}
class y0 {
  constructor(e) {
    this.settings = e, this.name = e.layout || "reflowable", this._spread = e.spread !== "none", this._minSpreadWidth = e.minSpreadWidth || 800, this._evenSpreads = e.evenSpreads || !1, e.flow === "scrolled" || e.flow === "scrolled-continuous" || e.flow === "scrolled-doc" ? this._flow = "scrolled" : this._flow = "paginated", this.width = 0, this.height = 0, this.spreadWidth = 0, this.delta = 0, this.columnWidth = 0, this.gap = 0, this.divisor = 1, this.props = {
      name: this.name,
      spread: this._spread,
      flow: this._flow,
      width: 0,
      height: 0,
      spreadWidth: 0,
      delta: 0,
      columnWidth: 0,
      gap: 0,
      divisor: 1
    };
  }
  /**
   * Switch the flow between paginated and scrolled
   * @param  {string} flow paginated | scrolled
   * @return {string} simplified flow
   */
  flow(e) {
    return typeof e < "u" && (e === "scrolled" || e === "scrolled-continuous" || e === "scrolled-doc" ? this._flow = "scrolled" : this._flow = "paginated", this.update({ flow: this._flow })), this._flow;
  }
  /**
   * Switch between using spreads or not, and set the
   * width at which they switch to single.
   * @param  {string} spread "none" | "always" | "auto"
   * @param  {number} min integer in pixels
   * @return {boolean} spread true | false
   */
  spread(e, n) {
    return e && (this._spread = e !== "none", this.update({ spread: this._spread })), n >= 0 && (this._minSpreadWidth = n), this._spread;
  }
  /**
   * Calculate the dimensions of the pagination
   * @param  {number} _width  width of the rendering
   * @param  {number} _height height of the rendering
   * @param  {number} _gap    width of the gap between columns
   */
  calculate(e, n, r) {
    var i = 1, s = r || 0, o = e, a = n, l = Math.floor(o / 12), u, c, d, h;
    this._spread && o >= this._minSpreadWidth ? i = 2 : i = 1, this.name === "reflowable" && this._flow === "paginated" && !(r >= 0) && (s = l % 2 === 0 ? l : l - 1), this.name === "pre-paginated" && (s = 0), i > 1 ? (u = o / i - s, d = u + s) : (u = o, d = o), this.name === "pre-paginated" && i > 1 && (o = u), c = u * i + s, h = o, this.width = o, this.height = a, this.spreadWidth = c, this.pageWidth = d, this.delta = h, this.columnWidth = u, this.gap = s, this.divisor = i, this.update({
      width: o,
      height: a,
      spreadWidth: c,
      pageWidth: d,
      delta: h,
      columnWidth: u,
      gap: s,
      divisor: i
    });
  }
  /**
   * Apply Css to a Document
   * @param  {Contents} contents
   * @return {Promise}
   */
  format(e, n, r) {
    var i;
    return this.name === "pre-paginated" ? i = e.fit(this.columnWidth, this.height, n) : this._flow === "paginated" ? i = e.columns(this.width, this.height, this.columnWidth, this.gap, this.settings.direction) : r && r === "horizontal" ? i = e.size(null, this.height) : i = e.size(this.width, null), i;
  }
  /**
   * Count number of pages
   * @param  {number} totalLength
   * @param  {number} pageLength
   * @return {{spreads: Number, pages: Number}}
   */
  count(e, n) {
    let r, i;
    return this.name === "pre-paginated" ? (r = 1, i = 1) : this._flow === "paginated" ? (n = n || this.delta, r = Math.ceil(e / n), i = r * this.divisor) : (n = n || this.height, r = Math.ceil(e / n), i = r), {
      spreads: r,
      pages: i
    };
  }
  /**
   * Update props that have changed
   * @private
   * @param  {object} props
   */
  update(e) {
    if (Object.keys(e).forEach((n) => {
      this.props[n] === e[n] && delete e[n];
    }), Object.keys(e).length > 0) {
      let n = Sn(this.props, e);
      this.emit(Re.LAYOUT.UPDATED, n, e);
    }
  }
}
Lr(y0.prototype);
class C8 {
  constructor(e) {
    this.rendition = e, this._themes = {
      default: {
        rules: {},
        url: "",
        serialized: ""
      }
    }, this._overrides = {}, this._current = "default", this._injected = [], this.rendition.hooks.content.register(this.inject.bind(this)), this.rendition.hooks.content.register(this.overrides.bind(this));
  }
  /**
   * Add themes to be used by a rendition
   * @param {object | Array<object> | string}
   * @example themes.register("light", "http://example.com/light.css")
   * @example themes.register("light", { "body": { "color": "purple"}})
   * @example themes.register({ "light" : {...}, "dark" : {...}})
   */
  register() {
    if (arguments.length !== 0) {
      if (arguments.length === 1 && typeof arguments[0] == "object")
        return this.registerThemes(arguments[0]);
      if (arguments.length === 1 && typeof arguments[0] == "string")
        return this.default(arguments[0]);
      if (arguments.length === 2 && typeof arguments[1] == "string")
        return this.registerUrl(arguments[0], arguments[1]);
      if (arguments.length === 2 && typeof arguments[1] == "object")
        return this.registerRules(arguments[0], arguments[1]);
    }
  }
  /**
   * Add a default theme to be used by a rendition
   * @param {object | string} theme
   * @example themes.register("http://example.com/default.css")
   * @example themes.register({ "body": { "color": "purple"}})
   */
  default(e) {
    if (e) {
      if (typeof e == "string")
        return this.registerUrl("default", e);
      if (typeof e == "object")
        return this.registerRules("default", e);
    }
  }
  /**
   * Register themes object
   * @param {object} themes
   */
  registerThemes(e) {
    for (var n in e)
      e.hasOwnProperty(n) && (typeof e[n] == "string" ? this.registerUrl(n, e[n]) : this.registerRules(n, e[n]));
  }
  /**
   * Register a theme by passing its css as string
   * @param {string} name 
   * @param {string} css 
   */
  registerCss(e, n) {
    this._themes[e] = { serialized: n }, (this._injected[e] || e == "default") && this.update(e);
  }
  /**
   * Register a url
   * @param {string} name
   * @param {string} input
   */
  registerUrl(e, n) {
    var r = new fr(n);
    this._themes[e] = { url: r.toString() }, (this._injected[e] || e == "default") && this.update(e);
  }
  /**
   * Register rule
   * @param {string} name
   * @param {object} rules
   */
  registerRules(e, n) {
    this._themes[e] = { rules: n }, (this._injected[e] || e == "default") && this.update(e);
  }
  /**
   * Select a theme
   * @param {string} name
   */
  select(e) {
    var n = this._current, r;
    this._current = e, this.update(e), r = this.rendition.getContents(), r.forEach((i) => {
      i.removeClass(n), i.addClass(e);
    });
  }
  /**
   * Update a theme
   * @param {string} name
   */
  update(e) {
    var n = this.rendition.getContents();
    n.forEach((r) => {
      this.add(e, r);
    });
  }
  /**
   * Inject all themes into contents
   * @param {Contents} contents
   */
  inject(e) {
    var n = [], r = this._themes, i;
    for (var s in r)
      r.hasOwnProperty(s) && (s === this._current || s === "default") && (i = r[s], (i.rules && Object.keys(i.rules).length > 0 || i.url && n.indexOf(i.url) === -1) && this.add(s, e), this._injected.push(s));
    this._current != "default" && e.addClass(this._current);
  }
  /**
   * Add Theme to contents
   * @param {string} name
   * @param {Contents} contents
   */
  add(e, n) {
    var r = this._themes[e];
    !r || !n || (r.url ? n.addStylesheet(r.url) : r.serialized ? (n.addStylesheetCss(r.serialized, e), r.injected = !0) : r.rules && (n.addStylesheetRules(r.rules, e), r.injected = !0));
  }
  /**
   * Add override
   * @param {string} name
   * @param {string} value
   * @param {boolean} priority
   */
  override(e, n, r) {
    var i = this.rendition.getContents();
    this._overrides[e] = {
      value: n,
      priority: r === !0
    }, i.forEach((s) => {
      s.css(e, this._overrides[e].value, this._overrides[e].priority);
    });
  }
  removeOverride(e) {
    var n = this.rendition.getContents();
    delete this._overrides[e], n.forEach((r) => {
      r.css(e);
    });
  }
  /**
   * Add all overrides
   * @param {Content} content
   */
  overrides(e) {
    var n = this._overrides;
    for (var r in n)
      n.hasOwnProperty(r) && e.css(r, n[r].value, n[r].priority);
  }
  /**
   * Adjust the font size of a rendition
   * @param {number} size
   */
  fontSize(e) {
    this.override("font-size", e);
  }
  /**
   * Adjust the font-family of a rendition
   * @param {string} f
   */
  font(e) {
    this.override("font-family", e, !0);
  }
  destroy() {
    this.rendition = void 0, this._themes = void 0, this._overrides = void 0, this._current = void 0, this._injected = void 0;
  }
}
class Rl {
  constructor(e, n, r, i = !1) {
    this.layout = e, this.horizontal = r === "horizontal", this.direction = n || "ltr", this._dev = i;
  }
  /**
   * Find CFI pairs for entire section at once
   */
  section(e) {
    var n = this.findRanges(e), r = this.rangeListToCfiList(e.section.cfiBase, n);
    return r;
  }
  /**
   * Find CFI pairs for a page
   * @param {Contents} contents Contents from view
   * @param {string} cfiBase string of the base for a cfi
   * @param {number} start position to start at
   * @param {number} end position to end at
   */
  page(e, n, r, i) {
    var s = e && e.document ? e.document.body : !1, o;
    if (s) {
      if (o = this.rangePairToCfiPair(n, {
        start: this.findStart(s, r, i),
        end: this.findEnd(s, r, i)
      }), this._dev === !0) {
        let a = e.document, l = new gt(o.start).toRange(a), u = new gt(o.end).toRange(a), c = a.defaultView.getSelection(), d = a.createRange();
        c.removeAllRanges(), d.setStart(l.startContainer, l.startOffset), d.setEnd(u.endContainer, u.endOffset), c.addRange(d);
      }
      return o;
    }
  }
  /**
   * Walk a node, preforming a function on each node it finds
   * @private
   * @param {Node} root Node to walkToNode
   * @param {function} func walk function
   * @return {*} returns the result of the walk function
   */
  walk(e, n) {
    if (!(e && e.nodeType === Node.TEXT_NODE)) {
      var r = {
        acceptNode: function(l) {
          return l.data.trim().length > 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
        }
      }, i = r.acceptNode;
      i.acceptNode = r.acceptNode;
      for (var s = document.createTreeWalker(e, NodeFilter.SHOW_TEXT, i, !1), o, a; (o = s.nextNode()) && (a = n(o), !a); )
        ;
      return a;
    }
  }
  findRanges(e) {
    for (var n = [], r = e.contents.scrollWidth(), i = Math.ceil(r / this.layout.spreadWidth), s = i * this.layout.divisor, o = this.layout.columnWidth, a = this.layout.gap, l, u, c = 0; c < s.pages; c++)
      l = (o + a) * c, u = o * (c + 1) + a * c, n.push({
        start: this.findStart(e.document.body, l, u),
        end: this.findEnd(e.document.body, l, u)
      });
    return n;
  }
  /**
   * Find Start Range
   * @private
   * @param {Node} root root node
   * @param {number} start position to start at
   * @param {number} end position to end at
   * @return {Range}
   */
  findStart(e, n, r) {
    for (var i = [e], s, o, a = e; i.length; )
      if (s = i.shift(), o = this.walk(s, (l) => {
        var u, c, d, h, v;
        if (v = nd(l), this.horizontal && this.direction === "ltr") {
          if (u = this.horizontal ? v.left : v.top, c = this.horizontal ? v.right : v.bottom, u >= n && u <= r)
            return l;
          if (c > n)
            return l;
          a = l, i.push(l);
        } else if (this.horizontal && this.direction === "rtl") {
          if (u = v.left, c = v.right, c <= r && c >= n)
            return l;
          if (u < r)
            return l;
          a = l, i.push(l);
        } else {
          if (d = v.top, h = v.bottom, d >= n && d <= r)
            return l;
          if (h > n)
            return l;
          a = l, i.push(l);
        }
      }), o)
        return this.findTextStartRange(o, n, r);
    return this.findTextStartRange(a, n, r);
  }
  /**
   * Find End Range
   * @private
   * @param {Node} root root node
   * @param {number} start position to start at
   * @param {number} end position to end at
   * @return {Range}
   */
  findEnd(e, n, r) {
    for (var i = [e], s, o = e, a; i.length; )
      if (s = i.shift(), a = this.walk(s, (l) => {
        var u, c, d, h, v;
        if (v = nd(l), this.horizontal && this.direction === "ltr") {
          if (u = Math.round(v.left), c = Math.round(v.right), u > r && o)
            return o;
          if (c > r)
            return l;
          o = l, i.push(l);
        } else if (this.horizontal && this.direction === "rtl") {
          if (u = Math.round(this.horizontal ? v.left : v.top), c = Math.round(this.horizontal ? v.right : v.bottom), c < n && o)
            return o;
          if (u < n)
            return l;
          o = l, i.push(l);
        } else {
          if (d = Math.round(v.top), h = Math.round(v.bottom), d > r && o)
            return o;
          if (h > r)
            return l;
          o = l, i.push(l);
        }
      }), a)
        return this.findTextEndRange(a, n, r);
    return this.findTextEndRange(o, n, r);
  }
  /**
   * Find Text Start Range
   * @private
   * @param {Node} root root node
   * @param {number} start position to start at
   * @param {number} end position to end at
   * @return {Range}
   */
  findTextStartRange(e, n, r) {
    for (var i = this.splitTextNodeIntoRanges(e), s, o, a, l, u, c = 0; c < i.length; c++)
      if (s = i[c], o = s.getBoundingClientRect(), this.horizontal && this.direction === "ltr") {
        if (a = o.left, a >= n)
          return s;
      } else if (this.horizontal && this.direction === "rtl") {
        if (u = o.right, u <= r)
          return s;
      } else if (l = o.top, l >= n)
        return s;
    return i[0];
  }
  /**
   * Find Text End Range
   * @private
   * @param {Node} root root node
   * @param {number} start position to start at
   * @param {number} end position to end at
   * @return {Range}
   */
  findTextEndRange(e, n, r) {
    for (var i = this.splitTextNodeIntoRanges(e), s, o, a, l, u, c, d, h = 0; h < i.length; h++) {
      if (o = i[h], a = o.getBoundingClientRect(), this.horizontal && this.direction === "ltr") {
        if (l = a.left, u = a.right, l > r && s)
          return s;
        if (u > r)
          return o;
      } else if (this.horizontal && this.direction === "rtl") {
        if (l = a.left, u = a.right, u < n && s)
          return s;
        if (l < n)
          return o;
      } else {
        if (c = a.top, d = a.bottom, c > r && s)
          return s;
        if (d > r)
          return o;
      }
      s = o;
    }
    return i[i.length - 1];
  }
  /**
   * Split up a text node into ranges for each word
   * @private
   * @param {Node} root root node
   * @param {string} [_splitter] what to split on
   * @return {Range[]}
   */
  splitTextNodeIntoRanges(e, n) {
    var r = [], i = e.textContent || "", s = i.trim(), o, a = e.ownerDocument, l = n || " ", u = s.indexOf(l);
    if (u === -1 || e.nodeType != Node.TEXT_NODE)
      return o = a.createRange(), o.selectNodeContents(e), [o];
    for (o = a.createRange(), o.setStart(e, 0), o.setEnd(e, u), r.push(o), o = !1; u != -1; )
      u = s.indexOf(l, u + 1), u > 0 && (o && (o.setEnd(e, u), r.push(o)), o = a.createRange(), o.setStart(e, u + 1));
    return o && (o.setEnd(e, s.length), r.push(o)), r;
  }
  /**
   * Turn a pair of ranges into a pair of CFIs
   * @private
   * @param {string} cfiBase base string for an EpubCFI
   * @param {object} rangePair { start: Range, end: Range }
   * @return {object} { start: "epubcfi(...)", end: "epubcfi(...)" }
   */
  rangePairToCfiPair(e, n) {
    var r = n.start, i = n.end;
    r.collapse(!0), i.collapse(!1);
    let s = new gt(r, e).toString(), o = new gt(i, e).toString();
    return {
      start: s,
      end: o
    };
  }
  rangeListToCfiList(e, n) {
    for (var r = [], i, s = 0; s < n.length; s++)
      i = this.rangePairToCfiPair(e, n[s]), r.push(i);
    return r;
  }
  /**
   * Set the axis for mapping
   * @param {string} axis horizontal | vertical
   * @return {boolean} is it horizontal?
   */
  axis(e) {
    return e && (this.horizontal = e === "horizontal"), this.horizontal;
  }
}
const b0 = typeof navigator < "u", T8 = b0 && /Chrome/.test(navigator.userAgent), sv = b0 && !T8 && /AppleWebKit/.test(navigator.userAgent), O8 = 1;
class If {
  constructor(e, n, r, i) {
    this.epubcfi = new gt(), this.document = e, this.documentElement = this.document.documentElement, this.content = n || this.document.body, this.window = this.document.defaultView, this._size = {
      width: 0,
      height: 0
    }, this.sectionIndex = i || 0, this.cfiBase = r || "", this.epubReadingSystem("epub.js", iu), this.called = 0, this.active = !0, this.listeners();
  }
  /**
  	* Get DOM events that are listened for and passed along
  	*/
  static get listenedEvents() {
    return tl;
  }
  /**
  	* Get or Set width
  	* @param {number} [w]
  	* @returns {number} width
  	*/
  width(e) {
    var n = this.content;
    return e && Yt(e) && (e = e + "px"), e && (n.style.width = e), parseInt(this.window.getComputedStyle(n).width);
  }
  /**
  	* Get or Set height
  	* @param {number} [h]
  	* @returns {number} height
  	*/
  height(e) {
    var n = this.content;
    return e && Yt(e) && (e = e + "px"), e && (n.style.height = e), parseInt(this.window.getComputedStyle(n).height);
  }
  /**
  	* Get or Set width of the contents
  	* @param {number} [w]
  	* @returns {number} width
  	*/
  contentWidth(e) {
    var n = this.content || this.document.body;
    return e && Yt(e) && (e = e + "px"), e && (n.style.width = e), parseInt(this.window.getComputedStyle(n).width);
  }
  /**
  	* Get or Set height of the contents
  	* @param {number} [h]
  	* @returns {number} height
  	*/
  contentHeight(e) {
    var n = this.content || this.document.body;
    return e && Yt(e) && (e = e + "px"), e && (n.style.height = e), parseInt(this.window.getComputedStyle(n).height);
  }
  /**
  	* Get the width of the text using Range
  	* @returns {number} width
  	*/
  textWidth() {
    let e, n, r = this.document.createRange(), i = this.content || this.document.body, s = Cl(i);
    return r.selectNodeContents(i), e = r.getBoundingClientRect(), n = e.width, s && s.width && (n += s.width), Math.round(n);
  }
  /**
  	* Get the height of the text using Range
  	* @returns {number} height
  	*/
  textHeight() {
    let e, n, r = this.document.createRange(), i = this.content || this.document.body;
    return r.selectNodeContents(i), e = r.getBoundingClientRect(), n = e.bottom, Math.round(n);
  }
  /**
  	* Get documentElement scrollWidth
  	* @returns {number} width
  	*/
  scrollWidth() {
    var e = this.documentElement.scrollWidth;
    return e;
  }
  /**
  	* Get documentElement scrollHeight
  	* @returns {number} height
  	*/
  scrollHeight() {
    var e = this.documentElement.scrollHeight;
    return e;
  }
  /**
  	* Set overflow css style of the contents
  	* @param {string} [overflow]
  	*/
  overflow(e) {
    return e && (this.documentElement.style.overflow = e), this.window.getComputedStyle(this.documentElement).overflow;
  }
  /**
  	* Set overflowX css style of the documentElement
  	* @param {string} [overflow]
  	*/
  overflowX(e) {
    return e && (this.documentElement.style.overflowX = e), this.window.getComputedStyle(this.documentElement).overflowX;
  }
  /**
  	* Set overflowY css style of the documentElement
  	* @param {string} [overflow]
  	*/
  overflowY(e) {
    return e && (this.documentElement.style.overflowY = e), this.window.getComputedStyle(this.documentElement).overflowY;
  }
  /**
  	* Set Css styles on the contents element (typically Body)
  	* @param {string} property
  	* @param {string} value
  	* @param {boolean} [priority] set as "important"
  	*/
  css(e, n, r) {
    var i = this.content || this.document.body;
    return n ? i.style.setProperty(e, n, r ? "important" : "") : i.style.removeProperty(e), this.window.getComputedStyle(i)[e];
  }
  /**
  	* Get or Set the viewport element
  	* @param {object} [options]
  	* @param {string} [options.width]
  	* @param {string} [options.height]
  	* @param {string} [options.scale]
  	* @param {string} [options.minimum]
  	* @param {string} [options.maximum]
  	* @param {string} [options.scalable]
  	*/
  viewport(e) {
    var n = this.document.querySelector("meta[name='viewport']"), r = {
      width: void 0,
      height: void 0,
      scale: void 0,
      minimum: void 0,
      maximum: void 0,
      scalable: void 0
    }, i = [], s = {};
    if (n && n.hasAttribute("content")) {
      let o = n.getAttribute("content"), a = o.match(/width\s*=\s*([^,]*)/), l = o.match(/height\s*=\s*([^,]*)/), u = o.match(/initial-scale\s*=\s*([^,]*)/), c = o.match(/minimum-scale\s*=\s*([^,]*)/), d = o.match(/maximum-scale\s*=\s*([^,]*)/), h = o.match(/user-scalable\s*=\s*([^,]*)/);
      a && a.length && typeof a[1] < "u" && (r.width = a[1]), l && l.length && typeof l[1] < "u" && (r.height = l[1]), u && u.length && typeof u[1] < "u" && (r.scale = u[1]), c && c.length && typeof c[1] < "u" && (r.minimum = c[1]), d && d.length && typeof d[1] < "u" && (r.maximum = d[1]), h && h.length && typeof h[1] < "u" && (r.scalable = h[1]);
    }
    return s = a0(e || {}, r), e && (s.width && i.push("width=" + s.width), s.height && i.push("height=" + s.height), s.scale && i.push("initial-scale=" + s.scale), s.scalable === "no" ? (i.push("minimum-scale=" + s.scale), i.push("maximum-scale=" + s.scale), i.push("user-scalable=" + s.scalable)) : (s.scalable && i.push("user-scalable=" + s.scalable), s.minimum && i.push("minimum-scale=" + s.minimum), s.maximum && i.push("minimum-scale=" + s.maximum)), n || (n = this.document.createElement("meta"), n.setAttribute("name", "viewport"), this.document.querySelector("head").appendChild(n)), n.setAttribute("content", i.join(", ")), this.window.scrollTo(0, 0)), s;
  }
  /**
   * Event emitter for when the contents has expanded
   * @private
   */
  expand() {
    this.emit(Re.CONTENTS.EXPAND);
  }
  /**
   * Add DOM listeners
   * @private
   */
  listeners() {
    this.imageLoadListeners(), this.mediaQueryListeners(), this.addEventListeners(), this.addSelectionListeners(), typeof ResizeObserver > "u" ? (this.resizeListeners(), this.visibilityListeners()) : this.resizeObservers(), this.linksHandler();
  }
  /**
   * Remove DOM listeners
   * @private
   */
  removeListeners() {
    this.removeEventListeners(), this.removeSelectionListeners(), this.observer && this.observer.disconnect(), clearTimeout(this.expanding);
  }
  /**
   * Check if size of contents has changed and
   * emit 'resize' event if it has.
   * @private
   */
  resizeCheck() {
    let e = this.textWidth(), n = this.textHeight();
    (e != this._size.width || n != this._size.height) && (this._size = {
      width: e,
      height: n
    }, this.onResize && this.onResize(this._size), this.emit(Re.CONTENTS.RESIZE, this._size));
  }
  /**
   * Poll for resize detection
   * @private
   */
  resizeListeners() {
    clearTimeout(this.expanding), requestAnimationFrame(this.resizeCheck.bind(this)), this.expanding = setTimeout(this.resizeListeners.bind(this), 350);
  }
  /**
   * Listen for visibility of tab to change
   * @private
   */
  visibilityListeners() {
    document.addEventListener("visibilitychange", () => {
      document.visibilityState === "visible" && this.active === !1 ? (this.active = !0, this.resizeListeners()) : (this.active = !1, clearTimeout(this.expanding));
    });
  }
  /**
   * Use css transitions to detect resize
   * @private
   */
  transitionListeners() {
    let e = this.content;
    e.style.transitionProperty = "font, font-size, font-size-adjust, font-stretch, font-variation-settings, font-weight, width, height", e.style.transitionDuration = "0.001ms", e.style.transitionTimingFunction = "linear", e.style.transitionDelay = "0", this._resizeCheck = this.resizeCheck.bind(this), this.document.addEventListener("transitionend", this._resizeCheck);
  }
  /**
   * Listen for media query changes and emit 'expand' event
   * Adapted from: https://github.com/tylergaw/media-query-events/blob/master/js/mq-events.js
   * @private
   */
  mediaQueryListeners() {
    for (var e = this.document.styleSheets, n = function(a) {
      a.matches && !this._expanding && setTimeout(this.expand.bind(this), 1);
    }.bind(this), r = 0; r < e.length; r += 1) {
      var i;
      try {
        i = e[r].cssRules;
      } catch {
        return;
      }
      if (!i)
        return;
      for (var s = 0; s < i.length; s += 1)
        if (i[s].media) {
          var o = this.window.matchMedia(i[s].media.mediaText);
          o.addListener(n);
        }
    }
  }
  /**
   * Use ResizeObserver to listen for changes in the DOM and check for resize
   * @private
   */
  resizeObservers() {
    this.observer = new ResizeObserver((e) => {
      requestAnimationFrame(this.resizeCheck.bind(this));
    }), this.observer.observe(this.document.documentElement);
  }
  /**
   * Use MutationObserver to listen for changes in the DOM and check for resize
   * @private
   */
  mutationObservers() {
    this.observer = new MutationObserver((n) => {
      this.resizeCheck();
    });
    let e = { attributes: !0, childList: !0, characterData: !0, subtree: !0 };
    this.observer.observe(this.document, e);
  }
  /**
   * Test if images are loaded or add listener for when they load
   * @private
   */
  imageLoadListeners() {
    for (var e = this.document.querySelectorAll("img"), n, r = 0; r < e.length; r++)
      n = e[r], typeof n.naturalWidth < "u" && n.naturalWidth === 0 && (n.onload = this.expand.bind(this));
  }
  /**
   * Listen for font load and check for resize when loaded
   * @private
   */
  fontLoadListeners() {
    !this.document || !this.document.fonts || this.document.fonts.ready.then(function() {
      this.resizeCheck();
    }.bind(this));
  }
  /**
   * Get the documentElement
   * @returns {element} documentElement
   */
  root() {
    return this.document ? this.document.documentElement : null;
  }
  /**
   * Get the location offset of a EpubCFI or an #id
   * @param {string | EpubCFI} target
   * @param {string} [ignoreClass] for the cfi
   * @returns { {left: Number, top: Number }
   */
  locationOf(e, n) {
    var r, i = { left: 0, top: 0 };
    if (!this.document)
      return i;
    if (this.epubcfi.isCfiString(e)) {
      let s = new gt(e).toRange(this.document, n);
      if (s) {
        try {
          if (!s.endContainer || s.startContainer == s.endContainer && s.startOffset == s.endOffset) {
            let o = s.startContainer.textContent.indexOf(" ", s.startOffset);
            o == -1 && (o = s.startContainer.textContent.length), s.setEnd(s.startContainer, o);
          }
        } catch (o) {
          console.error("setting end offset to start container length failed", o);
        }
        if (s.startContainer.nodeType === Node.ELEMENT_NODE)
          r = s.startContainer.getBoundingClientRect(), i.left = r.left, i.top = r.top;
        else if (sv) {
          let o = s.startContainer, a = new Range();
          try {
            o.nodeType === O8 ? r = o.getBoundingClientRect() : s.startOffset + 2 < o.length ? (a.setStart(o, s.startOffset), a.setEnd(o, s.startOffset + 2), r = a.getBoundingClientRect()) : s.startOffset - 2 > 0 ? (a.setStart(o, s.startOffset - 2), a.setEnd(o, s.startOffset), r = a.getBoundingClientRect()) : r = o.parentNode.getBoundingClientRect();
          } catch (l) {
            console.error(l, l.stack);
          }
        } else
          r = s.getBoundingClientRect();
      }
    } else if (typeof e == "string" && e.indexOf("#") > -1) {
      let s = e.substring(e.indexOf("#") + 1), o = this.document.getElementById(s);
      if (o)
        if (sv) {
          let a = new Range();
          a.selectNode(o), r = a.getBoundingClientRect();
        } else
          r = o.getBoundingClientRect();
    }
    return r && (i.left = r.left, i.top = r.top), i;
  }
  /**
   * Append a stylesheet link to the document head
   * @param {string} src url
   */
  addStylesheet(e) {
    return new Promise(function(n, r) {
      var i, s = !1;
      if (!this.document) {
        n(!1);
        return;
      }
      if (i = this.document.querySelector("link[href='" + e + "']"), i) {
        n(!0);
        return;
      }
      i = this.document.createElement("link"), i.type = "text/css", i.rel = "stylesheet", i.href = e, i.onload = i.onreadystatechange = function() {
        !s && (!this.readyState || this.readyState == "complete") && (s = !0, setTimeout(() => {
          n(!0);
        }, 1));
      }, this.document.head.appendChild(i);
    }.bind(this));
  }
  _getStylesheetNode(e) {
    var n;
    return e = "epubjs-inserted-css-" + (e || ""), this.document ? (n = this.document.getElementById(e), n || (n = this.document.createElement("style"), n.id = e, this.document.head.appendChild(n)), n) : !1;
  }
  /**
   * Append stylesheet css
   * @param {string} serializedCss
   * @param {string} key If the key is the same, the CSS will be replaced instead of inserted
   */
  addStylesheetCss(e, n) {
    if (!this.document || !e)
      return !1;
    var r;
    return r = this._getStylesheetNode(n), r.innerHTML = e, !0;
  }
  /**
   * Append stylesheet rules to a generate stylesheet
   * Array: https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/insertRule
   * Object: https://github.com/desirable-objects/json-to-css
   * @param {array | object} rules
   * @param {string} key If the key is the same, the CSS will be replaced instead of inserted
   */
  addStylesheetRules(e, n) {
    var r;
    if (!(!this.document || !e || e.length === 0))
      if (r = this._getStylesheetNode(n).sheet, Object.prototype.toString.call(e) === "[object Array]")
        for (var i = 0, s = e.length; i < s; i++) {
          var o = 1, a = e[i], l = e[i][0], u = "";
          Object.prototype.toString.call(a[1][0]) === "[object Array]" && (a = a[1], o = 0);
          for (var c = a.length; o < c; o++) {
            var d = a[o];
            u += d[0] + ":" + d[1] + (d[2] ? " !important" : "") + `;
`;
          }
          r.insertRule(l + "{" + u + "}", r.cssRules.length);
        }
      else
        Object.keys(e).forEach((v) => {
          const y = e[v];
          if (Array.isArray(y))
            y.forEach((b) => {
              const f = Object.keys(b).map((g) => `${g}:${b[g]}`).join(";");
              r.insertRule(`${v}{${f}}`, r.cssRules.length);
            });
          else {
            const p = Object.keys(y).map((f) => `${f}:${y[f]}`).join(";");
            r.insertRule(`${v}{${p}}`, r.cssRules.length);
          }
        });
  }
  /**
   * Append a script tag to the document head
   * @param {string} src url
   * @returns {Promise} loaded
   */
  addScript(e) {
    return new Promise(function(n, r) {
      var i, s = !1;
      if (!this.document) {
        n(!1);
        return;
      }
      i = this.document.createElement("script"), i.type = "text/javascript", i.async = !0, i.src = e, i.onload = i.onreadystatechange = function() {
        !s && (!this.readyState || this.readyState == "complete") && (s = !0, setTimeout(function() {
          n(!0);
        }, 1));
      }, this.document.head.appendChild(i);
    }.bind(this));
  }
  /**
   * Add a class to the contents container
   * @param {string} className
   */
  addClass(e) {
    var n;
    this.document && (n = this.content || this.document.body, n && n.classList.add(e));
  }
  /**
   * Remove a class from the contents container
   * @param {string} removeClass
   */
  removeClass(e) {
    var n;
    this.document && (n = this.content || this.document.body, n && n.classList.remove(e));
  }
  /**
   * Add DOM event listeners
   * @private
   */
  addEventListeners() {
    this.document && (this._triggerEvent = this.triggerEvent.bind(this), tl.forEach(function(e) {
      this.document.addEventListener(e, this._triggerEvent, { passive: !0 });
    }, this));
  }
  /**
   * Remove DOM event listeners
   * @private
   */
  removeEventListeners() {
    this.document && (tl.forEach(function(e) {
      this.document.removeEventListener(e, this._triggerEvent, { passive: !0 });
    }, this), this._triggerEvent = void 0);
  }
  /**
   * Emit passed browser events
   * @private
   */
  triggerEvent(e) {
    this.emit(e.type, e);
  }
  /**
   * Add listener for text selection
   * @private
   */
  addSelectionListeners() {
    this.document && (this._onSelectionChange = this.onSelectionChange.bind(this), this.document.addEventListener("selectionchange", this._onSelectionChange, { passive: !0 }));
  }
  /**
   * Remove listener for text selection
   * @private
   */
  removeSelectionListeners() {
    this.document && (this.document.removeEventListener("selectionchange", this._onSelectionChange, { passive: !0 }), this._onSelectionChange = void 0);
  }
  /**
   * Handle getting text on selection
   * @private
   */
  onSelectionChange(e) {
    this.selectionEndTimeout && clearTimeout(this.selectionEndTimeout), this.selectionEndTimeout = setTimeout(function() {
      var n = this.window.getSelection();
      this.triggerSelectedEvent(n);
    }.bind(this), 250);
  }
  /**
   * Emit event on text selection
   * @private
   */
  triggerSelectedEvent(e) {
    var n, r;
    e && e.rangeCount > 0 && (n = e.getRangeAt(0), n.collapsed || (r = new gt(n, this.cfiBase).toString(), this.emit(Re.CONTENTS.SELECTED, r), this.emit(Re.CONTENTS.SELECTED_RANGE, n)));
  }
  /**
   * Get a Dom Range from EpubCFI
   * @param {EpubCFI} _cfi
   * @param {string} [ignoreClass]
   * @returns {Range} range
   */
  range(e, n) {
    var r = new gt(e);
    return r.toRange(this.document, n);
  }
  /**
   * Get an EpubCFI from a Dom Range
   * @param {Range} range
   * @param {string} [ignoreClass]
   * @returns {EpubCFI} cfi
   */
  cfiFromRange(e, n) {
    return new gt(e, this.cfiBase, n).toString();
  }
  /**
   * Get an EpubCFI from a Dom node
   * @param {node} node
   * @param {string} [ignoreClass]
   * @returns {EpubCFI} cfi
   */
  cfiFromNode(e, n) {
    return new gt(e, this.cfiBase, n).toString();
  }
  // TODO: find where this is used - remove?
  map(e) {
    var n = new Rl(e);
    return n.section();
  }
  /**
   * Size the contents to a given width and height
   * @param {number} [width]
   * @param {number} [height]
   */
  size(e, n) {
    var r = { scale: 1, scalable: "no" };
    this.layoutStyle("scrolling"), e >= 0 && (this.width(e), r.width = e, this.css("padding", "0 " + e / 12 + "px")), n >= 0 && (this.height(n), r.height = n), this.css("margin", "0"), this.css("box-sizing", "border-box"), this.viewport(r);
  }
  /**
   * Apply columns to the contents for pagination
   * @param {number} width
   * @param {number} height
   * @param {number} columnWidth
   * @param {number} gap
   */
  columns(e, n, r, i, s) {
    let o = vs("column-axis"), a = vs("column-gap"), l = vs("column-width"), u = vs("column-fill"), d = this.writingMode().indexOf("vertical") === 0 ? "vertical" : "horizontal";
    this.layoutStyle("paginated"), s === "rtl" && d === "horizontal" && this.direction(s), this.width(e), this.height(n), this.viewport({ width: e, height: n, scale: 1, scalable: "no" }), this.css("overflow-y", "hidden"), this.css("margin", "0", !0), d === "vertical" ? (this.css("padding-top", i / 2 + "px", !0), this.css("padding-bottom", i / 2 + "px", !0), this.css("padding-left", "20px"), this.css("padding-right", "20px"), this.css(o, "vertical")) : (this.css("padding-top", "20px"), this.css("padding-bottom", "20px"), this.css("padding-left", i / 2 + "px", !0), this.css("padding-right", i / 2 + "px", !0), this.css(o, "horizontal")), this.css("box-sizing", "border-box"), this.css("max-width", "inherit"), this.css(u, "auto"), this.css(a, i + "px"), this.css(l, r + "px"), this.css("-webkit-line-box-contain", "block glyphs replaced");
  }
  /**
   * Scale contents from center
   * @param {number} scale
   * @param {number} offsetX
   * @param {number} offsetY
   */
  scaler(e, n, r) {
    var i = "scale(" + e + ")", s = "";
    this.css("transform-origin", "top left"), (n >= 0 || r >= 0) && (s = " translate(" + (n || 0) + "px, " + (r || 0) + "px )"), this.css("transform", i + s);
  }
  /**
   * Fit contents into a fixed width and height
   * @param {number} width
   * @param {number} height
   */
  fit(e, n, r) {
    var i = this.viewport(), s = parseInt(i.width), o = parseInt(i.height), a = e / s, l = n / o, u = a < l ? a : l;
    if (this.layoutStyle("paginated"), this.width(s), this.height(o), this.overflow("hidden"), this.scaler(u, 0, 0), this.css("background-size", s * u + "px " + o * u + "px"), this.css("background-color", "transparent"), r && r.properties.includes("page-spread-left")) {
      var c = e - s * u;
      this.css("margin-left", c + "px");
    }
  }
  /**
   * Set the direction of the text
   * @param {string} [dir="ltr"] "rtl" | "ltr"
   */
  direction(e) {
    this.documentElement && (this.documentElement.style.direction = e);
  }
  mapPage(e, n, r, i, s) {
    var o = new Rl(n, s);
    return o.page(this, e, r, i);
  }
  /**
   * Emit event when link in content is clicked
   * @private
   */
  linksHandler() {
    b8(this.content, (e) => {
      this.emit(Re.CONTENTS.LINK_CLICKED, e);
    });
  }
  /**
   * Set the writingMode of the text
   * @param {string} [mode="horizontal-tb"] "horizontal-tb" | "vertical-rl" | "vertical-lr"
   */
  writingMode(e) {
    let n = vs("writing-mode");
    return e && this.documentElement && (this.documentElement.style[n] = e), this.window.getComputedStyle(this.documentElement)[n] || "";
  }
  /**
   * Set the layoutStyle of the content
   * @param {string} [style="paginated"] "scrolling" | "paginated"
   * @private
   */
  layoutStyle(e) {
    return e && (this._layoutStyle = e, navigator.epubReadingSystem.layoutStyle = this._layoutStyle), this._layoutStyle || "paginated";
  }
  /**
   * Add the epubReadingSystem object to the navigator
   * @param {string} name
   * @param {string} version
   * @private
   */
  epubReadingSystem(e, n) {
    return navigator.epubReadingSystem = {
      name: e,
      version: n,
      layoutStyle: this.layoutStyle(),
      hasFeature: function(r) {
        switch (r) {
          case "dom-manipulation":
            return !0;
          case "layout-changes":
            return !0;
          case "touch-events":
            return !0;
          case "mouse-events":
            return !0;
          case "keyboard-events":
            return !0;
          case "spine-scripting":
            return !1;
          default:
            return !1;
        }
      }
    }, navigator.epubReadingSystem;
  }
  destroy() {
    this.removeListeners();
  }
}
Lr(If.prototype);
class I8 {
  constructor(e) {
    this.rendition = e, this.highlights = [], this.underlines = [], this.marks = [], this._annotations = {}, this._annotationsBySectionIndex = {}, this.rendition.hooks.render.register(this.inject.bind(this)), this.rendition.hooks.unloaded.register(this.clear.bind(this));
  }
  /**
   * Add an annotation to store
   * @param {string} type Type of annotation to add: "highlight", "underline", "mark"
   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to
   * @param {object} data Data to assign to annotation
   * @param {function} [cb] Callback after annotation is added
   * @param {string} className CSS class to assign to annotation
   * @param {object} styles CSS styles to assign to annotation
   * @returns {Annotation} annotation
   */
  add(e, n, r, i, s, o) {
    let a = encodeURI(n + e), u = new gt(n).spinePos, c = new w0({
      type: e,
      cfiRange: n,
      data: r,
      sectionIndex: u,
      cb: i,
      className: s,
      styles: o
    });
    return this._annotations[a] = c, u in this._annotationsBySectionIndex ? this._annotationsBySectionIndex[u].push(a) : this._annotationsBySectionIndex[u] = [a], this.rendition.views().forEach((h) => {
      c.sectionIndex === h.index && c.attach(h);
    }), c;
  }
  /**
   * Remove an annotation from store
   * @param {EpubCFI} cfiRange EpubCFI range the annotation is attached to
   * @param {string} type Type of annotation to add: "highlight", "underline", "mark"
   */
  remove(e, n) {
    let r = encodeURI(e + n);
    if (r in this._annotations) {
      let i = this._annotations[r];
      if (n && i.type !== n)
        return;
      this.rendition.views().forEach((o) => {
        this._removeFromAnnotationBySectionIndex(i.sectionIndex, r), i.sectionIndex === o.index && i.detach(o);
      }), delete this._annotations[r];
    }
  }
  /**
   * Remove an annotations by Section Index
   * @private
   */
  _removeFromAnnotationBySectionIndex(e, n) {
    this._annotationsBySectionIndex[e] = this._annotationsAt(e).filter((r) => r !== n);
  }
  /**
   * Get annotations by Section Index
   * @private
   */
  _annotationsAt(e) {
    return this._annotationsBySectionIndex[e];
  }
  /**
   * Add a highlight to the store
   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to
   * @param {object} data Data to assign to annotation
   * @param {function} cb Callback after annotation is clicked
   * @param {string} className CSS class to assign to annotation
   * @param {object} styles CSS styles to assign to annotation
   */
  highlight(e, n, r, i, s) {
    return this.add("highlight", e, n, r, i, s);
  }
  /**
   * Add a underline to the store
   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to
   * @param {object} data Data to assign to annotation
   * @param {function} cb Callback after annotation is clicked
   * @param {string} className CSS class to assign to annotation
   * @param {object} styles CSS styles to assign to annotation
   */
  underline(e, n, r, i, s) {
    return this.add("underline", e, n, r, i, s);
  }
  /**
   * Add a mark to the store
   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to
   * @param {object} data Data to assign to annotation
   * @param {function} cb Callback after annotation is clicked
   */
  mark(e, n, r) {
    return this.add("mark", e, n, r);
  }
  /**
   * iterate over annotations in the store
   */
  each() {
    return this._annotations.forEach.apply(this._annotations, arguments);
  }
  /**
   * Hook for injecting annotation into a view
   * @param {View} view
   * @private
   */
  inject(e) {
    let n = e.index;
    n in this._annotationsBySectionIndex && this._annotationsBySectionIndex[n].forEach((i) => {
      this._annotations[i].attach(e);
    });
  }
  /**
   * Hook for removing annotation from a view
   * @param {View} view
   * @private
   */
  clear(e) {
    let n = e.index;
    n in this._annotationsBySectionIndex && this._annotationsBySectionIndex[n].forEach((i) => {
      this._annotations[i].detach(e);
    });
  }
  /**
   * [Not Implemented] Show annotations
   * @TODO: needs implementation in View
   */
  show() {
  }
  /**
   * [Not Implemented] Hide annotations
   * @TODO: needs implementation in View
   */
  hide() {
  }
}
class w0 {
  constructor({
    type: e,
    cfiRange: n,
    data: r,
    sectionIndex: i,
    cb: s,
    className: o,
    styles: a
  }) {
    this.type = e, this.cfiRange = n, this.data = r, this.sectionIndex = i, this.mark = void 0, this.cb = s, this.className = o, this.styles = a;
  }
  /**
   * Update stored data
   * @param {object} data
   */
  update(e) {
    this.data = e;
  }
  /**
   * Add to a view
   * @param {View} view
   */
  attach(e) {
    let { cfiRange: n, data: r, type: i, mark: s, cb: o, className: a, styles: l } = this, u;
    return i === "highlight" ? u = e.highlight(n, r, o, a, l) : i === "underline" ? u = e.underline(n, r, o, a, l) : i === "mark" && (u = e.mark(n, r, o)), this.mark = u, this.emit(Re.ANNOTATION.ATTACH, u), u;
  }
  /**
   * Remove from a view
   * @param {View} view
   */
  detach(e) {
    let { cfiRange: n, type: r } = this, i;
    return e && (r === "highlight" ? i = e.unhighlight(n) : r === "underline" ? i = e.ununderline(n) : r === "mark" && (i = e.unmark(n))), this.mark = void 0, this.emit(Re.ANNOTATION.DETACH, i), i;
  }
  /**
   * [Not Implemented] Get text of an annotation
   * @TODO: needs implementation in contents
   */
  text() {
  }
}
Lr(w0.prototype);
var $r = {}, su = {};
Object.defineProperty(su, "__esModule", {
  value: !0
});
su.createElement = _0;
function _0(t) {
  return document.createElementNS("http://www.w3.org/2000/svg", t);
}
su.default = {
  createElement: _0
};
var ca = {};
Object.defineProperty(ca, "__esModule", {
  value: !0
});
ca.proxyMouse = S0;
ca.clone = E0;
ca.default = {
  proxyMouse: S0
};
function S0(t, e) {
  function n(o) {
    for (var a = e.length - 1; a >= 0; a--) {
      var l = e[a], u = o.clientX, c = o.clientY;
      if (o.touches && o.touches.length && (u = o.touches[0].clientX, c = o.touches[0].clientY), !!N8(l, t, u, c)) {
        l.dispatchEvent(E0(o));
        break;
      }
    }
  }
  if (t.nodeName === "iframe" || t.nodeName === "IFRAME")
    try {
      this.target = t.contentDocument;
    } catch {
      this.target = t;
    }
  else
    this.target = t;
  for (var r = ["mouseup", "mousedown", "click", "touchstart"], i = 0; i < r.length; i++) {
    var s = r[i];
    this.target.addEventListener(s, function(o) {
      return n(o);
    }, !1);
  }
}
function E0(t) {
  var e = Object.assign({}, t, { bubbles: !1 });
  try {
    return new MouseEvent(t.type, e);
  } catch {
    var n = document.createEvent("MouseEvents");
    return n.initMouseEvent(t.type, !1, e.cancelable, e.view, e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget), n;
  }
}
function N8(t, e, n, r) {
  var i = e.getBoundingClientRect();
  function s(c, d, h) {
    var v = c.top - i.top, y = c.left - i.left, b = v + c.height, p = y + c.width;
    return v <= h && y <= d && b > h && p > d;
  }
  var o = t.getBoundingClientRect();
  if (!s(o, n, r))
    return !1;
  for (var a = t.getClientRects(), l = 0, u = a.length; l < u; l++)
    if (s(a[l], n, r))
      return !0;
  return !1;
}
var Pl, Nf;
Object.defineProperty($r, "__esModule", {
  value: !0
});
var x0 = $r.Underline = Nf = $r.Highlight = $r.Mark = Pl = $r.Pane = void 0, R8 = function t(e, n, r) {
  e === null && (e = Function.prototype);
  var i = Object.getOwnPropertyDescriptor(e, n);
  if (i === void 0) {
    var s = Object.getPrototypeOf(e);
    return s === null ? void 0 : t(s, n, r);
  } else {
    if ("value" in i)
      return i.value;
    var o = i.get;
    return o === void 0 ? void 0 : o.call(r);
  }
}, ou = function() {
  function t(e, n) {
    for (var r = 0; r < n.length; r++) {
      var i = n[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  return function(e, n, r) {
    return n && t(e.prototype, n), r && t(e, r), e;
  };
}(), P8 = su, Vo = A0(P8), B8 = ca, D8 = A0(B8);
function A0(t) {
  return t && t.__esModule ? t : { default: t };
}
function k0(t, e) {
  if (!t)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e && (typeof e == "object" || typeof e == "function") ? e : t;
}
function C0(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof e);
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
}
function au(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
Pl = $r.Pane = function() {
  function t(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : document.body;
    au(this, t), this.target = e, this.element = Vo.default.createElement("svg"), this.marks = [], this.element.style.position = "absolute", this.element.setAttribute("pointer-events", "none"), D8.default.proxyMouse(this.target, this.marks), this.container = n, this.container.appendChild(this.element), this.render();
  }
  return ou(t, [{
    key: "addMark",
    value: function(n) {
      var r = Vo.default.createElement("g");
      return this.element.appendChild(r), n.bind(r, this.container), this.marks.push(n), n.render(), n;
    }
  }, {
    key: "removeMark",
    value: function(n) {
      var r = this.marks.indexOf(n);
      if (r !== -1) {
        var i = n.unbind();
        this.element.removeChild(i), this.marks.splice(r, 1);
      }
    }
  }, {
    key: "render",
    value: function() {
      j8(this.element, z8(this.target, this.container));
      var n = !0, r = !1, i = void 0;
      try {
        for (var s = this.marks[Symbol.iterator](), o; !(n = (o = s.next()).done); n = !0) {
          var a = o.value;
          a.render();
        }
      } catch (l) {
        r = !0, i = l;
      } finally {
        try {
          !n && s.return && s.return();
        } finally {
          if (r)
            throw i;
        }
      }
    }
  }]), t;
}();
var M8 = $r.Mark = function() {
  function t() {
    au(this, t), this.element = null;
  }
  return ou(t, [{
    key: "bind",
    value: function(n, r) {
      this.element = n, this.container = r;
    }
  }, {
    key: "unbind",
    value: function() {
      var n = this.element;
      return this.element = null, n;
    }
  }, {
    key: "render",
    value: function() {
    }
  }, {
    key: "dispatchEvent",
    value: function(n) {
      this.element && this.element.dispatchEvent(n);
    }
  }, {
    key: "getBoundingClientRect",
    value: function() {
      return this.element.getBoundingClientRect();
    }
  }, {
    key: "getClientRects",
    value: function() {
      for (var n = [], r = this.element.firstChild; r; )
        n.push(r.getBoundingClientRect()), r = r.nextSibling;
      return n;
    }
  }, {
    key: "filteredRanges",
    value: function() {
      var n = Array.from(this.range.getClientRects());
      return n.filter(function(r) {
        for (var i = 0; i < n.length; i++) {
          if (n[i] === r)
            return !0;
          var s = F8(n[i], r);
          if (s)
            return !1;
        }
        return !0;
      });
    }
  }]), t;
}(), L8 = Nf = $r.Highlight = function(t) {
  C0(e, t);
  function e(n, r, i, s) {
    au(this, e);
    var o = k0(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
    return o.range = n, o.className = r, o.data = i || {}, o.attributes = s || {}, o;
  }
  return ou(e, [{
    key: "bind",
    value: function(r, i) {
      R8(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "bind", this).call(this, r, i);
      for (var s in this.data)
        this.data.hasOwnProperty(s) && (this.element.dataset[s] = this.data[s]);
      for (var s in this.attributes)
        this.attributes.hasOwnProperty(s) && this.element.setAttribute(s, this.attributes[s]);
      this.className && this.element.classList.add(this.className);
    }
  }, {
    key: "render",
    value: function() {
      for (; this.element.firstChild; )
        this.element.removeChild(this.element.firstChild);
      for (var r = this.element.ownerDocument.createDocumentFragment(), i = this.filteredRanges(), s = this.element.getBoundingClientRect(), o = this.container.getBoundingClientRect(), a = 0, l = i.length; a < l; a++) {
        var u = i[a], c = Vo.default.createElement("rect");
        c.setAttribute("x", u.left - s.left + o.left), c.setAttribute("y", u.top - s.top + o.top), c.setAttribute("height", u.height), c.setAttribute("width", u.width), r.appendChild(c);
      }
      this.element.appendChild(r);
    }
  }]), e;
}(M8);
x0 = $r.Underline = function(t) {
  C0(e, t);
  function e(n, r, i, s) {
    return au(this, e), k0(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, n, r, i, s));
  }
  return ou(e, [{
    key: "render",
    value: function() {
      for (; this.element.firstChild; )
        this.element.removeChild(this.element.firstChild);
      for (var r = this.element.ownerDocument.createDocumentFragment(), i = this.filteredRanges(), s = this.element.getBoundingClientRect(), o = this.container.getBoundingClientRect(), a = 0, l = i.length; a < l; a++) {
        var u = i[a], c = Vo.default.createElement("rect");
        c.setAttribute("x", u.left - s.left + o.left), c.setAttribute("y", u.top - s.top + o.top), c.setAttribute("height", u.height), c.setAttribute("width", u.width), c.setAttribute("fill", "none");
        var d = Vo.default.createElement("line");
        d.setAttribute("x1", u.left - s.left + o.left), d.setAttribute("x2", u.left - s.left + o.left + u.width), d.setAttribute("y1", u.top - s.top + o.top + u.height - 1), d.setAttribute("y2", u.top - s.top + o.top + u.height - 1), d.setAttribute("stroke-width", 1), d.setAttribute("stroke", "black"), d.setAttribute("stroke-linecap", "square"), r.appendChild(c), r.appendChild(d);
      }
      this.element.appendChild(r);
    }
  }]), e;
}(L8);
function z8(t, e) {
  var n = e.getBoundingClientRect(), r = t.getBoundingClientRect();
  return {
    top: r.top - n.top,
    left: r.left - n.left,
    height: t.scrollHeight,
    width: t.scrollWidth
  };
}
function j8(t, e) {
  t.style.setProperty("top", e.top + "px", "important"), t.style.setProperty("left", e.left + "px", "important"), t.style.setProperty("height", e.height + "px", "important"), t.style.setProperty("width", e.width + "px", "important");
}
function F8(t, e) {
  return e.right <= t.right && e.left >= t.left && e.top >= t.top && e.bottom <= t.bottom;
}
class T0 {
  constructor(e, n) {
    this.settings = Sn({
      ignoreClass: "",
      axis: void 0,
      //options.layout && options.layout.props.flow === "scrolled" ? "vertical" : "horizontal",
      direction: void 0,
      width: 0,
      height: 0,
      layout: void 0,
      globalLayoutProperties: {},
      method: void 0,
      forceRight: !1,
      allowScriptedContent: !1,
      allowPopups: !1
    }, n || {}), this.id = "epubjs-view-" + ru(), this.section = e, this.index = e.index, this.element = this.container(this.settings.axis), this.added = !1, this.displayed = !1, this.rendered = !1, this.fixedWidth = 0, this.fixedHeight = 0, this.epubcfi = new gt(), this.layout = this.settings.layout, this.pane = void 0, this.highlights = {}, this.underlines = {}, this.marks = {};
  }
  container(e) {
    var n = document.createElement("div");
    return n.classList.add("epub-view"), n.style.height = "0px", n.style.width = "0px", n.style.overflow = "hidden", n.style.position = "relative", n.style.display = "block", e && e == "horizontal" ? n.style.flex = "none" : n.style.flex = "initial", n;
  }
  create() {
    return this.iframe ? this.iframe : (this.element || (this.element = this.createContainer()), this.iframe = document.createElement("iframe"), this.iframe.id = this.id, this.iframe.scrolling = "no", this.iframe.style.overflow = "hidden", this.iframe.seamless = "seamless", this.iframe.style.border = "none", this.iframe.sandbox = "allow-same-origin", this.settings.allowScriptedContent && (this.iframe.sandbox += " allow-scripts"), this.settings.allowPopups && (this.iframe.sandbox += " allow-popups"), this.iframe.setAttribute("enable-annotation", "true"), this.resizing = !0, this.element.style.visibility = "hidden", this.iframe.style.visibility = "hidden", this.iframe.style.width = "0", this.iframe.style.height = "0", this._width = 0, this._height = 0, this.element.setAttribute("ref", this.index), this.added = !0, this.elementBounds = Xa(this.element), "srcdoc" in this.iframe ? this.supportsSrcdoc = !0 : this.supportsSrcdoc = !1, this.settings.method || (this.settings.method = this.supportsSrcdoc ? "srcdoc" : "write"), this.iframe);
  }
  render(e, n) {
    return this.create(), this.size(), this.sectionRender || (this.sectionRender = this.section.render(e)), this.sectionRender.then(function(r) {
      return this.load(r);
    }.bind(this)).then(function() {
      let r = this.contents.writingMode(), i;
      return this.settings.flow === "scrolled" ? i = r.indexOf("vertical") === 0 ? "horizontal" : "vertical" : i = r.indexOf("vertical") === 0 ? "vertical" : "horizontal", r.indexOf("vertical") === 0 && this.settings.flow === "paginated" && (this.layout.delta = this.layout.height), this.setAxis(i), this.emit(Re.VIEWS.AXIS, i), this.setWritingMode(r), this.emit(Re.VIEWS.WRITING_MODE, r), this.layout.format(this.contents, this.section, this.axis), this.addListeners(), new Promise((s, o) => {
        this.expand(), this.settings.forceRight && (this.element.style.marginLeft = this.width() + "px"), s();
      });
    }.bind(this), function(r) {
      return this.emit(Re.VIEWS.LOAD_ERROR, r), new Promise((i, s) => {
        s(r);
      });
    }.bind(this)).then(function() {
      this.emit(Re.VIEWS.RENDERED, this.section);
    }.bind(this));
  }
  reset() {
    this.iframe && (this.iframe.style.width = "0", this.iframe.style.height = "0", this._width = 0, this._height = 0, this._textWidth = void 0, this._contentWidth = void 0, this._textHeight = void 0, this._contentHeight = void 0), this._needsReframe = !0;
  }
  // Determine locks base on settings
  size(e, n) {
    var r = e || this.settings.width, i = n || this.settings.height;
    this.layout.name === "pre-paginated" ? this.lock("both", r, i) : this.settings.axis === "horizontal" ? this.lock("height", r, i) : this.lock("width", r, i), this.settings.width = r, this.settings.height = i;
  }
  // Lock an axis to element dimensions, taking borders into account
  lock(e, n, r) {
    var i = Cl(this.element), s;
    this.iframe ? s = Cl(this.iframe) : s = { width: 0, height: 0 }, e == "width" && Yt(n) && (this.lockedWidth = n - i.width - s.width), e == "height" && Yt(r) && (this.lockedHeight = r - i.height - s.height), e === "both" && Yt(n) && Yt(r) && (this.lockedWidth = n - i.width - s.width, this.lockedHeight = r - i.height - s.height), this.displayed && this.iframe && this.expand();
  }
  // Resize a single axis based on content dimensions
  expand(e) {
    var n = this.lockedWidth, r = this.lockedHeight, i;
    !this.iframe || this._expanding || (this._expanding = !0, this.layout.name === "pre-paginated" ? (n = this.layout.columnWidth, r = this.layout.height) : this.settings.axis === "horizontal" ? (n = this.contents.textWidth(), n % this.layout.pageWidth > 0 && (n = Math.ceil(n / this.layout.pageWidth) * this.layout.pageWidth), this.settings.forceEvenPages && (i = n / this.layout.pageWidth, this.layout.divisor > 1 && this.layout.name === "reflowable" && i % 2 > 0 && (n += this.layout.pageWidth))) : this.settings.axis === "vertical" && (r = this.contents.textHeight(), this.settings.flow === "paginated" && r % this.layout.height > 0 && (r = Math.ceil(r / this.layout.height) * this.layout.height)), (this._needsReframe || n != this._width || r != this._height) && this.reframe(n, r), this._expanding = !1);
  }
  reframe(e, n) {
    var r;
    Yt(e) && (this.element.style.width = e + "px", this.iframe.style.width = e + "px", this._width = e), Yt(n) && (this.element.style.height = n + "px", this.iframe.style.height = n + "px", this._height = n);
    let i = this.prevBounds ? e - this.prevBounds.width : e, s = this.prevBounds ? n - this.prevBounds.height : n;
    r = {
      width: e,
      height: n,
      widthDelta: i,
      heightDelta: s
    }, this.pane && this.pane.render(), requestAnimationFrame(() => {
      let o;
      for (let a in this.marks)
        this.marks.hasOwnProperty(a) && (o = this.marks[a], this.placeMark(o.element, o.range));
    }), this.onResize(this, r), this.emit(Re.VIEWS.RESIZED, r), this.prevBounds = r, this.elementBounds = Xa(this.element);
  }
  load(e) {
    var n = new vt(), r = n.promise;
    if (!this.iframe)
      return n.reject(new Error("No Iframe Available")), r;
    if (this.iframe.onload = function(s) {
      this.onLoad(s, n);
    }.bind(this), this.settings.method === "blobUrl")
      this.blobUrl = Ol(e, "application/xhtml+xml"), this.iframe.src = this.blobUrl, this.element.appendChild(this.iframe);
    else if (this.settings.method === "srcdoc")
      this.iframe.srcdoc = e, this.element.appendChild(this.iframe);
    else {
      if (this.element.appendChild(this.iframe), this.document = this.iframe.contentDocument, !this.document)
        return n.reject(new Error("No Document Available")), r;
      if (this.iframe.contentDocument.open(), window.MSApp && MSApp.execUnsafeLocalFunction) {
        var i = this;
        MSApp.execUnsafeLocalFunction(function() {
          i.iframe.contentDocument.write(e);
        });
      } else
        this.iframe.contentDocument.write(e);
      this.iframe.contentDocument.close();
    }
    return r;
  }
  onLoad(e, n) {
    this.window = this.iframe.contentWindow, this.document = this.iframe.contentDocument, this.contents = new If(this.document, this.document.body, this.section.cfiBase, this.section.index), this.rendering = !1;
    var r = this.document.querySelector("link[rel='canonical']");
    r ? r.setAttribute("href", this.section.canonical) : (r = this.document.createElement("link"), r.setAttribute("rel", "canonical"), r.setAttribute("href", this.section.canonical), this.document.querySelector("head").appendChild(r)), this.contents.on(Re.CONTENTS.EXPAND, () => {
      this.displayed && this.iframe && (this.expand(), this.contents && this.layout.format(this.contents));
    }), this.contents.on(Re.CONTENTS.RESIZE, (i) => {
      this.displayed && this.iframe && (this.expand(), this.contents && this.layout.format(this.contents));
    }), n.resolve(this.contents);
  }
  setLayout(e) {
    this.layout = e, this.contents && (this.layout.format(this.contents), this.expand());
  }
  setAxis(e) {
    this.settings.axis = e, e == "horizontal" ? this.element.style.flex = "none" : this.element.style.flex = "initial", this.size();
  }
  setWritingMode(e) {
    this.writingMode = e;
  }
  addListeners() {
  }
  removeListeners(e) {
  }
  display(e) {
    var n = new vt();
    return this.displayed ? n.resolve(this) : this.render(e).then(function() {
      this.emit(Re.VIEWS.DISPLAYED, this), this.onDisplayed(this), this.displayed = !0, n.resolve(this);
    }.bind(this), function(r) {
      n.reject(r, this);
    }), n.promise;
  }
  show() {
    this.element.style.visibility = "visible", this.iframe && (this.iframe.style.visibility = "visible", this.iframe.style.transform = "translateZ(0)", this.iframe.offsetWidth, this.iframe.style.transform = null), this.emit(Re.VIEWS.SHOWN, this);
  }
  hide() {
    this.element.style.visibility = "hidden", this.iframe.style.visibility = "hidden", this.stopExpanding = !0, this.emit(Re.VIEWS.HIDDEN, this);
  }
  offset() {
    return {
      top: this.element.offsetTop,
      left: this.element.offsetLeft
    };
  }
  width() {
    return this._width;
  }
  height() {
    return this._height;
  }
  position() {
    return this.element.getBoundingClientRect();
  }
  locationOf(e) {
    this.iframe.getBoundingClientRect();
    var n = this.contents.locationOf(e, this.settings.ignoreClass);
    return {
      left: n.left,
      top: n.top
    };
  }
  onDisplayed(e) {
  }
  onResize(e, n) {
  }
  bounds(e) {
    return (e || !this.elementBounds) && (this.elementBounds = Xa(this.element)), this.elementBounds;
  }
  highlight(e, n = {}, r, i = "epubjs-hl", s = {}) {
    if (!this.contents)
      return;
    const o = Object.assign({ fill: "yellow", "fill-opacity": "0.3", "mix-blend-mode": "multiply" }, s);
    let a = this.contents.range(e), l = () => {
      this.emit(Re.VIEWS.MARK_CLICKED, e, n);
    };
    n.epubcfi = e, this.pane || (this.pane = new Pl(this.iframe, this.element));
    let u = new Nf(a, i, n, o), c = this.pane.addMark(u);
    return this.highlights[e] = { mark: c, element: c.element, listeners: [l, r] }, c.element.setAttribute("ref", i), c.element.addEventListener("click", l), c.element.addEventListener("touchstart", l), r && (c.element.addEventListener("click", r), c.element.addEventListener("touchstart", r)), c;
  }
  underline(e, n = {}, r, i = "epubjs-ul", s = {}) {
    if (!this.contents)
      return;
    const o = Object.assign({ stroke: "black", "stroke-opacity": "0.3", "mix-blend-mode": "multiply" }, s);
    let a = this.contents.range(e), l = () => {
      this.emit(Re.VIEWS.MARK_CLICKED, e, n);
    };
    n.epubcfi = e, this.pane || (this.pane = new Pl(this.iframe, this.element));
    let u = new x0(a, i, n, o), c = this.pane.addMark(u);
    return this.underlines[e] = { mark: c, element: c.element, listeners: [l, r] }, c.element.setAttribute("ref", i), c.element.addEventListener("click", l), c.element.addEventListener("touchstart", l), r && (c.element.addEventListener("click", r), c.element.addEventListener("touchstart", r)), c;
  }
  mark(e, n = {}, r) {
    if (!this.contents)
      return;
    if (e in this.marks)
      return this.marks[e];
    let i = this.contents.range(e);
    if (!i)
      return;
    let s = i.commonAncestorContainer, o = s.nodeType === 1 ? s : s.parentNode, a = (u) => {
      this.emit(Re.VIEWS.MARK_CLICKED, e, n);
    };
    i.collapsed && s.nodeType === 1 ? (i = new Range(), i.selectNodeContents(s)) : i.collapsed && (i = new Range(), i.selectNodeContents(o));
    let l = this.document.createElement("a");
    return l.setAttribute("ref", "epubjs-mk"), l.style.position = "absolute", l.dataset.epubcfi = e, n && Object.keys(n).forEach((u) => {
      l.dataset[u] = n[u];
    }), r && (l.addEventListener("click", r), l.addEventListener("touchstart", r)), l.addEventListener("click", a), l.addEventListener("touchstart", a), this.placeMark(l, i), this.element.appendChild(l), this.marks[e] = { element: l, range: i, listeners: [a, r] }, o;
  }
  placeMark(e, n) {
    let r, i, s;
    if (this.layout.name === "pre-paginated" || this.settings.axis !== "horizontal") {
      let a = n.getBoundingClientRect();
      r = a.top, i = a.right;
    } else {
      let a = n.getClientRects(), l;
      for (var o = 0; o != a.length; o++)
        l = a[o], (!s || l.left < s) && (s = l.left, i = Math.ceil(s / this.layout.props.pageWidth) * this.layout.props.pageWidth - this.layout.gap / 2, r = l.top);
    }
    e.style.top = `${r}px`, e.style.left = `${i}px`;
  }
  unhighlight(e) {
    let n;
    e in this.highlights && (n = this.highlights[e], this.pane.removeMark(n.mark), n.listeners.forEach((r) => {
      r && (n.element.removeEventListener("click", r), n.element.removeEventListener("touchstart", r));
    }), delete this.highlights[e]);
  }
  ununderline(e) {
    let n;
    e in this.underlines && (n = this.underlines[e], this.pane.removeMark(n.mark), n.listeners.forEach((r) => {
      r && (n.element.removeEventListener("click", r), n.element.removeEventListener("touchstart", r));
    }), delete this.underlines[e]);
  }
  unmark(e) {
    let n;
    e in this.marks && (n = this.marks[e], this.element.removeChild(n.element), n.listeners.forEach((r) => {
      r && (n.element.removeEventListener("click", r), n.element.removeEventListener("touchstart", r));
    }), delete this.marks[e]);
  }
  destroy() {
    for (let e in this.highlights)
      this.unhighlight(e);
    for (let e in this.underlines)
      this.ununderline(e);
    for (let e in this.marks)
      this.unmark(e);
    this.blobUrl && c0(this.blobUrl), this.displayed && (this.displayed = !1, this.removeListeners(), this.contents.destroy(), this.stopExpanding = !0, this.element.removeChild(this.iframe), this.pane && (this.pane.element.remove(), this.pane = void 0), this.iframe = void 0, this.contents = void 0, this._textWidth = null, this._textHeight = null, this._width = null, this._height = null);
  }
}
Lr(T0.prototype);
function H8() {
  var t = "reverse", e = U8();
  return document.body.appendChild(e), e.scrollLeft > 0 ? t = "default" : typeof Element < "u" && Element.prototype.scrollIntoView ? (e.children[0].children[1].scrollIntoView(), e.scrollLeft < 0 && (t = "negative")) : (e.scrollLeft = 1, e.scrollLeft === 0 && (t = "negative")), document.body.removeChild(e), t;
}
function U8() {
  var t = document.createElement("div");
  t.dir = "rtl", t.style.position = "fixed", t.style.width = "1px", t.style.height = "1px", t.style.top = "0px", t.style.left = "0px", t.style.overflow = "hidden";
  var e = document.createElement("div");
  e.style.width = "2px";
  var n = document.createElement("span");
  n.style.width = "1px", n.style.display = "inline-block";
  var r = document.createElement("span");
  return r.style.width = "1px", r.style.display = "inline-block", e.appendChild(n), e.appendChild(r), t.appendChild(e), t;
}
function V8(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var Rf = V8, W8 = typeof mn == "object" && mn && mn.Object === Object && mn, K8 = W8, $8 = K8, G8 = typeof self == "object" && self && self.Object === Object && self, q8 = $8 || G8 || Function("return this")(), O0 = q8, J8 = O0, Y8 = function() {
  return J8.Date.now();
}, Q8 = Y8, Z8 = /\s/;
function X8(t) {
  for (var e = t.length; e-- && Z8.test(t.charAt(e)); )
    ;
  return e;
}
var e6 = X8, t6 = e6, n6 = /^\s+/;
function r6(t) {
  return t && t.slice(0, t6(t) + 1).replace(n6, "");
}
var i6 = r6, s6 = O0, o6 = s6.Symbol, I0 = o6, ov = I0, N0 = Object.prototype, a6 = N0.hasOwnProperty, l6 = N0.toString, no = ov ? ov.toStringTag : void 0;
function u6(t) {
  var e = a6.call(t, no), n = t[no];
  try {
    t[no] = void 0;
    var r = !0;
  } catch {
  }
  var i = l6.call(t);
  return r && (e ? t[no] = n : delete t[no]), i;
}
var c6 = u6, d6 = Object.prototype, f6 = d6.toString;
function h6(t) {
  return f6.call(t);
}
var p6 = h6, av = I0, v6 = c6, g6 = p6, m6 = "[object Null]", y6 = "[object Undefined]", lv = av ? av.toStringTag : void 0;
function b6(t) {
  return t == null ? t === void 0 ? y6 : m6 : lv && lv in Object(t) ? v6(t) : g6(t);
}
var w6 = b6;
function _6(t) {
  return t != null && typeof t == "object";
}
var S6 = _6, E6 = w6, x6 = S6, A6 = "[object Symbol]";
function k6(t) {
  return typeof t == "symbol" || x6(t) && E6(t) == A6;
}
var C6 = k6, T6 = i6, uv = Rf, O6 = C6, cv = 0 / 0, I6 = /^[-+]0x[0-9a-f]+$/i, N6 = /^0b[01]+$/i, R6 = /^0o[0-7]+$/i, P6 = parseInt;
function B6(t) {
  if (typeof t == "number")
    return t;
  if (O6(t))
    return cv;
  if (uv(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = uv(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = T6(t);
  var n = N6.test(t);
  return n || R6.test(t) ? P6(t.slice(2), n ? 2 : 8) : I6.test(t) ? cv : +t;
}
var D6 = B6, M6 = Rf, $u = Q8, dv = D6, L6 = "Expected a function", z6 = Math.max, j6 = Math.min;
function F6(t, e, n) {
  var r, i, s, o, a, l, u = 0, c = !1, d = !1, h = !0;
  if (typeof t != "function")
    throw new TypeError(L6);
  e = dv(e) || 0, M6(n) && (c = !!n.leading, d = "maxWait" in n, s = d ? z6(dv(n.maxWait) || 0, e) : s, h = "trailing" in n ? !!n.trailing : h);
  function v(S) {
    var A = r, C = i;
    return r = i = void 0, u = S, o = t.apply(C, A), o;
  }
  function y(S) {
    return u = S, a = setTimeout(f, e), c ? v(S) : o;
  }
  function b(S) {
    var A = S - l, C = S - u, k = e - A;
    return d ? j6(k, s - C) : k;
  }
  function p(S) {
    var A = S - l, C = S - u;
    return l === void 0 || A >= e || A < 0 || d && C >= s;
  }
  function f() {
    var S = $u();
    if (p(S))
      return g(S);
    a = setTimeout(f, b(S));
  }
  function g(S) {
    return a = void 0, h && r ? v(S) : (r = i = void 0, o);
  }
  function m() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = i = a = void 0;
  }
  function w() {
    return a === void 0 ? o : g($u());
  }
  function _() {
    var S = $u(), A = p(S);
    if (r = arguments, i = this, l = S, A) {
      if (a === void 0)
        return y(l);
      if (d)
        return clearTimeout(a), a = setTimeout(f, e), v(l);
    }
    return a === void 0 && (a = setTimeout(f, e)), o;
  }
  return _.cancel = m, _.flush = w, _;
}
var R0 = F6, H6 = R0, U6 = Rf, V6 = "Expected a function";
function W6(t, e, n) {
  var r = !0, i = !0;
  if (typeof t != "function")
    throw new TypeError(V6);
  return U6(n) && (r = "leading" in n ? !!n.leading : r, i = "trailing" in n ? !!n.trailing : i), H6(t, e, {
    leading: r,
    maxWait: e,
    trailing: i
  });
}
var K6 = W6;
class $6 {
  constructor(e) {
    this.settings = e || {}, this.id = "epubjs-container-" + ru(), this.container = this.create(this.settings), this.settings.hidden && (this.wrapper = this.wrap(this.container));
  }
  /*
  * Creates an element to render to.
  * Resizes to passed width and height or to the elements size
  */
  create(e) {
    let n = e.height, r = e.width, i = e.overflow || !1, s = e.axis || "vertical", o = e.direction;
    Sn(this.settings, e), e.height && Yt(e.height) && (n = e.height + "px"), e.width && Yt(e.width) && (r = e.width + "px");
    let a = document.createElement("div");
    return a.id = this.id, a.classList.add("epub-container"), a.style.wordSpacing = "0", a.style.lineHeight = "0", a.style.verticalAlign = "top", a.style.position = "relative", s === "horizontal" && (a.style.display = "flex", a.style.flexDirection = "row", a.style.flexWrap = "nowrap"), r && (a.style.width = r), n && (a.style.height = n), i && (i === "scroll" && s === "vertical" ? (a.style["overflow-y"] = i, a.style["overflow-x"] = "hidden") : i === "scroll" && s === "horizontal" ? (a.style["overflow-y"] = "hidden", a.style["overflow-x"] = i) : a.style.overflow = i), o && (a.dir = o, a.style.direction = o), o && this.settings.fullsize && (document.body.style.direction = o), a;
  }
  wrap(e) {
    var n = document.createElement("div");
    return n.style.visibility = "hidden", n.style.overflow = "hidden", n.style.width = "0", n.style.height = "0", n.appendChild(e), n;
  }
  getElement(e) {
    var n;
    if (s0(e) ? n = e : typeof e == "string" && (n = document.getElementById(e)), !n)
      throw new Error("Not an Element");
    return n;
  }
  attachTo(e) {
    var n = this.getElement(e), r;
    if (n)
      return this.settings.hidden ? r = this.wrapper : r = this.container, n.appendChild(r), this.element = n, n;
  }
  getContainer() {
    return this.container;
  }
  onResize(e) {
    (!Yt(this.settings.width) || !Yt(this.settings.height)) && (this.resizeFunc = K6(e, 50), window.addEventListener("resize", this.resizeFunc, !1));
  }
  onOrientationChange(e) {
    this.orientationChangeFunc = e, window.addEventListener("orientationchange", this.orientationChangeFunc, !1);
  }
  size(e, n) {
    var r;
    let i = e || this.settings.width, s = n || this.settings.height;
    e === null ? (r = this.element.getBoundingClientRect(), r.width && (e = Math.floor(r.width), this.container.style.width = e + "px")) : Yt(e) ? this.container.style.width = e + "px" : this.container.style.width = e, n === null ? (r = r || this.element.getBoundingClientRect(), r.height && (n = r.height, this.container.style.height = n + "px")) : Yt(n) ? this.container.style.height = n + "px" : this.container.style.height = n, Yt(e) || (e = this.container.clientWidth), Yt(n) || (n = this.container.clientHeight), this.containerStyles = window.getComputedStyle(this.container), this.containerPadding = {
      left: parseFloat(this.containerStyles["padding-left"]) || 0,
      right: parseFloat(this.containerStyles["padding-right"]) || 0,
      top: parseFloat(this.containerStyles["padding-top"]) || 0,
      bottom: parseFloat(this.containerStyles["padding-bottom"]) || 0
    };
    let o = Tl(), a = window.getComputedStyle(document.body), l = {
      left: parseFloat(a["padding-left"]) || 0,
      right: parseFloat(a["padding-right"]) || 0,
      top: parseFloat(a["padding-top"]) || 0,
      bottom: parseFloat(a["padding-bottom"]) || 0
    };
    return i || (e = o.width - l.left - l.right), (this.settings.fullsize && !s || !s) && (n = o.height - l.top - l.bottom), {
      width: e - this.containerPadding.left - this.containerPadding.right,
      height: n - this.containerPadding.top - this.containerPadding.bottom
    };
  }
  bounds() {
    let e;
    return this.container.style.overflow !== "visible" && (e = this.container && this.container.getBoundingClientRect()), !e || !e.width || !e.height ? Tl() : e;
  }
  getSheet() {
    var e = document.createElement("style");
    return e.appendChild(document.createTextNode("")), document.head.appendChild(e), e.sheet;
  }
  addStyleRules(e, n) {
    var r = "#" + this.id + " ", i = "";
    this.sheet || (this.sheet = this.getSheet()), n.forEach(function(s) {
      for (var o in s)
        s.hasOwnProperty(o) && (i += o + ":" + s[o] + ";");
    }), this.sheet.insertRule(r + e + " {" + i + "}", 0);
  }
  axis(e) {
    e === "horizontal" ? (this.container.style.display = "flex", this.container.style.flexDirection = "row", this.container.style.flexWrap = "nowrap") : this.container.style.display = "block", this.settings.axis = e;
  }
  // orientation(orientation) {
  // 	if (orientation === "landscape") {
  //
  // 	} else {
  //
  // 	}
  //
  // 	this.orientation = orientation;
  // }
  direction(e) {
    this.container && (this.container.dir = e, this.container.style.direction = e), this.settings.fullsize && (document.body.style.direction = e), this.settings.dir = e;
  }
  overflow(e) {
    this.container && (e === "scroll" && this.settings.axis === "vertical" ? (this.container.style["overflow-y"] = e, this.container.style["overflow-x"] = "hidden") : e === "scroll" && this.settings.axis === "horizontal" ? (this.container.style["overflow-y"] = "hidden", this.container.style["overflow-x"] = e) : this.container.style.overflow = e), this.settings.overflow = e;
  }
  destroy() {
    this.element && (this.settings.hidden ? this.wrapper : this.container, this.element.contains(this.container) && this.element.removeChild(this.container), window.removeEventListener("resize", this.resizeFunc), window.removeEventListener("orientationChange", this.orientationChangeFunc));
  }
}
class G6 {
  constructor(e) {
    this.container = e, this._views = [], this.length = 0, this.hidden = !1;
  }
  all() {
    return this._views;
  }
  first() {
    return this._views[0];
  }
  last() {
    return this._views[this._views.length - 1];
  }
  indexOf(e) {
    return this._views.indexOf(e);
  }
  slice() {
    return this._views.slice.apply(this._views, arguments);
  }
  get(e) {
    return this._views[e];
  }
  append(e) {
    return this._views.push(e), this.container && this.container.appendChild(e.element), this.length++, e;
  }
  prepend(e) {
    return this._views.unshift(e), this.container && this.container.insertBefore(e.element, this.container.firstChild), this.length++, e;
  }
  insert(e, n) {
    return this._views.splice(n, 0, e), this.container && (n < this.container.children.length ? this.container.insertBefore(e.element, this.container.children[n]) : this.container.appendChild(e.element)), this.length++, e;
  }
  remove(e) {
    var n = this._views.indexOf(e);
    n > -1 && this._views.splice(n, 1), this.destroy(e), this.length--;
  }
  destroy(e) {
    e.displayed && e.destroy(), this.container && this.container.removeChild(e.element), e = null;
  }
  // Iterators
  forEach() {
    return this._views.forEach.apply(this._views, arguments);
  }
  clear() {
    var e, n = this.length;
    if (this.length) {
      for (var r = 0; r < n; r++)
        e = this._views[r], this.destroy(e);
      this._views = [], this.length = 0;
    }
  }
  find(e) {
    for (var n, r = this.length, i = 0; i < r; i++)
      if (n = this._views[i], n.displayed && n.section.index == e.index)
        return n;
  }
  displayed() {
    for (var e = [], n, r = this.length, i = 0; i < r; i++)
      n = this._views[i], n.displayed && e.push(n);
    return e;
  }
  show() {
    for (var e, n = this.length, r = 0; r < n; r++)
      e = this._views[r], e.displayed && e.show();
    this.hidden = !1;
  }
  hide() {
    for (var e, n = this.length, r = 0; r < n; r++)
      e = this._views[r], e.displayed && e.hide();
    this.hidden = !0;
  }
}
class Bl {
  constructor(e) {
    this.name = "default", this.optsSettings = e.settings, this.View = e.view, this.request = e.request, this.renditionQueue = e.queue, this.q = new Of(this), this.settings = Sn(this.settings || {}, {
      infinite: !0,
      hidden: !1,
      width: void 0,
      height: void 0,
      axis: void 0,
      writingMode: void 0,
      flow: "scrolled",
      ignoreClass: "",
      fullsize: void 0,
      allowScriptedContent: !1,
      allowPopups: !1
    }), Sn(this.settings, e.settings || {}), this.viewSettings = {
      ignoreClass: this.settings.ignoreClass,
      axis: this.settings.axis,
      flow: this.settings.flow,
      layout: this.layout,
      method: this.settings.method,
      // srcdoc, blobUrl, write
      width: 0,
      height: 0,
      forceEvenPages: !0,
      allowScriptedContent: this.settings.allowScriptedContent,
      allowPopups: this.settings.allowPopups
    }, this.rendered = !1;
  }
  render(e, n) {
    let r = e.tagName;
    typeof this.settings.fullsize > "u" && r && (r.toLowerCase() == "body" || r.toLowerCase() == "html") && (this.settings.fullsize = !0), this.settings.fullsize && (this.settings.overflow = "visible", this.overflow = this.settings.overflow), this.settings.size = n, this.settings.rtlScrollType = H8(), this.stage = new $6({
      width: n.width,
      height: n.height,
      overflow: this.overflow,
      hidden: this.settings.hidden,
      axis: this.settings.axis,
      fullsize: this.settings.fullsize,
      direction: this.settings.direction
    }), this.stage.attachTo(e), this.container = this.stage.getContainer(), this.views = new G6(this.container), this._bounds = this.bounds(), this._stageSize = this.stage.size(), this.viewSettings.width = this._stageSize.width, this.viewSettings.height = this._stageSize.height, this.stage.onResize(this.onResized.bind(this)), this.stage.onOrientationChange(this.onOrientationChange.bind(this)), this.addEventListeners(), this.layout && this.updateLayout(), this.rendered = !0;
  }
  addEventListeners() {
    var e;
    window.addEventListener("unload", function(n) {
      this.destroy();
    }.bind(this)), this.settings.fullsize ? e = window : e = this.container, this._onScroll = this.onScroll.bind(this), e.addEventListener("scroll", this._onScroll);
  }
  removeEventListeners() {
    var e;
    this.settings.fullsize ? e = window : e = this.container, e.removeEventListener("scroll", this._onScroll), this._onScroll = void 0;
  }
  destroy() {
    clearTimeout(this.orientationTimeout), clearTimeout(this.resizeTimeout), clearTimeout(this.afterScrolled), this.clear(), this.removeEventListeners(), this.stage.destroy(), this.rendered = !1;
  }
  onOrientationChange(e) {
    let { orientation: n } = window;
    this.optsSettings.resizeOnOrientationChange && this.resize(), clearTimeout(this.orientationTimeout), this.orientationTimeout = setTimeout(function() {
      this.orientationTimeout = void 0, this.optsSettings.resizeOnOrientationChange && this.resize(), this.emit(Re.MANAGERS.ORIENTATION_CHANGE, n);
    }.bind(this), 500);
  }
  onResized(e) {
    this.resize();
  }
  resize(e, n, r) {
    let i = this.stage.size(e, n);
    if (this.winBounds = Tl(), this.orientationTimeout && this.winBounds.width === this.winBounds.height) {
      this._stageSize = void 0;
      return;
    }
    this._stageSize && this._stageSize.width === i.width && this._stageSize.height === i.height || (this._stageSize = i, this._bounds = this.bounds(), this.clear(), this.viewSettings.width = this._stageSize.width, this.viewSettings.height = this._stageSize.height, this.updateLayout(), this.emit(Re.MANAGERS.RESIZED, {
      width: this._stageSize.width,
      height: this._stageSize.height
    }, r));
  }
  createView(e, n) {
    return new this.View(e, Sn(this.viewSettings, { forceRight: n }));
  }
  handleNextPrePaginated(e, n, r) {
    let i;
    if (this.layout.name === "pre-paginated" && this.layout.divisor > 1) {
      if (e || n.index === 0)
        return;
      if (i = n.next(), i && !i.properties.includes("page-spread-left"))
        return r.call(this, i);
    }
  }
  display(e, n) {
    var r = new vt(), i = r.promise;
    (n === e.href || Yt(n)) && (n = void 0);
    var s = this.views.find(e);
    if (s && e && this.layout.name !== "pre-paginated") {
      let a = s.offset();
      if (this.settings.direction === "ltr")
        this.scrollTo(a.left, a.top, !0);
      else {
        let l = s.width();
        this.scrollTo(a.left + l, a.top, !0);
      }
      if (n) {
        let l = s.locationOf(n), u = s.width();
        this.moveTo(l, u);
      }
      return r.resolve(), i;
    }
    this.clear();
    let o = !1;
    return this.layout.name === "pre-paginated" && this.layout.divisor === 2 && e.properties.includes("page-spread-right") && (o = !0), this.add(e, o).then(function(a) {
      if (n) {
        let l = a.locationOf(n), u = a.width();
        this.moveTo(l, u);
      }
    }.bind(this), (a) => {
      r.reject(a);
    }).then(function() {
      return this.handleNextPrePaginated(o, e, this.add);
    }.bind(this)).then(function() {
      this.views.show(), r.resolve();
    }.bind(this)), i;
  }
  afterDisplayed(e) {
    this.emit(Re.MANAGERS.ADDED, e);
  }
  afterResized(e) {
    this.emit(Re.MANAGERS.RESIZE, e.section);
  }
  moveTo(e, n) {
    var r = 0, i = 0;
    this.isPaginated ? (r = Math.floor(e.left / this.layout.delta) * this.layout.delta, r + this.layout.delta > this.container.scrollWidth && (r = this.container.scrollWidth - this.layout.delta), i = Math.floor(e.top / this.layout.delta) * this.layout.delta, i + this.layout.delta > this.container.scrollHeight && (i = this.container.scrollHeight - this.layout.delta)) : i = e.top, this.settings.direction === "rtl" && (r = r + this.layout.delta, r = r - n), this.scrollTo(r, i, !0);
  }
  add(e, n) {
    var r = this.createView(e, n);
    return this.views.append(r), r.onDisplayed = this.afterDisplayed.bind(this), r.onResize = this.afterResized.bind(this), r.on(Re.VIEWS.AXIS, (i) => {
      this.updateAxis(i);
    }), r.on(Re.VIEWS.WRITING_MODE, (i) => {
      this.updateWritingMode(i);
    }), r.display(this.request);
  }
  append(e, n) {
    var r = this.createView(e, n);
    return this.views.append(r), r.onDisplayed = this.afterDisplayed.bind(this), r.onResize = this.afterResized.bind(this), r.on(Re.VIEWS.AXIS, (i) => {
      this.updateAxis(i);
    }), r.on(Re.VIEWS.WRITING_MODE, (i) => {
      this.updateWritingMode(i);
    }), r.display(this.request);
  }
  prepend(e, n) {
    var r = this.createView(e, n);
    return r.on(Re.VIEWS.RESIZED, (i) => {
      this.counter(i);
    }), this.views.prepend(r), r.onDisplayed = this.afterDisplayed.bind(this), r.onResize = this.afterResized.bind(this), r.on(Re.VIEWS.AXIS, (i) => {
      this.updateAxis(i);
    }), r.on(Re.VIEWS.WRITING_MODE, (i) => {
      this.updateWritingMode(i);
    }), r.display(this.request);
  }
  counter(e) {
    this.settings.axis === "vertical" ? this.scrollBy(0, e.heightDelta, !0) : this.scrollBy(e.widthDelta, 0, !0);
  }
  // resizeView(view) {
  //
  // 	if(this.settings.globalLayoutProperties.layout === "pre-paginated") {
  // 		view.lock("both", this.bounds.width, this.bounds.height);
  // 	} else {
  // 		view.lock("width", this.bounds.width, this.bounds.height);
  // 	}
  //
  // };
  next() {
    var e, n;
    let r = this.settings.direction;
    if (this.views.length && (this.isPaginated && this.settings.axis === "horizontal" && (!r || r === "ltr") ? (this.scrollLeft = this.container.scrollLeft, n = this.container.scrollLeft + this.container.offsetWidth + this.layout.delta, n <= this.container.scrollWidth ? this.scrollBy(this.layout.delta, 0, !0) : e = this.views.last().section.next()) : this.isPaginated && this.settings.axis === "horizontal" && r === "rtl" ? (this.scrollLeft = this.container.scrollLeft, this.settings.rtlScrollType === "default" ? (n = this.container.scrollLeft, n > 0 ? this.scrollBy(this.layout.delta, 0, !0) : e = this.views.last().section.next()) : (n = this.container.scrollLeft + this.layout.delta * -1, n > this.container.scrollWidth * -1 ? this.scrollBy(this.layout.delta, 0, !0) : e = this.views.last().section.next())) : this.isPaginated && this.settings.axis === "vertical" ? (this.scrollTop = this.container.scrollTop, this.container.scrollTop + this.container.offsetHeight < this.container.scrollHeight ? this.scrollBy(0, this.layout.height, !0) : e = this.views.last().section.next()) : e = this.views.last().section.next(), e)) {
      this.clear(), this.updateLayout();
      let i = !1;
      return this.layout.name === "pre-paginated" && this.layout.divisor === 2 && e.properties.includes("page-spread-right") && (i = !0), this.append(e, i).then(function() {
        return this.handleNextPrePaginated(i, e, this.append);
      }.bind(this), (s) => s).then(function() {
        !this.isPaginated && this.settings.axis === "horizontal" && this.settings.direction === "rtl" && this.settings.rtlScrollType === "default" && this.scrollTo(this.container.scrollWidth, 0, !0), this.views.show();
      }.bind(this));
    }
  }
  prev() {
    var e, n;
    let r = this.settings.direction;
    if (this.views.length && (this.isPaginated && this.settings.axis === "horizontal" && (!r || r === "ltr") ? (this.scrollLeft = this.container.scrollLeft, n = this.container.scrollLeft, n > 0 ? this.scrollBy(-this.layout.delta, 0, !0) : e = this.views.first().section.prev()) : this.isPaginated && this.settings.axis === "horizontal" && r === "rtl" ? (this.scrollLeft = this.container.scrollLeft, this.settings.rtlScrollType === "default" ? (n = this.container.scrollLeft + this.container.offsetWidth, n < this.container.scrollWidth ? this.scrollBy(-this.layout.delta, 0, !0) : e = this.views.first().section.prev()) : (n = this.container.scrollLeft, n < 0 ? this.scrollBy(-this.layout.delta, 0, !0) : e = this.views.first().section.prev())) : this.isPaginated && this.settings.axis === "vertical" ? (this.scrollTop = this.container.scrollTop, this.container.scrollTop > 0 ? this.scrollBy(0, -this.layout.height, !0) : e = this.views.first().section.prev()) : e = this.views.first().section.prev(), e)) {
      this.clear(), this.updateLayout();
      let i = !1;
      return this.layout.name === "pre-paginated" && this.layout.divisor === 2 && typeof e.prev() != "object" && (i = !0), this.prepend(e, i).then(function() {
        var s;
        if (this.layout.name === "pre-paginated" && this.layout.divisor > 1 && (s = e.prev(), s))
          return this.prepend(s);
      }.bind(this), (s) => s).then(function() {
        this.isPaginated && this.settings.axis === "horizontal" && (this.settings.direction === "rtl" ? this.settings.rtlScrollType === "default" ? this.scrollTo(0, 0, !0) : this.scrollTo(this.container.scrollWidth * -1 + this.layout.delta, 0, !0) : this.scrollTo(this.container.scrollWidth - this.layout.delta, 0, !0)), this.views.show();
      }.bind(this));
    }
  }
  current() {
    var e = this.visible();
    return e.length ? e[e.length - 1] : null;
  }
  clear() {
    this.views && (this.views.hide(), this.scrollTo(0, 0, !0), this.views.clear());
  }
  currentLocation() {
    return this.updateLayout(), this.isPaginated && this.settings.axis === "horizontal" ? this.location = this.paginatedLocation() : this.location = this.scrolledLocation(), this.location;
  }
  scrolledLocation() {
    let e = this.visible(), n = this.container.getBoundingClientRect(), r = n.height < window.innerHeight ? n.height : window.innerHeight, i = n.width < window.innerWidth ? n.width : window.innerWidth, s = this.settings.axis === "vertical";
    this.settings.direction;
    let o = 0, a = 0;
    return this.settings.fullsize && (o = s ? window.scrollY : window.scrollX), e.map((u) => {
      let { index: c, href: d } = u.section, h = u.position(), v = u.width(), y = u.height(), b, p, f, g;
      s ? (b = o + n.top - h.top + a, p = b + r - a, g = this.layout.count(y, r).pages, f = r) : (b = o + n.left - h.left + a, p = b + i - a, g = this.layout.count(v, i).pages, f = i);
      let m = Math.ceil(b / f), w = [], _ = Math.ceil(p / f);
      if (this.settings.direction === "rtl" && !s) {
        let C = m;
        m = g - _, _ = g - C;
      }
      w = [];
      for (var S = m; S <= _; S++) {
        let C = S + 1;
        w.push(C);
      }
      let A = this.mapping.page(u.contents, u.section.cfiBase, b, p);
      return {
        index: c,
        href: d,
        pages: w,
        totalPages: g,
        mapping: A
      };
    });
  }
  paginatedLocation() {
    let e = this.visible(), n = this.container.getBoundingClientRect(), r = 0, i = 0;
    return this.settings.fullsize && (r = window.scrollX), e.map((o) => {
      let { index: a, href: l } = o.section, u, c = o.position(), d = o.width(), h, v, y;
      this.settings.direction === "rtl" ? (u = n.right - r, y = Math.min(Math.abs(u - c.left), this.layout.width) - i, v = c.width - (c.right - u) - i, h = v - y) : (u = n.left + r, y = Math.min(c.right - u, this.layout.width) - i, h = u - c.left + i, v = h + y), i += y;
      let b = this.mapping.page(o.contents, o.section.cfiBase, h, v), p = this.layout.count(d).pages, f = Math.floor(h / this.layout.pageWidth), g = [], m = Math.floor(v / this.layout.pageWidth);
      if (f < 0 && (f = 0, m = m + 1), this.settings.direction === "rtl") {
        let _ = f;
        f = p - m, m = p - _;
      }
      for (var w = f + 1; w <= m; w++) {
        let _ = w;
        g.push(_);
      }
      return {
        index: a,
        href: l,
        pages: g,
        totalPages: p,
        mapping: b
      };
    });
  }
  isVisible(e, n, r, i) {
    var s = e.position(), o = i || this.bounds();
    return this.settings.axis === "horizontal" && s.right > o.left - n && s.left < o.right + r ? !0 : this.settings.axis === "vertical" && s.bottom > o.top - n && s.top < o.bottom + r;
  }
  visible() {
    for (var e = this.bounds(), n = this.views.displayed(), r = n.length, i = [], s, o, a = 0; a < r; a++)
      o = n[a], s = this.isVisible(o, 0, 0, e), s === !0 && i.push(o);
    return i;
  }
  scrollBy(e, n, r) {
    let i = this.settings.direction === "rtl" ? -1 : 1;
    r && (this.ignore = !0), this.settings.fullsize ? window.scrollBy(e * i, n * i) : (e && (this.container.scrollLeft += e * i), n && (this.container.scrollTop += n)), this.scrolled = !0;
  }
  scrollTo(e, n, r) {
    r && (this.ignore = !0), this.settings.fullsize ? window.scrollTo(e, n) : (this.container.scrollLeft = e, this.container.scrollTop = n), this.scrolled = !0;
  }
  onScroll() {
    let e, n;
    this.settings.fullsize ? (e = window.scrollY, n = window.scrollX) : (e = this.container.scrollTop, n = this.container.scrollLeft), this.scrollTop = e, this.scrollLeft = n, this.ignore ? this.ignore = !1 : (this.emit(Re.MANAGERS.SCROLL, {
      top: e,
      left: n
    }), clearTimeout(this.afterScrolled), this.afterScrolled = setTimeout(function() {
      this.emit(Re.MANAGERS.SCROLLED, {
        top: this.scrollTop,
        left: this.scrollLeft
      });
    }.bind(this), 20));
  }
  bounds() {
    var e;
    return e = this.stage.bounds(), e;
  }
  applyLayout(e) {
    this.layout = e, this.updateLayout(), this.views && this.views.length > 0 && this.layout.name === "pre-paginated" && this.display(this.views.first().section);
  }
  updateLayout() {
    this.stage && (this._stageSize = this.stage.size(), this.isPaginated ? (this.layout.calculate(
      this._stageSize.width,
      this._stageSize.height,
      this.settings.gap
    ), this.settings.offset = this.layout.delta / this.layout.divisor) : this.layout.calculate(this._stageSize.width, this._stageSize.height), this.viewSettings.width = this.layout.width, this.viewSettings.height = this.layout.height, this.setLayout(this.layout));
  }
  setLayout(e) {
    this.viewSettings.layout = e, this.mapping = new Rl(e.props, this.settings.direction, this.settings.axis), this.views && this.views.forEach(function(n) {
      n && n.setLayout(e);
    });
  }
  updateWritingMode(e) {
    this.writingMode = e;
  }
  updateAxis(e, n) {
    !n && e === this.settings.axis || (this.settings.axis = e, this.stage && this.stage.axis(e), this.viewSettings.axis = e, this.mapping && (this.mapping = new Rl(this.layout.props, this.settings.direction, this.settings.axis)), this.layout && (e === "vertical" ? this.layout.spread("none") : this.layout.spread(this.layout.settings.spread)));
  }
  updateFlow(e, n = "auto") {
    let r = e === "paginated" || e === "auto";
    this.isPaginated = r, e === "scrolled-doc" || e === "scrolled-continuous" || e === "scrolled" ? this.updateAxis("vertical") : this.updateAxis("horizontal"), this.viewSettings.flow = e, this.settings.overflow ? this.overflow = this.settings.overflow : this.overflow = r ? "hidden" : n, this.stage && this.stage.overflow(this.overflow), this.updateLayout();
  }
  getContents() {
    var e = [];
    return this.views && this.views.forEach(function(n) {
      const r = n && n.contents;
      r && e.push(r);
    }), e;
  }
  direction(e = "ltr") {
    this.settings.direction = e, this.stage && this.stage.direction(e), this.viewSettings.direction = e, this.updateLayout();
  }
  isRendered() {
    return this.rendered;
  }
}
Lr(Bl.prototype);
const q6 = Math.PI / 2, J6 = {
  easeOutSine: function(t) {
    return Math.sin(t * q6);
  },
  easeInOutSine: function(t) {
    return -0.5 * (Math.cos(Math.PI * t) - 1);
  },
  easeInOutQuint: function(t) {
    return (t /= 0.5) < 1 ? 0.5 * Math.pow(t, 5) : 0.5 * (Math.pow(t - 2, 5) + 2);
  },
  easeInCubic: function(t) {
    return Math.pow(t, 3);
  }
};
class od {
  constructor(e, n) {
    this.settings = Sn({
      duration: 80,
      minVelocity: 0.2,
      minDistance: 10,
      easing: J6.easeInCubic
    }, n || {}), this.supportsTouch = this.supportsTouch(), this.supportsTouch && this.setup(e);
  }
  setup(e) {
    this.manager = e, this.layout = this.manager.layout, this.fullsize = this.manager.settings.fullsize, this.fullsize ? (this.element = this.manager.stage.element, this.scroller = window, this.disableScroll()) : (this.element = this.manager.stage.container, this.scroller = this.element, this.element.style.WebkitOverflowScrolling = "touch"), this.manager.settings.offset = this.layout.width, this.manager.settings.afterScrolledTimeout = this.settings.duration * 2, this.isVertical = this.manager.settings.axis === "vertical", !(!this.manager.isPaginated || this.isVertical) && (this.touchCanceler = !1, this.resizeCanceler = !1, this.snapping = !1, this.scrollLeft, this.scrollTop, this.startTouchX = void 0, this.startTouchY = void 0, this.startTime = void 0, this.endTouchX = void 0, this.endTouchY = void 0, this.endTime = void 0, this.addListeners());
  }
  supportsTouch() {
    return !!("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch);
  }
  disableScroll() {
    this.element.style.overflow = "hidden";
  }
  enableScroll() {
    this.element.style.overflow = "";
  }
  addListeners() {
    this._onResize = this.onResize.bind(this), window.addEventListener("resize", this._onResize), this._onScroll = this.onScroll.bind(this), this.scroller.addEventListener("scroll", this._onScroll), this._onTouchStart = this.onTouchStart.bind(this), this.scroller.addEventListener("touchstart", this._onTouchStart, { passive: !0 }), this.on("touchstart", this._onTouchStart), this._onTouchMove = this.onTouchMove.bind(this), this.scroller.addEventListener("touchmove", this._onTouchMove, { passive: !0 }), this.on("touchmove", this._onTouchMove), this._onTouchEnd = this.onTouchEnd.bind(this), this.scroller.addEventListener("touchend", this._onTouchEnd, { passive: !0 }), this.on("touchend", this._onTouchEnd), this._afterDisplayed = this.afterDisplayed.bind(this), this.manager.on(Re.MANAGERS.ADDED, this._afterDisplayed);
  }
  removeListeners() {
    window.removeEventListener("resize", this._onResize), this._onResize = void 0, this.scroller.removeEventListener("scroll", this._onScroll), this._onScroll = void 0, this.scroller.removeEventListener("touchstart", this._onTouchStart, { passive: !0 }), this.off("touchstart", this._onTouchStart), this._onTouchStart = void 0, this.scroller.removeEventListener("touchmove", this._onTouchMove, { passive: !0 }), this.off("touchmove", this._onTouchMove), this._onTouchMove = void 0, this.scroller.removeEventListener("touchend", this._onTouchEnd, { passive: !0 }), this.off("touchend", this._onTouchEnd), this._onTouchEnd = void 0, this.manager.off(Re.MANAGERS.ADDED, this._afterDisplayed), this._afterDisplayed = void 0;
  }
  afterDisplayed(e) {
    let n = e.contents;
    ["touchstart", "touchmove", "touchend"].forEach((r) => {
      n.on(r, (i) => this.triggerViewEvent(i, n));
    });
  }
  triggerViewEvent(e, n) {
    this.emit(e.type, e, n);
  }
  onScroll(e) {
    this.scrollLeft = this.fullsize ? window.scrollX : this.scroller.scrollLeft, this.scrollTop = this.fullsize ? window.scrollY : this.scroller.scrollTop;
  }
  onResize(e) {
    this.resizeCanceler = !0;
  }
  onTouchStart(e) {
    let { screenX: n, screenY: r } = e.touches[0];
    this.fullsize && this.enableScroll(), this.touchCanceler = !0, this.startTouchX || (this.startTouchX = n, this.startTouchY = r, this.startTime = this.now()), this.endTouchX = n, this.endTouchY = r, this.endTime = this.now();
  }
  onTouchMove(e) {
    let { screenX: n, screenY: r } = e.touches[0], i = Math.abs(r - this.endTouchY);
    this.touchCanceler = !0, !this.fullsize && i < 10 && (this.element.scrollLeft -= n - this.endTouchX), this.endTouchX = n, this.endTouchY = r, this.endTime = this.now();
  }
  onTouchEnd(e) {
    this.fullsize && this.disableScroll(), this.touchCanceler = !1;
    let n = this.wasSwiped();
    n !== 0 ? this.snap(n) : this.snap(), this.startTouchX = void 0, this.startTouchY = void 0, this.startTime = void 0, this.endTouchX = void 0, this.endTouchY = void 0, this.endTime = void 0;
  }
  wasSwiped() {
    let e = this.layout.pageWidth * this.layout.divisor, n = this.endTouchX - this.startTouchX, r = Math.abs(n), i = this.endTime - this.startTime, s = n / i, o = this.settings.minVelocity;
    if (r <= this.settings.minDistance || r >= e)
      return 0;
    if (s > o)
      return -1;
    if (s < -o)
      return 1;
  }
  needsSnap() {
    let e = this.scrollLeft, n = this.layout.pageWidth * this.layout.divisor;
    return e % n !== 0;
  }
  snap(e = 0) {
    let n = this.scrollLeft, r = this.layout.pageWidth * this.layout.divisor, i = Math.round(n / r) * r;
    return e && (i += e * r), this.smoothScrollTo(i);
  }
  smoothScrollTo(e) {
    const n = new vt(), r = this.scrollLeft, i = this.now(), s = this.settings.duration, o = this.settings.easing;
    this.snapping = !0;
    function a() {
      const l = this.now(), u = Math.min(1, (l - i) / s);
      if (o(u), this.touchCanceler || this.resizeCanceler) {
        this.resizeCanceler = !1, this.snapping = !1, n.resolve();
        return;
      }
      u < 1 ? (window.requestAnimationFrame(a.bind(this)), this.scrollTo(r + (e - r) * u, 0)) : (this.scrollTo(e, 0), this.snapping = !1, n.resolve());
    }
    return a.call(this), n.promise;
  }
  scrollTo(e = 0, n = 0) {
    this.fullsize ? window.scroll(e, n) : (this.scroller.scrollLeft = e, this.scroller.scrollTop = n);
  }
  now() {
    return "now" in window.performance ? performance.now() : (/* @__PURE__ */ new Date()).getTime();
  }
  destroy() {
    this.scroller && (this.fullsize && this.enableScroll(), this.removeListeners(), this.scroller = void 0);
  }
}
Lr(od.prototype);
class Y6 extends Bl {
  constructor(e) {
    super(e), this.name = "continuous", this.settings = Sn(this.settings || {}, {
      infinite: !0,
      overflow: void 0,
      axis: void 0,
      writingMode: void 0,
      flow: "scrolled",
      offset: 500,
      offsetDelta: 250,
      width: void 0,
      height: void 0,
      snap: !1,
      afterScrolledTimeout: 10,
      allowScriptedContent: !1,
      allowPopups: !1
    }), Sn(this.settings, e.settings || {}), e.settings.gap != "undefined" && e.settings.gap === 0 && (this.settings.gap = e.settings.gap), this.viewSettings = {
      ignoreClass: this.settings.ignoreClass,
      axis: this.settings.axis,
      flow: this.settings.flow,
      layout: this.layout,
      width: 0,
      height: 0,
      forceEvenPages: !1,
      allowScriptedContent: this.settings.allowScriptedContent,
      allowPopups: this.settings.allowPopups
    }, this.scrollTop = 0, this.scrollLeft = 0;
  }
  display(e, n) {
    return Bl.prototype.display.call(this, e, n).then(function() {
      return this.fill();
    }.bind(this));
  }
  fill(e) {
    var n = e || new vt();
    return this.q.enqueue(() => this.check()).then((r) => {
      r ? this.fill(n) : n.resolve();
    }), n.promise;
  }
  moveTo(e) {
    var n = 0, r = 0;
    this.isPaginated ? (n = Math.floor(e.left / this.layout.delta) * this.layout.delta, n + this.settings.offsetDelta) : (r = e.top, e.top + this.settings.offsetDelta), (n > 0 || r > 0) && this.scrollBy(n, r, !0);
  }
  afterResized(e) {
    this.emit(Re.MANAGERS.RESIZE, e.section);
  }
  // Remove Previous Listeners if present
  removeShownListeners(e) {
    e.onDisplayed = function() {
    };
  }
  add(e) {
    var n = this.createView(e);
    return this.views.append(n), n.on(Re.VIEWS.RESIZED, (r) => {
      n.expanded = !0;
    }), n.on(Re.VIEWS.AXIS, (r) => {
      this.updateAxis(r);
    }), n.on(Re.VIEWS.WRITING_MODE, (r) => {
      this.updateWritingMode(r);
    }), n.onDisplayed = this.afterDisplayed.bind(this), n.onResize = this.afterResized.bind(this), n.display(this.request);
  }
  append(e) {
    var n = this.createView(e);
    return n.on(Re.VIEWS.RESIZED, (r) => {
      n.expanded = !0;
    }), n.on(Re.VIEWS.AXIS, (r) => {
      this.updateAxis(r);
    }), n.on(Re.VIEWS.WRITING_MODE, (r) => {
      this.updateWritingMode(r);
    }), this.views.append(n), n.onDisplayed = this.afterDisplayed.bind(this), n;
  }
  prepend(e) {
    var n = this.createView(e);
    return n.on(Re.VIEWS.RESIZED, (r) => {
      this.counter(r), n.expanded = !0;
    }), n.on(Re.VIEWS.AXIS, (r) => {
      this.updateAxis(r);
    }), n.on(Re.VIEWS.WRITING_MODE, (r) => {
      this.updateWritingMode(r);
    }), this.views.prepend(n), n.onDisplayed = this.afterDisplayed.bind(this), n;
  }
  counter(e) {
    this.settings.axis === "vertical" ? this.scrollBy(0, e.heightDelta, !0) : this.scrollBy(e.widthDelta, 0, !0);
  }
  update(e) {
    for (var n = this.bounds(), r = this.views.all(), i = r.length, s = typeof e < "u" ? e : this.settings.offset || 0, o, a, l = new vt(), u = [], c = 0; c < i; c++)
      if (a = r[c], o = this.isVisible(a, s, s, n), o === !0)
        if (a.displayed)
          a.show();
        else {
          let d = a.display(this.request).then(function(h) {
            h.show();
          }, (h) => {
            a.hide();
          });
          u.push(d);
        }
      else
        this.q.enqueue(a.destroy.bind(a)), clearTimeout(this.trimTimeout), this.trimTimeout = setTimeout(function() {
          this.q.enqueue(this.trim.bind(this));
        }.bind(this), 250);
    return u.length ? Promise.all(u).catch((d) => {
      l.reject(d);
    }) : (l.resolve(), l.promise);
  }
  check(e, n) {
    var r = new vt(), i = [], s = this.settings.axis === "horizontal", o = this.settings.offset || 0;
    e && s && (o = e), n && !s && (o = n);
    var a = this._bounds;
    let l = s ? this.scrollLeft : this.scrollTop, u = s ? Math.floor(a.width) : a.height, c = s ? this.container.scrollWidth : this.container.scrollHeight, d = this.writingMode && this.writingMode.indexOf("vertical") === 0 ? "vertical" : "horizontal", h = this.settings.rtlScrollType, v = this.settings.direction === "rtl";
    this.settings.fullsize ? (s && v && h === "negative" || !s && v && h === "default") && (l = l * -1) : (v && h === "default" && d === "horizontal" && (l = c - u - l), v && h === "negative" && d === "horizontal" && (l = l * -1));
    let y = () => {
      let m = this.views.first(), w = m && m.section.prev();
      w && i.push(this.prepend(w));
    }, b = () => {
      let m = this.views.last(), w = m && m.section.next();
      w && i.push(this.append(w));
    }, p = l + u + o, f = l - o;
    p >= c && b(), f < 0 && y();
    let g = i.map((m) => m.display(this.request));
    return i.length ? Promise.all(g).then(() => this.check()).then(() => this.update(o), (m) => m) : (this.q.enqueue(function() {
      this.update();
    }.bind(this)), r.resolve(!1), r.promise);
  }
  trim() {
    for (var e = new vt(), n = this.views.displayed(), r = n[0], i = n[n.length - 1], s = this.views.indexOf(r), o = this.views.indexOf(i), a = this.views.slice(0, s), l = this.views.slice(o + 1), u = 0; u < a.length - 1; u++)
      this.erase(a[u], a);
    for (var c = 1; c < l.length; c++)
      this.erase(l[c]);
    return e.resolve(), e.promise;
  }
  erase(e, n) {
    var r, i;
    this.settings.fullsize ? (r = window.scrollY, i = window.scrollX) : (r = this.container.scrollTop, i = this.container.scrollLeft);
    var s = e.bounds();
    this.views.remove(e), n && (this.settings.axis === "vertical" ? this.scrollTo(0, r - s.height, !0) : this.settings.direction === "rtl" ? this.settings.fullsize ? this.scrollTo(i + Math.floor(s.width), 0, !0) : this.scrollTo(i, 0, !0) : this.scrollTo(i - Math.floor(s.width), 0, !0));
  }
  addEventListeners(e) {
    window.addEventListener("unload", function(n) {
      this.ignore = !0, this.destroy();
    }.bind(this)), this.addScrollListeners(), this.isPaginated && this.settings.snap && (this.snapper = new od(this, this.settings.snap && typeof this.settings.snap == "object" && this.settings.snap));
  }
  addScrollListeners() {
    var e;
    this.tick = kf;
    let n = this.settings.direction === "rtl" && this.settings.rtlScrollType === "default" ? -1 : 1;
    this.scrollDeltaVert = 0, this.scrollDeltaHorz = 0, this.settings.fullsize ? (e = window, this.scrollTop = window.scrollY * n, this.scrollLeft = window.scrollX * n) : (e = this.container, this.scrollTop = this.container.scrollTop, this.scrollLeft = this.container.scrollLeft), this._onScroll = this.onScroll.bind(this), e.addEventListener("scroll", this._onScroll), this._scrolled = R0(this.scrolled.bind(this), 30), this.didScroll = !1;
  }
  removeEventListeners() {
    var e;
    this.settings.fullsize ? e = window : e = this.container, e.removeEventListener("scroll", this._onScroll), this._onScroll = void 0;
  }
  onScroll() {
    let e, n, r = this.settings.direction === "rtl" && this.settings.rtlScrollType === "default" ? -1 : 1;
    this.settings.fullsize ? (e = window.scrollY * r, n = window.scrollX * r) : (e = this.container.scrollTop, n = this.container.scrollLeft), this.scrollTop = e, this.scrollLeft = n, this.ignore ? this.ignore = !1 : this._scrolled(), this.scrollDeltaVert += Math.abs(e - this.prevScrollTop), this.scrollDeltaHorz += Math.abs(n - this.prevScrollLeft), this.prevScrollTop = e, this.prevScrollLeft = n, clearTimeout(this.scrollTimeout), this.scrollTimeout = setTimeout(function() {
      this.scrollDeltaVert = 0, this.scrollDeltaHorz = 0;
    }.bind(this), 150), clearTimeout(this.afterScrolled), this.didScroll = !1;
  }
  scrolled() {
    this.q.enqueue(function() {
      return this.check();
    }.bind(this)), this.emit(Re.MANAGERS.SCROLL, {
      top: this.scrollTop,
      left: this.scrollLeft
    }), clearTimeout(this.afterScrolled), this.afterScrolled = setTimeout(function() {
      this.snapper && this.snapper.supportsTouch && this.snapper.needsSnap() || this.emit(Re.MANAGERS.SCROLLED, {
        top: this.scrollTop,
        left: this.scrollLeft
      });
    }.bind(this), this.settings.afterScrolledTimeout);
  }
  next() {
    let e = this.layout.props.name === "pre-paginated" && this.layout.props.spread ? this.layout.props.delta * 2 : this.layout.props.delta;
    this.views.length && (this.isPaginated && this.settings.axis === "horizontal" ? this.scrollBy(e, 0, !0) : this.scrollBy(0, this.layout.height, !0), this.q.enqueue(function() {
      return this.check();
    }.bind(this)));
  }
  prev() {
    let e = this.layout.props.name === "pre-paginated" && this.layout.props.spread ? this.layout.props.delta * 2 : this.layout.props.delta;
    this.views.length && (this.isPaginated && this.settings.axis === "horizontal" ? this.scrollBy(-e, 0, !0) : this.scrollBy(0, -this.layout.height, !0), this.q.enqueue(function() {
      return this.check();
    }.bind(this)));
  }
  updateFlow(e) {
    this.rendered && this.snapper && (this.snapper.destroy(), this.snapper = void 0), super.updateFlow(e, "scroll"), this.rendered && this.isPaginated && this.settings.snap && (this.snapper = new od(this, this.settings.snap && typeof this.settings.snap == "object" && this.settings.snap));
  }
  destroy() {
    super.destroy(), this.snapper && this.snapper.destroy();
  }
}
class Pf {
  constructor(e, n) {
    this.settings = Sn(this.settings || {}, {
      width: null,
      height: null,
      ignoreClass: "",
      manager: "default",
      view: "iframe",
      flow: null,
      layout: null,
      spread: null,
      minSpreadWidth: 800,
      stylesheet: null,
      resizeOnOrientationChange: !0,
      script: null,
      snap: !1,
      defaultDirection: "ltr",
      allowScriptedContent: !1,
      allowPopups: !1
    }), Sn(this.settings, n), typeof this.settings.manager == "object" && (this.manager = this.settings.manager), this.book = e, this.hooks = {}, this.hooks.display = new hr(this), this.hooks.serialize = new hr(this), this.hooks.content = new hr(this), this.hooks.unloaded = new hr(this), this.hooks.layout = new hr(this), this.hooks.render = new hr(this), this.hooks.show = new hr(this), this.hooks.content.register(this.handleLinks.bind(this)), this.hooks.content.register(this.passEvents.bind(this)), this.hooks.content.register(this.adjustImages.bind(this)), this.book.spine.hooks.content.register(this.injectIdentifier.bind(this)), this.settings.stylesheet && this.book.spine.hooks.content.register(this.injectStylesheet.bind(this)), this.settings.script && this.book.spine.hooks.content.register(this.injectScript.bind(this)), this.themes = new C8(this), this.annotations = new I8(this), this.epubcfi = new gt(), this.q = new Of(this), this.location = void 0, this.q.enqueue(this.book.opened), this.starting = new vt(), this.started = this.starting.promise, this.q.enqueue(this.start);
  }
  /**
   * Set the manager function
   * @param {function} manager
   */
  setManager(e) {
    this.manager = e;
  }
  /**
   * Require the manager from passed string, or as a class function
   * @param  {string|object} manager [description]
   * @return {method}
   */
  requireManager(e) {
    var n;
    return typeof e == "string" && e === "default" ? n = Bl : typeof e == "string" && e === "continuous" ? n = Y6 : n = e, n;
  }
  /**
   * Require the view from passed string, or as a class function
   * @param  {string|object} view
   * @return {view}
   */
  requireView(e) {
    var n;
    return typeof e == "string" && e === "iframe" ? n = T0 : n = e, n;
  }
  /**
   * Start the rendering
   * @return {Promise} rendering has started
   */
  start() {
    switch (!this.settings.layout && (this.book.package.metadata.layout === "pre-paginated" || this.book.displayOptions.fixedLayout === "true") && (this.settings.layout = "pre-paginated"), this.book.package.metadata.spread) {
      case "none":
        this.settings.spread = "none";
        break;
      case "both":
        this.settings.spread = !0;
        break;
    }
    this.manager || (this.ViewManager = this.requireManager(this.settings.manager), this.View = this.requireView(this.settings.view), this.manager = new this.ViewManager({
      view: this.View,
      queue: this.q,
      request: this.book.load.bind(this.book),
      settings: this.settings
    })), this.direction(this.book.package.metadata.direction || this.settings.defaultDirection), this.settings.globalLayoutProperties = this.determineLayoutProperties(this.book.package.metadata), this.flow(this.settings.globalLayoutProperties.flow), this.layout(this.settings.globalLayoutProperties), this.manager.on(Re.MANAGERS.ADDED, this.afterDisplayed.bind(this)), this.manager.on(Re.MANAGERS.REMOVED, this.afterRemoved.bind(this)), this.manager.on(Re.MANAGERS.RESIZED, this.onResized.bind(this)), this.manager.on(Re.MANAGERS.ORIENTATION_CHANGE, this.onOrientationChange.bind(this)), this.manager.on(Re.MANAGERS.SCROLLED, this.reportLocation.bind(this)), this.emit(Re.RENDITION.STARTED), this.starting.resolve();
  }
  /**
   * Call to attach the container to an element in the dom
   * Container must be attached before rendering can begin
   * @param  {element} element to attach to
   * @return {Promise}
   */
  attachTo(e) {
    return this.q.enqueue(function() {
      this.manager.render(e, {
        width: this.settings.width,
        height: this.settings.height
      }), this.emit(Re.RENDITION.ATTACHED);
    }.bind(this));
  }
  /**
   * Display a point in the book
   * The request will be added to the rendering Queue,
   * so it will wait until book is opened, rendering started
   * and all other rendering tasks have finished to be called.
   * @param  {string} target Url or EpubCFI
   * @return {Promise}
   */
  display(e) {
    return this.displaying && this.displaying.resolve(), this.q.enqueue(this._display, e);
  }
  /**
   * Tells the manager what to display immediately
   * @private
   * @param  {string} target Url or EpubCFI
   * @return {Promise}
   */
  _display(e) {
    if (this.book) {
      this.epubcfi.isCfiString(e);
      var n = new vt(), r = n.promise, i;
      return this.displaying = n, this.book.locations.length() && o0(e) && (e = this.book.locations.cfiFromPercentage(parseFloat(e))), i = this.book.spine.get(e), i ? (this.manager.display(i, e).then(() => {
        n.resolve(i), this.displaying = void 0, this.emit(Re.RENDITION.DISPLAYED, i), this.reportLocation();
      }, (s) => {
        this.emit(Re.RENDITION.DISPLAY_ERROR, s);
      }), r) : (n.reject(new Error("No Section Found")), r);
    }
  }
  /*
  	render(view, show) {
  
  		// view.onLayout = this.layout.format.bind(this.layout);
  		view.create();
  
  		// Fit to size of the container, apply padding
  		this.manager.resizeView(view);
  
  		// Render Chain
  		return view.section.render(this.book.request)
  			.then(function(contents){
  				return view.load(contents);
  			}.bind(this))
  			.then(function(doc){
  				return this.hooks.content.trigger(view, this);
  			}.bind(this))
  			.then(function(){
  				this.layout.format(view.contents);
  				return this.hooks.layout.trigger(view, this);
  			}.bind(this))
  			.then(function(){
  				return view.display();
  			}.bind(this))
  			.then(function(){
  				return this.hooks.render.trigger(view, this);
  			}.bind(this))
  			.then(function(){
  				if(show !== false) {
  					this.q.enqueue(function(view){
  						view.show();
  					}, view);
  				}
  				// this.map = new Map(view, this.layout);
  				this.hooks.show.trigger(view, this);
  				this.trigger("rendered", view.section);
  
  			}.bind(this))
  			.catch(function(e){
  				this.trigger("loaderror", e);
  			}.bind(this));
  
  	}
  	*/
  /**
   * Report what section has been displayed
   * @private
   * @param  {*} view
   */
  afterDisplayed(e) {
    e.on(Re.VIEWS.MARK_CLICKED, (n, r) => this.triggerMarkEvent(n, r, e.contents)), this.hooks.render.trigger(e, this).then(() => {
      e.contents ? this.hooks.content.trigger(e.contents, this).then(() => {
        this.emit(Re.RENDITION.RENDERED, e.section, e);
      }) : this.emit(Re.RENDITION.RENDERED, e.section, e);
    });
  }
  /**
   * Report what has been removed
   * @private
   * @param  {*} view
   */
  afterRemoved(e) {
    this.hooks.unloaded.trigger(e, this).then(() => {
      this.emit(Re.RENDITION.REMOVED, e.section, e);
    });
  }
  /**
   * Report resize events and display the last seen location
   * @private
   */
  onResized(e, n) {
    this.emit(Re.RENDITION.RESIZED, {
      width: e.width,
      height: e.height
    }, n), this.location && this.location.start && this.display(n || this.location.start.cfi);
  }
  /**
   * Report orientation events and display the last seen location
   * @private
   */
  onOrientationChange(e) {
    this.emit(Re.RENDITION.ORIENTATION_CHANGE, e);
  }
  /**
   * Move the Rendition to a specific offset
   * Usually you would be better off calling display()
   * @param {object} offset
   */
  moveTo(e) {
    this.manager.moveTo(e);
  }
  /**
   * Trigger a resize of the views
   * @param {number} [width]
   * @param {number} [height]
   * @param {string} [epubcfi] (optional)
   */
  resize(e, n, r) {
    e && (this.settings.width = e), n && (this.settings.height = n), this.manager.resize(e, n, r);
  }
  /**
   * Clear all rendered views
   */
  clear() {
    this.manager.clear();
  }
  /**
   * Go to the next "page" in the rendition
   * @return {Promise}
   */
  next() {
    return this.q.enqueue(this.manager.next.bind(this.manager)).then(this.reportLocation.bind(this));
  }
  /**
   * Go to the previous "page" in the rendition
   * @return {Promise}
   */
  prev() {
    return this.q.enqueue(this.manager.prev.bind(this.manager)).then(this.reportLocation.bind(this));
  }
  //-- http://www.idpf.org/epub/301/spec/epub-publications.html#meta-properties-rendering
  /**
   * Determine the Layout properties from metadata and settings
   * @private
   * @param  {object} metadata
   * @return {object} properties
   */
  determineLayoutProperties(e) {
    var n, r = this.settings.layout || e.layout || "reflowable", i = this.settings.spread || e.spread || "auto", s = this.settings.orientation || e.orientation || "auto", o = this.settings.flow || e.flow || "auto", a = e.viewport || "", l = this.settings.minSpreadWidth || e.minSpreadWidth || 800, u = this.settings.direction || e.direction || "ltr";
    return (this.settings.width === 0 || this.settings.width > 0) && (this.settings.height === 0 || this.settings.height > 0), n = {
      layout: r,
      spread: i,
      orientation: s,
      flow: o,
      viewport: a,
      minSpreadWidth: l,
      direction: u
    }, n;
  }
  /**
   * Adjust the flow of the rendition to paginated or scrolled
   * (scrolled-continuous vs scrolled-doc are handled by different view managers)
   * @param  {string} flow
   */
  flow(e) {
    var n = e;
    (e === "scrolled" || e === "scrolled-doc" || e === "scrolled-continuous") && (n = "scrolled"), (e === "auto" || e === "paginated") && (n = "paginated"), this.settings.flow = e, this._layout && this._layout.flow(n), this.manager && this._layout && this.manager.applyLayout(this._layout), this.manager && this.manager.updateFlow(n), this.manager && this.manager.isRendered() && this.location && (this.manager.clear(), this.display(this.location.start.cfi));
  }
  /**
   * Adjust the layout of the rendition to reflowable or pre-paginated
   * @param  {object} settings
   */
  layout(e) {
    return e && (this._layout = new y0(e), this._layout.spread(e.spread, this.settings.minSpreadWidth), this._layout.on(Re.LAYOUT.UPDATED, (n, r) => {
      this.emit(Re.RENDITION.LAYOUT, n, r);
    })), this.manager && this._layout && this.manager.applyLayout(this._layout), this._layout;
  }
  /**
   * Adjust if the rendition uses spreads
   * @param  {string} spread none | auto (TODO: implement landscape, portrait, both)
   * @param  {int} [min] min width to use spreads at
   */
  spread(e, n) {
    this.settings.spread = e, n && (this.settings.minSpreadWidth = n), this._layout && this._layout.spread(e, n), this.manager && this.manager.isRendered() && this.manager.updateLayout();
  }
  /**
   * Adjust the direction of the rendition
   * @param  {string} dir
   */
  direction(e) {
    this.settings.direction = e || "ltr", this.manager && this.manager.direction(this.settings.direction), this.manager && this.manager.isRendered() && this.location && (this.manager.clear(), this.display(this.location.start.cfi));
  }
  /**
   * Report the current location
   * @fires relocated
   * @fires locationChanged
   */
  reportLocation() {
    return this.q.enqueue(function() {
      requestAnimationFrame(function() {
        var r = this.manager.currentLocation();
        if (r && r.then && typeof r.then == "function")
          r.then(function(i) {
            let s = this.located(i);
            !s || !s.start || !s.end || (this.location = s, this.emit(Re.RENDITION.LOCATION_CHANGED, {
              index: this.location.start.index,
              href: this.location.start.href,
              start: this.location.start.cfi,
              end: this.location.end.cfi,
              percentage: this.location.start.percentage
            }), this.emit(Re.RENDITION.RELOCATED, this.location));
          }.bind(this));
        else if (r) {
          let i = this.located(r);
          if (!i || !i.start || !i.end)
            return;
          this.location = i, this.emit(Re.RENDITION.LOCATION_CHANGED, {
            index: this.location.start.index,
            href: this.location.start.href,
            start: this.location.start.cfi,
            end: this.location.end.cfi,
            percentage: this.location.start.percentage
          }), this.emit(Re.RENDITION.RELOCATED, this.location);
        }
      }.bind(this));
    }.bind(this));
  }
  /**
   * Get the Current Location object
   * @return {displayedLocation | promise} location (may be a promise)
   */
  currentLocation() {
    var e = this.manager.currentLocation();
    if (e && e.then && typeof e.then == "function")
      e.then(function(n) {
        return this.located(n);
      }.bind(this));
    else if (e)
      return this.located(e);
  }
  /**
   * Creates a Rendition#locationRange from location
   * passed by the Manager
   * @returns {displayedLocation}
   * @private
   */
  located(e) {
    if (!e.length)
      return {};
    let n = e[0], r = e[e.length - 1], i = {
      start: {
        index: n.index,
        href: n.href,
        cfi: n.mapping.start,
        displayed: {
          page: n.pages[0] || 1,
          total: n.totalPages
        }
      },
      end: {
        index: r.index,
        href: r.href,
        cfi: r.mapping.end,
        displayed: {
          page: r.pages[r.pages.length - 1] || 1,
          total: r.totalPages
        }
      }
    }, s = this.book.locations.locationFromCfi(n.mapping.start), o = this.book.locations.locationFromCfi(r.mapping.end);
    s != null && (i.start.location = s, i.start.percentage = this.book.locations.percentageFromLocation(s)), o != null && (i.end.location = o, i.end.percentage = this.book.locations.percentageFromLocation(o));
    let a = this.book.pageList.pageFromCfi(n.mapping.start), l = this.book.pageList.pageFromCfi(r.mapping.end);
    return a != -1 && (i.start.page = a), l != -1 && (i.end.page = l), r.index === this.book.spine.last().index && i.end.displayed.page >= i.end.displayed.total && (i.atEnd = !0), n.index === this.book.spine.first().index && i.start.displayed.page === 1 && (i.atStart = !0), i;
  }
  /**
   * Remove and Clean Up the Rendition
   */
  destroy() {
    this.manager && this.manager.destroy(), this.book = void 0;
  }
  /**
   * Pass the events from a view's Contents
   * @private
   * @param  {Contents} view contents
   */
  passEvents(e) {
    tl.forEach((n) => {
      e.on(n, (r) => this.triggerViewEvent(r, e));
    }), e.on(Re.CONTENTS.SELECTED, (n) => this.triggerSelectedEvent(n, e));
  }
  /**
   * Emit events passed by a view
   * @private
   * @param  {event} e
   */
  triggerViewEvent(e, n) {
    this.emit(e.type, e, n);
  }
  /**
   * Emit a selection event's CFI Range passed from a a view
   * @private
   * @param  {string} cfirange
   */
  triggerSelectedEvent(e, n) {
    this.emit(Re.RENDITION.SELECTED, e, n);
  }
  /**
   * Emit a markClicked event with the cfiRange and data from a mark
   * @private
   * @param  {EpubCFI} cfirange
   */
  triggerMarkEvent(e, n, r) {
    this.emit(Re.RENDITION.MARK_CLICKED, e, n, r);
  }
  /**
   * Get a Range from a Visible CFI
   * @param  {string} cfi EpubCfi String
   * @param  {string} ignoreClass
   * @return {range}
   */
  getRange(e, n) {
    var r = new gt(e), i = this.manager.visible().filter(function(s) {
      if (r.spinePos === s.index)
        return !0;
    });
    if (i.length)
      return i[0].contents.range(r, n);
  }
  /**
   * Hook to adjust images to fit in columns
   * @param  {Contents} contents
   * @private
   */
  adjustImages(e) {
    if (this._layout.name === "pre-paginated")
      return new Promise(function(s) {
        s();
      });
    let n = e.window.getComputedStyle(e.content, null), r = (e.content.offsetHeight - (parseFloat(n.paddingTop) + parseFloat(n.paddingBottom))) * 0.95, i = parseFloat(n.paddingLeft) + parseFloat(n.paddingRight);
    return e.addStylesheetRules({
      img: {
        "max-width": (this._layout.columnWidth ? this._layout.columnWidth - i + "px" : "100%") + "!important",
        "max-height": r + "px!important",
        "object-fit": "contain",
        "page-break-inside": "avoid",
        "break-inside": "avoid",
        "box-sizing": "border-box"
      },
      svg: {
        "max-width": (this._layout.columnWidth ? this._layout.columnWidth - i + "px" : "100%") + "!important",
        "max-height": r + "px!important",
        "page-break-inside": "avoid",
        "break-inside": "avoid"
      }
    }), new Promise(function(s, o) {
      setTimeout(function() {
        s();
      }, 1);
    });
  }
  /**
   * Get the Contents object of each rendered view
   * @returns {Contents[]}
   */
  getContents() {
    return this.manager ? this.manager.getContents() : [];
  }
  /**
   * Get the views member from the manager
   * @returns {Views}
   */
  views() {
    return (this.manager ? this.manager.views : void 0) || [];
  }
  /**
   * Hook to handle link clicks in rendered content
   * @param  {Contents} contents
   * @private
   */
  handleLinks(e) {
    e && e.on(Re.CONTENTS.LINK_CLICKED, (n) => {
      let r = this.book.path.relative(n);
      this.display(r);
    });
  }
  /**
   * Hook to handle injecting stylesheet before
   * a Section is serialized
   * @param  {document} doc
   * @param  {Section} section
   * @private
   */
  injectStylesheet(e, n) {
    let r = e.createElement("link");
    r.setAttribute("type", "text/css"), r.setAttribute("rel", "stylesheet"), r.setAttribute("href", this.settings.stylesheet), e.getElementsByTagName("head")[0].appendChild(r);
  }
  /**
   * Hook to handle injecting scripts before
   * a Section is serialized
   * @param  {document} doc
   * @param  {Section} section
   * @private
   */
  injectScript(e, n) {
    let r = e.createElement("script");
    r.setAttribute("type", "text/javascript"), r.setAttribute("src", this.settings.script), r.textContent = " ", e.getElementsByTagName("head")[0].appendChild(r);
  }
  /**
   * Hook to handle the document identifier before
   * a Section is serialized
   * @param  {document} doc
   * @param  {Section} section
   * @private
   */
  injectIdentifier(e, n) {
    let r = this.book.packaging.metadata.identifier, i = e.createElement("meta");
    i.setAttribute("name", "dc.relation.ispartof"), r && i.setAttribute("content", r), e.getElementsByTagName("head")[0].appendChild(i);
  }
}
Lr(Pf.prototype);
function mi(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var ad = {}, Q6 = {
  get exports() {
    return ad;
  },
  set exports(t) {
    ad = t;
  }
};
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(t, e) {
  (function(n) {
    t.exports = n();
  })(function() {
    return function n(r, i, s) {
      function o(u, c) {
        if (!i[u]) {
          if (!r[u]) {
            var d = typeof mi == "function" && mi;
            if (!c && d)
              return d(u, !0);
            if (a)
              return a(u, !0);
            var h = new Error("Cannot find module '" + u + "'");
            throw h.code = "MODULE_NOT_FOUND", h;
          }
          var v = i[u] = { exports: {} };
          r[u][0].call(v.exports, function(y) {
            var b = r[u][1][y];
            return o(b || y);
          }, v, v.exports, n, r, i, s);
        }
        return i[u].exports;
      }
      for (var a = typeof mi == "function" && mi, l = 0; l < s.length; l++)
        o(s[l]);
      return o;
    }({ 1: [function(n, r, i) {
      var s = n("./utils"), o = n("./support"), a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      i.encode = function(l) {
        for (var u = [], c, d, h, v, y, b, p, f = 0, g = l.length, m = g, w = s.getTypeOf(l) !== "string"; f < l.length; )
          m = g - f, w ? (c = l[f++], d = f < g ? l[f++] : 0, h = f < g ? l[f++] : 0) : (c = l.charCodeAt(f++), d = f < g ? l.charCodeAt(f++) : 0, h = f < g ? l.charCodeAt(f++) : 0), v = c >> 2, y = (c & 3) << 4 | d >> 4, b = m > 1 ? (d & 15) << 2 | h >> 6 : 64, p = m > 2 ? h & 63 : 64, u.push(a.charAt(v) + a.charAt(y) + a.charAt(b) + a.charAt(p));
        return u.join("");
      }, i.decode = function(l) {
        var u, c, d, h, v, y, b, p = 0, f = 0, g = "data:";
        if (l.substr(0, g.length) === g)
          throw new Error("Invalid base64 input, it looks like a data url.");
        l = l.replace(/[^A-Za-z0-9+/=]/g, "");
        var m = l.length * 3 / 4;
        if (l.charAt(l.length - 1) === a.charAt(64) && m--, l.charAt(l.length - 2) === a.charAt(64) && m--, m % 1 !== 0)
          throw new Error("Invalid base64 input, bad content length.");
        var w;
        for (o.uint8array ? w = new Uint8Array(m | 0) : w = new Array(m | 0); p < l.length; )
          h = a.indexOf(l.charAt(p++)), v = a.indexOf(l.charAt(p++)), y = a.indexOf(l.charAt(p++)), b = a.indexOf(l.charAt(p++)), u = h << 2 | v >> 4, c = (v & 15) << 4 | y >> 2, d = (y & 3) << 6 | b, w[f++] = u, y !== 64 && (w[f++] = c), b !== 64 && (w[f++] = d);
        return w;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(n, r, i) {
      var s = n("./external"), o = n("./stream/DataWorker"), a = n("./stream/Crc32Probe"), l = n("./stream/DataLengthProbe");
      function u(c, d, h, v, y) {
        this.compressedSize = c, this.uncompressedSize = d, this.crc32 = h, this.compression = v, this.compressedContent = y;
      }
      u.prototype = {
        /**
         * Create a worker to get the uncompressed content.
         * @return {GenericWorker} the worker.
         */
        getContentWorker: function() {
          var c = new o(s.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new l("data_length")), d = this;
          return c.on("end", function() {
            if (this.streamInfo.data_length !== d.uncompressedSize)
              throw new Error("Bug : uncompressed data size mismatch");
          }), c;
        },
        /**
         * Create a worker to get the compressed content.
         * @return {GenericWorker} the worker.
         */
        getCompressedWorker: function() {
          return new o(s.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        }
      }, u.createWorkerFrom = function(c, d, h) {
        return c.pipe(new a()).pipe(new l("uncompressedSize")).pipe(d.compressWorker(h)).pipe(new l("compressedSize")).withStreamInfo("compression", d);
      }, r.exports = u;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(n, r, i) {
      var s = n("./stream/GenericWorker");
      i.STORE = {
        magic: "\0\0",
        compressWorker: function() {
          return new s("STORE compression");
        },
        uncompressWorker: function() {
          return new s("STORE decompression");
        }
      }, i.DEFLATE = n("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(n, r, i) {
      var s = n("./utils");
      function o() {
        for (var c, d = [], h = 0; h < 256; h++) {
          c = h;
          for (var v = 0; v < 8; v++)
            c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
          d[h] = c;
        }
        return d;
      }
      var a = o();
      function l(c, d, h, v) {
        var y = a, b = v + h;
        c = c ^ -1;
        for (var p = v; p < b; p++)
          c = c >>> 8 ^ y[(c ^ d[p]) & 255];
        return c ^ -1;
      }
      function u(c, d, h, v) {
        var y = a, b = v + h;
        c = c ^ -1;
        for (var p = v; p < b; p++)
          c = c >>> 8 ^ y[(c ^ d.charCodeAt(p)) & 255];
        return c ^ -1;
      }
      r.exports = function(d, h) {
        if (typeof d > "u" || !d.length)
          return 0;
        var v = s.getTypeOf(d) !== "string";
        return v ? l(h | 0, d, d.length, 0) : u(h | 0, d, d.length, 0);
      };
    }, { "./utils": 32 }], 5: [function(n, r, i) {
      i.base64 = !1, i.binary = !1, i.dir = !1, i.createFolders = !0, i.date = null, i.compression = null, i.compressionOptions = null, i.comment = null, i.unixPermissions = null, i.dosPermissions = null;
    }, {}], 6: [function(n, r, i) {
      var s = null;
      typeof Promise < "u" ? s = Promise : s = n("lie"), r.exports = {
        Promise: s
      };
    }, { lie: 37 }], 7: [function(n, r, i) {
      var s = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", o = n("pako"), a = n("./utils"), l = n("./stream/GenericWorker"), u = s ? "uint8array" : "array";
      i.magic = "\b\0";
      function c(d, h) {
        l.call(this, "FlateWorker/" + d), this._pako = null, this._pakoAction = d, this._pakoOptions = h, this.meta = {};
      }
      a.inherits(c, l), c.prototype.processChunk = function(d) {
        this.meta = d.meta, this._pako === null && this._createPako(), this._pako.push(a.transformTo(u, d.data), !1);
      }, c.prototype.flush = function() {
        l.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, c.prototype.cleanUp = function() {
        l.prototype.cleanUp.call(this), this._pako = null;
      }, c.prototype._createPako = function() {
        this._pako = new o[this._pakoAction]({
          raw: !0,
          level: this._pakoOptions.level || -1
          // default compression
        });
        var d = this;
        this._pako.onData = function(h) {
          d.push({
            data: h,
            meta: d.meta
          });
        };
      }, i.compressWorker = function(d) {
        return new c("Deflate", d);
      }, i.uncompressWorker = function() {
        return new c("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(n, r, i) {
      var s = n("../utils"), o = n("../stream/GenericWorker"), a = n("../utf8"), l = n("../crc32"), u = n("../signature"), c = function(f, g) {
        var m = "", w;
        for (w = 0; w < g; w++)
          m += String.fromCharCode(f & 255), f = f >>> 8;
        return m;
      }, d = function(f, g) {
        var m = f;
        return f || (m = g ? 16893 : 33204), (m & 65535) << 16;
      }, h = function(f) {
        return (f || 0) & 63;
      }, v = function(f, g, m, w, _, S) {
        var A = f.file, C = f.compression, k = S !== a.utf8encode, O = s.transformTo("string", S(A.name)), N = s.transformTo("string", a.utf8encode(A.name)), B = A.comment, M = s.transformTo("string", S(B)), j = s.transformTo("string", a.utf8encode(B)), q = N.length !== A.name.length, X = j.length !== B.length, z, U, H = "", re = "", fe = "", J = A.dir, le = A.date, ce = {
          crc32: 0,
          compressedSize: 0,
          uncompressedSize: 0
        };
        (!g || m) && (ce.crc32 = f.crc32, ce.compressedSize = f.compressedSize, ce.uncompressedSize = f.uncompressedSize);
        var ge = 0;
        g && (ge |= 8), !k && (q || X) && (ge |= 2048);
        var _e = 0, je = 0;
        J && (_e |= 16), _ === "UNIX" ? (je = 798, _e |= d(A.unixPermissions, J)) : (je = 20, _e |= h(A.dosPermissions)), z = le.getUTCHours(), z = z << 6, z = z | le.getUTCMinutes(), z = z << 5, z = z | le.getUTCSeconds() / 2, U = le.getUTCFullYear() - 1980, U = U << 4, U = U | le.getUTCMonth() + 1, U = U << 5, U = U | le.getUTCDate(), q && (re = // Version
        c(1, 1) + // NameCRC32
        c(l(O), 4) + // UnicodeName
        N, H += // Info-ZIP Unicode Path Extra Field
        "up" + // size
        c(re.length, 2) + // content
        re), X && (fe = // Version
        c(1, 1) + // CommentCRC32
        c(l(M), 4) + // UnicodeName
        j, H += // Info-ZIP Unicode Path Extra Field
        "uc" + // size
        c(fe.length, 2) + // content
        fe);
        var Te = "";
        Te += `
\0`, Te += c(ge, 2), Te += C.magic, Te += c(z, 2), Te += c(U, 2), Te += c(ce.crc32, 4), Te += c(ce.compressedSize, 4), Te += c(ce.uncompressedSize, 4), Te += c(O.length, 2), Te += c(H.length, 2);
        var Ze = u.LOCAL_FILE_HEADER + Te + O + H, Le = u.CENTRAL_FILE_HEADER + // version made by (00: DOS)
        c(je, 2) + // file header (common to file and central directory)
        Te + // file comment length
        c(M.length, 2) + // disk number start
        "\0\0\0\0" + // external file attributes
        c(_e, 4) + // relative offset of local header
        c(w, 4) + // file name
        O + // extra field
        H + // file comment
        M;
        return {
          fileRecord: Ze,
          dirRecord: Le
        };
      }, y = function(f, g, m, w, _) {
        var S = "", A = s.transformTo("string", _(w));
        return S = u.CENTRAL_DIRECTORY_END + // number of this disk
        "\0\0\0\0" + // total number of entries in the central directory on this disk
        c(f, 2) + // total number of entries in the central directory
        c(f, 2) + // size of the central directory   4 bytes
        c(g, 4) + // offset of start of central directory with respect to the starting disk number
        c(m, 4) + // .ZIP file comment length
        c(A.length, 2) + // .ZIP file comment
        A, S;
      }, b = function(f) {
        var g = "";
        return g = u.DATA_DESCRIPTOR + // crc-32                          4 bytes
        c(f.crc32, 4) + // compressed size                 4 bytes
        c(f.compressedSize, 4) + // uncompressed size               4 bytes
        c(f.uncompressedSize, 4), g;
      };
      function p(f, g, m, w) {
        o.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = g, this.zipPlatform = m, this.encodeFileName = w, this.streamFiles = f, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      s.inherits(p, o), p.prototype.push = function(f) {
        var g = f.meta.percent || 0, m = this.entriesCount, w = this._sources.length;
        this.accumulate ? this.contentBuffer.push(f) : (this.bytesWritten += f.data.length, o.prototype.push.call(this, {
          data: f.data,
          meta: {
            currentFile: this.currentFile,
            percent: m ? (g + 100 * (m - w - 1)) / m : 100
          }
        }));
      }, p.prototype.openedSource = function(f) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = f.file.name;
        var g = this.streamFiles && !f.file.dir;
        if (g) {
          var m = v(f, g, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({
            data: m.fileRecord,
            meta: { percent: 0 }
          });
        } else
          this.accumulate = !0;
      }, p.prototype.closedSource = function(f) {
        this.accumulate = !1;
        var g = this.streamFiles && !f.file.dir, m = v(f, g, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(m.dirRecord), g)
          this.push({
            data: b(f),
            meta: { percent: 100 }
          });
        else
          for (this.push({
            data: m.fileRecord,
            meta: { percent: 0 }
          }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, p.prototype.flush = function() {
        for (var f = this.bytesWritten, g = 0; g < this.dirRecords.length; g++)
          this.push({
            data: this.dirRecords[g],
            meta: { percent: 100 }
          });
        var m = this.bytesWritten - f, w = y(this.dirRecords.length, m, f, this.zipComment, this.encodeFileName);
        this.push({
          data: w,
          meta: { percent: 100 }
        });
      }, p.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, p.prototype.registerPrevious = function(f) {
        this._sources.push(f);
        var g = this;
        return f.on("data", function(m) {
          g.processChunk(m);
        }), f.on("end", function() {
          g.closedSource(g.previous.streamInfo), g._sources.length ? g.prepareNextSource() : g.end();
        }), f.on("error", function(m) {
          g.error(m);
        }), this;
      }, p.prototype.resume = function() {
        if (!o.prototype.resume.call(this))
          return !1;
        if (!this.previous && this._sources.length)
          return this.prepareNextSource(), !0;
        if (!this.previous && !this._sources.length && !this.generatedError)
          return this.end(), !0;
      }, p.prototype.error = function(f) {
        var g = this._sources;
        if (!o.prototype.error.call(this, f))
          return !1;
        for (var m = 0; m < g.length; m++)
          try {
            g[m].error(f);
          } catch {
          }
        return !0;
      }, p.prototype.lock = function() {
        o.prototype.lock.call(this);
        for (var f = this._sources, g = 0; g < f.length; g++)
          f[g].lock();
      }, r.exports = p;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(n, r, i) {
      var s = n("../compressions"), o = n("./ZipFileWorker"), a = function(l, u) {
        var c = l || u, d = s[c];
        if (!d)
          throw new Error(c + " is not a valid compression method !");
        return d;
      };
      i.generateWorker = function(l, u, c) {
        var d = new o(u.streamFiles, c, u.platform, u.encodeFileName), h = 0;
        try {
          l.forEach(function(v, y) {
            h++;
            var b = a(y.options.compression, u.compression), p = y.options.compressionOptions || u.compressionOptions || {}, f = y.dir, g = y.date;
            y._compressWorker(b, p).withStreamInfo("file", {
              name: v,
              dir: f,
              date: g,
              comment: y.comment || "",
              unixPermissions: y.unixPermissions,
              dosPermissions: y.dosPermissions
            }).pipe(d);
          }), d.entriesCount = h;
        } catch (v) {
          d.error(v);
        }
        return d;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(n, r, i) {
      function s() {
        if (!(this instanceof s))
          return new s();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var o = new s();
          for (var a in this)
            typeof this[a] != "function" && (o[a] = this[a]);
          return o;
        };
      }
      s.prototype = n("./object"), s.prototype.loadAsync = n("./load"), s.support = n("./support"), s.defaults = n("./defaults"), s.version = "3.10.1", s.loadAsync = function(o, a) {
        return new s().loadAsync(o, a);
      }, s.external = n("./external"), r.exports = s;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(n, r, i) {
      var s = n("./utils"), o = n("./external"), a = n("./utf8"), l = n("./zipEntries"), u = n("./stream/Crc32Probe"), c = n("./nodejsUtils");
      function d(h) {
        return new o.Promise(function(v, y) {
          var b = h.decompressed.getContentWorker().pipe(new u());
          b.on("error", function(p) {
            y(p);
          }).on("end", function() {
            b.streamInfo.crc32 !== h.decompressed.crc32 ? y(new Error("Corrupted zip : CRC32 mismatch")) : v();
          }).resume();
        });
      }
      r.exports = function(h, v) {
        var y = this;
        return v = s.extend(v || {}, {
          base64: !1,
          checkCRC32: !1,
          optimizedBinaryString: !1,
          createFolders: !1,
          decodeFileName: a.utf8decode
        }), c.isNode && c.isStream(h) ? o.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : s.prepareContent("the loaded zip file", h, !0, v.optimizedBinaryString, v.base64).then(function(b) {
          var p = new l(v);
          return p.load(b), p;
        }).then(function(p) {
          var f = [o.Promise.resolve(p)], g = p.files;
          if (v.checkCRC32)
            for (var m = 0; m < g.length; m++)
              f.push(d(g[m]));
          return o.Promise.all(f);
        }).then(function(p) {
          for (var f = p.shift(), g = f.files, m = 0; m < g.length; m++) {
            var w = g[m], _ = w.fileNameStr, S = s.resolve(w.fileNameStr);
            y.file(S, w.decompressed, {
              binary: !0,
              optimizedBinaryString: !0,
              date: w.date,
              dir: w.dir,
              comment: w.fileCommentStr.length ? w.fileCommentStr : null,
              unixPermissions: w.unixPermissions,
              dosPermissions: w.dosPermissions,
              createFolders: v.createFolders
            }), w.dir || (y.file(S).unsafeOriginalName = _);
          }
          return f.zipComment.length && (y.comment = f.zipComment), y;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(n, r, i) {
      var s = n("../utils"), o = n("../stream/GenericWorker");
      function a(l, u) {
        o.call(this, "Nodejs stream input adapter for " + l), this._upstreamEnded = !1, this._bindStream(u);
      }
      s.inherits(a, o), a.prototype._bindStream = function(l) {
        var u = this;
        this._stream = l, l.pause(), l.on("data", function(c) {
          u.push({
            data: c,
            meta: {
              percent: 0
            }
          });
        }).on("error", function(c) {
          u.isPaused ? this.generatedError = c : u.error(c);
        }).on("end", function() {
          u.isPaused ? u._upstreamEnded = !0 : u.end();
        });
      }, a.prototype.pause = function() {
        return o.prototype.pause.call(this) ? (this._stream.pause(), !0) : !1;
      }, a.prototype.resume = function() {
        return o.prototype.resume.call(this) ? (this._upstreamEnded ? this.end() : this._stream.resume(), !0) : !1;
      }, r.exports = a;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(n, r, i) {
      var s = n("readable-stream").Readable, o = n("../utils");
      o.inherits(a, s);
      function a(l, u, c) {
        s.call(this, u), this._helper = l;
        var d = this;
        l.on("data", function(h, v) {
          d.push(h) || d._helper.pause(), c && c(v);
        }).on("error", function(h) {
          d.emit("error", h);
        }).on("end", function() {
          d.push(null);
        });
      }
      a.prototype._read = function() {
        this._helper.resume();
      }, r.exports = a;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(n, r, i) {
      r.exports = {
        /**
         * True if this is running in Nodejs, will be undefined in a browser.
         * In a browser, browserify won't include this file and the whole module
         * will be resolved an empty object.
         */
        isNode: typeof Buffer < "u",
        /**
         * Create a new nodejs Buffer from an existing content.
         * @param {Object} data the data to pass to the constructor.
         * @param {String} encoding the encoding to use.
         * @return {Buffer} a new Buffer.
         */
        newBufferFrom: function(s, o) {
          if (Buffer.from && Buffer.from !== Uint8Array.from)
            return Buffer.from(s, o);
          if (typeof s == "number")
            throw new Error('The "data" argument must not be a number');
          return new Buffer(s, o);
        },
        /**
         * Create a new nodejs Buffer with the specified size.
         * @param {Integer} size the size of the buffer.
         * @return {Buffer} a new Buffer.
         */
        allocBuffer: function(s) {
          if (Buffer.alloc)
            return Buffer.alloc(s);
          var o = new Buffer(s);
          return o.fill(0), o;
        },
        /**
         * Find out if an object is a Buffer.
         * @param {Object} b the object to test.
         * @return {Boolean} true if the object is a Buffer, false otherwise.
         */
        isBuffer: function(s) {
          return Buffer.isBuffer(s);
        },
        isStream: function(s) {
          return s && typeof s.on == "function" && typeof s.pause == "function" && typeof s.resume == "function";
        }
      };
    }, {}], 15: [function(n, r, i) {
      var s = n("./utf8"), o = n("./utils"), a = n("./stream/GenericWorker"), l = n("./stream/StreamHelper"), u = n("./defaults"), c = n("./compressedObject"), d = n("./zipObject"), h = n("./generate"), v = n("./nodejsUtils"), y = n("./nodejs/NodejsStreamInputAdapter"), b = function(_, S, A) {
        var C = o.getTypeOf(S), k, O = o.extend(A || {}, u);
        O.date = O.date || /* @__PURE__ */ new Date(), O.compression !== null && (O.compression = O.compression.toUpperCase()), typeof O.unixPermissions == "string" && (O.unixPermissions = parseInt(O.unixPermissions, 8)), O.unixPermissions && O.unixPermissions & 16384 && (O.dir = !0), O.dosPermissions && O.dosPermissions & 16 && (O.dir = !0), O.dir && (_ = f(_)), O.createFolders && (k = p(_)) && g.call(this, k, !0);
        var N = C === "string" && O.binary === !1 && O.base64 === !1;
        (!A || typeof A.binary > "u") && (O.binary = !N);
        var B = S instanceof c && S.uncompressedSize === 0;
        (B || O.dir || !S || S.length === 0) && (O.base64 = !1, O.binary = !0, S = "", O.compression = "STORE", C = "string");
        var M = null;
        S instanceof c || S instanceof a ? M = S : v.isNode && v.isStream(S) ? M = new y(_, S) : M = o.prepareContent(_, S, O.binary, O.optimizedBinaryString, O.base64);
        var j = new d(_, M, O);
        this.files[_] = j;
      }, p = function(_) {
        _.slice(-1) === "/" && (_ = _.substring(0, _.length - 1));
        var S = _.lastIndexOf("/");
        return S > 0 ? _.substring(0, S) : "";
      }, f = function(_) {
        return _.slice(-1) !== "/" && (_ += "/"), _;
      }, g = function(_, S) {
        return S = typeof S < "u" ? S : u.createFolders, _ = f(_), this.files[_] || b.call(this, _, null, {
          dir: !0,
          createFolders: S
        }), this.files[_];
      };
      function m(_) {
        return Object.prototype.toString.call(_) === "[object RegExp]";
      }
      var w = {
        /**
         * @see loadAsync
         */
        load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        },
        /**
         * Call a callback function for each entry at this folder level.
         * @param {Function} cb the callback function:
         * function (relativePath, file) {...}
         * It takes 2 arguments : the relative path and the file.
         */
        forEach: function(_) {
          var S, A, C;
          for (S in this.files)
            C = this.files[S], A = S.slice(this.root.length, S.length), A && S.slice(0, this.root.length) === this.root && _(A, C);
        },
        /**
         * Filter nested files/folders with the specified function.
         * @param {Function} search the predicate to use :
         * function (relativePath, file) {...}
         * It takes 2 arguments : the relative path and the file.
         * @return {Array} An array of matching elements.
         */
        filter: function(_) {
          var S = [];
          return this.forEach(function(A, C) {
            _(A, C) && S.push(C);
          }), S;
        },
        /**
         * Add a file to the zip file, or search a file.
         * @param   {string|RegExp} name The name of the file to add (if data is defined),
         * the name of the file to find (if no data) or a regex to match files.
         * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
         * @param   {Object} o     File options
         * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
         * a file (when searching by string) or an array of files (when searching by regex).
         */
        file: function(_, S, A) {
          if (arguments.length === 1)
            if (m(_)) {
              var C = _;
              return this.filter(function(O, N) {
                return !N.dir && C.test(O);
              });
            } else {
              var k = this.files[this.root + _];
              return k && !k.dir ? k : null;
            }
          else
            _ = this.root + _, b.call(this, _, S, A);
          return this;
        },
        /**
         * Add a directory to the zip file, or search.
         * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
         * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
         */
        folder: function(_) {
          if (!_)
            return this;
          if (m(_))
            return this.filter(function(k, O) {
              return O.dir && _.test(k);
            });
          var S = this.root + _, A = g.call(this, S), C = this.clone();
          return C.root = A.name, C;
        },
        /**
         * Delete a file, or a directory and all sub-files, from the zip
         * @param {string} name the name of the file to delete
         * @return {JSZip} this JSZip object
         */
        remove: function(_) {
          _ = this.root + _;
          var S = this.files[_];
          if (S || (_.slice(-1) !== "/" && (_ += "/"), S = this.files[_]), S && !S.dir)
            delete this.files[_];
          else
            for (var A = this.filter(function(k, O) {
              return O.name.slice(0, _.length) === _;
            }), C = 0; C < A.length; C++)
              delete this.files[A[C].name];
          return this;
        },
        /**
         * @deprecated This method has been removed in JSZip 3.0, please check the upgrade guide.
         */
        generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        },
        /**
         * Generate the complete zip file as an internal stream.
         * @param {Object} options the options to generate the zip file :
         * - compression, "STORE" by default.
         * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
         * @return {StreamHelper} the streamed zip file.
         */
        generateInternalStream: function(_) {
          var S, A = {};
          try {
            if (A = o.extend(_ || {}, {
              streamFiles: !1,
              compression: "STORE",
              compressionOptions: null,
              type: "",
              platform: "DOS",
              comment: null,
              mimeType: "application/zip",
              encodeFileName: s.utf8encode
            }), A.type = A.type.toLowerCase(), A.compression = A.compression.toUpperCase(), A.type === "binarystring" && (A.type = "string"), !A.type)
              throw new Error("No output type specified.");
            o.checkSupport(A.type), (A.platform === "darwin" || A.platform === "freebsd" || A.platform === "linux" || A.platform === "sunos") && (A.platform = "UNIX"), A.platform === "win32" && (A.platform = "DOS");
            var C = A.comment || this.comment || "";
            S = h.generateWorker(this, A, C);
          } catch (k) {
            S = new a("error"), S.error(k);
          }
          return new l(S, A.type || "string", A.mimeType);
        },
        /**
         * Generate the complete zip file asynchronously.
         * @see generateInternalStream
         */
        generateAsync: function(_, S) {
          return this.generateInternalStream(_).accumulate(S);
        },
        /**
         * Generate the complete zip file asynchronously.
         * @see generateInternalStream
         */
        generateNodeStream: function(_, S) {
          return _ = _ || {}, _.type || (_.type = "nodebuffer"), this.generateInternalStream(_).toNodejsStream(S);
        }
      };
      r.exports = w;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(n, r, i) {
      r.exports = n("stream");
    }, { stream: void 0 }], 17: [function(n, r, i) {
      var s = n("./DataReader"), o = n("../utils");
      function a(l) {
        s.call(this, l);
        for (var u = 0; u < this.data.length; u++)
          l[u] = l[u] & 255;
      }
      o.inherits(a, s), a.prototype.byteAt = function(l) {
        return this.data[this.zero + l];
      }, a.prototype.lastIndexOfSignature = function(l) {
        for (var u = l.charCodeAt(0), c = l.charCodeAt(1), d = l.charCodeAt(2), h = l.charCodeAt(3), v = this.length - 4; v >= 0; --v)
          if (this.data[v] === u && this.data[v + 1] === c && this.data[v + 2] === d && this.data[v + 3] === h)
            return v - this.zero;
        return -1;
      }, a.prototype.readAndCheckSignature = function(l) {
        var u = l.charCodeAt(0), c = l.charCodeAt(1), d = l.charCodeAt(2), h = l.charCodeAt(3), v = this.readData(4);
        return u === v[0] && c === v[1] && d === v[2] && h === v[3];
      }, a.prototype.readData = function(l) {
        if (this.checkOffset(l), l === 0)
          return [];
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, u;
      }, r.exports = a;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(n, r, i) {
      var s = n("../utils");
      function o(a) {
        this.data = a, this.length = a.length, this.index = 0, this.zero = 0;
      }
      o.prototype = {
        /**
         * Check that the offset will not go too far.
         * @param {string} offset the additional offset to check.
         * @throws {Error} an Error if the offset is out of bounds.
         */
        checkOffset: function(a) {
          this.checkIndex(this.index + a);
        },
        /**
         * Check that the specified index will not be too far.
         * @param {string} newIndex the index to check.
         * @throws {Error} an Error if the index is out of bounds.
         */
        checkIndex: function(a) {
          if (this.length < this.zero + a || a < 0)
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + a + "). Corrupted zip ?");
        },
        /**
         * Change the index.
         * @param {number} newIndex The new index.
         * @throws {Error} if the new index is out of the data.
         */
        setIndex: function(a) {
          this.checkIndex(a), this.index = a;
        },
        /**
         * Skip the next n bytes.
         * @param {number} n the number of bytes to skip.
         * @throws {Error} if the new index is out of the data.
         */
        skip: function(a) {
          this.setIndex(this.index + a);
        },
        /**
         * Get the byte at the specified index.
         * @param {number} i the index to use.
         * @return {number} a byte.
         */
        byteAt: function() {
        },
        /**
         * Get the next number with a given byte size.
         * @param {number} size the number of bytes to read.
         * @return {number} the corresponding number.
         */
        readInt: function(a) {
          var l = 0, u;
          for (this.checkOffset(a), u = this.index + a - 1; u >= this.index; u--)
            l = (l << 8) + this.byteAt(u);
          return this.index += a, l;
        },
        /**
         * Get the next string with a given byte size.
         * @param {number} size the number of bytes to read.
         * @return {string} the corresponding string.
         */
        readString: function(a) {
          return s.transformTo("string", this.readData(a));
        },
        /**
         * Get raw data without conversion, <size> bytes.
         * @param {number} size the number of bytes to read.
         * @return {Object} the raw data, implementation specific.
         */
        readData: function() {
        },
        /**
         * Find the last occurrence of a zip signature (4 bytes).
         * @param {string} sig the signature to find.
         * @return {number} the index of the last occurrence, -1 if not found.
         */
        lastIndexOfSignature: function() {
        },
        /**
         * Read the signature (4 bytes) at the current position and compare it with sig.
         * @param {string} sig the expected signature
         * @return {boolean} true if the signature matches, false otherwise.
         */
        readAndCheckSignature: function() {
        },
        /**
         * Get the next date.
         * @return {Date} the date.
         */
        readDate: function() {
          var a = this.readInt(4);
          return new Date(Date.UTC(
            (a >> 25 & 127) + 1980,
            // year
            (a >> 21 & 15) - 1,
            // month
            a >> 16 & 31,
            // day
            a >> 11 & 31,
            // hour
            a >> 5 & 63,
            // minute
            (a & 31) << 1
          ));
        }
      }, r.exports = o;
    }, { "../utils": 32 }], 19: [function(n, r, i) {
      var s = n("./Uint8ArrayReader"), o = n("../utils");
      function a(l) {
        s.call(this, l);
      }
      o.inherits(a, s), a.prototype.readData = function(l) {
        this.checkOffset(l);
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, u;
      }, r.exports = a;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(n, r, i) {
      var s = n("./DataReader"), o = n("../utils");
      function a(l) {
        s.call(this, l);
      }
      o.inherits(a, s), a.prototype.byteAt = function(l) {
        return this.data.charCodeAt(this.zero + l);
      }, a.prototype.lastIndexOfSignature = function(l) {
        return this.data.lastIndexOf(l) - this.zero;
      }, a.prototype.readAndCheckSignature = function(l) {
        var u = this.readData(4);
        return l === u;
      }, a.prototype.readData = function(l) {
        this.checkOffset(l);
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, u;
      }, r.exports = a;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(n, r, i) {
      var s = n("./ArrayReader"), o = n("../utils");
      function a(l) {
        s.call(this, l);
      }
      o.inherits(a, s), a.prototype.readData = function(l) {
        if (this.checkOffset(l), l === 0)
          return new Uint8Array(0);
        var u = this.data.subarray(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, u;
      }, r.exports = a;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(n, r, i) {
      var s = n("../utils"), o = n("../support"), a = n("./ArrayReader"), l = n("./StringReader"), u = n("./NodeBufferReader"), c = n("./Uint8ArrayReader");
      r.exports = function(d) {
        var h = s.getTypeOf(d);
        return s.checkSupport(h), h === "string" && !o.uint8array ? new l(d) : h === "nodebuffer" ? new u(d) : o.uint8array ? new c(s.transformTo("uint8array", d)) : new a(s.transformTo("array", d));
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(n, r, i) {
      i.LOCAL_FILE_HEADER = "PK", i.CENTRAL_FILE_HEADER = "PK", i.CENTRAL_DIRECTORY_END = "PK", i.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", i.ZIP64_CENTRAL_DIRECTORY_END = "PK", i.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(n, r, i) {
      var s = n("./GenericWorker"), o = n("../utils");
      function a(l) {
        s.call(this, "ConvertWorker to " + l), this.destType = l;
      }
      o.inherits(a, s), a.prototype.processChunk = function(l) {
        this.push({
          data: o.transformTo(this.destType, l.data),
          meta: l.meta
        });
      }, r.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(n, r, i) {
      var s = n("./GenericWorker"), o = n("../crc32"), a = n("../utils");
      function l() {
        s.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      a.inherits(l, s), l.prototype.processChunk = function(u) {
        this.streamInfo.crc32 = o(u.data, this.streamInfo.crc32 || 0), this.push(u);
      }, r.exports = l;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(n, r, i) {
      var s = n("../utils"), o = n("./GenericWorker");
      function a(l) {
        o.call(this, "DataLengthProbe for " + l), this.propName = l, this.withStreamInfo(l, 0);
      }
      s.inherits(a, o), a.prototype.processChunk = function(l) {
        if (l) {
          var u = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = u + l.data.length;
        }
        o.prototype.processChunk.call(this, l);
      }, r.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(n, r, i) {
      var s = n("../utils"), o = n("./GenericWorker"), a = 16 * 1024;
      function l(u) {
        o.call(this, "DataWorker");
        var c = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, u.then(function(d) {
          c.dataIsReady = !0, c.data = d, c.max = d && d.length || 0, c.type = s.getTypeOf(d), c.isPaused || c._tickAndRepeat();
        }, function(d) {
          c.error(d);
        });
      }
      s.inherits(l, o), l.prototype.cleanUp = function() {
        o.prototype.cleanUp.call(this), this.data = null;
      }, l.prototype.resume = function() {
        return o.prototype.resume.call(this) ? (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, s.delay(this._tickAndRepeat, [], this)), !0) : !1;
      }, l.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, !(this.isPaused || this.isFinished) && (this._tick(), this.isFinished || (s.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, l.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return !1;
        var u = a, c = null, d = Math.min(this.max, this.index + u);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            c = this.data.substring(this.index, d);
            break;
          case "uint8array":
            c = this.data.subarray(this.index, d);
            break;
          case "array":
          case "nodebuffer":
            c = this.data.slice(this.index, d);
            break;
        }
        return this.index = d, this.push({
          data: c,
          meta: {
            percent: this.max ? this.index / this.max * 100 : 0
          }
        });
      }, r.exports = l;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(n, r, i) {
      function s(o) {
        this.name = o || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = {
          data: [],
          end: [],
          error: []
        }, this.previous = null;
      }
      s.prototype = {
        /**
         * Push a chunk to the next workers.
         * @param {Object} chunk the chunk to push
         */
        push: function(o) {
          this.emit("data", o);
        },
        /**
         * End the stream.
         * @return {Boolean} true if this call ended the worker, false otherwise.
         */
        end: function() {
          if (this.isFinished)
            return !1;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = !0;
          } catch (o) {
            this.emit("error", o);
          }
          return !0;
        },
        /**
         * End the stream with an error.
         * @param {Error} e the error which caused the premature end.
         * @return {Boolean} true if this call ended the worker with an error, false otherwise.
         */
        error: function(o) {
          return this.isFinished ? !1 : (this.isPaused ? this.generatedError = o : (this.isFinished = !0, this.emit("error", o), this.previous && this.previous.error(o), this.cleanUp()), !0);
        },
        /**
         * Add a callback on an event.
         * @param {String} name the name of the event (data, end, error)
         * @param {Function} listener the function to call when the event is triggered
         * @return {GenericWorker} the current object for chainability
         */
        on: function(o, a) {
          return this._listeners[o].push(a), this;
        },
        /**
         * Clean any references when a worker is ending.
         */
        cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        },
        /**
         * Trigger an event. This will call registered callback with the provided arg.
         * @param {String} name the name of the event (data, end, error)
         * @param {Object} arg the argument to call the callback with.
         */
        emit: function(o, a) {
          if (this._listeners[o])
            for (var l = 0; l < this._listeners[o].length; l++)
              this._listeners[o][l].call(this, a);
        },
        /**
         * Chain a worker with an other.
         * @param {Worker} next the worker receiving events from the current one.
         * @return {worker} the next worker for chainability
         */
        pipe: function(o) {
          return o.registerPrevious(this);
        },
        /**
         * Same as `pipe` in the other direction.
         * Using an API with `pipe(next)` is very easy.
         * Implementing the API with the point of view of the next one registering
         * a source is easier, see the ZipFileWorker.
         * @param {Worker} previous the previous worker, sending events to this one
         * @return {Worker} the current worker for chainability
         */
        registerPrevious: function(o) {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = o.streamInfo, this.mergeStreamInfo(), this.previous = o;
          var a = this;
          return o.on("data", function(l) {
            a.processChunk(l);
          }), o.on("end", function() {
            a.end();
          }), o.on("error", function(l) {
            a.error(l);
          }), this;
        },
        /**
         * Pause the stream so it doesn't send events anymore.
         * @return {Boolean} true if this call paused the worker, false otherwise.
         */
        pause: function() {
          return this.isPaused || this.isFinished ? !1 : (this.isPaused = !0, this.previous && this.previous.pause(), !0);
        },
        /**
         * Resume a paused stream.
         * @return {Boolean} true if this call resumed the worker, false otherwise.
         */
        resume: function() {
          if (!this.isPaused || this.isFinished)
            return !1;
          this.isPaused = !1;
          var o = !1;
          return this.generatedError && (this.error(this.generatedError), o = !0), this.previous && this.previous.resume(), !o;
        },
        /**
         * Flush any remaining bytes as the stream is ending.
         */
        flush: function() {
        },
        /**
         * Process a chunk. This is usually the method overridden.
         * @param {Object} chunk the chunk to process.
         */
        processChunk: function(o) {
          this.push(o);
        },
        /**
         * Add a key/value to be added in the workers chain streamInfo once activated.
         * @param {String} key the key to use
         * @param {Object} value the associated value
         * @return {Worker} the current worker for chainability
         */
        withStreamInfo: function(o, a) {
          return this.extraStreamInfo[o] = a, this.mergeStreamInfo(), this;
        },
        /**
         * Merge this worker's streamInfo into the chain's streamInfo.
         */
        mergeStreamInfo: function() {
          for (var o in this.extraStreamInfo)
            Object.prototype.hasOwnProperty.call(this.extraStreamInfo, o) && (this.streamInfo[o] = this.extraStreamInfo[o]);
        },
        /**
         * Lock the stream to prevent further updates on the workers chain.
         * After calling this method, all calls to pipe will fail.
         */
        lock: function() {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = !0, this.previous && this.previous.lock();
        },
        /**
         *
         * Pretty print the workers chain.
         */
        toString: function() {
          var o = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + o : o;
        }
      }, r.exports = s;
    }, {}], 29: [function(n, r, i) {
      var s = n("../utils"), o = n("./ConvertWorker"), a = n("./GenericWorker"), l = n("../base64"), u = n("../support"), c = n("../external"), d = null;
      if (u.nodestream)
        try {
          d = n("../nodejs/NodejsStreamOutputAdapter");
        } catch {
        }
      function h(p, f, g) {
        switch (p) {
          case "blob":
            return s.newBlob(s.transformTo("arraybuffer", f), g);
          case "base64":
            return l.encode(f);
          default:
            return s.transformTo(p, f);
        }
      }
      function v(p, f) {
        var g, m = 0, w = null, _ = 0;
        for (g = 0; g < f.length; g++)
          _ += f[g].length;
        switch (p) {
          case "string":
            return f.join("");
          case "array":
            return Array.prototype.concat.apply([], f);
          case "uint8array":
            for (w = new Uint8Array(_), g = 0; g < f.length; g++)
              w.set(f[g], m), m += f[g].length;
            return w;
          case "nodebuffer":
            return Buffer.concat(f);
          default:
            throw new Error("concat : unsupported type '" + p + "'");
        }
      }
      function y(p, f) {
        return new c.Promise(function(g, m) {
          var w = [], _ = p._internalType, S = p._outputType, A = p._mimeType;
          p.on("data", function(C, k) {
            w.push(C), f && f(k);
          }).on("error", function(C) {
            w = [], m(C);
          }).on("end", function() {
            try {
              var C = h(S, v(_, w), A);
              g(C);
            } catch (k) {
              m(k);
            }
            w = [];
          }).resume();
        });
      }
      function b(p, f, g) {
        var m = f;
        switch (f) {
          case "blob":
          case "arraybuffer":
            m = "uint8array";
            break;
          case "base64":
            m = "string";
            break;
        }
        try {
          this._internalType = m, this._outputType = f, this._mimeType = g, s.checkSupport(m), this._worker = p.pipe(new o(m)), p.lock();
        } catch (w) {
          this._worker = new a("error"), this._worker.error(w);
        }
      }
      b.prototype = {
        /**
         * Listen a StreamHelper, accumulate its content and concatenate it into a
         * complete block.
         * @param {Function} updateCb the update callback.
         * @return Promise the promise for the accumulation.
         */
        accumulate: function(p) {
          return y(this, p);
        },
        /**
         * Add a listener on an event triggered on a stream.
         * @param {String} evt the name of the event
         * @param {Function} fn the listener
         * @return {StreamHelper} the current helper.
         */
        on: function(p, f) {
          var g = this;
          return p === "data" ? this._worker.on(p, function(m) {
            f.call(g, m.data, m.meta);
          }) : this._worker.on(p, function() {
            s.delay(f, arguments, g);
          }), this;
        },
        /**
         * Resume the flow of chunks.
         * @return {StreamHelper} the current helper.
         */
        resume: function() {
          return s.delay(this._worker.resume, [], this._worker), this;
        },
        /**
         * Pause the flow of chunks.
         * @return {StreamHelper} the current helper.
         */
        pause: function() {
          return this._worker.pause(), this;
        },
        /**
         * Return a nodejs stream for this helper.
         * @param {Function} updateCb the update callback.
         * @return {NodejsStreamOutputAdapter} the nodejs stream.
         */
        toNodejsStream: function(p) {
          if (s.checkSupport("nodestream"), this._outputType !== "nodebuffer")
            throw new Error(this._outputType + " is not supported by this method");
          return new d(this, {
            objectMode: this._outputType !== "nodebuffer"
          }, p);
        }
      }, r.exports = b;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(n, r, i) {
      if (i.base64 = !0, i.array = !0, i.string = !0, i.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", i.nodebuffer = typeof Buffer < "u", i.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u")
        i.blob = !1;
      else {
        var s = new ArrayBuffer(0);
        try {
          i.blob = new Blob([s], {
            type: "application/zip"
          }).size === 0;
        } catch {
          try {
            var o = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder, a = new o();
            a.append(s), i.blob = a.getBlob("application/zip").size === 0;
          } catch {
            i.blob = !1;
          }
        }
      }
      try {
        i.nodestream = !!n("readable-stream").Readable;
      } catch {
        i.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(n, r, i) {
      for (var s = n("./utils"), o = n("./support"), a = n("./nodejsUtils"), l = n("./stream/GenericWorker"), u = new Array(256), c = 0; c < 256; c++)
        u[c] = c >= 252 ? 6 : c >= 248 ? 5 : c >= 240 ? 4 : c >= 224 ? 3 : c >= 192 ? 2 : 1;
      u[254] = u[254] = 1;
      var d = function(p) {
        var f, g, m, w, _, S = p.length, A = 0;
        for (w = 0; w < S; w++)
          g = p.charCodeAt(w), (g & 64512) === 55296 && w + 1 < S && (m = p.charCodeAt(w + 1), (m & 64512) === 56320 && (g = 65536 + (g - 55296 << 10) + (m - 56320), w++)), A += g < 128 ? 1 : g < 2048 ? 2 : g < 65536 ? 3 : 4;
        for (o.uint8array ? f = new Uint8Array(A) : f = new Array(A), _ = 0, w = 0; _ < A; w++)
          g = p.charCodeAt(w), (g & 64512) === 55296 && w + 1 < S && (m = p.charCodeAt(w + 1), (m & 64512) === 56320 && (g = 65536 + (g - 55296 << 10) + (m - 56320), w++)), g < 128 ? f[_++] = g : g < 2048 ? (f[_++] = 192 | g >>> 6, f[_++] = 128 | g & 63) : g < 65536 ? (f[_++] = 224 | g >>> 12, f[_++] = 128 | g >>> 6 & 63, f[_++] = 128 | g & 63) : (f[_++] = 240 | g >>> 18, f[_++] = 128 | g >>> 12 & 63, f[_++] = 128 | g >>> 6 & 63, f[_++] = 128 | g & 63);
        return f;
      }, h = function(p, f) {
        var g;
        for (f = f || p.length, f > p.length && (f = p.length), g = f - 1; g >= 0 && (p[g] & 192) === 128; )
          g--;
        return g < 0 || g === 0 ? f : g + u[p[g]] > f ? g : f;
      }, v = function(p) {
        var f, g, m, w, _ = p.length, S = new Array(_ * 2);
        for (g = 0, f = 0; f < _; ) {
          if (m = p[f++], m < 128) {
            S[g++] = m;
            continue;
          }
          if (w = u[m], w > 4) {
            S[g++] = 65533, f += w - 1;
            continue;
          }
          for (m &= w === 2 ? 31 : w === 3 ? 15 : 7; w > 1 && f < _; )
            m = m << 6 | p[f++] & 63, w--;
          if (w > 1) {
            S[g++] = 65533;
            continue;
          }
          m < 65536 ? S[g++] = m : (m -= 65536, S[g++] = 55296 | m >> 10 & 1023, S[g++] = 56320 | m & 1023);
        }
        return S.length !== g && (S.subarray ? S = S.subarray(0, g) : S.length = g), s.applyFromCharCode(S);
      };
      i.utf8encode = function(f) {
        return o.nodebuffer ? a.newBufferFrom(f, "utf-8") : d(f);
      }, i.utf8decode = function(f) {
        return o.nodebuffer ? s.transformTo("nodebuffer", f).toString("utf-8") : (f = s.transformTo(o.uint8array ? "uint8array" : "array", f), v(f));
      };
      function y() {
        l.call(this, "utf-8 decode"), this.leftOver = null;
      }
      s.inherits(y, l), y.prototype.processChunk = function(p) {
        var f = s.transformTo(o.uint8array ? "uint8array" : "array", p.data);
        if (this.leftOver && this.leftOver.length) {
          if (o.uint8array) {
            var g = f;
            f = new Uint8Array(g.length + this.leftOver.length), f.set(this.leftOver, 0), f.set(g, this.leftOver.length);
          } else
            f = this.leftOver.concat(f);
          this.leftOver = null;
        }
        var m = h(f), w = f;
        m !== f.length && (o.uint8array ? (w = f.subarray(0, m), this.leftOver = f.subarray(m, f.length)) : (w = f.slice(0, m), this.leftOver = f.slice(m, f.length))), this.push({
          data: i.utf8decode(w),
          meta: p.meta
        });
      }, y.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({
          data: i.utf8decode(this.leftOver),
          meta: {}
        }), this.leftOver = null);
      }, i.Utf8DecodeWorker = y;
      function b() {
        l.call(this, "utf-8 encode");
      }
      s.inherits(b, l), b.prototype.processChunk = function(p) {
        this.push({
          data: i.utf8encode(p.data),
          meta: p.meta
        });
      }, i.Utf8EncodeWorker = b;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(n, r, i) {
      var s = n("./support"), o = n("./base64"), a = n("./nodejsUtils"), l = n("./external");
      n("setimmediate");
      function u(p) {
        var f = null;
        return s.uint8array ? f = new Uint8Array(p.length) : f = new Array(p.length), d(p, f);
      }
      i.newBlob = function(p, f) {
        i.checkSupport("blob");
        try {
          return new Blob([p], {
            type: f
          });
        } catch {
          try {
            var g = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder, m = new g();
            return m.append(p), m.getBlob(f);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      function c(p) {
        return p;
      }
      function d(p, f) {
        for (var g = 0; g < p.length; ++g)
          f[g] = p.charCodeAt(g) & 255;
        return f;
      }
      var h = {
        /**
         * Transform an array of int into a string, chunk by chunk.
         * See the performances notes on arrayLikeToString.
         * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
         * @param {String} type the type of the array.
         * @param {Integer} chunk the chunk size.
         * @return {String} the resulting string.
         * @throws Error if the chunk is too big for the stack.
         */
        stringifyByChunk: function(p, f, g) {
          var m = [], w = 0, _ = p.length;
          if (_ <= g)
            return String.fromCharCode.apply(null, p);
          for (; w < _; )
            f === "array" || f === "nodebuffer" ? m.push(String.fromCharCode.apply(null, p.slice(w, Math.min(w + g, _)))) : m.push(String.fromCharCode.apply(null, p.subarray(w, Math.min(w + g, _)))), w += g;
          return m.join("");
        },
        /**
         * Call String.fromCharCode on every item in the array.
         * This is the naive implementation, which generate A LOT of intermediate string.
         * This should be used when everything else fail.
         * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
         * @return {String} the result.
         */
        stringifyByChar: function(p) {
          for (var f = "", g = 0; g < p.length; g++)
            f += String.fromCharCode(p[g]);
          return f;
        },
        applyCanBeUsed: {
          /**
           * true if the browser accepts to use String.fromCharCode on Uint8Array
           */
          uint8array: function() {
            try {
              return s.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
            } catch {
              return !1;
            }
          }(),
          /**
           * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
           */
          nodebuffer: function() {
            try {
              return s.nodebuffer && String.fromCharCode.apply(null, a.allocBuffer(1)).length === 1;
            } catch {
              return !1;
            }
          }()
        }
      };
      function v(p) {
        var f = 65536, g = i.getTypeOf(p), m = !0;
        if (g === "uint8array" ? m = h.applyCanBeUsed.uint8array : g === "nodebuffer" && (m = h.applyCanBeUsed.nodebuffer), m)
          for (; f > 1; )
            try {
              return h.stringifyByChunk(p, g, f);
            } catch {
              f = Math.floor(f / 2);
            }
        return h.stringifyByChar(p);
      }
      i.applyFromCharCode = v;
      function y(p, f) {
        for (var g = 0; g < p.length; g++)
          f[g] = p[g];
        return f;
      }
      var b = {};
      b.string = {
        string: c,
        array: function(p) {
          return d(p, new Array(p.length));
        },
        arraybuffer: function(p) {
          return b.string.uint8array(p).buffer;
        },
        uint8array: function(p) {
          return d(p, new Uint8Array(p.length));
        },
        nodebuffer: function(p) {
          return d(p, a.allocBuffer(p.length));
        }
      }, b.array = {
        string: v,
        array: c,
        arraybuffer: function(p) {
          return new Uint8Array(p).buffer;
        },
        uint8array: function(p) {
          return new Uint8Array(p);
        },
        nodebuffer: function(p) {
          return a.newBufferFrom(p);
        }
      }, b.arraybuffer = {
        string: function(p) {
          return v(new Uint8Array(p));
        },
        array: function(p) {
          return y(new Uint8Array(p), new Array(p.byteLength));
        },
        arraybuffer: c,
        uint8array: function(p) {
          return new Uint8Array(p);
        },
        nodebuffer: function(p) {
          return a.newBufferFrom(new Uint8Array(p));
        }
      }, b.uint8array = {
        string: v,
        array: function(p) {
          return y(p, new Array(p.length));
        },
        arraybuffer: function(p) {
          return p.buffer;
        },
        uint8array: c,
        nodebuffer: function(p) {
          return a.newBufferFrom(p);
        }
      }, b.nodebuffer = {
        string: v,
        array: function(p) {
          return y(p, new Array(p.length));
        },
        arraybuffer: function(p) {
          return b.nodebuffer.uint8array(p).buffer;
        },
        uint8array: function(p) {
          return y(p, new Uint8Array(p.length));
        },
        nodebuffer: c
      }, i.transformTo = function(p, f) {
        if (f || (f = ""), !p)
          return f;
        i.checkSupport(p);
        var g = i.getTypeOf(f), m = b[g][p](f);
        return m;
      }, i.resolve = function(p) {
        for (var f = p.split("/"), g = [], m = 0; m < f.length; m++) {
          var w = f[m];
          w === "." || w === "" && m !== 0 && m !== f.length - 1 || (w === ".." ? g.pop() : g.push(w));
        }
        return g.join("/");
      }, i.getTypeOf = function(p) {
        if (typeof p == "string")
          return "string";
        if (Object.prototype.toString.call(p) === "[object Array]")
          return "array";
        if (s.nodebuffer && a.isBuffer(p))
          return "nodebuffer";
        if (s.uint8array && p instanceof Uint8Array)
          return "uint8array";
        if (s.arraybuffer && p instanceof ArrayBuffer)
          return "arraybuffer";
      }, i.checkSupport = function(p) {
        var f = s[p.toLowerCase()];
        if (!f)
          throw new Error(p + " is not supported by this platform");
      }, i.MAX_VALUE_16BITS = 65535, i.MAX_VALUE_32BITS = -1, i.pretty = function(p) {
        var f = "", g, m;
        for (m = 0; m < (p || "").length; m++)
          g = p.charCodeAt(m), f += "\\x" + (g < 16 ? "0" : "") + g.toString(16).toUpperCase();
        return f;
      }, i.delay = function(p, f, g) {
        setImmediate(function() {
          p.apply(g || null, f || []);
        });
      }, i.inherits = function(p, f) {
        var g = function() {
        };
        g.prototype = f.prototype, p.prototype = new g();
      }, i.extend = function() {
        var p = {}, f, g;
        for (f = 0; f < arguments.length; f++)
          for (g in arguments[f])
            Object.prototype.hasOwnProperty.call(arguments[f], g) && typeof p[g] > "u" && (p[g] = arguments[f][g]);
        return p;
      }, i.prepareContent = function(p, f, g, m, w) {
        var _ = l.Promise.resolve(f).then(function(S) {
          var A = s.blob && (S instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(S)) !== -1);
          return A && typeof FileReader < "u" ? new l.Promise(function(C, k) {
            var O = new FileReader();
            O.onload = function(N) {
              C(N.target.result);
            }, O.onerror = function(N) {
              k(N.target.error);
            }, O.readAsArrayBuffer(S);
          }) : S;
        });
        return _.then(function(S) {
          var A = i.getTypeOf(S);
          return A ? (A === "arraybuffer" ? S = i.transformTo("uint8array", S) : A === "string" && (w ? S = o.decode(S) : g && m !== !0 && (S = u(S))), S) : l.Promise.reject(
            new Error("Can't read the data of '" + p + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")
          );
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(n, r, i) {
      var s = n("./reader/readerFor"), o = n("./utils"), a = n("./signature"), l = n("./zipEntry"), u = n("./support");
      function c(d) {
        this.files = [], this.loadOptions = d;
      }
      c.prototype = {
        /**
         * Check that the reader is on the specified signature.
         * @param {string} expectedSignature the expected signature.
         * @throws {Error} if it is an other signature.
         */
        checkSignature: function(d) {
          if (!this.reader.readAndCheckSignature(d)) {
            this.reader.index -= 4;
            var h = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + o.pretty(h) + ", expected " + o.pretty(d) + ")");
          }
        },
        /**
         * Check if the given signature is at the given index.
         * @param {number} askedIndex the index to check.
         * @param {string} expectedSignature the signature to expect.
         * @return {boolean} true if the signature is here, false otherwise.
         */
        isSignature: function(d, h) {
          var v = this.reader.index;
          this.reader.setIndex(d);
          var y = this.reader.readString(4), b = y === h;
          return this.reader.setIndex(v), b;
        },
        /**
         * Read the end of the central directory.
         */
        readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var d = this.reader.readData(this.zipCommentLength), h = u.uint8array ? "uint8array" : "array", v = o.transformTo(h, d);
          this.zipComment = this.loadOptions.decodeFileName(v);
        },
        /**
         * Read the end of the Zip 64 central directory.
         * Not merged with the method readEndOfCentral :
         * The end of central can coexist with its Zip64 brother,
         * I don't want to read the wrong number of bytes !
         */
        readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var d = this.zip64EndOfCentralSize - 44, h = 0, v, y, b; h < d; )
            v = this.reader.readInt(2), y = this.reader.readInt(4), b = this.reader.readData(y), this.zip64ExtensibleData[v] = {
              id: v,
              length: y,
              value: b
            };
        },
        /**
         * Read the end of the Zip 64 central directory locator.
         */
        readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), this.disksCount > 1)
            throw new Error("Multi-volumes zip are not supported");
        },
        /**
         * Read the local files, based on the offset read in the central part.
         */
        readLocalFiles: function() {
          var d, h;
          for (d = 0; d < this.files.length; d++)
            h = this.files[d], this.reader.setIndex(h.localHeaderOffset), this.checkSignature(a.LOCAL_FILE_HEADER), h.readLocalPart(this.reader), h.handleUTF8(), h.processAttributes();
        },
        /**
         * Read the central directory.
         */
        readCentralDir: function() {
          var d;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(a.CENTRAL_FILE_HEADER); )
            d = new l({
              zip64: this.zip64
            }, this.loadOptions), d.readCentralPart(this.reader), this.files.push(d);
          if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        },
        /**
         * Read the end of central directory.
         */
        readEndOfCentral: function() {
          var d = this.reader.lastIndexOfSignature(a.CENTRAL_DIRECTORY_END);
          if (d < 0) {
            var h = !this.isSignature(0, a.LOCAL_FILE_HEADER);
            throw h ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
          }
          this.reader.setIndex(d);
          var v = d;
          if (this.checkSignature(a.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === o.MAX_VALUE_16BITS || this.diskWithCentralDirStart === o.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === o.MAX_VALUE_16BITS || this.centralDirRecords === o.MAX_VALUE_16BITS || this.centralDirSize === o.MAX_VALUE_32BITS || this.centralDirOffset === o.MAX_VALUE_32BITS) {
            if (this.zip64 = !0, d = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR), d < 0)
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(d), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, a.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var y = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (y += 20, y += 12 + this.zip64EndOfCentralSize);
          var b = v - y;
          if (b > 0)
            this.isSignature(v, a.CENTRAL_FILE_HEADER) || (this.reader.zero = b);
          else if (b < 0)
            throw new Error("Corrupted zip: missing " + Math.abs(b) + " bytes.");
        },
        prepareReader: function(d) {
          this.reader = s(d);
        },
        /**
         * Read a zip file and create ZipEntries.
         * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
         */
        load: function(d) {
          this.prepareReader(d), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        }
      }, r.exports = c;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(n, r, i) {
      var s = n("./reader/readerFor"), o = n("./utils"), a = n("./compressedObject"), l = n("./crc32"), u = n("./utf8"), c = n("./compressions"), d = n("./support"), h = 0, v = 3, y = function(p) {
        for (var f in c)
          if (Object.prototype.hasOwnProperty.call(c, f) && c[f].magic === p)
            return c[f];
        return null;
      };
      function b(p, f) {
        this.options = p, this.loadOptions = f;
      }
      b.prototype = {
        /**
         * say if the file is encrypted.
         * @return {boolean} true if the file is encrypted, false otherwise.
         */
        isEncrypted: function() {
          return (this.bitFlag & 1) === 1;
        },
        /**
         * say if the file has utf-8 filename/comment.
         * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
         */
        useUTF8: function() {
          return (this.bitFlag & 2048) === 2048;
        },
        /**
         * Read the local part of a zip file and add the info in this object.
         * @param {DataReader} reader the reader to use.
         */
        readLocalPart: function(p) {
          var f, g;
          if (p.skip(22), this.fileNameLength = p.readInt(2), g = p.readInt(2), this.fileName = p.readData(this.fileNameLength), p.skip(g), this.compressedSize === -1 || this.uncompressedSize === -1)
            throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if (f = y(this.compressionMethod), f === null)
            throw new Error("Corrupted zip : compression " + o.pretty(this.compressionMethod) + " unknown (inner file : " + o.transformTo("string", this.fileName) + ")");
          this.decompressed = new a(this.compressedSize, this.uncompressedSize, this.crc32, f, p.readData(this.compressedSize));
        },
        /**
         * Read the central part of a zip file and add the info in this object.
         * @param {DataReader} reader the reader to use.
         */
        readCentralPart: function(p) {
          this.versionMadeBy = p.readInt(2), p.skip(2), this.bitFlag = p.readInt(2), this.compressionMethod = p.readString(2), this.date = p.readDate(), this.crc32 = p.readInt(4), this.compressedSize = p.readInt(4), this.uncompressedSize = p.readInt(4);
          var f = p.readInt(2);
          if (this.extraFieldsLength = p.readInt(2), this.fileCommentLength = p.readInt(2), this.diskNumberStart = p.readInt(2), this.internalFileAttributes = p.readInt(2), this.externalFileAttributes = p.readInt(4), this.localHeaderOffset = p.readInt(4), this.isEncrypted())
            throw new Error("Encrypted zip are not supported");
          p.skip(f), this.readExtraFields(p), this.parseZIP64ExtraField(p), this.fileComment = p.readData(this.fileCommentLength);
        },
        /**
         * Parse the external file attributes and get the unix/dos permissions.
         */
        processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var p = this.versionMadeBy >> 8;
          this.dir = !!(this.externalFileAttributes & 16), p === h && (this.dosPermissions = this.externalFileAttributes & 63), p === v && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), !this.dir && this.fileNameStr.slice(-1) === "/" && (this.dir = !0);
        },
        /**
         * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
         * @param {DataReader} reader the reader to use.
         */
        parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var p = s(this.extraFields[1].value);
            this.uncompressedSize === o.MAX_VALUE_32BITS && (this.uncompressedSize = p.readInt(8)), this.compressedSize === o.MAX_VALUE_32BITS && (this.compressedSize = p.readInt(8)), this.localHeaderOffset === o.MAX_VALUE_32BITS && (this.localHeaderOffset = p.readInt(8)), this.diskNumberStart === o.MAX_VALUE_32BITS && (this.diskNumberStart = p.readInt(4));
          }
        },
        /**
         * Read the central part of a zip file and add the info in this object.
         * @param {DataReader} reader the reader to use.
         */
        readExtraFields: function(p) {
          var f = p.index + this.extraFieldsLength, g, m, w;
          for (this.extraFields || (this.extraFields = {}); p.index + 4 < f; )
            g = p.readInt(2), m = p.readInt(2), w = p.readData(m), this.extraFields[g] = {
              id: g,
              length: m,
              value: w
            };
          p.setIndex(f);
        },
        /**
         * Apply an UTF8 transformation if needed.
         */
        handleUTF8: function() {
          var p = d.uint8array ? "uint8array" : "array";
          if (this.useUTF8())
            this.fileNameStr = u.utf8decode(this.fileName), this.fileCommentStr = u.utf8decode(this.fileComment);
          else {
            var f = this.findExtraFieldUnicodePath();
            if (f !== null)
              this.fileNameStr = f;
            else {
              var g = o.transformTo(p, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(g);
            }
            var m = this.findExtraFieldUnicodeComment();
            if (m !== null)
              this.fileCommentStr = m;
            else {
              var w = o.transformTo(p, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(w);
            }
          }
        },
        /**
         * Find the unicode path declared in the extra field, if any.
         * @return {String} the unicode path, null otherwise.
         */
        findExtraFieldUnicodePath: function() {
          var p = this.extraFields[28789];
          if (p) {
            var f = s(p.value);
            return f.readInt(1) !== 1 || l(this.fileName) !== f.readInt(4) ? null : u.utf8decode(f.readData(p.length - 5));
          }
          return null;
        },
        /**
         * Find the unicode comment declared in the extra field, if any.
         * @return {String} the unicode comment, null otherwise.
         */
        findExtraFieldUnicodeComment: function() {
          var p = this.extraFields[25461];
          if (p) {
            var f = s(p.value);
            return f.readInt(1) !== 1 || l(this.fileComment) !== f.readInt(4) ? null : u.utf8decode(f.readData(p.length - 5));
          }
          return null;
        }
      }, r.exports = b;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(n, r, i) {
      var s = n("./stream/StreamHelper"), o = n("./stream/DataWorker"), a = n("./utf8"), l = n("./compressedObject"), u = n("./stream/GenericWorker"), c = function(y, b, p) {
        this.name = y, this.dir = p.dir, this.date = p.date, this.comment = p.comment, this.unixPermissions = p.unixPermissions, this.dosPermissions = p.dosPermissions, this._data = b, this._dataBinary = p.binary, this.options = {
          compression: p.compression,
          compressionOptions: p.compressionOptions
        };
      };
      c.prototype = {
        /**
         * Create an internal stream for the content of this object.
         * @param {String} type the type of each chunk.
         * @return StreamHelper the stream.
         */
        internalStream: function(y) {
          var b = null, p = "string";
          try {
            if (!y)
              throw new Error("No output type specified.");
            p = y.toLowerCase();
            var f = p === "string" || p === "text";
            (p === "binarystring" || p === "text") && (p = "string"), b = this._decompressWorker();
            var g = !this._dataBinary;
            g && !f && (b = b.pipe(new a.Utf8EncodeWorker())), !g && f && (b = b.pipe(new a.Utf8DecodeWorker()));
          } catch (m) {
            b = new u("error"), b.error(m);
          }
          return new s(b, p, "");
        },
        /**
         * Prepare the content in the asked type.
         * @param {String} type the type of the result.
         * @param {Function} onUpdate a function to call on each internal update.
         * @return Promise the promise of the result.
         */
        async: function(y, b) {
          return this.internalStream(y).accumulate(b);
        },
        /**
         * Prepare the content as a nodejs stream.
         * @param {String} type the type of each chunk.
         * @param {Function} onUpdate a function to call on each internal update.
         * @return Stream the stream.
         */
        nodeStream: function(y, b) {
          return this.internalStream(y || "nodebuffer").toNodejsStream(b);
        },
        /**
         * Return a worker for the compressed content.
         * @private
         * @param {Object} compression the compression object to use.
         * @param {Object} compressionOptions the options to use when compressing.
         * @return Worker the worker.
         */
        _compressWorker: function(y, b) {
          if (this._data instanceof l && this._data.compression.magic === y.magic)
            return this._data.getCompressedWorker();
          var p = this._decompressWorker();
          return this._dataBinary || (p = p.pipe(new a.Utf8EncodeWorker())), l.createWorkerFrom(p, y, b);
        },
        /**
         * Return a worker for the decompressed content.
         * @private
         * @return Worker the worker.
         */
        _decompressWorker: function() {
          return this._data instanceof l ? this._data.getContentWorker() : this._data instanceof u ? this._data : new o(this._data);
        }
      };
      for (var d = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], h = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, v = 0; v < d.length; v++)
        c.prototype[d[v]] = h;
      r.exports = c;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(n, r, i) {
      (function(s) {
        var o = s.MutationObserver || s.WebKitMutationObserver, a;
        if (o) {
          var l = 0, u = new o(y), c = s.document.createTextNode("");
          u.observe(c, {
            characterData: !0
          }), a = function() {
            c.data = l = ++l % 2;
          };
        } else if (!s.setImmediate && typeof s.MessageChannel < "u") {
          var d = new s.MessageChannel();
          d.port1.onmessage = y, a = function() {
            d.port2.postMessage(0);
          };
        } else
          "document" in s && "onreadystatechange" in s.document.createElement("script") ? a = function() {
            var p = s.document.createElement("script");
            p.onreadystatechange = function() {
              y(), p.onreadystatechange = null, p.parentNode.removeChild(p), p = null;
            }, s.document.documentElement.appendChild(p);
          } : a = function() {
            setTimeout(y, 0);
          };
        var h, v = [];
        function y() {
          h = !0;
          for (var p, f, g = v.length; g; ) {
            for (f = v, v = [], p = -1; ++p < g; )
              f[p]();
            g = v.length;
          }
          h = !1;
        }
        r.exports = b;
        function b(p) {
          v.push(p) === 1 && !h && a();
        }
      }).call(this, typeof mn < "u" ? mn : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(n, r, i) {
      var s = n("immediate");
      function o() {
      }
      var a = {}, l = ["REJECTED"], u = ["FULFILLED"], c = ["PENDING"];
      r.exports = d;
      function d(_) {
        if (typeof _ != "function")
          throw new TypeError("resolver must be a function");
        this.state = c, this.queue = [], this.outcome = void 0, _ !== o && b(this, _);
      }
      d.prototype.finally = function(_) {
        if (typeof _ != "function")
          return this;
        var S = this.constructor;
        return this.then(A, C);
        function A(k) {
          function O() {
            return k;
          }
          return S.resolve(_()).then(O);
        }
        function C(k) {
          function O() {
            throw k;
          }
          return S.resolve(_()).then(O);
        }
      }, d.prototype.catch = function(_) {
        return this.then(null, _);
      }, d.prototype.then = function(_, S) {
        if (typeof _ != "function" && this.state === u || typeof S != "function" && this.state === l)
          return this;
        var A = new this.constructor(o);
        if (this.state !== c) {
          var C = this.state === u ? _ : S;
          v(A, C, this.outcome);
        } else
          this.queue.push(new h(A, _, S));
        return A;
      };
      function h(_, S, A) {
        this.promise = _, typeof S == "function" && (this.onFulfilled = S, this.callFulfilled = this.otherCallFulfilled), typeof A == "function" && (this.onRejected = A, this.callRejected = this.otherCallRejected);
      }
      h.prototype.callFulfilled = function(_) {
        a.resolve(this.promise, _);
      }, h.prototype.otherCallFulfilled = function(_) {
        v(this.promise, this.onFulfilled, _);
      }, h.prototype.callRejected = function(_) {
        a.reject(this.promise, _);
      }, h.prototype.otherCallRejected = function(_) {
        v(this.promise, this.onRejected, _);
      };
      function v(_, S, A) {
        s(function() {
          var C;
          try {
            C = S(A);
          } catch (k) {
            return a.reject(_, k);
          }
          C === _ ? a.reject(_, new TypeError("Cannot resolve promise with itself")) : a.resolve(_, C);
        });
      }
      a.resolve = function(_, S) {
        var A = p(y, S);
        if (A.status === "error")
          return a.reject(_, A.value);
        var C = A.value;
        if (C)
          b(_, C);
        else {
          _.state = u, _.outcome = S;
          for (var k = -1, O = _.queue.length; ++k < O; )
            _.queue[k].callFulfilled(S);
        }
        return _;
      }, a.reject = function(_, S) {
        _.state = l, _.outcome = S;
        for (var A = -1, C = _.queue.length; ++A < C; )
          _.queue[A].callRejected(S);
        return _;
      };
      function y(_) {
        var S = _ && _.then;
        if (_ && (typeof _ == "object" || typeof _ == "function") && typeof S == "function")
          return function() {
            S.apply(_, arguments);
          };
      }
      function b(_, S) {
        var A = !1;
        function C(B) {
          A || (A = !0, a.reject(_, B));
        }
        function k(B) {
          A || (A = !0, a.resolve(_, B));
        }
        function O() {
          S(k, C);
        }
        var N = p(O);
        N.status === "error" && C(N.value);
      }
      function p(_, S) {
        var A = {};
        try {
          A.value = _(S), A.status = "success";
        } catch (C) {
          A.status = "error", A.value = C;
        }
        return A;
      }
      d.resolve = f;
      function f(_) {
        return _ instanceof this ? _ : a.resolve(new this(o), _);
      }
      d.reject = g;
      function g(_) {
        var S = new this(o);
        return a.reject(S, _);
      }
      d.all = m;
      function m(_) {
        var S = this;
        if (Object.prototype.toString.call(_) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var A = _.length, C = !1;
        if (!A)
          return this.resolve([]);
        for (var k = new Array(A), O = 0, N = -1, B = new this(o); ++N < A; )
          M(_[N], N);
        return B;
        function M(j, q) {
          S.resolve(j).then(X, function(z) {
            C || (C = !0, a.reject(B, z));
          });
          function X(z) {
            k[q] = z, ++O === A && !C && (C = !0, a.resolve(B, k));
          }
        }
      }
      d.race = w;
      function w(_) {
        var S = this;
        if (Object.prototype.toString.call(_) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var A = _.length, C = !1;
        if (!A)
          return this.resolve([]);
        for (var k = -1, O = new this(o); ++k < A; )
          N(_[k]);
        return O;
        function N(B) {
          S.resolve(B).then(function(M) {
            C || (C = !0, a.resolve(O, M));
          }, function(M) {
            C || (C = !0, a.reject(O, M));
          });
        }
      }
    }, { immediate: 36 }], 38: [function(n, r, i) {
      var s = n("./lib/utils/common").assign, o = n("./lib/deflate"), a = n("./lib/inflate"), l = n("./lib/zlib/constants"), u = {};
      s(u, o, a, l), r.exports = u;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(n, r, i) {
      var s = n("./zlib/deflate"), o = n("./utils/common"), a = n("./utils/strings"), l = n("./zlib/messages"), u = n("./zlib/zstream"), c = Object.prototype.toString, d = 0, h = 4, v = 0, y = 1, b = 2, p = -1, f = 0, g = 8;
      function m(A) {
        if (!(this instanceof m))
          return new m(A);
        this.options = o.assign({
          level: p,
          method: g,
          chunkSize: 16384,
          windowBits: 15,
          memLevel: 8,
          strategy: f,
          to: ""
        }, A || {});
        var C = this.options;
        C.raw && C.windowBits > 0 ? C.windowBits = -C.windowBits : C.gzip && C.windowBits > 0 && C.windowBits < 16 && (C.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new u(), this.strm.avail_out = 0;
        var k = s.deflateInit2(
          this.strm,
          C.level,
          C.method,
          C.windowBits,
          C.memLevel,
          C.strategy
        );
        if (k !== v)
          throw new Error(l[k]);
        if (C.header && s.deflateSetHeader(this.strm, C.header), C.dictionary) {
          var O;
          if (typeof C.dictionary == "string" ? O = a.string2buf(C.dictionary) : c.call(C.dictionary) === "[object ArrayBuffer]" ? O = new Uint8Array(C.dictionary) : O = C.dictionary, k = s.deflateSetDictionary(this.strm, O), k !== v)
            throw new Error(l[k]);
          this._dict_set = !0;
        }
      }
      m.prototype.push = function(A, C) {
        var k = this.strm, O = this.options.chunkSize, N, B;
        if (this.ended)
          return !1;
        B = C === ~~C ? C : C === !0 ? h : d, typeof A == "string" ? k.input = a.string2buf(A) : c.call(A) === "[object ArrayBuffer]" ? k.input = new Uint8Array(A) : k.input = A, k.next_in = 0, k.avail_in = k.input.length;
        do {
          if (k.avail_out === 0 && (k.output = new o.Buf8(O), k.next_out = 0, k.avail_out = O), N = s.deflate(k, B), N !== y && N !== v)
            return this.onEnd(N), this.ended = !0, !1;
          (k.avail_out === 0 || k.avail_in === 0 && (B === h || B === b)) && (this.options.to === "string" ? this.onData(a.buf2binstring(o.shrinkBuf(k.output, k.next_out))) : this.onData(o.shrinkBuf(k.output, k.next_out)));
        } while ((k.avail_in > 0 || k.avail_out === 0) && N !== y);
        return B === h ? (N = s.deflateEnd(this.strm), this.onEnd(N), this.ended = !0, N === v) : (B === b && (this.onEnd(v), k.avail_out = 0), !0);
      }, m.prototype.onData = function(A) {
        this.chunks.push(A);
      }, m.prototype.onEnd = function(A) {
        A === v && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = A, this.msg = this.strm.msg;
      };
      function w(A, C) {
        var k = new m(C);
        if (k.push(A, !0), k.err)
          throw k.msg || l[k.err];
        return k.result;
      }
      function _(A, C) {
        return C = C || {}, C.raw = !0, w(A, C);
      }
      function S(A, C) {
        return C = C || {}, C.gzip = !0, w(A, C);
      }
      i.Deflate = m, i.deflate = w, i.deflateRaw = _, i.gzip = S;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(n, r, i) {
      var s = n("./zlib/inflate"), o = n("./utils/common"), a = n("./utils/strings"), l = n("./zlib/constants"), u = n("./zlib/messages"), c = n("./zlib/zstream"), d = n("./zlib/gzheader"), h = Object.prototype.toString;
      function v(p) {
        if (!(this instanceof v))
          return new v(p);
        this.options = o.assign({
          chunkSize: 16384,
          windowBits: 0,
          to: ""
        }, p || {});
        var f = this.options;
        f.raw && f.windowBits >= 0 && f.windowBits < 16 && (f.windowBits = -f.windowBits, f.windowBits === 0 && (f.windowBits = -15)), f.windowBits >= 0 && f.windowBits < 16 && !(p && p.windowBits) && (f.windowBits += 32), f.windowBits > 15 && f.windowBits < 48 && (f.windowBits & 15 || (f.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new c(), this.strm.avail_out = 0;
        var g = s.inflateInit2(
          this.strm,
          f.windowBits
        );
        if (g !== l.Z_OK)
          throw new Error(u[g]);
        this.header = new d(), s.inflateGetHeader(this.strm, this.header);
      }
      v.prototype.push = function(p, f) {
        var g = this.strm, m = this.options.chunkSize, w = this.options.dictionary, _, S, A, C, k, O, N = !1;
        if (this.ended)
          return !1;
        S = f === ~~f ? f : f === !0 ? l.Z_FINISH : l.Z_NO_FLUSH, typeof p == "string" ? g.input = a.binstring2buf(p) : h.call(p) === "[object ArrayBuffer]" ? g.input = new Uint8Array(p) : g.input = p, g.next_in = 0, g.avail_in = g.input.length;
        do {
          if (g.avail_out === 0 && (g.output = new o.Buf8(m), g.next_out = 0, g.avail_out = m), _ = s.inflate(g, l.Z_NO_FLUSH), _ === l.Z_NEED_DICT && w && (typeof w == "string" ? O = a.string2buf(w) : h.call(w) === "[object ArrayBuffer]" ? O = new Uint8Array(w) : O = w, _ = s.inflateSetDictionary(this.strm, O)), _ === l.Z_BUF_ERROR && N === !0 && (_ = l.Z_OK, N = !1), _ !== l.Z_STREAM_END && _ !== l.Z_OK)
            return this.onEnd(_), this.ended = !0, !1;
          g.next_out && (g.avail_out === 0 || _ === l.Z_STREAM_END || g.avail_in === 0 && (S === l.Z_FINISH || S === l.Z_SYNC_FLUSH)) && (this.options.to === "string" ? (A = a.utf8border(g.output, g.next_out), C = g.next_out - A, k = a.buf2string(g.output, A), g.next_out = C, g.avail_out = m - C, C && o.arraySet(g.output, g.output, A, C, 0), this.onData(k)) : this.onData(o.shrinkBuf(g.output, g.next_out))), g.avail_in === 0 && g.avail_out === 0 && (N = !0);
        } while ((g.avail_in > 0 || g.avail_out === 0) && _ !== l.Z_STREAM_END);
        return _ === l.Z_STREAM_END && (S = l.Z_FINISH), S === l.Z_FINISH ? (_ = s.inflateEnd(this.strm), this.onEnd(_), this.ended = !0, _ === l.Z_OK) : (S === l.Z_SYNC_FLUSH && (this.onEnd(l.Z_OK), g.avail_out = 0), !0);
      }, v.prototype.onData = function(p) {
        this.chunks.push(p);
      }, v.prototype.onEnd = function(p) {
        p === l.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = p, this.msg = this.strm.msg;
      };
      function y(p, f) {
        var g = new v(f);
        if (g.push(p, !0), g.err)
          throw g.msg || u[g.err];
        return g.result;
      }
      function b(p, f) {
        return f = f || {}, f.raw = !0, y(p, f);
      }
      i.Inflate = v, i.inflate = y, i.inflateRaw = b, i.ungzip = y;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(n, r, i) {
      var s = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      i.assign = function(l) {
        for (var u = Array.prototype.slice.call(arguments, 1); u.length; ) {
          var c = u.shift();
          if (c) {
            if (typeof c != "object")
              throw new TypeError(c + "must be non-object");
            for (var d in c)
              c.hasOwnProperty(d) && (l[d] = c[d]);
          }
        }
        return l;
      }, i.shrinkBuf = function(l, u) {
        return l.length === u ? l : l.subarray ? l.subarray(0, u) : (l.length = u, l);
      };
      var o = {
        arraySet: function(l, u, c, d, h) {
          if (u.subarray && l.subarray) {
            l.set(u.subarray(c, c + d), h);
            return;
          }
          for (var v = 0; v < d; v++)
            l[h + v] = u[c + v];
        },
        // Join array of chunks to single array.
        flattenChunks: function(l) {
          var u, c, d, h, v, y;
          for (d = 0, u = 0, c = l.length; u < c; u++)
            d += l[u].length;
          for (y = new Uint8Array(d), h = 0, u = 0, c = l.length; u < c; u++)
            v = l[u], y.set(v, h), h += v.length;
          return y;
        }
      }, a = {
        arraySet: function(l, u, c, d, h) {
          for (var v = 0; v < d; v++)
            l[h + v] = u[c + v];
        },
        // Join array of chunks to single array.
        flattenChunks: function(l) {
          return [].concat.apply([], l);
        }
      };
      i.setTyped = function(l) {
        l ? (i.Buf8 = Uint8Array, i.Buf16 = Uint16Array, i.Buf32 = Int32Array, i.assign(i, o)) : (i.Buf8 = Array, i.Buf16 = Array, i.Buf32 = Array, i.assign(i, a));
      }, i.setTyped(s);
    }, {}], 42: [function(n, r, i) {
      var s = n("./common"), o = !0, a = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        o = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        a = !1;
      }
      for (var l = new s.Buf8(256), u = 0; u < 256; u++)
        l[u] = u >= 252 ? 6 : u >= 248 ? 5 : u >= 240 ? 4 : u >= 224 ? 3 : u >= 192 ? 2 : 1;
      l[254] = l[254] = 1, i.string2buf = function(d) {
        var h, v, y, b, p, f = d.length, g = 0;
        for (b = 0; b < f; b++)
          v = d.charCodeAt(b), (v & 64512) === 55296 && b + 1 < f && (y = d.charCodeAt(b + 1), (y & 64512) === 56320 && (v = 65536 + (v - 55296 << 10) + (y - 56320), b++)), g += v < 128 ? 1 : v < 2048 ? 2 : v < 65536 ? 3 : 4;
        for (h = new s.Buf8(g), p = 0, b = 0; p < g; b++)
          v = d.charCodeAt(b), (v & 64512) === 55296 && b + 1 < f && (y = d.charCodeAt(b + 1), (y & 64512) === 56320 && (v = 65536 + (v - 55296 << 10) + (y - 56320), b++)), v < 128 ? h[p++] = v : v < 2048 ? (h[p++] = 192 | v >>> 6, h[p++] = 128 | v & 63) : v < 65536 ? (h[p++] = 224 | v >>> 12, h[p++] = 128 | v >>> 6 & 63, h[p++] = 128 | v & 63) : (h[p++] = 240 | v >>> 18, h[p++] = 128 | v >>> 12 & 63, h[p++] = 128 | v >>> 6 & 63, h[p++] = 128 | v & 63);
        return h;
      };
      function c(d, h) {
        if (h < 65537 && (d.subarray && a || !d.subarray && o))
          return String.fromCharCode.apply(null, s.shrinkBuf(d, h));
        for (var v = "", y = 0; y < h; y++)
          v += String.fromCharCode(d[y]);
        return v;
      }
      i.buf2binstring = function(d) {
        return c(d, d.length);
      }, i.binstring2buf = function(d) {
        for (var h = new s.Buf8(d.length), v = 0, y = h.length; v < y; v++)
          h[v] = d.charCodeAt(v);
        return h;
      }, i.buf2string = function(d, h) {
        var v, y, b, p, f = h || d.length, g = new Array(f * 2);
        for (y = 0, v = 0; v < f; ) {
          if (b = d[v++], b < 128) {
            g[y++] = b;
            continue;
          }
          if (p = l[b], p > 4) {
            g[y++] = 65533, v += p - 1;
            continue;
          }
          for (b &= p === 2 ? 31 : p === 3 ? 15 : 7; p > 1 && v < f; )
            b = b << 6 | d[v++] & 63, p--;
          if (p > 1) {
            g[y++] = 65533;
            continue;
          }
          b < 65536 ? g[y++] = b : (b -= 65536, g[y++] = 55296 | b >> 10 & 1023, g[y++] = 56320 | b & 1023);
        }
        return c(g, y);
      }, i.utf8border = function(d, h) {
        var v;
        for (h = h || d.length, h > d.length && (h = d.length), v = h - 1; v >= 0 && (d[v] & 192) === 128; )
          v--;
        return v < 0 || v === 0 ? h : v + l[d[v]] > h ? v : h;
      };
    }, { "./common": 41 }], 43: [function(n, r, i) {
      function s(o, a, l, u) {
        for (var c = o & 65535 | 0, d = o >>> 16 & 65535 | 0, h = 0; l !== 0; ) {
          h = l > 2e3 ? 2e3 : l, l -= h;
          do
            c = c + a[u++] | 0, d = d + c | 0;
          while (--h);
          c %= 65521, d %= 65521;
        }
        return c | d << 16 | 0;
      }
      r.exports = s;
    }, {}], 44: [function(n, r, i) {
      r.exports = {
        /* Allowed flush values; see deflate() and inflate() below for details */
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        /* Return codes for the compression/decompression functions. Negative values
        * are errors, positive values are used for special but normal events.
        */
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        //Z_MEM_ERROR:     -4,
        Z_BUF_ERROR: -5,
        //Z_VERSION_ERROR: -6,
        /* compression levels */
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        /* Possible values of the data_type field (though see inflate()) */
        Z_BINARY: 0,
        Z_TEXT: 1,
        //Z_ASCII:                1, // = Z_TEXT (deprecated)
        Z_UNKNOWN: 2,
        /* The deflate compression method */
        Z_DEFLATED: 8
        //Z_NULL:                 null // Use -1 or null inline, depending on var type
      };
    }, {}], 45: [function(n, r, i) {
      function s() {
        for (var l, u = [], c = 0; c < 256; c++) {
          l = c;
          for (var d = 0; d < 8; d++)
            l = l & 1 ? 3988292384 ^ l >>> 1 : l >>> 1;
          u[c] = l;
        }
        return u;
      }
      var o = s();
      function a(l, u, c, d) {
        var h = o, v = d + c;
        l ^= -1;
        for (var y = d; y < v; y++)
          l = l >>> 8 ^ h[(l ^ u[y]) & 255];
        return l ^ -1;
      }
      r.exports = a;
    }, {}], 46: [function(n, r, i) {
      var s = n("../utils/common"), o = n("./trees"), a = n("./adler32"), l = n("./crc32"), u = n("./messages"), c = 0, d = 1, h = 3, v = 4, y = 5, b = 0, p = 1, f = -2, g = -3, m = -5, w = -1, _ = 1, S = 2, A = 3, C = 4, k = 0, O = 2, N = 8, B = 9, M = 15, j = 8, q = 29, X = 256, z = X + 1 + q, U = 30, H = 19, re = 2 * z + 1, fe = 15, J = 3, le = 258, ce = le + J + 1, ge = 32, _e = 42, je = 69, Te = 73, Ze = 91, Le = 103, Ke = 113, ct = 666, nt = 1, Et = 2, yt = 3, Nt = 4, ot = 3;
      function bt(E, Q) {
        return E.msg = u[Q], Q;
      }
      function $t(E) {
        return (E << 1) - (E > 4 ? 9 : 0);
      }
      function wt(E) {
        for (var Q = E.length; --Q >= 0; )
          E[Q] = 0;
      }
      function xt(E) {
        var Q = E.state, ie = Q.pending;
        ie > E.avail_out && (ie = E.avail_out), ie !== 0 && (s.arraySet(E.output, Q.pending_buf, Q.pending_out, ie, E.next_out), E.next_out += ie, Q.pending_out += ie, E.total_out += ie, E.avail_out -= ie, Q.pending -= ie, Q.pending === 0 && (Q.pending_out = 0));
      }
      function lt(E, Q) {
        o._tr_flush_block(E, E.block_start >= 0 ? E.block_start : -1, E.strstart - E.block_start, Q), E.block_start = E.strstart, xt(E.strm);
      }
      function qe(E, Q) {
        E.pending_buf[E.pending++] = Q;
      }
      function Rt(E, Q) {
        E.pending_buf[E.pending++] = Q >>> 8 & 255, E.pending_buf[E.pending++] = Q & 255;
      }
      function we(E, Q, ie, I) {
        var W = E.avail_in;
        return W > I && (W = I), W === 0 ? 0 : (E.avail_in -= W, s.arraySet(Q, E.input, E.next_in, W, ie), E.state.wrap === 1 ? E.adler = a(E.adler, Q, W, ie) : E.state.wrap === 2 && (E.adler = l(E.adler, Q, W, ie)), E.next_in += W, E.total_in += W, W);
      }
      function Ue(E, Q) {
        var ie = E.max_chain_length, I = E.strstart, W, ne, Pe = E.prev_length, Oe = E.nice_match, De = E.strstart > E.w_size - ce ? E.strstart - (E.w_size - ce) : 0, Ye = E.window, ln = E.w_mask, Wt = E.prev, pt = E.strstart + le, Zt = Ye[I + Pe - 1], fn = Ye[I + Pe];
        E.prev_length >= E.good_match && (ie >>= 2), Oe > E.lookahead && (Oe = E.lookahead);
        do
          if (W = Q, !(Ye[W + Pe] !== fn || Ye[W + Pe - 1] !== Zt || Ye[W] !== Ye[I] || Ye[++W] !== Ye[I + 1])) {
            I += 2, W++;
            do
              ;
            while (Ye[++I] === Ye[++W] && Ye[++I] === Ye[++W] && Ye[++I] === Ye[++W] && Ye[++I] === Ye[++W] && Ye[++I] === Ye[++W] && Ye[++I] === Ye[++W] && Ye[++I] === Ye[++W] && Ye[++I] === Ye[++W] && I < pt);
            if (ne = le - (pt - I), I = pt - le, ne > Pe) {
              if (E.match_start = Q, Pe = ne, ne >= Oe)
                break;
              Zt = Ye[I + Pe - 1], fn = Ye[I + Pe];
            }
          }
        while ((Q = Wt[Q & ln]) > De && --ie !== 0);
        return Pe <= E.lookahead ? Pe : E.lookahead;
      }
      function at(E) {
        var Q = E.w_size, ie, I, W, ne, Pe;
        do {
          if (ne = E.window_size - E.lookahead - E.strstart, E.strstart >= Q + (Q - ce)) {
            s.arraySet(E.window, E.window, Q, Q, 0), E.match_start -= Q, E.strstart -= Q, E.block_start -= Q, I = E.hash_size, ie = I;
            do
              W = E.head[--ie], E.head[ie] = W >= Q ? W - Q : 0;
            while (--I);
            I = Q, ie = I;
            do
              W = E.prev[--ie], E.prev[ie] = W >= Q ? W - Q : 0;
            while (--I);
            ne += Q;
          }
          if (E.strm.avail_in === 0)
            break;
          if (I = we(E.strm, E.window, E.strstart + E.lookahead, ne), E.lookahead += I, E.lookahead + E.insert >= J)
            for (Pe = E.strstart - E.insert, E.ins_h = E.window[Pe], E.ins_h = (E.ins_h << E.hash_shift ^ E.window[Pe + 1]) & E.hash_mask; E.insert && (E.ins_h = (E.ins_h << E.hash_shift ^ E.window[Pe + J - 1]) & E.hash_mask, E.prev[Pe & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = Pe, Pe++, E.insert--, !(E.lookahead + E.insert < J)); )
              ;
        } while (E.lookahead < ce && E.strm.avail_in !== 0);
      }
      function Pt(E, Q) {
        var ie = 65535;
        for (ie > E.pending_buf_size - 5 && (ie = E.pending_buf_size - 5); ; ) {
          if (E.lookahead <= 1) {
            if (at(E), E.lookahead === 0 && Q === c)
              return nt;
            if (E.lookahead === 0)
              break;
          }
          E.strstart += E.lookahead, E.lookahead = 0;
          var I = E.block_start + ie;
          if ((E.strstart === 0 || E.strstart >= I) && (E.lookahead = E.strstart - I, E.strstart = I, lt(E, !1), E.strm.avail_out === 0) || E.strstart - E.block_start >= E.w_size - ce && (lt(E, !1), E.strm.avail_out === 0))
            return nt;
        }
        return E.insert = 0, Q === v ? (lt(E, !0), E.strm.avail_out === 0 ? yt : Nt) : (E.strstart > E.block_start && (lt(E, !1), E.strm.avail_out === 0), nt);
      }
      function Qt(E, Q) {
        for (var ie, I; ; ) {
          if (E.lookahead < ce) {
            if (at(E), E.lookahead < ce && Q === c)
              return nt;
            if (E.lookahead === 0)
              break;
          }
          if (ie = 0, E.lookahead >= J && (E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + J - 1]) & E.hash_mask, ie = E.prev[E.strstart & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = E.strstart), ie !== 0 && E.strstart - ie <= E.w_size - ce && (E.match_length = Ue(E, ie)), E.match_length >= J)
            if (I = o._tr_tally(E, E.strstart - E.match_start, E.match_length - J), E.lookahead -= E.match_length, E.match_length <= E.max_lazy_match && E.lookahead >= J) {
              E.match_length--;
              do
                E.strstart++, E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + J - 1]) & E.hash_mask, ie = E.prev[E.strstart & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = E.strstart;
              while (--E.match_length !== 0);
              E.strstart++;
            } else
              E.strstart += E.match_length, E.match_length = 0, E.ins_h = E.window[E.strstart], E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + 1]) & E.hash_mask;
          else
            I = o._tr_tally(E, 0, E.window[E.strstart]), E.lookahead--, E.strstart++;
          if (I && (lt(E, !1), E.strm.avail_out === 0))
            return nt;
        }
        return E.insert = E.strstart < J - 1 ? E.strstart : J - 1, Q === v ? (lt(E, !0), E.strm.avail_out === 0 ? yt : Nt) : E.last_lit && (lt(E, !1), E.strm.avail_out === 0) ? nt : Et;
      }
      function Ie(E, Q) {
        for (var ie, I, W; ; ) {
          if (E.lookahead < ce) {
            if (at(E), E.lookahead < ce && Q === c)
              return nt;
            if (E.lookahead === 0)
              break;
          }
          if (ie = 0, E.lookahead >= J && (E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + J - 1]) & E.hash_mask, ie = E.prev[E.strstart & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = E.strstart), E.prev_length = E.match_length, E.prev_match = E.match_start, E.match_length = J - 1, ie !== 0 && E.prev_length < E.max_lazy_match && E.strstart - ie <= E.w_size - ce && (E.match_length = Ue(E, ie), E.match_length <= 5 && (E.strategy === _ || E.match_length === J && E.strstart - E.match_start > 4096) && (E.match_length = J - 1)), E.prev_length >= J && E.match_length <= E.prev_length) {
            W = E.strstart + E.lookahead - J, I = o._tr_tally(E, E.strstart - 1 - E.prev_match, E.prev_length - J), E.lookahead -= E.prev_length - 1, E.prev_length -= 2;
            do
              ++E.strstart <= W && (E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + J - 1]) & E.hash_mask, ie = E.prev[E.strstart & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = E.strstart);
            while (--E.prev_length !== 0);
            if (E.match_available = 0, E.match_length = J - 1, E.strstart++, I && (lt(E, !1), E.strm.avail_out === 0))
              return nt;
          } else if (E.match_available) {
            if (I = o._tr_tally(E, 0, E.window[E.strstart - 1]), I && lt(E, !1), E.strstart++, E.lookahead--, E.strm.avail_out === 0)
              return nt;
          } else
            E.match_available = 1, E.strstart++, E.lookahead--;
        }
        return E.match_available && (I = o._tr_tally(E, 0, E.window[E.strstart - 1]), E.match_available = 0), E.insert = E.strstart < J - 1 ? E.strstart : J - 1, Q === v ? (lt(E, !0), E.strm.avail_out === 0 ? yt : Nt) : E.last_lit && (lt(E, !1), E.strm.avail_out === 0) ? nt : Et;
      }
      function Ve(E, Q) {
        for (var ie, I, W, ne, Pe = E.window; ; ) {
          if (E.lookahead <= le) {
            if (at(E), E.lookahead <= le && Q === c)
              return nt;
            if (E.lookahead === 0)
              break;
          }
          if (E.match_length = 0, E.lookahead >= J && E.strstart > 0 && (W = E.strstart - 1, I = Pe[W], I === Pe[++W] && I === Pe[++W] && I === Pe[++W])) {
            ne = E.strstart + le;
            do
              ;
            while (I === Pe[++W] && I === Pe[++W] && I === Pe[++W] && I === Pe[++W] && I === Pe[++W] && I === Pe[++W] && I === Pe[++W] && I === Pe[++W] && W < ne);
            E.match_length = le - (ne - W), E.match_length > E.lookahead && (E.match_length = E.lookahead);
          }
          if (E.match_length >= J ? (ie = o._tr_tally(E, 1, E.match_length - J), E.lookahead -= E.match_length, E.strstart += E.match_length, E.match_length = 0) : (ie = o._tr_tally(E, 0, E.window[E.strstart]), E.lookahead--, E.strstart++), ie && (lt(E, !1), E.strm.avail_out === 0))
            return nt;
        }
        return E.insert = 0, Q === v ? (lt(E, !0), E.strm.avail_out === 0 ? yt : Nt) : E.last_lit && (lt(E, !1), E.strm.avail_out === 0) ? nt : Et;
      }
      function Je(E, Q) {
        for (var ie; ; ) {
          if (E.lookahead === 0 && (at(E), E.lookahead === 0)) {
            if (Q === c)
              return nt;
            break;
          }
          if (E.match_length = 0, ie = o._tr_tally(E, 0, E.window[E.strstart]), E.lookahead--, E.strstart++, ie && (lt(E, !1), E.strm.avail_out === 0))
            return nt;
        }
        return E.insert = 0, Q === v ? (lt(E, !0), E.strm.avail_out === 0 ? yt : Nt) : E.last_lit && (lt(E, !1), E.strm.avail_out === 0) ? nt : Et;
      }
      function He(E, Q, ie, I, W) {
        this.good_length = E, this.max_lazy = Q, this.nice_length = ie, this.max_chain = I, this.func = W;
      }
      var Qe;
      Qe = [
        /*      good lazy nice chain */
        new He(0, 0, 0, 0, Pt),
        /* 0 store only */
        new He(4, 4, 8, 4, Qt),
        /* 1 max speed, no lazy matches */
        new He(4, 5, 16, 8, Qt),
        /* 2 */
        new He(4, 6, 32, 32, Qt),
        /* 3 */
        new He(4, 4, 16, 16, Ie),
        /* 4 lazy matches */
        new He(8, 16, 32, 32, Ie),
        /* 5 */
        new He(8, 16, 128, 128, Ie),
        /* 6 */
        new He(8, 32, 128, 256, Ie),
        /* 7 */
        new He(32, 128, 258, 1024, Ie),
        /* 8 */
        new He(32, 258, 258, 4096, Ie)
        /* 9 max compression */
      ];
      function At(E) {
        E.window_size = 2 * E.w_size, wt(E.head), E.max_lazy_match = Qe[E.level].max_lazy, E.good_match = Qe[E.level].good_length, E.nice_match = Qe[E.level].nice_length, E.max_chain_length = Qe[E.level].max_chain, E.strstart = 0, E.block_start = 0, E.lookahead = 0, E.insert = 0, E.match_length = E.prev_length = J - 1, E.match_available = 0, E.ins_h = 0;
      }
      function P() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = N, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new s.Buf16(re * 2), this.dyn_dtree = new s.Buf16((2 * U + 1) * 2), this.bl_tree = new s.Buf16((2 * H + 1) * 2), wt(this.dyn_ltree), wt(this.dyn_dtree), wt(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new s.Buf16(fe + 1), this.heap = new s.Buf16(2 * z + 1), wt(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new s.Buf16(2 * z + 1), wt(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function he(E) {
        var Q;
        return !E || !E.state ? bt(E, f) : (E.total_in = E.total_out = 0, E.data_type = O, Q = E.state, Q.pending = 0, Q.pending_out = 0, Q.wrap < 0 && (Q.wrap = -Q.wrap), Q.status = Q.wrap ? _e : Ke, E.adler = Q.wrap === 2 ? 0 : 1, Q.last_flush = c, o._tr_init(Q), b);
      }
      function me(E) {
        var Q = he(E);
        return Q === b && At(E.state), Q;
      }
      function Ne(E, Q) {
        return !E || !E.state || E.state.wrap !== 2 ? f : (E.state.gzhead = Q, b);
      }
      function G(E, Q, ie, I, W, ne) {
        if (!E)
          return f;
        var Pe = 1;
        if (Q === w && (Q = 6), I < 0 ? (Pe = 0, I = -I) : I > 15 && (Pe = 2, I -= 16), W < 1 || W > B || ie !== N || I < 8 || I > 15 || Q < 0 || Q > 9 || ne < 0 || ne > C)
          return bt(E, f);
        I === 8 && (I = 9);
        var Oe = new P();
        return E.state = Oe, Oe.strm = E, Oe.wrap = Pe, Oe.gzhead = null, Oe.w_bits = I, Oe.w_size = 1 << Oe.w_bits, Oe.w_mask = Oe.w_size - 1, Oe.hash_bits = W + 7, Oe.hash_size = 1 << Oe.hash_bits, Oe.hash_mask = Oe.hash_size - 1, Oe.hash_shift = ~~((Oe.hash_bits + J - 1) / J), Oe.window = new s.Buf8(Oe.w_size * 2), Oe.head = new s.Buf16(Oe.hash_size), Oe.prev = new s.Buf16(Oe.w_size), Oe.lit_bufsize = 1 << W + 6, Oe.pending_buf_size = Oe.lit_bufsize * 4, Oe.pending_buf = new s.Buf8(Oe.pending_buf_size), Oe.d_buf = 1 * Oe.lit_bufsize, Oe.l_buf = (1 + 2) * Oe.lit_bufsize, Oe.level = Q, Oe.strategy = ne, Oe.method = ie, me(E);
      }
      function ue(E, Q) {
        return G(E, Q, N, M, j, k);
      }
      function T(E, Q) {
        var ie, I, W, ne;
        if (!E || !E.state || Q > y || Q < 0)
          return E ? bt(E, f) : f;
        if (I = E.state, !E.output || !E.input && E.avail_in !== 0 || I.status === ct && Q !== v)
          return bt(E, E.avail_out === 0 ? m : f);
        if (I.strm = E, ie = I.last_flush, I.last_flush = Q, I.status === _e)
          if (I.wrap === 2)
            E.adler = 0, qe(I, 31), qe(I, 139), qe(I, 8), I.gzhead ? (qe(
              I,
              (I.gzhead.text ? 1 : 0) + (I.gzhead.hcrc ? 2 : 0) + (I.gzhead.extra ? 4 : 0) + (I.gzhead.name ? 8 : 0) + (I.gzhead.comment ? 16 : 0)
            ), qe(I, I.gzhead.time & 255), qe(I, I.gzhead.time >> 8 & 255), qe(I, I.gzhead.time >> 16 & 255), qe(I, I.gzhead.time >> 24 & 255), qe(I, I.level === 9 ? 2 : I.strategy >= S || I.level < 2 ? 4 : 0), qe(I, I.gzhead.os & 255), I.gzhead.extra && I.gzhead.extra.length && (qe(I, I.gzhead.extra.length & 255), qe(I, I.gzhead.extra.length >> 8 & 255)), I.gzhead.hcrc && (E.adler = l(E.adler, I.pending_buf, I.pending, 0)), I.gzindex = 0, I.status = je) : (qe(I, 0), qe(I, 0), qe(I, 0), qe(I, 0), qe(I, 0), qe(I, I.level === 9 ? 2 : I.strategy >= S || I.level < 2 ? 4 : 0), qe(I, ot), I.status = Ke);
          else {
            var Pe = N + (I.w_bits - 8 << 4) << 8, Oe = -1;
            I.strategy >= S || I.level < 2 ? Oe = 0 : I.level < 6 ? Oe = 1 : I.level === 6 ? Oe = 2 : Oe = 3, Pe |= Oe << 6, I.strstart !== 0 && (Pe |= ge), Pe += 31 - Pe % 31, I.status = Ke, Rt(I, Pe), I.strstart !== 0 && (Rt(I, E.adler >>> 16), Rt(I, E.adler & 65535)), E.adler = 1;
          }
        if (I.status === je)
          if (I.gzhead.extra) {
            for (W = I.pending; I.gzindex < (I.gzhead.extra.length & 65535) && !(I.pending === I.pending_buf_size && (I.gzhead.hcrc && I.pending > W && (E.adler = l(E.adler, I.pending_buf, I.pending - W, W)), xt(E), W = I.pending, I.pending === I.pending_buf_size)); )
              qe(I, I.gzhead.extra[I.gzindex] & 255), I.gzindex++;
            I.gzhead.hcrc && I.pending > W && (E.adler = l(E.adler, I.pending_buf, I.pending - W, W)), I.gzindex === I.gzhead.extra.length && (I.gzindex = 0, I.status = Te);
          } else
            I.status = Te;
        if (I.status === Te)
          if (I.gzhead.name) {
            W = I.pending;
            do {
              if (I.pending === I.pending_buf_size && (I.gzhead.hcrc && I.pending > W && (E.adler = l(E.adler, I.pending_buf, I.pending - W, W)), xt(E), W = I.pending, I.pending === I.pending_buf_size)) {
                ne = 1;
                break;
              }
              I.gzindex < I.gzhead.name.length ? ne = I.gzhead.name.charCodeAt(I.gzindex++) & 255 : ne = 0, qe(I, ne);
            } while (ne !== 0);
            I.gzhead.hcrc && I.pending > W && (E.adler = l(E.adler, I.pending_buf, I.pending - W, W)), ne === 0 && (I.gzindex = 0, I.status = Ze);
          } else
            I.status = Ze;
        if (I.status === Ze)
          if (I.gzhead.comment) {
            W = I.pending;
            do {
              if (I.pending === I.pending_buf_size && (I.gzhead.hcrc && I.pending > W && (E.adler = l(E.adler, I.pending_buf, I.pending - W, W)), xt(E), W = I.pending, I.pending === I.pending_buf_size)) {
                ne = 1;
                break;
              }
              I.gzindex < I.gzhead.comment.length ? ne = I.gzhead.comment.charCodeAt(I.gzindex++) & 255 : ne = 0, qe(I, ne);
            } while (ne !== 0);
            I.gzhead.hcrc && I.pending > W && (E.adler = l(E.adler, I.pending_buf, I.pending - W, W)), ne === 0 && (I.status = Le);
          } else
            I.status = Le;
        if (I.status === Le && (I.gzhead.hcrc ? (I.pending + 2 > I.pending_buf_size && xt(E), I.pending + 2 <= I.pending_buf_size && (qe(I, E.adler & 255), qe(I, E.adler >> 8 & 255), E.adler = 0, I.status = Ke)) : I.status = Ke), I.pending !== 0) {
          if (xt(E), E.avail_out === 0)
            return I.last_flush = -1, b;
        } else if (E.avail_in === 0 && $t(Q) <= $t(ie) && Q !== v)
          return bt(E, m);
        if (I.status === ct && E.avail_in !== 0)
          return bt(E, m);
        if (E.avail_in !== 0 || I.lookahead !== 0 || Q !== c && I.status !== ct) {
          var De = I.strategy === S ? Je(I, Q) : I.strategy === A ? Ve(I, Q) : Qe[I.level].func(I, Q);
          if ((De === yt || De === Nt) && (I.status = ct), De === nt || De === yt)
            return E.avail_out === 0 && (I.last_flush = -1), b;
          if (De === Et && (Q === d ? o._tr_align(I) : Q !== y && (o._tr_stored_block(I, 0, 0, !1), Q === h && (wt(I.head), I.lookahead === 0 && (I.strstart = 0, I.block_start = 0, I.insert = 0))), xt(E), E.avail_out === 0))
            return I.last_flush = -1, b;
        }
        return Q !== v ? b : I.wrap <= 0 ? p : (I.wrap === 2 ? (qe(I, E.adler & 255), qe(I, E.adler >> 8 & 255), qe(I, E.adler >> 16 & 255), qe(I, E.adler >> 24 & 255), qe(I, E.total_in & 255), qe(I, E.total_in >> 8 & 255), qe(I, E.total_in >> 16 & 255), qe(I, E.total_in >> 24 & 255)) : (Rt(I, E.adler >>> 16), Rt(I, E.adler & 65535)), xt(E), I.wrap > 0 && (I.wrap = -I.wrap), I.pending !== 0 ? b : p);
      }
      function L(E) {
        var Q;
        return !E || !E.state ? f : (Q = E.state.status, Q !== _e && Q !== je && Q !== Te && Q !== Ze && Q !== Le && Q !== Ke && Q !== ct ? bt(E, f) : (E.state = null, Q === Ke ? bt(E, g) : b));
      }
      function oe(E, Q) {
        var ie = Q.length, I, W, ne, Pe, Oe, De, Ye, ln;
        if (!E || !E.state || (I = E.state, Pe = I.wrap, Pe === 2 || Pe === 1 && I.status !== _e || I.lookahead))
          return f;
        for (Pe === 1 && (E.adler = a(E.adler, Q, ie, 0)), I.wrap = 0, ie >= I.w_size && (Pe === 0 && (wt(I.head), I.strstart = 0, I.block_start = 0, I.insert = 0), ln = new s.Buf8(I.w_size), s.arraySet(ln, Q, ie - I.w_size, I.w_size, 0), Q = ln, ie = I.w_size), Oe = E.avail_in, De = E.next_in, Ye = E.input, E.avail_in = ie, E.next_in = 0, E.input = Q, at(I); I.lookahead >= J; ) {
          W = I.strstart, ne = I.lookahead - (J - 1);
          do
            I.ins_h = (I.ins_h << I.hash_shift ^ I.window[W + J - 1]) & I.hash_mask, I.prev[W & I.w_mask] = I.head[I.ins_h], I.head[I.ins_h] = W, W++;
          while (--ne);
          I.strstart = W, I.lookahead = J - 1, at(I);
        }
        return I.strstart += I.lookahead, I.block_start = I.strstart, I.insert = I.lookahead, I.lookahead = 0, I.match_length = I.prev_length = J - 1, I.match_available = 0, E.next_in = De, E.input = Ye, E.avail_in = Oe, I.wrap = Pe, b;
      }
      i.deflateInit = ue, i.deflateInit2 = G, i.deflateReset = me, i.deflateResetKeep = he, i.deflateSetHeader = Ne, i.deflate = T, i.deflateEnd = L, i.deflateSetDictionary = oe, i.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(n, r, i) {
      function s() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      }
      r.exports = s;
    }, {}], 48: [function(n, r, i) {
      var s = 30, o = 12;
      r.exports = function(l, u) {
        var c, d, h, v, y, b, p, f, g, m, w, _, S, A, C, k, O, N, B, M, j, q, X, z, U;
        c = l.state, d = l.next_in, z = l.input, h = d + (l.avail_in - 5), v = l.next_out, U = l.output, y = v - (u - l.avail_out), b = v + (l.avail_out - 257), p = c.dmax, f = c.wsize, g = c.whave, m = c.wnext, w = c.window, _ = c.hold, S = c.bits, A = c.lencode, C = c.distcode, k = (1 << c.lenbits) - 1, O = (1 << c.distbits) - 1;
        e:
          do {
            S < 15 && (_ += z[d++] << S, S += 8, _ += z[d++] << S, S += 8), N = A[_ & k];
            t:
              for (; ; ) {
                if (B = N >>> 24, _ >>>= B, S -= B, B = N >>> 16 & 255, B === 0)
                  U[v++] = N & 65535;
                else if (B & 16) {
                  M = N & 65535, B &= 15, B && (S < B && (_ += z[d++] << S, S += 8), M += _ & (1 << B) - 1, _ >>>= B, S -= B), S < 15 && (_ += z[d++] << S, S += 8, _ += z[d++] << S, S += 8), N = C[_ & O];
                  n:
                    for (; ; ) {
                      if (B = N >>> 24, _ >>>= B, S -= B, B = N >>> 16 & 255, B & 16) {
                        if (j = N & 65535, B &= 15, S < B && (_ += z[d++] << S, S += 8, S < B && (_ += z[d++] << S, S += 8)), j += _ & (1 << B) - 1, j > p) {
                          l.msg = "invalid distance too far back", c.mode = s;
                          break e;
                        }
                        if (_ >>>= B, S -= B, B = v - y, j > B) {
                          if (B = j - B, B > g && c.sane) {
                            l.msg = "invalid distance too far back", c.mode = s;
                            break e;
                          }
                          if (q = 0, X = w, m === 0) {
                            if (q += f - B, B < M) {
                              M -= B;
                              do
                                U[v++] = w[q++];
                              while (--B);
                              q = v - j, X = U;
                            }
                          } else if (m < B) {
                            if (q += f + m - B, B -= m, B < M) {
                              M -= B;
                              do
                                U[v++] = w[q++];
                              while (--B);
                              if (q = 0, m < M) {
                                B = m, M -= B;
                                do
                                  U[v++] = w[q++];
                                while (--B);
                                q = v - j, X = U;
                              }
                            }
                          } else if (q += m - B, B < M) {
                            M -= B;
                            do
                              U[v++] = w[q++];
                            while (--B);
                            q = v - j, X = U;
                          }
                          for (; M > 2; )
                            U[v++] = X[q++], U[v++] = X[q++], U[v++] = X[q++], M -= 3;
                          M && (U[v++] = X[q++], M > 1 && (U[v++] = X[q++]));
                        } else {
                          q = v - j;
                          do
                            U[v++] = U[q++], U[v++] = U[q++], U[v++] = U[q++], M -= 3;
                          while (M > 2);
                          M && (U[v++] = U[q++], M > 1 && (U[v++] = U[q++]));
                        }
                      } else if (B & 64) {
                        l.msg = "invalid distance code", c.mode = s;
                        break e;
                      } else {
                        N = C[(N & 65535) + (_ & (1 << B) - 1)];
                        continue n;
                      }
                      break;
                    }
                } else if (B & 64)
                  if (B & 32) {
                    c.mode = o;
                    break e;
                  } else {
                    l.msg = "invalid literal/length code", c.mode = s;
                    break e;
                  }
                else {
                  N = A[(N & 65535) + (_ & (1 << B) - 1)];
                  continue t;
                }
                break;
              }
          } while (d < h && v < b);
        M = S >> 3, d -= M, S -= M << 3, _ &= (1 << S) - 1, l.next_in = d, l.next_out = v, l.avail_in = d < h ? 5 + (h - d) : 5 - (d - h), l.avail_out = v < b ? 257 + (b - v) : 257 - (v - b), c.hold = _, c.bits = S;
      };
    }, {}], 49: [function(n, r, i) {
      var s = n("../utils/common"), o = n("./adler32"), a = n("./crc32"), l = n("./inffast"), u = n("./inftrees"), c = 0, d = 1, h = 2, v = 4, y = 5, b = 6, p = 0, f = 1, g = 2, m = -2, w = -3, _ = -4, S = -5, A = 8, C = 1, k = 2, O = 3, N = 4, B = 5, M = 6, j = 7, q = 8, X = 9, z = 10, U = 11, H = 12, re = 13, fe = 14, J = 15, le = 16, ce = 17, ge = 18, _e = 19, je = 20, Te = 21, Ze = 22, Le = 23, Ke = 24, ct = 25, nt = 26, Et = 27, yt = 28, Nt = 29, ot = 30, bt = 31, $t = 32, wt = 852, xt = 592, lt = 15, qe = lt;
      function Rt(G) {
        return (G >>> 24 & 255) + (G >>> 8 & 65280) + ((G & 65280) << 8) + ((G & 255) << 24);
      }
      function we() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new s.Buf16(320), this.work = new s.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function Ue(G) {
        var ue;
        return !G || !G.state ? m : (ue = G.state, G.total_in = G.total_out = ue.total = 0, G.msg = "", ue.wrap && (G.adler = ue.wrap & 1), ue.mode = C, ue.last = 0, ue.havedict = 0, ue.dmax = 32768, ue.head = null, ue.hold = 0, ue.bits = 0, ue.lencode = ue.lendyn = new s.Buf32(wt), ue.distcode = ue.distdyn = new s.Buf32(xt), ue.sane = 1, ue.back = -1, p);
      }
      function at(G) {
        var ue;
        return !G || !G.state ? m : (ue = G.state, ue.wsize = 0, ue.whave = 0, ue.wnext = 0, Ue(G));
      }
      function Pt(G, ue) {
        var T, L;
        return !G || !G.state || (L = G.state, ue < 0 ? (T = 0, ue = -ue) : (T = (ue >> 4) + 1, ue < 48 && (ue &= 15)), ue && (ue < 8 || ue > 15)) ? m : (L.window !== null && L.wbits !== ue && (L.window = null), L.wrap = T, L.wbits = ue, at(G));
      }
      function Qt(G, ue) {
        var T, L;
        return G ? (L = new we(), G.state = L, L.window = null, T = Pt(G, ue), T !== p && (G.state = null), T) : m;
      }
      function Ie(G) {
        return Qt(G, qe);
      }
      var Ve = !0, Je, He;
      function Qe(G) {
        if (Ve) {
          var ue;
          for (Je = new s.Buf32(512), He = new s.Buf32(32), ue = 0; ue < 144; )
            G.lens[ue++] = 8;
          for (; ue < 256; )
            G.lens[ue++] = 9;
          for (; ue < 280; )
            G.lens[ue++] = 7;
          for (; ue < 288; )
            G.lens[ue++] = 8;
          for (u(d, G.lens, 0, 288, Je, 0, G.work, { bits: 9 }), ue = 0; ue < 32; )
            G.lens[ue++] = 5;
          u(h, G.lens, 0, 32, He, 0, G.work, { bits: 5 }), Ve = !1;
        }
        G.lencode = Je, G.lenbits = 9, G.distcode = He, G.distbits = 5;
      }
      function At(G, ue, T, L) {
        var oe, E = G.state;
        return E.window === null && (E.wsize = 1 << E.wbits, E.wnext = 0, E.whave = 0, E.window = new s.Buf8(E.wsize)), L >= E.wsize ? (s.arraySet(E.window, ue, T - E.wsize, E.wsize, 0), E.wnext = 0, E.whave = E.wsize) : (oe = E.wsize - E.wnext, oe > L && (oe = L), s.arraySet(E.window, ue, T - L, oe, E.wnext), L -= oe, L ? (s.arraySet(E.window, ue, T - L, L, 0), E.wnext = L, E.whave = E.wsize) : (E.wnext += oe, E.wnext === E.wsize && (E.wnext = 0), E.whave < E.wsize && (E.whave += oe))), 0;
      }
      function P(G, ue) {
        var T, L, oe, E, Q, ie, I, W, ne, Pe, Oe, De, Ye, ln, Wt = 0, pt, Zt, fn, xn, es, ts, Jt, Dn, un = new s.Buf8(4), ar, Qn, da = (
          /* permutation of code lengths */
          [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
        );
        if (!G || !G.state || !G.output || !G.input && G.avail_in !== 0)
          return m;
        T = G.state, T.mode === H && (T.mode = re), Q = G.next_out, oe = G.output, I = G.avail_out, E = G.next_in, L = G.input, ie = G.avail_in, W = T.hold, ne = T.bits, Pe = ie, Oe = I, Dn = p;
        e:
          for (; ; )
            switch (T.mode) {
              case C:
                if (T.wrap === 0) {
                  T.mode = re;
                  break;
                }
                for (; ne < 16; ) {
                  if (ie === 0)
                    break e;
                  ie--, W += L[E++] << ne, ne += 8;
                }
                if (T.wrap & 2 && W === 35615) {
                  T.check = 0, un[0] = W & 255, un[1] = W >>> 8 & 255, T.check = a(T.check, un, 2, 0), W = 0, ne = 0, T.mode = k;
                  break;
                }
                if (T.flags = 0, T.head && (T.head.done = !1), !(T.wrap & 1) || /* check if zlib header allowed */
                (((W & 255) << 8) + (W >> 8)) % 31) {
                  G.msg = "incorrect header check", T.mode = ot;
                  break;
                }
                if ((W & 15) !== A) {
                  G.msg = "unknown compression method", T.mode = ot;
                  break;
                }
                if (W >>>= 4, ne -= 4, Jt = (W & 15) + 8, T.wbits === 0)
                  T.wbits = Jt;
                else if (Jt > T.wbits) {
                  G.msg = "invalid window size", T.mode = ot;
                  break;
                }
                T.dmax = 1 << Jt, G.adler = T.check = 1, T.mode = W & 512 ? z : H, W = 0, ne = 0;
                break;
              case k:
                for (; ne < 16; ) {
                  if (ie === 0)
                    break e;
                  ie--, W += L[E++] << ne, ne += 8;
                }
                if (T.flags = W, (T.flags & 255) !== A) {
                  G.msg = "unknown compression method", T.mode = ot;
                  break;
                }
                if (T.flags & 57344) {
                  G.msg = "unknown header flags set", T.mode = ot;
                  break;
                }
                T.head && (T.head.text = W >> 8 & 1), T.flags & 512 && (un[0] = W & 255, un[1] = W >>> 8 & 255, T.check = a(T.check, un, 2, 0)), W = 0, ne = 0, T.mode = O;
              case O:
                for (; ne < 32; ) {
                  if (ie === 0)
                    break e;
                  ie--, W += L[E++] << ne, ne += 8;
                }
                T.head && (T.head.time = W), T.flags & 512 && (un[0] = W & 255, un[1] = W >>> 8 & 255, un[2] = W >>> 16 & 255, un[3] = W >>> 24 & 255, T.check = a(T.check, un, 4, 0)), W = 0, ne = 0, T.mode = N;
              case N:
                for (; ne < 16; ) {
                  if (ie === 0)
                    break e;
                  ie--, W += L[E++] << ne, ne += 8;
                }
                T.head && (T.head.xflags = W & 255, T.head.os = W >> 8), T.flags & 512 && (un[0] = W & 255, un[1] = W >>> 8 & 255, T.check = a(T.check, un, 2, 0)), W = 0, ne = 0, T.mode = B;
              case B:
                if (T.flags & 1024) {
                  for (; ne < 16; ) {
                    if (ie === 0)
                      break e;
                    ie--, W += L[E++] << ne, ne += 8;
                  }
                  T.length = W, T.head && (T.head.extra_len = W), T.flags & 512 && (un[0] = W & 255, un[1] = W >>> 8 & 255, T.check = a(T.check, un, 2, 0)), W = 0, ne = 0;
                } else
                  T.head && (T.head.extra = null);
                T.mode = M;
              case M:
                if (T.flags & 1024 && (De = T.length, De > ie && (De = ie), De && (T.head && (Jt = T.head.extra_len - T.length, T.head.extra || (T.head.extra = new Array(T.head.extra_len)), s.arraySet(
                  T.head.extra,
                  L,
                  E,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  De,
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  Jt
                )), T.flags & 512 && (T.check = a(T.check, L, De, E)), ie -= De, E += De, T.length -= De), T.length))
                  break e;
                T.length = 0, T.mode = j;
              case j:
                if (T.flags & 2048) {
                  if (ie === 0)
                    break e;
                  De = 0;
                  do
                    Jt = L[E + De++], T.head && Jt && T.length < 65536 && (T.head.name += String.fromCharCode(Jt));
                  while (Jt && De < ie);
                  if (T.flags & 512 && (T.check = a(T.check, L, De, E)), ie -= De, E += De, Jt)
                    break e;
                } else
                  T.head && (T.head.name = null);
                T.length = 0, T.mode = q;
              case q:
                if (T.flags & 4096) {
                  if (ie === 0)
                    break e;
                  De = 0;
                  do
                    Jt = L[E + De++], T.head && Jt && T.length < 65536 && (T.head.comment += String.fromCharCode(Jt));
                  while (Jt && De < ie);
                  if (T.flags & 512 && (T.check = a(T.check, L, De, E)), ie -= De, E += De, Jt)
                    break e;
                } else
                  T.head && (T.head.comment = null);
                T.mode = X;
              case X:
                if (T.flags & 512) {
                  for (; ne < 16; ) {
                    if (ie === 0)
                      break e;
                    ie--, W += L[E++] << ne, ne += 8;
                  }
                  if (W !== (T.check & 65535)) {
                    G.msg = "header crc mismatch", T.mode = ot;
                    break;
                  }
                  W = 0, ne = 0;
                }
                T.head && (T.head.hcrc = T.flags >> 9 & 1, T.head.done = !0), G.adler = T.check = 0, T.mode = H;
                break;
              case z:
                for (; ne < 32; ) {
                  if (ie === 0)
                    break e;
                  ie--, W += L[E++] << ne, ne += 8;
                }
                G.adler = T.check = Rt(W), W = 0, ne = 0, T.mode = U;
              case U:
                if (T.havedict === 0)
                  return G.next_out = Q, G.avail_out = I, G.next_in = E, G.avail_in = ie, T.hold = W, T.bits = ne, g;
                G.adler = T.check = 1, T.mode = H;
              case H:
                if (ue === y || ue === b)
                  break e;
              case re:
                if (T.last) {
                  W >>>= ne & 7, ne -= ne & 7, T.mode = Et;
                  break;
                }
                for (; ne < 3; ) {
                  if (ie === 0)
                    break e;
                  ie--, W += L[E++] << ne, ne += 8;
                }
                switch (T.last = W & 1, W >>>= 1, ne -= 1, W & 3) {
                  case 0:
                    T.mode = fe;
                    break;
                  case 1:
                    if (Qe(T), T.mode = je, ue === b) {
                      W >>>= 2, ne -= 2;
                      break e;
                    }
                    break;
                  case 2:
                    T.mode = ce;
                    break;
                  case 3:
                    G.msg = "invalid block type", T.mode = ot;
                }
                W >>>= 2, ne -= 2;
                break;
              case fe:
                for (W >>>= ne & 7, ne -= ne & 7; ne < 32; ) {
                  if (ie === 0)
                    break e;
                  ie--, W += L[E++] << ne, ne += 8;
                }
                if ((W & 65535) !== (W >>> 16 ^ 65535)) {
                  G.msg = "invalid stored block lengths", T.mode = ot;
                  break;
                }
                if (T.length = W & 65535, W = 0, ne = 0, T.mode = J, ue === b)
                  break e;
              case J:
                T.mode = le;
              case le:
                if (De = T.length, De) {
                  if (De > ie && (De = ie), De > I && (De = I), De === 0)
                    break e;
                  s.arraySet(oe, L, E, De, Q), ie -= De, E += De, I -= De, Q += De, T.length -= De;
                  break;
                }
                T.mode = H;
                break;
              case ce:
                for (; ne < 14; ) {
                  if (ie === 0)
                    break e;
                  ie--, W += L[E++] << ne, ne += 8;
                }
                if (T.nlen = (W & 31) + 257, W >>>= 5, ne -= 5, T.ndist = (W & 31) + 1, W >>>= 5, ne -= 5, T.ncode = (W & 15) + 4, W >>>= 4, ne -= 4, T.nlen > 286 || T.ndist > 30) {
                  G.msg = "too many length or distance symbols", T.mode = ot;
                  break;
                }
                T.have = 0, T.mode = ge;
              case ge:
                for (; T.have < T.ncode; ) {
                  for (; ne < 3; ) {
                    if (ie === 0)
                      break e;
                    ie--, W += L[E++] << ne, ne += 8;
                  }
                  T.lens[da[T.have++]] = W & 7, W >>>= 3, ne -= 3;
                }
                for (; T.have < 19; )
                  T.lens[da[T.have++]] = 0;
                if (T.lencode = T.lendyn, T.lenbits = 7, ar = { bits: T.lenbits }, Dn = u(c, T.lens, 0, 19, T.lencode, 0, T.work, ar), T.lenbits = ar.bits, Dn) {
                  G.msg = "invalid code lengths set", T.mode = ot;
                  break;
                }
                T.have = 0, T.mode = _e;
              case _e:
                for (; T.have < T.nlen + T.ndist; ) {
                  for (; Wt = T.lencode[W & (1 << T.lenbits) - 1], pt = Wt >>> 24, Zt = Wt >>> 16 & 255, fn = Wt & 65535, !(pt <= ne); ) {
                    if (ie === 0)
                      break e;
                    ie--, W += L[E++] << ne, ne += 8;
                  }
                  if (fn < 16)
                    W >>>= pt, ne -= pt, T.lens[T.have++] = fn;
                  else {
                    if (fn === 16) {
                      for (Qn = pt + 2; ne < Qn; ) {
                        if (ie === 0)
                          break e;
                        ie--, W += L[E++] << ne, ne += 8;
                      }
                      if (W >>>= pt, ne -= pt, T.have === 0) {
                        G.msg = "invalid bit length repeat", T.mode = ot;
                        break;
                      }
                      Jt = T.lens[T.have - 1], De = 3 + (W & 3), W >>>= 2, ne -= 2;
                    } else if (fn === 17) {
                      for (Qn = pt + 3; ne < Qn; ) {
                        if (ie === 0)
                          break e;
                        ie--, W += L[E++] << ne, ne += 8;
                      }
                      W >>>= pt, ne -= pt, Jt = 0, De = 3 + (W & 7), W >>>= 3, ne -= 3;
                    } else {
                      for (Qn = pt + 7; ne < Qn; ) {
                        if (ie === 0)
                          break e;
                        ie--, W += L[E++] << ne, ne += 8;
                      }
                      W >>>= pt, ne -= pt, Jt = 0, De = 11 + (W & 127), W >>>= 7, ne -= 7;
                    }
                    if (T.have + De > T.nlen + T.ndist) {
                      G.msg = "invalid bit length repeat", T.mode = ot;
                      break;
                    }
                    for (; De--; )
                      T.lens[T.have++] = Jt;
                  }
                }
                if (T.mode === ot)
                  break;
                if (T.lens[256] === 0) {
                  G.msg = "invalid code -- missing end-of-block", T.mode = ot;
                  break;
                }
                if (T.lenbits = 9, ar = { bits: T.lenbits }, Dn = u(d, T.lens, 0, T.nlen, T.lencode, 0, T.work, ar), T.lenbits = ar.bits, Dn) {
                  G.msg = "invalid literal/lengths set", T.mode = ot;
                  break;
                }
                if (T.distbits = 6, T.distcode = T.distdyn, ar = { bits: T.distbits }, Dn = u(h, T.lens, T.nlen, T.ndist, T.distcode, 0, T.work, ar), T.distbits = ar.bits, Dn) {
                  G.msg = "invalid distances set", T.mode = ot;
                  break;
                }
                if (T.mode = je, ue === b)
                  break e;
              case je:
                T.mode = Te;
              case Te:
                if (ie >= 6 && I >= 258) {
                  G.next_out = Q, G.avail_out = I, G.next_in = E, G.avail_in = ie, T.hold = W, T.bits = ne, l(G, Oe), Q = G.next_out, oe = G.output, I = G.avail_out, E = G.next_in, L = G.input, ie = G.avail_in, W = T.hold, ne = T.bits, T.mode === H && (T.back = -1);
                  break;
                }
                for (T.back = 0; Wt = T.lencode[W & (1 << T.lenbits) - 1], pt = Wt >>> 24, Zt = Wt >>> 16 & 255, fn = Wt & 65535, !(pt <= ne); ) {
                  if (ie === 0)
                    break e;
                  ie--, W += L[E++] << ne, ne += 8;
                }
                if (Zt && !(Zt & 240)) {
                  for (xn = pt, es = Zt, ts = fn; Wt = T.lencode[ts + ((W & (1 << xn + es) - 1) >> xn)], pt = Wt >>> 24, Zt = Wt >>> 16 & 255, fn = Wt & 65535, !(xn + pt <= ne); ) {
                    if (ie === 0)
                      break e;
                    ie--, W += L[E++] << ne, ne += 8;
                  }
                  W >>>= xn, ne -= xn, T.back += xn;
                }
                if (W >>>= pt, ne -= pt, T.back += pt, T.length = fn, Zt === 0) {
                  T.mode = nt;
                  break;
                }
                if (Zt & 32) {
                  T.back = -1, T.mode = H;
                  break;
                }
                if (Zt & 64) {
                  G.msg = "invalid literal/length code", T.mode = ot;
                  break;
                }
                T.extra = Zt & 15, T.mode = Ze;
              case Ze:
                if (T.extra) {
                  for (Qn = T.extra; ne < Qn; ) {
                    if (ie === 0)
                      break e;
                    ie--, W += L[E++] << ne, ne += 8;
                  }
                  T.length += W & (1 << T.extra) - 1, W >>>= T.extra, ne -= T.extra, T.back += T.extra;
                }
                T.was = T.length, T.mode = Le;
              case Le:
                for (; Wt = T.distcode[W & (1 << T.distbits) - 1], pt = Wt >>> 24, Zt = Wt >>> 16 & 255, fn = Wt & 65535, !(pt <= ne); ) {
                  if (ie === 0)
                    break e;
                  ie--, W += L[E++] << ne, ne += 8;
                }
                if (!(Zt & 240)) {
                  for (xn = pt, es = Zt, ts = fn; Wt = T.distcode[ts + ((W & (1 << xn + es) - 1) >> xn)], pt = Wt >>> 24, Zt = Wt >>> 16 & 255, fn = Wt & 65535, !(xn + pt <= ne); ) {
                    if (ie === 0)
                      break e;
                    ie--, W += L[E++] << ne, ne += 8;
                  }
                  W >>>= xn, ne -= xn, T.back += xn;
                }
                if (W >>>= pt, ne -= pt, T.back += pt, Zt & 64) {
                  G.msg = "invalid distance code", T.mode = ot;
                  break;
                }
                T.offset = fn, T.extra = Zt & 15, T.mode = Ke;
              case Ke:
                if (T.extra) {
                  for (Qn = T.extra; ne < Qn; ) {
                    if (ie === 0)
                      break e;
                    ie--, W += L[E++] << ne, ne += 8;
                  }
                  T.offset += W & (1 << T.extra) - 1, W >>>= T.extra, ne -= T.extra, T.back += T.extra;
                }
                if (T.offset > T.dmax) {
                  G.msg = "invalid distance too far back", T.mode = ot;
                  break;
                }
                T.mode = ct;
              case ct:
                if (I === 0)
                  break e;
                if (De = Oe - I, T.offset > De) {
                  if (De = T.offset - De, De > T.whave && T.sane) {
                    G.msg = "invalid distance too far back", T.mode = ot;
                    break;
                  }
                  De > T.wnext ? (De -= T.wnext, Ye = T.wsize - De) : Ye = T.wnext - De, De > T.length && (De = T.length), ln = T.window;
                } else
                  ln = oe, Ye = Q - T.offset, De = T.length;
                De > I && (De = I), I -= De, T.length -= De;
                do
                  oe[Q++] = ln[Ye++];
                while (--De);
                T.length === 0 && (T.mode = Te);
                break;
              case nt:
                if (I === 0)
                  break e;
                oe[Q++] = T.length, I--, T.mode = Te;
                break;
              case Et:
                if (T.wrap) {
                  for (; ne < 32; ) {
                    if (ie === 0)
                      break e;
                    ie--, W |= L[E++] << ne, ne += 8;
                  }
                  if (Oe -= I, G.total_out += Oe, T.total += Oe, Oe && (G.adler = T.check = /*UPDATE(state.check, put - _out, _out);*/
                  T.flags ? a(T.check, oe, Oe, Q - Oe) : o(T.check, oe, Oe, Q - Oe)), Oe = I, (T.flags ? W : Rt(W)) !== T.check) {
                    G.msg = "incorrect data check", T.mode = ot;
                    break;
                  }
                  W = 0, ne = 0;
                }
                T.mode = yt;
              case yt:
                if (T.wrap && T.flags) {
                  for (; ne < 32; ) {
                    if (ie === 0)
                      break e;
                    ie--, W += L[E++] << ne, ne += 8;
                  }
                  if (W !== (T.total & 4294967295)) {
                    G.msg = "incorrect length check", T.mode = ot;
                    break;
                  }
                  W = 0, ne = 0;
                }
                T.mode = Nt;
              case Nt:
                Dn = f;
                break e;
              case ot:
                Dn = w;
                break e;
              case bt:
                return _;
              case $t:
              default:
                return m;
            }
        return G.next_out = Q, G.avail_out = I, G.next_in = E, G.avail_in = ie, T.hold = W, T.bits = ne, (T.wsize || Oe !== G.avail_out && T.mode < ot && (T.mode < Et || ue !== v)) && At(G, G.output, G.next_out, Oe - G.avail_out), Pe -= G.avail_in, Oe -= G.avail_out, G.total_in += Pe, G.total_out += Oe, T.total += Oe, T.wrap && Oe && (G.adler = T.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        T.flags ? a(T.check, oe, Oe, G.next_out - Oe) : o(T.check, oe, Oe, G.next_out - Oe)), G.data_type = T.bits + (T.last ? 64 : 0) + (T.mode === H ? 128 : 0) + (T.mode === je || T.mode === J ? 256 : 0), (Pe === 0 && Oe === 0 || ue === v) && Dn === p && (Dn = S), Dn;
      }
      function he(G) {
        if (!G || !G.state)
          return m;
        var ue = G.state;
        return ue.window && (ue.window = null), G.state = null, p;
      }
      function me(G, ue) {
        var T;
        return !G || !G.state || (T = G.state, !(T.wrap & 2)) ? m : (T.head = ue, ue.done = !1, p);
      }
      function Ne(G, ue) {
        var T = ue.length, L, oe, E;
        return !G || !G.state || (L = G.state, L.wrap !== 0 && L.mode !== U) ? m : L.mode === U && (oe = 1, oe = o(oe, ue, T, 0), oe !== L.check) ? w : (E = At(G, ue, T, T), E ? (L.mode = bt, _) : (L.havedict = 1, p));
      }
      i.inflateReset = at, i.inflateReset2 = Pt, i.inflateResetKeep = Ue, i.inflateInit = Ie, i.inflateInit2 = Qt, i.inflate = P, i.inflateEnd = he, i.inflateGetHeader = me, i.inflateSetDictionary = Ne, i.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(n, r, i) {
      var s = n("../utils/common"), o = 15, a = 852, l = 592, u = 0, c = 1, d = 2, h = [
        /* Length codes 257..285 base */
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        13,
        15,
        17,
        19,
        23,
        27,
        31,
        35,
        43,
        51,
        59,
        67,
        83,
        99,
        115,
        131,
        163,
        195,
        227,
        258,
        0,
        0
      ], v = [
        /* Length codes 257..285 extra */
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        17,
        17,
        17,
        17,
        18,
        18,
        18,
        18,
        19,
        19,
        19,
        19,
        20,
        20,
        20,
        20,
        21,
        21,
        21,
        21,
        16,
        72,
        78
      ], y = [
        /* Distance codes 0..29 base */
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        13,
        17,
        25,
        33,
        49,
        65,
        97,
        129,
        193,
        257,
        385,
        513,
        769,
        1025,
        1537,
        2049,
        3073,
        4097,
        6145,
        8193,
        12289,
        16385,
        24577,
        0,
        0
      ], b = [
        /* Distance codes 0..29 extra */
        16,
        16,
        16,
        16,
        17,
        17,
        18,
        18,
        19,
        19,
        20,
        20,
        21,
        21,
        22,
        22,
        23,
        23,
        24,
        24,
        25,
        25,
        26,
        26,
        27,
        27,
        28,
        28,
        29,
        29,
        64,
        64
      ];
      r.exports = function(f, g, m, w, _, S, A, C) {
        var k = C.bits, O = 0, N = 0, B = 0, M = 0, j = 0, q = 0, X = 0, z = 0, U = 0, H = 0, re, fe, J, le, ce, ge = null, _e = 0, je, Te = new s.Buf16(o + 1), Ze = new s.Buf16(o + 1), Le = null, Ke = 0, ct, nt, Et;
        for (O = 0; O <= o; O++)
          Te[O] = 0;
        for (N = 0; N < w; N++)
          Te[g[m + N]]++;
        for (j = k, M = o; M >= 1 && Te[M] === 0; M--)
          ;
        if (j > M && (j = M), M === 0)
          return _[S++] = 1 << 24 | 64 << 16 | 0, _[S++] = 1 << 24 | 64 << 16 | 0, C.bits = 1, 0;
        for (B = 1; B < M && Te[B] === 0; B++)
          ;
        for (j < B && (j = B), z = 1, O = 1; O <= o; O++)
          if (z <<= 1, z -= Te[O], z < 0)
            return -1;
        if (z > 0 && (f === u || M !== 1))
          return -1;
        for (Ze[1] = 0, O = 1; O < o; O++)
          Ze[O + 1] = Ze[O] + Te[O];
        for (N = 0; N < w; N++)
          g[m + N] !== 0 && (A[Ze[g[m + N]]++] = N);
        if (f === u ? (ge = Le = A, je = 19) : f === c ? (ge = h, _e -= 257, Le = v, Ke -= 257, je = 256) : (ge = y, Le = b, je = -1), H = 0, N = 0, O = B, ce = S, q = j, X = 0, J = -1, U = 1 << j, le = U - 1, f === c && U > a || f === d && U > l)
          return 1;
        for (; ; ) {
          ct = O - X, A[N] < je ? (nt = 0, Et = A[N]) : A[N] > je ? (nt = Le[Ke + A[N]], Et = ge[_e + A[N]]) : (nt = 32 + 64, Et = 0), re = 1 << O - X, fe = 1 << q, B = fe;
          do
            fe -= re, _[ce + (H >> X) + fe] = ct << 24 | nt << 16 | Et | 0;
          while (fe !== 0);
          for (re = 1 << O - 1; H & re; )
            re >>= 1;
          if (re !== 0 ? (H &= re - 1, H += re) : H = 0, N++, --Te[O] === 0) {
            if (O === M)
              break;
            O = g[m + A[N]];
          }
          if (O > j && (H & le) !== J) {
            for (X === 0 && (X = j), ce += B, q = O - X, z = 1 << q; q + X < M && (z -= Te[q + X], !(z <= 0)); )
              q++, z <<= 1;
            if (U += 1 << q, f === c && U > a || f === d && U > l)
              return 1;
            J = H & le, _[J] = j << 24 | q << 16 | ce - S | 0;
          }
        }
        return H !== 0 && (_[ce + H] = O - X << 24 | 64 << 16 | 0), C.bits = j, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(n, r, i) {
      r.exports = {
        2: "need dictionary",
        /* Z_NEED_DICT       2  */
        1: "stream end",
        /* Z_STREAM_END      1  */
        0: "",
        /* Z_OK              0  */
        "-1": "file error",
        /* Z_ERRNO         (-1) */
        "-2": "stream error",
        /* Z_STREAM_ERROR  (-2) */
        "-3": "data error",
        /* Z_DATA_ERROR    (-3) */
        "-4": "insufficient memory",
        /* Z_MEM_ERROR     (-4) */
        "-5": "buffer error",
        /* Z_BUF_ERROR     (-5) */
        "-6": "incompatible version"
        /* Z_VERSION_ERROR (-6) */
      };
    }, {}], 52: [function(n, r, i) {
      var s = n("../utils/common"), o = 4, a = 0, l = 1, u = 2;
      function c(P) {
        for (var he = P.length; --he >= 0; )
          P[he] = 0;
      }
      var d = 0, h = 1, v = 2, y = 3, b = 258, p = 29, f = 256, g = f + 1 + p, m = 30, w = 19, _ = 2 * g + 1, S = 15, A = 16, C = 7, k = 256, O = 16, N = 17, B = 18, M = (
        /* extra bits for each length code */
        [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
      ), j = (
        /* extra bits for each distance code */
        [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
      ), q = (
        /* extra bits for each bit length code */
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
      ), X = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = 512, U = new Array((g + 2) * 2);
      c(U);
      var H = new Array(m * 2);
      c(H);
      var re = new Array(z);
      c(re);
      var fe = new Array(b - y + 1);
      c(fe);
      var J = new Array(p);
      c(J);
      var le = new Array(m);
      c(le);
      function ce(P, he, me, Ne, G) {
        this.static_tree = P, this.extra_bits = he, this.extra_base = me, this.elems = Ne, this.max_length = G, this.has_stree = P && P.length;
      }
      var ge, _e, je;
      function Te(P, he) {
        this.dyn_tree = P, this.max_code = 0, this.stat_desc = he;
      }
      function Ze(P) {
        return P < 256 ? re[P] : re[256 + (P >>> 7)];
      }
      function Le(P, he) {
        P.pending_buf[P.pending++] = he & 255, P.pending_buf[P.pending++] = he >>> 8 & 255;
      }
      function Ke(P, he, me) {
        P.bi_valid > A - me ? (P.bi_buf |= he << P.bi_valid & 65535, Le(P, P.bi_buf), P.bi_buf = he >> A - P.bi_valid, P.bi_valid += me - A) : (P.bi_buf |= he << P.bi_valid & 65535, P.bi_valid += me);
      }
      function ct(P, he, me) {
        Ke(
          P,
          me[he * 2],
          me[he * 2 + 1]
          /*.Len*/
        );
      }
      function nt(P, he) {
        var me = 0;
        do
          me |= P & 1, P >>>= 1, me <<= 1;
        while (--he > 0);
        return me >>> 1;
      }
      function Et(P) {
        P.bi_valid === 16 ? (Le(P, P.bi_buf), P.bi_buf = 0, P.bi_valid = 0) : P.bi_valid >= 8 && (P.pending_buf[P.pending++] = P.bi_buf & 255, P.bi_buf >>= 8, P.bi_valid -= 8);
      }
      function yt(P, he) {
        var me = he.dyn_tree, Ne = he.max_code, G = he.stat_desc.static_tree, ue = he.stat_desc.has_stree, T = he.stat_desc.extra_bits, L = he.stat_desc.extra_base, oe = he.stat_desc.max_length, E, Q, ie, I, W, ne, Pe = 0;
        for (I = 0; I <= S; I++)
          P.bl_count[I] = 0;
        for (me[P.heap[P.heap_max] * 2 + 1] = 0, E = P.heap_max + 1; E < _; E++)
          Q = P.heap[E], I = me[me[Q * 2 + 1] * 2 + 1] + 1, I > oe && (I = oe, Pe++), me[Q * 2 + 1] = I, !(Q > Ne) && (P.bl_count[I]++, W = 0, Q >= L && (W = T[Q - L]), ne = me[Q * 2], P.opt_len += ne * (I + W), ue && (P.static_len += ne * (G[Q * 2 + 1] + W)));
        if (Pe !== 0) {
          do {
            for (I = oe - 1; P.bl_count[I] === 0; )
              I--;
            P.bl_count[I]--, P.bl_count[I + 1] += 2, P.bl_count[oe]--, Pe -= 2;
          } while (Pe > 0);
          for (I = oe; I !== 0; I--)
            for (Q = P.bl_count[I]; Q !== 0; )
              ie = P.heap[--E], !(ie > Ne) && (me[ie * 2 + 1] !== I && (P.opt_len += (I - me[ie * 2 + 1]) * me[ie * 2], me[ie * 2 + 1] = I), Q--);
        }
      }
      function Nt(P, he, me) {
        var Ne = new Array(S + 1), G = 0, ue, T;
        for (ue = 1; ue <= S; ue++)
          Ne[ue] = G = G + me[ue - 1] << 1;
        for (T = 0; T <= he; T++) {
          var L = P[T * 2 + 1];
          L !== 0 && (P[T * 2] = nt(Ne[L]++, L));
        }
      }
      function ot() {
        var P, he, me, Ne, G, ue = new Array(S + 1);
        for (me = 0, Ne = 0; Ne < p - 1; Ne++)
          for (J[Ne] = me, P = 0; P < 1 << M[Ne]; P++)
            fe[me++] = Ne;
        for (fe[me - 1] = Ne, G = 0, Ne = 0; Ne < 16; Ne++)
          for (le[Ne] = G, P = 0; P < 1 << j[Ne]; P++)
            re[G++] = Ne;
        for (G >>= 7; Ne < m; Ne++)
          for (le[Ne] = G << 7, P = 0; P < 1 << j[Ne] - 7; P++)
            re[256 + G++] = Ne;
        for (he = 0; he <= S; he++)
          ue[he] = 0;
        for (P = 0; P <= 143; )
          U[P * 2 + 1] = 8, P++, ue[8]++;
        for (; P <= 255; )
          U[P * 2 + 1] = 9, P++, ue[9]++;
        for (; P <= 279; )
          U[P * 2 + 1] = 7, P++, ue[7]++;
        for (; P <= 287; )
          U[P * 2 + 1] = 8, P++, ue[8]++;
        for (Nt(U, g + 1, ue), P = 0; P < m; P++)
          H[P * 2 + 1] = 5, H[P * 2] = nt(P, 5);
        ge = new ce(U, M, f + 1, g, S), _e = new ce(H, j, 0, m, S), je = new ce(new Array(0), q, 0, w, C);
      }
      function bt(P) {
        var he;
        for (he = 0; he < g; he++)
          P.dyn_ltree[he * 2] = 0;
        for (he = 0; he < m; he++)
          P.dyn_dtree[he * 2] = 0;
        for (he = 0; he < w; he++)
          P.bl_tree[he * 2] = 0;
        P.dyn_ltree[k * 2] = 1, P.opt_len = P.static_len = 0, P.last_lit = P.matches = 0;
      }
      function $t(P) {
        P.bi_valid > 8 ? Le(P, P.bi_buf) : P.bi_valid > 0 && (P.pending_buf[P.pending++] = P.bi_buf), P.bi_buf = 0, P.bi_valid = 0;
      }
      function wt(P, he, me, Ne) {
        $t(P), Ne && (Le(P, me), Le(P, ~me)), s.arraySet(P.pending_buf, P.window, he, me, P.pending), P.pending += me;
      }
      function xt(P, he, me, Ne) {
        var G = he * 2, ue = me * 2;
        return P[G] < P[ue] || P[G] === P[ue] && Ne[he] <= Ne[me];
      }
      function lt(P, he, me) {
        for (var Ne = P.heap[me], G = me << 1; G <= P.heap_len && (G < P.heap_len && xt(he, P.heap[G + 1], P.heap[G], P.depth) && G++, !xt(he, Ne, P.heap[G], P.depth)); )
          P.heap[me] = P.heap[G], me = G, G <<= 1;
        P.heap[me] = Ne;
      }
      function qe(P, he, me) {
        var Ne, G, ue = 0, T, L;
        if (P.last_lit !== 0)
          do
            Ne = P.pending_buf[P.d_buf + ue * 2] << 8 | P.pending_buf[P.d_buf + ue * 2 + 1], G = P.pending_buf[P.l_buf + ue], ue++, Ne === 0 ? ct(P, G, he) : (T = fe[G], ct(P, T + f + 1, he), L = M[T], L !== 0 && (G -= J[T], Ke(P, G, L)), Ne--, T = Ze(Ne), ct(P, T, me), L = j[T], L !== 0 && (Ne -= le[T], Ke(P, Ne, L)));
          while (ue < P.last_lit);
        ct(P, k, he);
      }
      function Rt(P, he) {
        var me = he.dyn_tree, Ne = he.stat_desc.static_tree, G = he.stat_desc.has_stree, ue = he.stat_desc.elems, T, L, oe = -1, E;
        for (P.heap_len = 0, P.heap_max = _, T = 0; T < ue; T++)
          me[T * 2] !== 0 ? (P.heap[++P.heap_len] = oe = T, P.depth[T] = 0) : me[T * 2 + 1] = 0;
        for (; P.heap_len < 2; )
          E = P.heap[++P.heap_len] = oe < 2 ? ++oe : 0, me[E * 2] = 1, P.depth[E] = 0, P.opt_len--, G && (P.static_len -= Ne[E * 2 + 1]);
        for (he.max_code = oe, T = P.heap_len >> 1; T >= 1; T--)
          lt(P, me, T);
        E = ue;
        do
          T = P.heap[
            1
            /*SMALLEST*/
          ], P.heap[
            1
            /*SMALLEST*/
          ] = P.heap[P.heap_len--], lt(
            P,
            me,
            1
            /*SMALLEST*/
          ), L = P.heap[
            1
            /*SMALLEST*/
          ], P.heap[--P.heap_max] = T, P.heap[--P.heap_max] = L, me[E * 2] = me[T * 2] + me[L * 2], P.depth[E] = (P.depth[T] >= P.depth[L] ? P.depth[T] : P.depth[L]) + 1, me[T * 2 + 1] = me[L * 2 + 1] = E, P.heap[
            1
            /*SMALLEST*/
          ] = E++, lt(
            P,
            me,
            1
            /*SMALLEST*/
          );
        while (P.heap_len >= 2);
        P.heap[--P.heap_max] = P.heap[
          1
          /*SMALLEST*/
        ], yt(P, he), Nt(me, oe, P.bl_count);
      }
      function we(P, he, me) {
        var Ne, G = -1, ue, T = he[0 * 2 + 1], L = 0, oe = 7, E = 4;
        for (T === 0 && (oe = 138, E = 3), he[(me + 1) * 2 + 1] = 65535, Ne = 0; Ne <= me; Ne++)
          ue = T, T = he[(Ne + 1) * 2 + 1], !(++L < oe && ue === T) && (L < E ? P.bl_tree[ue * 2] += L : ue !== 0 ? (ue !== G && P.bl_tree[ue * 2]++, P.bl_tree[O * 2]++) : L <= 10 ? P.bl_tree[N * 2]++ : P.bl_tree[B * 2]++, L = 0, G = ue, T === 0 ? (oe = 138, E = 3) : ue === T ? (oe = 6, E = 3) : (oe = 7, E = 4));
      }
      function Ue(P, he, me) {
        var Ne, G = -1, ue, T = he[0 * 2 + 1], L = 0, oe = 7, E = 4;
        for (T === 0 && (oe = 138, E = 3), Ne = 0; Ne <= me; Ne++)
          if (ue = T, T = he[(Ne + 1) * 2 + 1], !(++L < oe && ue === T)) {
            if (L < E)
              do
                ct(P, ue, P.bl_tree);
              while (--L !== 0);
            else
              ue !== 0 ? (ue !== G && (ct(P, ue, P.bl_tree), L--), ct(P, O, P.bl_tree), Ke(P, L - 3, 2)) : L <= 10 ? (ct(P, N, P.bl_tree), Ke(P, L - 3, 3)) : (ct(P, B, P.bl_tree), Ke(P, L - 11, 7));
            L = 0, G = ue, T === 0 ? (oe = 138, E = 3) : ue === T ? (oe = 6, E = 3) : (oe = 7, E = 4);
          }
      }
      function at(P) {
        var he;
        for (we(P, P.dyn_ltree, P.l_desc.max_code), we(P, P.dyn_dtree, P.d_desc.max_code), Rt(P, P.bl_desc), he = w - 1; he >= 3 && P.bl_tree[X[he] * 2 + 1] === 0; he--)
          ;
        return P.opt_len += 3 * (he + 1) + 5 + 5 + 4, he;
      }
      function Pt(P, he, me, Ne) {
        var G;
        for (Ke(P, he - 257, 5), Ke(P, me - 1, 5), Ke(P, Ne - 4, 4), G = 0; G < Ne; G++)
          Ke(P, P.bl_tree[X[G] * 2 + 1], 3);
        Ue(P, P.dyn_ltree, he - 1), Ue(P, P.dyn_dtree, me - 1);
      }
      function Qt(P) {
        var he = 4093624447, me;
        for (me = 0; me <= 31; me++, he >>>= 1)
          if (he & 1 && P.dyn_ltree[me * 2] !== 0)
            return a;
        if (P.dyn_ltree[9 * 2] !== 0 || P.dyn_ltree[10 * 2] !== 0 || P.dyn_ltree[13 * 2] !== 0)
          return l;
        for (me = 32; me < f; me++)
          if (P.dyn_ltree[me * 2] !== 0)
            return l;
        return a;
      }
      var Ie = !1;
      function Ve(P) {
        Ie || (ot(), Ie = !0), P.l_desc = new Te(P.dyn_ltree, ge), P.d_desc = new Te(P.dyn_dtree, _e), P.bl_desc = new Te(P.bl_tree, je), P.bi_buf = 0, P.bi_valid = 0, bt(P);
      }
      function Je(P, he, me, Ne) {
        Ke(P, (d << 1) + (Ne ? 1 : 0), 3), wt(P, he, me, !0);
      }
      function He(P) {
        Ke(P, h << 1, 3), ct(P, k, U), Et(P);
      }
      function Qe(P, he, me, Ne) {
        var G, ue, T = 0;
        P.level > 0 ? (P.strm.data_type === u && (P.strm.data_type = Qt(P)), Rt(P, P.l_desc), Rt(P, P.d_desc), T = at(P), G = P.opt_len + 3 + 7 >>> 3, ue = P.static_len + 3 + 7 >>> 3, ue <= G && (G = ue)) : G = ue = me + 5, me + 4 <= G && he !== -1 ? Je(P, he, me, Ne) : P.strategy === o || ue === G ? (Ke(P, (h << 1) + (Ne ? 1 : 0), 3), qe(P, U, H)) : (Ke(P, (v << 1) + (Ne ? 1 : 0), 3), Pt(P, P.l_desc.max_code + 1, P.d_desc.max_code + 1, T + 1), qe(P, P.dyn_ltree, P.dyn_dtree)), bt(P), Ne && $t(P);
      }
      function At(P, he, me) {
        return P.pending_buf[P.d_buf + P.last_lit * 2] = he >>> 8 & 255, P.pending_buf[P.d_buf + P.last_lit * 2 + 1] = he & 255, P.pending_buf[P.l_buf + P.last_lit] = me & 255, P.last_lit++, he === 0 ? P.dyn_ltree[me * 2]++ : (P.matches++, he--, P.dyn_ltree[(fe[me] + f + 1) * 2]++, P.dyn_dtree[Ze(he) * 2]++), P.last_lit === P.lit_bufsize - 1;
      }
      i._tr_init = Ve, i._tr_stored_block = Je, i._tr_flush_block = Qe, i._tr_tally = At, i._tr_align = He;
    }, { "../utils/common": 41 }], 53: [function(n, r, i) {
      function s() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      }
      r.exports = s;
    }, {}], 54: [function(n, r, i) {
      (function(s) {
        (function(o, a) {
          if (o.setImmediate)
            return;
          var l = 1, u = {}, c = !1, d = o.document, h;
          function v(C) {
            typeof C != "function" && (C = new Function("" + C));
            for (var k = new Array(arguments.length - 1), O = 0; O < k.length; O++)
              k[O] = arguments[O + 1];
            var N = { callback: C, args: k };
            return u[l] = N, h(l), l++;
          }
          function y(C) {
            delete u[C];
          }
          function b(C) {
            var k = C.callback, O = C.args;
            switch (O.length) {
              case 0:
                k();
                break;
              case 1:
                k(O[0]);
                break;
              case 2:
                k(O[0], O[1]);
                break;
              case 3:
                k(O[0], O[1], O[2]);
                break;
              default:
                k.apply(a, O);
                break;
            }
          }
          function p(C) {
            if (c)
              setTimeout(p, 0, C);
            else {
              var k = u[C];
              if (k) {
                c = !0;
                try {
                  b(k);
                } finally {
                  y(C), c = !1;
                }
              }
            }
          }
          function f() {
            h = function(C) {
              process.nextTick(function() {
                p(C);
              });
            };
          }
          function g() {
            if (o.postMessage && !o.importScripts) {
              var C = !0, k = o.onmessage;
              return o.onmessage = function() {
                C = !1;
              }, o.postMessage("", "*"), o.onmessage = k, C;
            }
          }
          function m() {
            var C = "setImmediate$" + Math.random() + "$", k = function(O) {
              O.source === o && typeof O.data == "string" && O.data.indexOf(C) === 0 && p(+O.data.slice(C.length));
            };
            o.addEventListener ? o.addEventListener("message", k, !1) : o.attachEvent("onmessage", k), h = function(O) {
              o.postMessage(C + O, "*");
            };
          }
          function w() {
            var C = new MessageChannel();
            C.port1.onmessage = function(k) {
              var O = k.data;
              p(O);
            }, h = function(k) {
              C.port2.postMessage(k);
            };
          }
          function _() {
            var C = d.documentElement;
            h = function(k) {
              var O = d.createElement("script");
              O.onreadystatechange = function() {
                p(k), O.onreadystatechange = null, C.removeChild(O), O = null;
              }, C.appendChild(O);
            };
          }
          function S() {
            h = function(C) {
              setTimeout(p, 0, C);
            };
          }
          var A = Object.getPrototypeOf && Object.getPrototypeOf(o);
          A = A && A.setTimeout ? A : o, {}.toString.call(o.process) === "[object process]" ? f() : g() ? m() : o.MessageChannel ? w() : d && "onreadystatechange" in d.createElement("script") ? _() : S(), A.setImmediate = v, A.clearImmediate = y;
        })(typeof self > "u" ? typeof s > "u" ? this : s : self);
      }).call(this, typeof mn < "u" ? mn : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(Q6);
class Z6 {
  constructor() {
    this.zip = void 0, this.urlCache = {}, this.checkRequirements();
  }
  /**
   * Checks to see if JSZip exists in global namspace,
   * Requires JSZip if it isn't there
   * @private
   */
  checkRequirements() {
    try {
      this.zip = new ad();
    } catch {
      throw new Error("JSZip lib not loaded");
    }
  }
  /**
   * Open an archive
   * @param  {binary} input
   * @param  {boolean} [isBase64] tells JSZip if the input data is base64 encoded
   * @return {Promise} zipfile
   */
  open(e, n) {
    return this.zip.loadAsync(e, { base64: n });
  }
  /**
   * Load and Open an archive
   * @param  {string} zipUrl
   * @param  {boolean} [isBase64] tells JSZip if the input data is base64 encoded
   * @return {Promise} zipfile
   */
  openUrl(e, n) {
    return Uo(e, "binary").then(function(r) {
      return this.zip.loadAsync(r, { base64: n });
    }.bind(this));
  }
  /**
   * Request a url from the archive
   * @param  {string} url  a url to request from the archive
   * @param  {string} [type] specify the type of the returned result
   * @return {Promise<Blob | string | JSON | Document | XMLDocument>}
   */
  request(e, n) {
    var r = new vt(), i, s = new ri(e);
    return n || (n = s.extension), n == "blob" ? i = this.getBlob(e) : i = this.getText(e), i ? i.then(function(o) {
      let a = this.handleResponse(o, n);
      r.resolve(a);
    }.bind(this)) : r.reject({
      message: "File not found in the epub: " + e,
      stack: new Error().stack
    }), r.promise;
  }
  /**
   * Handle the response from request
   * @private
   * @param  {any} response
   * @param  {string} [type]
   * @return {any} the parsed result
   */
  handleResponse(e, n) {
    var r;
    return n == "json" ? r = JSON.parse(e) : Ho(n) ? r = Cr(e, "text/xml") : n == "xhtml" ? r = Cr(e, "application/xhtml+xml") : n == "html" || n == "htm" ? r = Cr(e, "text/html") : r = e, r;
  }
  /**
   * Get a Blob from Archive by Url
   * @param  {string} url
   * @param  {string} [mimeType]
   * @return {Blob}
   */
  getBlob(e, n) {
    var r = window.decodeURIComponent(e.substr(1)), i = this.zip.file(r);
    if (i)
      return n = n || xs.lookup(i.name), i.async("uint8array").then(function(s) {
        return new Blob([s], { type: n });
      });
  }
  /**
   * Get Text from Archive by Url
   * @param  {string} url
   * @param  {string} [encoding]
   * @return {string}
   */
  getText(e, n) {
    var r = window.decodeURIComponent(e.substr(1)), i = this.zip.file(r);
    if (i)
      return i.async("string").then(function(s) {
        return s;
      });
  }
  /**
   * Get a base64 encoded result from Archive by Url
   * @param  {string} url
   * @param  {string} [mimeType]
   * @return {string} base64 encoded
   */
  getBase64(e, n) {
    var r = window.decodeURIComponent(e.substr(1)), i = this.zip.file(r);
    if (i)
      return n = n || xs.lookup(i.name), i.async("base64").then(function(s) {
        return "data:" + n + ";base64," + s;
      });
  }
  /**
   * Create a Url from an unarchived item
   * @param  {string} url
   * @param  {object} [options.base64] use base64 encoding or blob url
   * @return {Promise} url promise with Url string
   */
  createUrl(e, n) {
    var r = new vt(), i = window.URL || window.webkitURL || window.mozURL, s, o, a = n && n.base64;
    return e in this.urlCache ? (r.resolve(this.urlCache[e]), r.promise) : (a ? (o = this.getBase64(e), o && o.then(function(l) {
      this.urlCache[e] = l, r.resolve(l);
    }.bind(this))) : (o = this.getBlob(e), o && o.then(function(l) {
      s = i.createObjectURL(l), this.urlCache[e] = s, r.resolve(s);
    }.bind(this))), o || r.reject({
      message: "File not found in the epub: " + e,
      stack: new Error().stack
    }), r.promise);
  }
  /**
   * Revoke Temp Url for a archive item
   * @param  {string} url url of the item in the archive
   */
  revokeUrl(e) {
    var n = window.URL || window.webkitURL || window.mozURL, r = this.urlCache[e];
    r && n.revokeObjectURL(r);
  }
  destroy() {
    var e = window.URL || window.webkitURL || window.mozURL;
    for (let n in this.urlCache)
      e.revokeObjectURL(n);
    this.zip = void 0, this.urlCache = {};
  }
}
var Dl = {}, X6 = {
  get exports() {
    return Dl;
  },
  set exports(t) {
    Dl = t;
  }
};
/*!
    localForage -- Offline Storage, Improved
    Version 1.10.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
(function(t, e) {
  (function(n) {
    t.exports = n();
  })(function() {
    return function n(r, i, s) {
      function o(u, c) {
        if (!i[u]) {
          if (!r[u]) {
            var d = typeof mi == "function" && mi;
            if (!c && d)
              return d(u, !0);
            if (a)
              return a(u, !0);
            var h = new Error("Cannot find module '" + u + "'");
            throw h.code = "MODULE_NOT_FOUND", h;
          }
          var v = i[u] = { exports: {} };
          r[u][0].call(v.exports, function(y) {
            var b = r[u][1][y];
            return o(b || y);
          }, v, v.exports, n, r, i, s);
        }
        return i[u].exports;
      }
      for (var a = typeof mi == "function" && mi, l = 0; l < s.length; l++)
        o(s[l]);
      return o;
    }({ 1: [function(n, r, i) {
      (function(s) {
        var o = s.MutationObserver || s.WebKitMutationObserver, a;
        if (o) {
          var l = 0, u = new o(y), c = s.document.createTextNode("");
          u.observe(c, {
            characterData: !0
          }), a = function() {
            c.data = l = ++l % 2;
          };
        } else if (!s.setImmediate && typeof s.MessageChannel < "u") {
          var d = new s.MessageChannel();
          d.port1.onmessage = y, a = function() {
            d.port2.postMessage(0);
          };
        } else
          "document" in s && "onreadystatechange" in s.document.createElement("script") ? a = function() {
            var p = s.document.createElement("script");
            p.onreadystatechange = function() {
              y(), p.onreadystatechange = null, p.parentNode.removeChild(p), p = null;
            }, s.document.documentElement.appendChild(p);
          } : a = function() {
            setTimeout(y, 0);
          };
        var h, v = [];
        function y() {
          h = !0;
          for (var p, f, g = v.length; g; ) {
            for (f = v, v = [], p = -1; ++p < g; )
              f[p]();
            g = v.length;
          }
          h = !1;
        }
        r.exports = b;
        function b(p) {
          v.push(p) === 1 && !h && a();
        }
      }).call(this, typeof mn < "u" ? mn : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 2: [function(n, r, i) {
      var s = n(1);
      function o() {
      }
      var a = {}, l = ["REJECTED"], u = ["FULFILLED"], c = ["PENDING"];
      r.exports = d;
      function d(_) {
        if (typeof _ != "function")
          throw new TypeError("resolver must be a function");
        this.state = c, this.queue = [], this.outcome = void 0, _ !== o && b(this, _);
      }
      d.prototype.catch = function(_) {
        return this.then(null, _);
      }, d.prototype.then = function(_, S) {
        if (typeof _ != "function" && this.state === u || typeof S != "function" && this.state === l)
          return this;
        var A = new this.constructor(o);
        if (this.state !== c) {
          var C = this.state === u ? _ : S;
          v(A, C, this.outcome);
        } else
          this.queue.push(new h(A, _, S));
        return A;
      };
      function h(_, S, A) {
        this.promise = _, typeof S == "function" && (this.onFulfilled = S, this.callFulfilled = this.otherCallFulfilled), typeof A == "function" && (this.onRejected = A, this.callRejected = this.otherCallRejected);
      }
      h.prototype.callFulfilled = function(_) {
        a.resolve(this.promise, _);
      }, h.prototype.otherCallFulfilled = function(_) {
        v(this.promise, this.onFulfilled, _);
      }, h.prototype.callRejected = function(_) {
        a.reject(this.promise, _);
      }, h.prototype.otherCallRejected = function(_) {
        v(this.promise, this.onRejected, _);
      };
      function v(_, S, A) {
        s(function() {
          var C;
          try {
            C = S(A);
          } catch (k) {
            return a.reject(_, k);
          }
          C === _ ? a.reject(_, new TypeError("Cannot resolve promise with itself")) : a.resolve(_, C);
        });
      }
      a.resolve = function(_, S) {
        var A = p(y, S);
        if (A.status === "error")
          return a.reject(_, A.value);
        var C = A.value;
        if (C)
          b(_, C);
        else {
          _.state = u, _.outcome = S;
          for (var k = -1, O = _.queue.length; ++k < O; )
            _.queue[k].callFulfilled(S);
        }
        return _;
      }, a.reject = function(_, S) {
        _.state = l, _.outcome = S;
        for (var A = -1, C = _.queue.length; ++A < C; )
          _.queue[A].callRejected(S);
        return _;
      };
      function y(_) {
        var S = _ && _.then;
        if (_ && (typeof _ == "object" || typeof _ == "function") && typeof S == "function")
          return function() {
            S.apply(_, arguments);
          };
      }
      function b(_, S) {
        var A = !1;
        function C(B) {
          A || (A = !0, a.reject(_, B));
        }
        function k(B) {
          A || (A = !0, a.resolve(_, B));
        }
        function O() {
          S(k, C);
        }
        var N = p(O);
        N.status === "error" && C(N.value);
      }
      function p(_, S) {
        var A = {};
        try {
          A.value = _(S), A.status = "success";
        } catch (C) {
          A.status = "error", A.value = C;
        }
        return A;
      }
      d.resolve = f;
      function f(_) {
        return _ instanceof this ? _ : a.resolve(new this(o), _);
      }
      d.reject = g;
      function g(_) {
        var S = new this(o);
        return a.reject(S, _);
      }
      d.all = m;
      function m(_) {
        var S = this;
        if (Object.prototype.toString.call(_) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var A = _.length, C = !1;
        if (!A)
          return this.resolve([]);
        for (var k = new Array(A), O = 0, N = -1, B = new this(o); ++N < A; )
          M(_[N], N);
        return B;
        function M(j, q) {
          S.resolve(j).then(X, function(z) {
            C || (C = !0, a.reject(B, z));
          });
          function X(z) {
            k[q] = z, ++O === A && !C && (C = !0, a.resolve(B, k));
          }
        }
      }
      d.race = w;
      function w(_) {
        var S = this;
        if (Object.prototype.toString.call(_) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var A = _.length, C = !1;
        if (!A)
          return this.resolve([]);
        for (var k = -1, O = new this(o); ++k < A; )
          N(_[k]);
        return O;
        function N(B) {
          S.resolve(B).then(function(M) {
            C || (C = !0, a.resolve(O, M));
          }, function(M) {
            C || (C = !0, a.reject(O, M));
          });
        }
      }
    }, { 1: 1 }], 3: [function(n, r, i) {
      (function(s) {
        typeof s.Promise != "function" && (s.Promise = n(2));
      }).call(this, typeof mn < "u" ? mn : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { 2: 2 }], 4: [function(n, r, i) {
      var s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(R) {
        return typeof R;
      } : function(R) {
        return R && typeof Symbol == "function" && R.constructor === Symbol && R !== Symbol.prototype ? "symbol" : typeof R;
      };
      function o(R, K) {
        if (!(R instanceof K))
          throw new TypeError("Cannot call a class as a function");
      }
      function a() {
        try {
          if (typeof indexedDB < "u")
            return indexedDB;
          if (typeof webkitIndexedDB < "u")
            return webkitIndexedDB;
          if (typeof mozIndexedDB < "u")
            return mozIndexedDB;
          if (typeof OIndexedDB < "u")
            return OIndexedDB;
          if (typeof msIndexedDB < "u")
            return msIndexedDB;
        } catch {
          return;
        }
      }
      var l = a();
      function u() {
        try {
          if (!l || !l.open)
            return !1;
          var R = typeof openDatabase < "u" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform), K = typeof fetch == "function" && fetch.toString().indexOf("[native code") !== -1;
          return (!R || K) && typeof indexedDB < "u" && // some outdated implementations of IDB that appear on Samsung
          // and HTC Android devices <4.4 are missing IDBKeyRange
          // See: https://github.com/mozilla/localForage/issues/128
          // See: https://github.com/mozilla/localForage/issues/272
          typeof IDBKeyRange < "u";
        } catch {
          return !1;
        }
      }
      function c(R, K) {
        R = R || [], K = K || {};
        try {
          return new Blob(R, K);
        } catch (Y) {
          if (Y.name !== "TypeError")
            throw Y;
          for (var D = typeof BlobBuilder < "u" ? BlobBuilder : typeof MSBlobBuilder < "u" ? MSBlobBuilder : typeof MozBlobBuilder < "u" ? MozBlobBuilder : WebKitBlobBuilder, Z = new D(), te = 0; te < R.length; te += 1)
            Z.append(R[te]);
          return Z.getBlob(K.type);
        }
      }
      typeof Promise > "u" && n(3);
      var d = Promise;
      function h(R, K) {
        K && R.then(function(D) {
          K(null, D);
        }, function(D) {
          K(D);
        });
      }
      function v(R, K, D) {
        typeof K == "function" && R.then(K), typeof D == "function" && R.catch(D);
      }
      function y(R) {
        return typeof R != "string" && (console.warn(R + " used as a key, but it is not a string."), R = String(R)), R;
      }
      function b() {
        if (arguments.length && typeof arguments[arguments.length - 1] == "function")
          return arguments[arguments.length - 1];
      }
      var p = "local-forage-detect-blob-support", f = void 0, g = {}, m = Object.prototype.toString, w = "readonly", _ = "readwrite";
      function S(R) {
        for (var K = R.length, D = new ArrayBuffer(K), Z = new Uint8Array(D), te = 0; te < K; te++)
          Z[te] = R.charCodeAt(te);
        return D;
      }
      function A(R) {
        return new d(function(K) {
          var D = R.transaction(p, _), Z = c([""]);
          D.objectStore(p).put(Z, "key"), D.onabort = function(te) {
            te.preventDefault(), te.stopPropagation(), K(!1);
          }, D.oncomplete = function() {
            var te = navigator.userAgent.match(/Chrome\/(\d+)/), Y = navigator.userAgent.match(/Edge\//);
            K(Y || !te || parseInt(te[1], 10) >= 43);
          };
        }).catch(function() {
          return !1;
        });
      }
      function C(R) {
        return typeof f == "boolean" ? d.resolve(f) : A(R).then(function(K) {
          return f = K, f;
        });
      }
      function k(R) {
        var K = g[R.name], D = {};
        D.promise = new d(function(Z, te) {
          D.resolve = Z, D.reject = te;
        }), K.deferredOperations.push(D), K.dbReady ? K.dbReady = K.dbReady.then(function() {
          return D.promise;
        }) : K.dbReady = D.promise;
      }
      function O(R) {
        var K = g[R.name], D = K.deferredOperations.pop();
        if (D)
          return D.resolve(), D.promise;
      }
      function N(R, K) {
        var D = g[R.name], Z = D.deferredOperations.pop();
        if (Z)
          return Z.reject(K), Z.promise;
      }
      function B(R, K) {
        return new d(function(D, Z) {
          if (g[R.name] = g[R.name] || J(), R.db)
            if (K)
              k(R), R.db.close();
            else
              return D(R.db);
          var te = [R.name];
          K && te.push(R.version);
          var Y = l.open.apply(l, te);
          K && (Y.onupgradeneeded = function(pe) {
            var Se = Y.result;
            try {
              Se.createObjectStore(R.storeName), pe.oldVersion <= 1 && Se.createObjectStore(p);
            } catch (Ee) {
              if (Ee.name === "ConstraintError")
                console.warn('The database "' + R.name + '" has been upgraded from version ' + pe.oldVersion + " to version " + pe.newVersion + ', but the storage "' + R.storeName + '" already exists.');
              else
                throw Ee;
            }
          }), Y.onerror = function(pe) {
            pe.preventDefault(), Z(Y.error);
          }, Y.onsuccess = function() {
            var pe = Y.result;
            pe.onversionchange = function(Se) {
              Se.target.close();
            }, D(pe), O(R);
          };
        });
      }
      function M(R) {
        return B(R, !1);
      }
      function j(R) {
        return B(R, !0);
      }
      function q(R, K) {
        if (!R.db)
          return !0;
        var D = !R.db.objectStoreNames.contains(R.storeName), Z = R.version < R.db.version, te = R.version > R.db.version;
        if (Z && (R.version !== K && console.warn('The database "' + R.name + `" can't be downgraded from version ` + R.db.version + " to version " + R.version + "."), R.version = R.db.version), te || D) {
          if (D) {
            var Y = R.db.version + 1;
            Y > R.version && (R.version = Y);
          }
          return !0;
        }
        return !1;
      }
      function X(R) {
        return new d(function(K, D) {
          var Z = new FileReader();
          Z.onerror = D, Z.onloadend = function(te) {
            var Y = btoa(te.target.result || "");
            K({
              __local_forage_encoded_blob: !0,
              data: Y,
              type: R.type
            });
          }, Z.readAsBinaryString(R);
        });
      }
      function z(R) {
        var K = S(atob(R.data));
        return c([K], { type: R.type });
      }
      function U(R) {
        return R && R.__local_forage_encoded_blob;
      }
      function H(R) {
        var K = this, D = K._initReady().then(function() {
          var Z = g[K._dbInfo.name];
          if (Z && Z.dbReady)
            return Z.dbReady;
        });
        return v(D, R, R), D;
      }
      function re(R) {
        k(R);
        for (var K = g[R.name], D = K.forages, Z = 0; Z < D.length; Z++) {
          var te = D[Z];
          te._dbInfo.db && (te._dbInfo.db.close(), te._dbInfo.db = null);
        }
        return R.db = null, M(R).then(function(Y) {
          return R.db = Y, q(R) ? j(R) : Y;
        }).then(function(Y) {
          R.db = K.db = Y;
          for (var pe = 0; pe < D.length; pe++)
            D[pe]._dbInfo.db = Y;
        }).catch(function(Y) {
          throw N(R, Y), Y;
        });
      }
      function fe(R, K, D, Z) {
        Z === void 0 && (Z = 1);
        try {
          var te = R.db.transaction(R.storeName, K);
          D(null, te);
        } catch (Y) {
          if (Z > 0 && (!R.db || Y.name === "InvalidStateError" || Y.name === "NotFoundError"))
            return d.resolve().then(function() {
              if (!R.db || Y.name === "NotFoundError" && !R.db.objectStoreNames.contains(R.storeName) && R.version <= R.db.version)
                return R.db && (R.version = R.db.version + 1), j(R);
            }).then(function() {
              return re(R).then(function() {
                fe(R, K, D, Z - 1);
              });
            }).catch(D);
          D(Y);
        }
      }
      function J() {
        return {
          // Running localForages sharing a database.
          forages: [],
          // Shared database.
          db: null,
          // Database readiness (promise).
          dbReady: null,
          // Deferred operations on the database.
          deferredOperations: []
        };
      }
      function le(R) {
        var K = this, D = {
          db: null
        };
        if (R)
          for (var Z in R)
            D[Z] = R[Z];
        var te = g[D.name];
        te || (te = J(), g[D.name] = te), te.forages.push(K), K._initReady || (K._initReady = K.ready, K.ready = H);
        var Y = [];
        function pe() {
          return d.resolve();
        }
        for (var Se = 0; Se < te.forages.length; Se++) {
          var Ee = te.forages[Se];
          Ee !== K && Y.push(Ee._initReady().catch(pe));
        }
        var xe = te.forages.slice(0);
        return d.all(Y).then(function() {
          return D.db = te.db, M(D);
        }).then(function(Ce) {
          return D.db = Ce, q(D, K._defaultConfig.version) ? j(D) : Ce;
        }).then(function(Ce) {
          D.db = te.db = Ce, K._dbInfo = D;
          for (var We = 0; We < xe.length; We++) {
            var dt = xe[We];
            dt !== K && (dt._dbInfo.db = D.db, dt._dbInfo.version = D.version);
          }
        });
      }
      function ce(R, K) {
        var D = this;
        R = y(R);
        var Z = new d(function(te, Y) {
          D.ready().then(function() {
            fe(D._dbInfo, w, function(pe, Se) {
              if (pe)
                return Y(pe);
              try {
                var Ee = Se.objectStore(D._dbInfo.storeName), xe = Ee.get(R);
                xe.onsuccess = function() {
                  var Ce = xe.result;
                  Ce === void 0 && (Ce = null), U(Ce) && (Ce = z(Ce)), te(Ce);
                }, xe.onerror = function() {
                  Y(xe.error);
                };
              } catch (Ce) {
                Y(Ce);
              }
            });
          }).catch(Y);
        });
        return h(Z, K), Z;
      }
      function ge(R, K) {
        var D = this, Z = new d(function(te, Y) {
          D.ready().then(function() {
            fe(D._dbInfo, w, function(pe, Se) {
              if (pe)
                return Y(pe);
              try {
                var Ee = Se.objectStore(D._dbInfo.storeName), xe = Ee.openCursor(), Ce = 1;
                xe.onsuccess = function() {
                  var We = xe.result;
                  if (We) {
                    var dt = We.value;
                    U(dt) && (dt = z(dt));
                    var kt = R(dt, We.key, Ce++);
                    kt !== void 0 ? te(kt) : We.continue();
                  } else
                    te();
                }, xe.onerror = function() {
                  Y(xe.error);
                };
              } catch (We) {
                Y(We);
              }
            });
          }).catch(Y);
        });
        return h(Z, K), Z;
      }
      function _e(R, K, D) {
        var Z = this;
        R = y(R);
        var te = new d(function(Y, pe) {
          var Se;
          Z.ready().then(function() {
            return Se = Z._dbInfo, m.call(K) === "[object Blob]" ? C(Se.db).then(function(Ee) {
              return Ee ? K : X(K);
            }) : K;
          }).then(function(Ee) {
            fe(Z._dbInfo, _, function(xe, Ce) {
              if (xe)
                return pe(xe);
              try {
                var We = Ce.objectStore(Z._dbInfo.storeName);
                Ee === null && (Ee = void 0);
                var dt = We.put(Ee, R);
                Ce.oncomplete = function() {
                  Ee === void 0 && (Ee = null), Y(Ee);
                }, Ce.onabort = Ce.onerror = function() {
                  var kt = dt.error ? dt.error : dt.transaction.error;
                  pe(kt);
                };
              } catch (kt) {
                pe(kt);
              }
            });
          }).catch(pe);
        });
        return h(te, D), te;
      }
      function je(R, K) {
        var D = this;
        R = y(R);
        var Z = new d(function(te, Y) {
          D.ready().then(function() {
            fe(D._dbInfo, _, function(pe, Se) {
              if (pe)
                return Y(pe);
              try {
                var Ee = Se.objectStore(D._dbInfo.storeName), xe = Ee.delete(R);
                Se.oncomplete = function() {
                  te();
                }, Se.onerror = function() {
                  Y(xe.error);
                }, Se.onabort = function() {
                  var Ce = xe.error ? xe.error : xe.transaction.error;
                  Y(Ce);
                };
              } catch (Ce) {
                Y(Ce);
              }
            });
          }).catch(Y);
        });
        return h(Z, K), Z;
      }
      function Te(R) {
        var K = this, D = new d(function(Z, te) {
          K.ready().then(function() {
            fe(K._dbInfo, _, function(Y, pe) {
              if (Y)
                return te(Y);
              try {
                var Se = pe.objectStore(K._dbInfo.storeName), Ee = Se.clear();
                pe.oncomplete = function() {
                  Z();
                }, pe.onabort = pe.onerror = function() {
                  var xe = Ee.error ? Ee.error : Ee.transaction.error;
                  te(xe);
                };
              } catch (xe) {
                te(xe);
              }
            });
          }).catch(te);
        });
        return h(D, R), D;
      }
      function Ze(R) {
        var K = this, D = new d(function(Z, te) {
          K.ready().then(function() {
            fe(K._dbInfo, w, function(Y, pe) {
              if (Y)
                return te(Y);
              try {
                var Se = pe.objectStore(K._dbInfo.storeName), Ee = Se.count();
                Ee.onsuccess = function() {
                  Z(Ee.result);
                }, Ee.onerror = function() {
                  te(Ee.error);
                };
              } catch (xe) {
                te(xe);
              }
            });
          }).catch(te);
        });
        return h(D, R), D;
      }
      function Le(R, K) {
        var D = this, Z = new d(function(te, Y) {
          if (R < 0) {
            te(null);
            return;
          }
          D.ready().then(function() {
            fe(D._dbInfo, w, function(pe, Se) {
              if (pe)
                return Y(pe);
              try {
                var Ee = Se.objectStore(D._dbInfo.storeName), xe = !1, Ce = Ee.openKeyCursor();
                Ce.onsuccess = function() {
                  var We = Ce.result;
                  if (!We) {
                    te(null);
                    return;
                  }
                  R === 0 || xe ? te(We.key) : (xe = !0, We.advance(R));
                }, Ce.onerror = function() {
                  Y(Ce.error);
                };
              } catch (We) {
                Y(We);
              }
            });
          }).catch(Y);
        });
        return h(Z, K), Z;
      }
      function Ke(R) {
        var K = this, D = new d(function(Z, te) {
          K.ready().then(function() {
            fe(K._dbInfo, w, function(Y, pe) {
              if (Y)
                return te(Y);
              try {
                var Se = pe.objectStore(K._dbInfo.storeName), Ee = Se.openKeyCursor(), xe = [];
                Ee.onsuccess = function() {
                  var Ce = Ee.result;
                  if (!Ce) {
                    Z(xe);
                    return;
                  }
                  xe.push(Ce.key), Ce.continue();
                }, Ee.onerror = function() {
                  te(Ee.error);
                };
              } catch (Ce) {
                te(Ce);
              }
            });
          }).catch(te);
        });
        return h(D, R), D;
      }
      function ct(R, K) {
        K = b.apply(this, arguments);
        var D = this.config();
        R = typeof R != "function" && R || {}, R.name || (R.name = R.name || D.name, R.storeName = R.storeName || D.storeName);
        var Z = this, te;
        if (!R.name)
          te = d.reject("Invalid arguments");
        else {
          var Y = R.name === D.name && Z._dbInfo.db, pe = Y ? d.resolve(Z._dbInfo.db) : M(R).then(function(Se) {
            var Ee = g[R.name], xe = Ee.forages;
            Ee.db = Se;
            for (var Ce = 0; Ce < xe.length; Ce++)
              xe[Ce]._dbInfo.db = Se;
            return Se;
          });
          R.storeName ? te = pe.then(function(Se) {
            if (Se.objectStoreNames.contains(R.storeName)) {
              var Ee = Se.version + 1;
              k(R);
              var xe = g[R.name], Ce = xe.forages;
              Se.close();
              for (var We = 0; We < Ce.length; We++) {
                var dt = Ce[We];
                dt._dbInfo.db = null, dt._dbInfo.version = Ee;
              }
              var kt = new d(function(Ot, rn) {
                var Xt = l.open(R.name, Ee);
                Xt.onerror = function(Zn) {
                  var Gs = Xt.result;
                  Gs.close(), rn(Zn);
                }, Xt.onupgradeneeded = function() {
                  var Zn = Xt.result;
                  Zn.deleteObjectStore(R.storeName);
                }, Xt.onsuccess = function() {
                  var Zn = Xt.result;
                  Zn.close(), Ot(Zn);
                };
              });
              return kt.then(function(Ot) {
                xe.db = Ot;
                for (var rn = 0; rn < Ce.length; rn++) {
                  var Xt = Ce[rn];
                  Xt._dbInfo.db = Ot, O(Xt._dbInfo);
                }
              }).catch(function(Ot) {
                throw (N(R, Ot) || d.resolve()).catch(function() {
                }), Ot;
              });
            }
          }) : te = pe.then(function(Se) {
            k(R);
            var Ee = g[R.name], xe = Ee.forages;
            Se.close();
            for (var Ce = 0; Ce < xe.length; Ce++) {
              var We = xe[Ce];
              We._dbInfo.db = null;
            }
            var dt = new d(function(kt, Ot) {
              var rn = l.deleteDatabase(R.name);
              rn.onerror = function() {
                var Xt = rn.result;
                Xt && Xt.close(), Ot(rn.error);
              }, rn.onblocked = function() {
                console.warn('dropInstance blocked for database "' + R.name + '" until all open connections are closed');
              }, rn.onsuccess = function() {
                var Xt = rn.result;
                Xt && Xt.close(), kt(Xt);
              };
            });
            return dt.then(function(kt) {
              Ee.db = kt;
              for (var Ot = 0; Ot < xe.length; Ot++) {
                var rn = xe[Ot];
                O(rn._dbInfo);
              }
            }).catch(function(kt) {
              throw (N(R, kt) || d.resolve()).catch(function() {
              }), kt;
            });
          });
        }
        return h(te, K), te;
      }
      var nt = {
        _driver: "asyncStorage",
        _initStorage: le,
        _support: u(),
        iterate: ge,
        getItem: ce,
        setItem: _e,
        removeItem: je,
        clear: Te,
        length: Ze,
        key: Le,
        keys: Ke,
        dropInstance: ct
      };
      function Et() {
        return typeof openDatabase == "function";
      }
      var yt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Nt = "~~local_forage_type~", ot = /^~~local_forage_type~([^~]+)~/, bt = "__lfsc__:", $t = bt.length, wt = "arbf", xt = "blob", lt = "si08", qe = "ui08", Rt = "uic8", we = "si16", Ue = "si32", at = "ur16", Pt = "ui32", Qt = "fl32", Ie = "fl64", Ve = $t + wt.length, Je = Object.prototype.toString;
      function He(R) {
        var K = R.length * 0.75, D = R.length, Z, te = 0, Y, pe, Se, Ee;
        R[R.length - 1] === "=" && (K--, R[R.length - 2] === "=" && K--);
        var xe = new ArrayBuffer(K), Ce = new Uint8Array(xe);
        for (Z = 0; Z < D; Z += 4)
          Y = yt.indexOf(R[Z]), pe = yt.indexOf(R[Z + 1]), Se = yt.indexOf(R[Z + 2]), Ee = yt.indexOf(R[Z + 3]), Ce[te++] = Y << 2 | pe >> 4, Ce[te++] = (pe & 15) << 4 | Se >> 2, Ce[te++] = (Se & 3) << 6 | Ee & 63;
        return xe;
      }
      function Qe(R) {
        var K = new Uint8Array(R), D = "", Z;
        for (Z = 0; Z < K.length; Z += 3)
          D += yt[K[Z] >> 2], D += yt[(K[Z] & 3) << 4 | K[Z + 1] >> 4], D += yt[(K[Z + 1] & 15) << 2 | K[Z + 2] >> 6], D += yt[K[Z + 2] & 63];
        return K.length % 3 === 2 ? D = D.substring(0, D.length - 1) + "=" : K.length % 3 === 1 && (D = D.substring(0, D.length - 2) + "=="), D;
      }
      function At(R, K) {
        var D = "";
        if (R && (D = Je.call(R)), R && (D === "[object ArrayBuffer]" || R.buffer && Je.call(R.buffer) === "[object ArrayBuffer]")) {
          var Z, te = bt;
          R instanceof ArrayBuffer ? (Z = R, te += wt) : (Z = R.buffer, D === "[object Int8Array]" ? te += lt : D === "[object Uint8Array]" ? te += qe : D === "[object Uint8ClampedArray]" ? te += Rt : D === "[object Int16Array]" ? te += we : D === "[object Uint16Array]" ? te += at : D === "[object Int32Array]" ? te += Ue : D === "[object Uint32Array]" ? te += Pt : D === "[object Float32Array]" ? te += Qt : D === "[object Float64Array]" ? te += Ie : K(new Error("Failed to get type for BinaryArray"))), K(te + Qe(Z));
        } else if (D === "[object Blob]") {
          var Y = new FileReader();
          Y.onload = function() {
            var pe = Nt + R.type + "~" + Qe(this.result);
            K(bt + xt + pe);
          }, Y.readAsArrayBuffer(R);
        } else
          try {
            K(JSON.stringify(R));
          } catch (pe) {
            console.error("Couldn't convert value into a JSON string: ", R), K(null, pe);
          }
      }
      function P(R) {
        if (R.substring(0, $t) !== bt)
          return JSON.parse(R);
        var K = R.substring(Ve), D = R.substring($t, Ve), Z;
        if (D === xt && ot.test(K)) {
          var te = K.match(ot);
          Z = te[1], K = K.substring(te[0].length);
        }
        var Y = He(K);
        switch (D) {
          case wt:
            return Y;
          case xt:
            return c([Y], { type: Z });
          case lt:
            return new Int8Array(Y);
          case qe:
            return new Uint8Array(Y);
          case Rt:
            return new Uint8ClampedArray(Y);
          case we:
            return new Int16Array(Y);
          case at:
            return new Uint16Array(Y);
          case Ue:
            return new Int32Array(Y);
          case Pt:
            return new Uint32Array(Y);
          case Qt:
            return new Float32Array(Y);
          case Ie:
            return new Float64Array(Y);
          default:
            throw new Error("Unkown type: " + D);
        }
      }
      var he = {
        serialize: At,
        deserialize: P,
        stringToBuffer: He,
        bufferToString: Qe
      };
      function me(R, K, D, Z) {
        R.executeSql("CREATE TABLE IF NOT EXISTS " + K.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], D, Z);
      }
      function Ne(R) {
        var K = this, D = {
          db: null
        };
        if (R)
          for (var Z in R)
            D[Z] = typeof R[Z] != "string" ? R[Z].toString() : R[Z];
        var te = new d(function(Y, pe) {
          try {
            D.db = openDatabase(D.name, String(D.version), D.description, D.size);
          } catch (Se) {
            return pe(Se);
          }
          D.db.transaction(function(Se) {
            me(Se, D, function() {
              K._dbInfo = D, Y();
            }, function(Ee, xe) {
              pe(xe);
            });
          }, pe);
        });
        return D.serializer = he, te;
      }
      function G(R, K, D, Z, te, Y) {
        R.executeSql(D, Z, te, function(pe, Se) {
          Se.code === Se.SYNTAX_ERR ? pe.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [K.storeName], function(Ee, xe) {
            xe.rows.length ? Y(Ee, Se) : me(Ee, K, function() {
              Ee.executeSql(D, Z, te, Y);
            }, Y);
          }, Y) : Y(pe, Se);
        }, Y);
      }
      function ue(R, K) {
        var D = this;
        R = y(R);
        var Z = new d(function(te, Y) {
          D.ready().then(function() {
            var pe = D._dbInfo;
            pe.db.transaction(function(Se) {
              G(Se, pe, "SELECT * FROM " + pe.storeName + " WHERE key = ? LIMIT 1", [R], function(Ee, xe) {
                var Ce = xe.rows.length ? xe.rows.item(0).value : null;
                Ce && (Ce = pe.serializer.deserialize(Ce)), te(Ce);
              }, function(Ee, xe) {
                Y(xe);
              });
            });
          }).catch(Y);
        });
        return h(Z, K), Z;
      }
      function T(R, K) {
        var D = this, Z = new d(function(te, Y) {
          D.ready().then(function() {
            var pe = D._dbInfo;
            pe.db.transaction(function(Se) {
              G(Se, pe, "SELECT * FROM " + pe.storeName, [], function(Ee, xe) {
                for (var Ce = xe.rows, We = Ce.length, dt = 0; dt < We; dt++) {
                  var kt = Ce.item(dt), Ot = kt.value;
                  if (Ot && (Ot = pe.serializer.deserialize(Ot)), Ot = R(Ot, kt.key, dt + 1), Ot !== void 0) {
                    te(Ot);
                    return;
                  }
                }
                te();
              }, function(Ee, xe) {
                Y(xe);
              });
            });
          }).catch(Y);
        });
        return h(Z, K), Z;
      }
      function L(R, K, D, Z) {
        var te = this;
        R = y(R);
        var Y = new d(function(pe, Se) {
          te.ready().then(function() {
            K === void 0 && (K = null);
            var Ee = K, xe = te._dbInfo;
            xe.serializer.serialize(K, function(Ce, We) {
              We ? Se(We) : xe.db.transaction(function(dt) {
                G(dt, xe, "INSERT OR REPLACE INTO " + xe.storeName + " (key, value) VALUES (?, ?)", [R, Ce], function() {
                  pe(Ee);
                }, function(kt, Ot) {
                  Se(Ot);
                });
              }, function(dt) {
                if (dt.code === dt.QUOTA_ERR) {
                  if (Z > 0) {
                    pe(L.apply(te, [R, Ee, D, Z - 1]));
                    return;
                  }
                  Se(dt);
                }
              });
            });
          }).catch(Se);
        });
        return h(Y, D), Y;
      }
      function oe(R, K, D) {
        return L.apply(this, [R, K, D, 1]);
      }
      function E(R, K) {
        var D = this;
        R = y(R);
        var Z = new d(function(te, Y) {
          D.ready().then(function() {
            var pe = D._dbInfo;
            pe.db.transaction(function(Se) {
              G(Se, pe, "DELETE FROM " + pe.storeName + " WHERE key = ?", [R], function() {
                te();
              }, function(Ee, xe) {
                Y(xe);
              });
            });
          }).catch(Y);
        });
        return h(Z, K), Z;
      }
      function Q(R) {
        var K = this, D = new d(function(Z, te) {
          K.ready().then(function() {
            var Y = K._dbInfo;
            Y.db.transaction(function(pe) {
              G(pe, Y, "DELETE FROM " + Y.storeName, [], function() {
                Z();
              }, function(Se, Ee) {
                te(Ee);
              });
            });
          }).catch(te);
        });
        return h(D, R), D;
      }
      function ie(R) {
        var K = this, D = new d(function(Z, te) {
          K.ready().then(function() {
            var Y = K._dbInfo;
            Y.db.transaction(function(pe) {
              G(pe, Y, "SELECT COUNT(key) as c FROM " + Y.storeName, [], function(Se, Ee) {
                var xe = Ee.rows.item(0).c;
                Z(xe);
              }, function(Se, Ee) {
                te(Ee);
              });
            });
          }).catch(te);
        });
        return h(D, R), D;
      }
      function I(R, K) {
        var D = this, Z = new d(function(te, Y) {
          D.ready().then(function() {
            var pe = D._dbInfo;
            pe.db.transaction(function(Se) {
              G(Se, pe, "SELECT key FROM " + pe.storeName + " WHERE id = ? LIMIT 1", [R + 1], function(Ee, xe) {
                var Ce = xe.rows.length ? xe.rows.item(0).key : null;
                te(Ce);
              }, function(Ee, xe) {
                Y(xe);
              });
            });
          }).catch(Y);
        });
        return h(Z, K), Z;
      }
      function W(R) {
        var K = this, D = new d(function(Z, te) {
          K.ready().then(function() {
            var Y = K._dbInfo;
            Y.db.transaction(function(pe) {
              G(pe, Y, "SELECT key FROM " + Y.storeName, [], function(Se, Ee) {
                for (var xe = [], Ce = 0; Ce < Ee.rows.length; Ce++)
                  xe.push(Ee.rows.item(Ce).key);
                Z(xe);
              }, function(Se, Ee) {
                te(Ee);
              });
            });
          }).catch(te);
        });
        return h(D, R), D;
      }
      function ne(R) {
        return new d(function(K, D) {
          R.transaction(function(Z) {
            Z.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(te, Y) {
              for (var pe = [], Se = 0; Se < Y.rows.length; Se++)
                pe.push(Y.rows.item(Se).name);
              K({
                db: R,
                storeNames: pe
              });
            }, function(te, Y) {
              D(Y);
            });
          }, function(Z) {
            D(Z);
          });
        });
      }
      function Pe(R, K) {
        K = b.apply(this, arguments);
        var D = this.config();
        R = typeof R != "function" && R || {}, R.name || (R.name = R.name || D.name, R.storeName = R.storeName || D.storeName);
        var Z = this, te;
        return R.name ? te = new d(function(Y) {
          var pe;
          R.name === D.name ? pe = Z._dbInfo.db : pe = openDatabase(R.name, "", "", 0), R.storeName ? Y({
            db: pe,
            storeNames: [R.storeName]
          }) : Y(ne(pe));
        }).then(function(Y) {
          return new d(function(pe, Se) {
            Y.db.transaction(function(Ee) {
              function xe(kt) {
                return new d(function(Ot, rn) {
                  Ee.executeSql("DROP TABLE IF EXISTS " + kt, [], function() {
                    Ot();
                  }, function(Xt, Zn) {
                    rn(Zn);
                  });
                });
              }
              for (var Ce = [], We = 0, dt = Y.storeNames.length; We < dt; We++)
                Ce.push(xe(Y.storeNames[We]));
              d.all(Ce).then(function() {
                pe();
              }).catch(function(kt) {
                Se(kt);
              });
            }, function(Ee) {
              Se(Ee);
            });
          });
        }) : te = d.reject("Invalid arguments"), h(te, K), te;
      }
      var Oe = {
        _driver: "webSQLStorage",
        _initStorage: Ne,
        _support: Et(),
        iterate: T,
        getItem: ue,
        setItem: oe,
        removeItem: E,
        clear: Q,
        length: ie,
        key: I,
        keys: W,
        dropInstance: Pe
      };
      function De() {
        try {
          return typeof localStorage < "u" && "setItem" in localStorage && // in IE8 typeof localStorage.setItem === 'object'
          !!localStorage.setItem;
        } catch {
          return !1;
        }
      }
      function Ye(R, K) {
        var D = R.name + "/";
        return R.storeName !== K.storeName && (D += R.storeName + "/"), D;
      }
      function ln() {
        var R = "_localforage_support_test";
        try {
          return localStorage.setItem(R, !0), localStorage.removeItem(R), !1;
        } catch {
          return !0;
        }
      }
      function Wt() {
        return !ln() || localStorage.length > 0;
      }
      function pt(R) {
        var K = this, D = {};
        if (R)
          for (var Z in R)
            D[Z] = R[Z];
        return D.keyPrefix = Ye(R, K._defaultConfig), Wt() ? (K._dbInfo = D, D.serializer = he, d.resolve()) : d.reject();
      }
      function Zt(R) {
        var K = this, D = K.ready().then(function() {
          for (var Z = K._dbInfo.keyPrefix, te = localStorage.length - 1; te >= 0; te--) {
            var Y = localStorage.key(te);
            Y.indexOf(Z) === 0 && localStorage.removeItem(Y);
          }
        });
        return h(D, R), D;
      }
      function fn(R, K) {
        var D = this;
        R = y(R);
        var Z = D.ready().then(function() {
          var te = D._dbInfo, Y = localStorage.getItem(te.keyPrefix + R);
          return Y && (Y = te.serializer.deserialize(Y)), Y;
        });
        return h(Z, K), Z;
      }
      function xn(R, K) {
        var D = this, Z = D.ready().then(function() {
          for (var te = D._dbInfo, Y = te.keyPrefix, pe = Y.length, Se = localStorage.length, Ee = 1, xe = 0; xe < Se; xe++) {
            var Ce = localStorage.key(xe);
            if (Ce.indexOf(Y) === 0) {
              var We = localStorage.getItem(Ce);
              if (We && (We = te.serializer.deserialize(We)), We = R(We, Ce.substring(pe), Ee++), We !== void 0)
                return We;
            }
          }
        });
        return h(Z, K), Z;
      }
      function es(R, K) {
        var D = this, Z = D.ready().then(function() {
          var te = D._dbInfo, Y;
          try {
            Y = localStorage.key(R);
          } catch {
            Y = null;
          }
          return Y && (Y = Y.substring(te.keyPrefix.length)), Y;
        });
        return h(Z, K), Z;
      }
      function ts(R) {
        var K = this, D = K.ready().then(function() {
          for (var Z = K._dbInfo, te = localStorage.length, Y = [], pe = 0; pe < te; pe++) {
            var Se = localStorage.key(pe);
            Se.indexOf(Z.keyPrefix) === 0 && Y.push(Se.substring(Z.keyPrefix.length));
          }
          return Y;
        });
        return h(D, R), D;
      }
      function Jt(R) {
        var K = this, D = K.keys().then(function(Z) {
          return Z.length;
        });
        return h(D, R), D;
      }
      function Dn(R, K) {
        var D = this;
        R = y(R);
        var Z = D.ready().then(function() {
          var te = D._dbInfo;
          localStorage.removeItem(te.keyPrefix + R);
        });
        return h(Z, K), Z;
      }
      function un(R, K, D) {
        var Z = this;
        R = y(R);
        var te = Z.ready().then(function() {
          K === void 0 && (K = null);
          var Y = K;
          return new d(function(pe, Se) {
            var Ee = Z._dbInfo;
            Ee.serializer.serialize(K, function(xe, Ce) {
              if (Ce)
                Se(Ce);
              else
                try {
                  localStorage.setItem(Ee.keyPrefix + R, xe), pe(Y);
                } catch (We) {
                  (We.name === "QuotaExceededError" || We.name === "NS_ERROR_DOM_QUOTA_REACHED") && Se(We), Se(We);
                }
            });
          });
        });
        return h(te, D), te;
      }
      function ar(R, K) {
        if (K = b.apply(this, arguments), R = typeof R != "function" && R || {}, !R.name) {
          var D = this.config();
          R.name = R.name || D.name, R.storeName = R.storeName || D.storeName;
        }
        var Z = this, te;
        return R.name ? te = new d(function(Y) {
          R.storeName ? Y(Ye(R, Z._defaultConfig)) : Y(R.name + "/");
        }).then(function(Y) {
          for (var pe = localStorage.length - 1; pe >= 0; pe--) {
            var Se = localStorage.key(pe);
            Se.indexOf(Y) === 0 && localStorage.removeItem(Se);
          }
        }) : te = d.reject("Invalid arguments"), h(te, K), te;
      }
      var Qn = {
        _driver: "localStorageWrapper",
        _initStorage: pt,
        _support: De(),
        iterate: xn,
        getItem: fn,
        setItem: un,
        removeItem: Dn,
        clear: Zt,
        length: Jt,
        key: es,
        keys: ts,
        dropInstance: ar
      }, da = function(K, D) {
        return K === D || typeof K == "number" && typeof D == "number" && isNaN(K) && isNaN(D);
      }, M0 = function(K, D) {
        for (var Z = K.length, te = 0; te < Z; ) {
          if (da(K[te], D))
            return !0;
          te++;
        }
        return !1;
      }, Df = Array.isArray || function(R) {
        return Object.prototype.toString.call(R) === "[object Array]";
      }, $s = {}, Mf = {}, ns = {
        INDEXEDDB: nt,
        WEBSQL: Oe,
        LOCALSTORAGE: Qn
      }, L0 = [ns.INDEXEDDB._driver, ns.WEBSQL._driver, ns.LOCALSTORAGE._driver], fa = ["dropInstance"], lu = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(fa), z0 = {
        description: "",
        driver: L0.slice(),
        name: "localforage",
        // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
        // we can use without a prompt.
        size: 4980736,
        storeName: "keyvaluepairs",
        version: 1
      };
      function j0(R, K) {
        R[K] = function() {
          var D = arguments;
          return R.ready().then(function() {
            return R[K].apply(R, D);
          });
        };
      }
      function uu() {
        for (var R = 1; R < arguments.length; R++) {
          var K = arguments[R];
          if (K)
            for (var D in K)
              K.hasOwnProperty(D) && (Df(K[D]) ? arguments[0][D] = K[D].slice() : arguments[0][D] = K[D]);
        }
        return arguments[0];
      }
      var F0 = function() {
        function R(K) {
          o(this, R);
          for (var D in ns)
            if (ns.hasOwnProperty(D)) {
              var Z = ns[D], te = Z._driver;
              this[D] = te, $s[te] || this.defineDriver(Z);
            }
          this._defaultConfig = uu({}, z0), this._config = uu({}, this._defaultConfig, K), this._driverSet = null, this._initDriver = null, this._ready = !1, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch(function() {
          });
        }
        return R.prototype.config = function(D) {
          if ((typeof D > "u" ? "undefined" : s(D)) === "object") {
            if (this._ready)
              return new Error("Can't call config() after localforage has been used.");
            for (var Z in D) {
              if (Z === "storeName" && (D[Z] = D[Z].replace(/\W/g, "_")), Z === "version" && typeof D[Z] != "number")
                return new Error("Database version must be a number.");
              this._config[Z] = D[Z];
            }
            return "driver" in D && D.driver ? this.setDriver(this._config.driver) : !0;
          } else
            return typeof D == "string" ? this._config[D] : this._config;
        }, R.prototype.defineDriver = function(D, Z, te) {
          var Y = new d(function(pe, Se) {
            try {
              var Ee = D._driver, xe = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
              if (!D._driver) {
                Se(xe);
                return;
              }
              for (var Ce = lu.concat("_initStorage"), We = 0, dt = Ce.length; We < dt; We++) {
                var kt = Ce[We], Ot = !M0(fa, kt);
                if ((Ot || D[kt]) && typeof D[kt] != "function") {
                  Se(xe);
                  return;
                }
              }
              var rn = function() {
                for (var Gs = function(V0) {
                  return function() {
                    var W0 = new Error("Method " + V0 + " is not implemented by the current driver"), Lf = d.reject(W0);
                    return h(Lf, arguments[arguments.length - 1]), Lf;
                  };
                }, cu = 0, U0 = fa.length; cu < U0; cu++) {
                  var du = fa[cu];
                  D[du] || (D[du] = Gs(du));
                }
              };
              rn();
              var Xt = function(Gs) {
                $s[Ee] && console.info("Redefining LocalForage driver: " + Ee), $s[Ee] = D, Mf[Ee] = Gs, pe();
              };
              "_support" in D ? D._support && typeof D._support == "function" ? D._support().then(Xt, Se) : Xt(!!D._support) : Xt(!0);
            } catch (Zn) {
              Se(Zn);
            }
          });
          return v(Y, Z, te), Y;
        }, R.prototype.driver = function() {
          return this._driver || null;
        }, R.prototype.getDriver = function(D, Z, te) {
          var Y = $s[D] ? d.resolve($s[D]) : d.reject(new Error("Driver not found."));
          return v(Y, Z, te), Y;
        }, R.prototype.getSerializer = function(D) {
          var Z = d.resolve(he);
          return v(Z, D), Z;
        }, R.prototype.ready = function(D) {
          var Z = this, te = Z._driverSet.then(function() {
            return Z._ready === null && (Z._ready = Z._initDriver()), Z._ready;
          });
          return v(te, D, D), te;
        }, R.prototype.setDriver = function(D, Z, te) {
          var Y = this;
          Df(D) || (D = [D]);
          var pe = this._getSupportedDrivers(D);
          function Se() {
            Y._config.driver = Y.driver();
          }
          function Ee(We) {
            return Y._extend(We), Se(), Y._ready = Y._initStorage(Y._config), Y._ready;
          }
          function xe(We) {
            return function() {
              var dt = 0;
              function kt() {
                for (; dt < We.length; ) {
                  var Ot = We[dt];
                  return dt++, Y._dbInfo = null, Y._ready = null, Y.getDriver(Ot).then(Ee).catch(kt);
                }
                Se();
                var rn = new Error("No available storage method found.");
                return Y._driverSet = d.reject(rn), Y._driverSet;
              }
              return kt();
            };
          }
          var Ce = this._driverSet !== null ? this._driverSet.catch(function() {
            return d.resolve();
          }) : d.resolve();
          return this._driverSet = Ce.then(function() {
            var We = pe[0];
            return Y._dbInfo = null, Y._ready = null, Y.getDriver(We).then(function(dt) {
              Y._driver = dt._driver, Se(), Y._wrapLibraryMethodsWithReady(), Y._initDriver = xe(pe);
            });
          }).catch(function() {
            Se();
            var We = new Error("No available storage method found.");
            return Y._driverSet = d.reject(We), Y._driverSet;
          }), v(this._driverSet, Z, te), this._driverSet;
        }, R.prototype.supports = function(D) {
          return !!Mf[D];
        }, R.prototype._extend = function(D) {
          uu(this, D);
        }, R.prototype._getSupportedDrivers = function(D) {
          for (var Z = [], te = 0, Y = D.length; te < Y; te++) {
            var pe = D[te];
            this.supports(pe) && Z.push(pe);
          }
          return Z;
        }, R.prototype._wrapLibraryMethodsWithReady = function() {
          for (var D = 0, Z = lu.length; D < Z; D++)
            j0(this, lu[D]);
        }, R.prototype.createInstance = function(D) {
          return new R(D);
        }, R;
      }(), H0 = new F0();
      r.exports = H0;
    }, { 3: 3 }] }, {}, [4])(4);
  });
})(X6);
class P0 {
  constructor(e, n, r) {
    this.urlCache = {}, this.storage = void 0, this.name = e, this.requester = n || Uo, this.resolver = r, this.online = !0, this.checkRequirements(), this.addListeners();
  }
  /**
   * Checks to see if localForage exists in global namspace,
   * Requires localForage if it isn't there
   * @private
   */
  checkRequirements() {
    try {
      let e;
      typeof Dl > "u" && (e = Dl), this.storage = e.createInstance({
        name: this.name
      });
    } catch {
      throw new Error("localForage lib not loaded");
    }
  }
  /**
   * Add online and offline event listeners
   * @private
   */
  addListeners() {
    this._status = this.status.bind(this), window.addEventListener("online", this._status), window.addEventListener("offline", this._status);
  }
  /**
   * Remove online and offline event listeners
   * @private
   */
  removeListeners() {
    window.removeEventListener("online", this._status), window.removeEventListener("offline", this._status), this._status = void 0;
  }
  /**
   * Update the online / offline status
   * @private
   */
  status(e) {
    let n = navigator.onLine;
    this.online = n, n ? this.emit("online", this) : this.emit("offline", this);
  }
  /**
   * Add all of a book resources to the store
   * @param  {Resources} resources  book resources
   * @param  {boolean} [force] force resaving resources
   * @return {Promise<object>} store objects
   */
  add(e, n) {
    let r = e.resources.map((i) => {
      let { href: s } = i, o = this.resolver(s), a = window.encodeURIComponent(o);
      return this.storage.getItem(a).then((l) => !l || n ? this.requester(o, "binary").then((u) => this.storage.setItem(a, u)) : l);
    });
    return Promise.all(r);
  }
  /**
   * Put binary data from a url to storage
   * @param  {string} url  a url to request from storage
   * @param  {boolean} [withCredentials]
   * @param  {object} [headers]
   * @return {Promise<Blob>}
   */
  put(e, n, r) {
    let i = window.encodeURIComponent(e);
    return this.storage.getItem(i).then((s) => s || this.requester(e, "binary", n, r).then((o) => this.storage.setItem(i, o)));
  }
  /**
   * Request a url
   * @param  {string} url  a url to request from storage
   * @param  {string} [type] specify the type of the returned result
   * @param  {boolean} [withCredentials]
   * @param  {object} [headers]
   * @return {Promise<Blob | string | JSON | Document | XMLDocument>}
   */
  request(e, n, r, i) {
    return this.online ? this.requester(e, n, r, i).then((s) => (this.put(e), s)) : this.retrieve(e, n);
  }
  /**
   * Request a url from storage
   * @param  {string} url  a url to request from storage
   * @param  {string} [type] specify the type of the returned result
   * @return {Promise<Blob | string | JSON | Document | XMLDocument>}
   */
  retrieve(e, n) {
    new vt();
    var r, i = new ri(e);
    return n || (n = i.extension), n == "blob" ? r = this.getBlob(e) : r = this.getText(e), r.then((s) => {
      var o = new vt(), a;
      return s ? (a = this.handleResponse(s, n), o.resolve(a)) : o.reject({
        message: "File not found in storage: " + e,
        stack: new Error().stack
      }), o.promise;
    });
  }
  /**
   * Handle the response from request
   * @private
   * @param  {any} response
   * @param  {string} [type]
   * @return {any} the parsed result
   */
  handleResponse(e, n) {
    var r;
    return n == "json" ? r = JSON.parse(e) : Ho(n) ? r = Cr(e, "text/xml") : n == "xhtml" ? r = Cr(e, "application/xhtml+xml") : n == "html" || n == "htm" ? r = Cr(e, "text/html") : r = e, r;
  }
  /**
   * Get a Blob from Storage by Url
   * @param  {string} url
   * @param  {string} [mimeType]
   * @return {Blob}
   */
  getBlob(e, n) {
    let r = window.encodeURIComponent(e);
    return this.storage.getItem(r).then(function(i) {
      if (i)
        return n = n || xs.lookup(e), new Blob([i], { type: n });
    });
  }
  /**
   * Get Text from Storage by Url
   * @param  {string} url
   * @param  {string} [mimeType]
   * @return {string}
   */
  getText(e, n) {
    let r = window.encodeURIComponent(e);
    return n = n || xs.lookup(e), this.storage.getItem(r).then(function(i) {
      var s = new vt(), o = new FileReader(), a;
      if (i)
        return a = new Blob([i], { type: n }), o.addEventListener("loadend", () => {
          s.resolve(o.result);
        }), o.readAsText(a, n), s.promise;
    });
  }
  /**
   * Get a base64 encoded result from Storage by Url
   * @param  {string} url
   * @param  {string} [mimeType]
   * @return {string} base64 encoded
   */
  getBase64(e, n) {
    let r = window.encodeURIComponent(e);
    return n = n || xs.lookup(e), this.storage.getItem(r).then((i) => {
      var s = new vt(), o = new FileReader(), a;
      if (i)
        return a = new Blob([i], { type: n }), o.addEventListener("loadend", () => {
          s.resolve(o.result);
        }), o.readAsDataURL(a, n), s.promise;
    });
  }
  /**
   * Create a Url from a stored item
   * @param  {string} url
   * @param  {object} [options.base64] use base64 encoding or blob url
   * @return {Promise} url promise with Url string
   */
  createUrl(e, n) {
    var r = new vt(), i = window.URL || window.webkitURL || window.mozURL, s, o, a = n && n.base64;
    return e in this.urlCache ? (r.resolve(this.urlCache[e]), r.promise) : (a ? (o = this.getBase64(e), o && o.then(function(l) {
      this.urlCache[e] = l, r.resolve(l);
    }.bind(this))) : (o = this.getBlob(e), o && o.then(function(l) {
      s = i.createObjectURL(l), this.urlCache[e] = s, r.resolve(s);
    }.bind(this))), o || r.reject({
      message: "File not found in storage: " + e,
      stack: new Error().stack
    }), r.promise);
  }
  /**
   * Revoke Temp Url for a archive item
   * @param  {string} url url of the item in the store
   */
  revokeUrl(e) {
    var n = window.URL || window.webkitURL || window.mozURL, r = this.urlCache[e];
    r && n.revokeObjectURL(r);
  }
  destroy() {
    var e = window.URL || window.webkitURL || window.mozURL;
    for (let n in this.urlCache)
      e.revokeObjectURL(n);
    this.urlCache = {}, this.removeListeners();
  }
}
Lr(P0.prototype);
class Gu {
  constructor(e) {
    this.interactive = "", this.fixedLayout = "", this.openToSpread = "", this.orientationLock = "", e && this.parse(e);
  }
  /**
   * Parse XML
   * @param  {document} displayOptionsDocument XML
   * @return {DisplayOptions} self
   */
  parse(e) {
    if (!e)
      return this;
    const n = zt(e, "display_options");
    return n ? (ni(n, "option").forEach((i) => {
      let s = "";
      switch (i.childNodes.length && (s = i.childNodes[0].nodeValue), i.attributes.name.value) {
        case "interactive":
          this.interactive = s;
          break;
        case "fixed-layout":
          this.fixedLayout = s;
          break;
        case "open-to-spread":
          this.openToSpread = s;
          break;
        case "orientation-lock":
          this.orientationLock = s;
          break;
      }
    }), this) : this;
  }
  destroy() {
    this.interactive = void 0, this.fixedLayout = void 0, this.openToSpread = void 0, this.orientationLock = void 0;
  }
}
const fv = "META-INF/container.xml", eM = "META-INF/com.apple.ibooks.display-options.xml", ur = {
  BINARY: "binary",
  BASE64: "base64",
  EPUB: "epub",
  OPF: "opf",
  MANIFEST: "json",
  DIRECTORY: "directory"
};
class Bf {
  constructor(e, n) {
    typeof n > "u" && typeof e != "string" && !(e instanceof Blob) && !(e instanceof ArrayBuffer) && (n = e, e = void 0), this.settings = Sn(this.settings || {}, {
      requestMethod: void 0,
      requestCredentials: void 0,
      requestHeaders: void 0,
      encoding: void 0,
      replacements: void 0,
      canonical: void 0,
      openAs: void 0,
      store: void 0
    }), Sn(this.settings, n), this.opening = new vt(), this.opened = this.opening.promise, this.isOpen = !1, this.loading = {
      manifest: new vt(),
      spine: new vt(),
      metadata: new vt(),
      cover: new vt(),
      navigation: new vt(),
      pageList: new vt(),
      resources: new vt(),
      displayOptions: new vt()
    }, this.loaded = {
      manifest: this.loading.manifest.promise,
      spine: this.loading.spine.promise,
      metadata: this.loading.metadata.promise,
      cover: this.loading.cover.promise,
      navigation: this.loading.navigation.promise,
      pageList: this.loading.pageList.promise,
      resources: this.loading.resources.promise,
      displayOptions: this.loading.displayOptions.promise
    }, this.ready = Promise.all([
      this.loaded.manifest,
      this.loaded.spine,
      this.loaded.metadata,
      this.loaded.cover,
      this.loaded.navigation,
      this.loaded.resources,
      this.loaded.displayOptions
    ]), this.isRendered = !1, this.request = this.settings.requestMethod || Uo, this.spine = new _8(), this.locations = new m0(this.spine, this.load.bind(this)), this.navigation = void 0, this.pageList = void 0, this.url = void 0, this.path = void 0, this.archived = !1, this.archive = void 0, this.storage = void 0, this.resources = void 0, this.rendition = void 0, this.container = void 0, this.packaging = void 0, this.displayOptions = void 0, this.settings.store && this.store(this.settings.store), e && this.open(e, this.settings.openAs).catch((r) => {
      var i = new Error("Cannot load book at " + e);
      this.emit(Re.BOOK.OPEN_FAILED, i);
    });
  }
  /**
   * Open a epub or url
   * @param {string | ArrayBuffer} input Url, Path or ArrayBuffer
   * @param {string} [what="binary", "base64", "epub", "opf", "json", "directory"] force opening as a certain type
   * @returns {Promise} of when the book has been loaded
   * @example book.open("/path/to/book.epub")
   */
  open(e, n) {
    var r, i = n || this.determineType(e);
    return i === ur.BINARY ? (this.archived = !0, this.url = new fr("/", ""), r = this.openEpub(e)) : i === ur.BASE64 ? (this.archived = !0, this.url = new fr("/", ""), r = this.openEpub(e, i)) : i === ur.EPUB ? (this.archived = !0, this.url = new fr("/", ""), r = this.request(e, "binary", this.settings.requestCredentials, this.settings.requestHeaders).then(this.openEpub.bind(this))) : i == ur.OPF ? (this.url = new fr(e), r = this.openPackaging(this.url.Path.toString())) : i == ur.MANIFEST ? (this.url = new fr(e), r = this.openManifest(this.url.Path.toString())) : (this.url = new fr(e), r = this.openContainer(fv).then(this.openPackaging.bind(this))), r;
  }
  /**
   * Open an archived epub
   * @private
   * @param  {binary} data
   * @param  {string} [encoding]
   * @return {Promise}
   */
  openEpub(e, n) {
    return this.unarchive(e, n || this.settings.encoding).then(() => this.openContainer(fv)).then((r) => this.openPackaging(r));
  }
  /**
   * Open the epub container
   * @private
   * @param  {string} url
   * @return {string} packagePath
   */
  openContainer(e) {
    return this.load(e).then((n) => (this.container = new S8(n), this.resolve(this.container.packagePath)));
  }
  /**
   * Open the Open Packaging Format Xml
   * @private
   * @param  {string} url
   * @return {Promise}
   */
  openPackaging(e) {
    return this.path = new ri(e), this.load(e).then((n) => (this.packaging = new iv(n), this.unpack(this.packaging)));
  }
  /**
   * Open the manifest JSON
   * @private
   * @param  {string} url
   * @return {Promise}
   */
  openManifest(e) {
    return this.path = new ri(e), this.load(e).then((n) => (this.packaging = new iv(), this.packaging.load(n), this.unpack(this.packaging)));
  }
  /**
   * Load a resource from the Book
   * @param  {string} path path to the resource to load
   * @return {Promise}     returns a promise with the requested resource
   */
  load(e) {
    var n = this.resolve(e);
    return this.archived ? this.archive.request(n) : this.request(n, null, this.settings.requestCredentials, this.settings.requestHeaders);
  }
  /**
   * Resolve a path to it's absolute position in the Book
   * @param  {string} path
   * @param  {boolean} [absolute] force resolving the full URL
   * @return {string}          the resolved path string
   */
  resolve(e, n) {
    if (e) {
      var r = e, i = e.indexOf("://") > -1;
      return i ? e : (this.path && (r = this.path.resolve(e)), n != !1 && this.url && (r = this.url.resolve(r)), r);
    }
  }
  /**
   * Get a canonical link to a path
   * @param  {string} path
   * @return {string} the canonical path string
   */
  canonical(e) {
    var n = e;
    return e ? (this.settings.canonical ? n = this.settings.canonical(e) : n = this.resolve(e, !0), n) : "";
  }
  /**
   * Determine the type of they input passed to open
   * @private
   * @param  {string} input
   * @return {string}  binary | directory | epub | opf
   */
  determineType(e) {
    var n, r, i;
    if (this.settings.encoding === "base64")
      return ur.BASE64;
    if (typeof e != "string")
      return ur.BINARY;
    if (n = new fr(e), r = n.path(), i = r.extension, i && (i = i.replace(/\?.*$/, "")), !i)
      return ur.DIRECTORY;
    if (i === "epub")
      return ur.EPUB;
    if (i === "opf")
      return ur.OPF;
    if (i === "json")
      return ur.MANIFEST;
  }
  /**
   * unpack the contents of the Books packaging
   * @private
   * @param {Packaging} packaging object
   */
  unpack(e) {
    this.package = e, this.packaging.metadata.layout === "" ? this.load(this.url.resolve(eM)).then((n) => {
      this.displayOptions = new Gu(n), this.loading.displayOptions.resolve(this.displayOptions);
    }).catch((n) => {
      this.displayOptions = new Gu(), this.loading.displayOptions.resolve(this.displayOptions);
    }) : (this.displayOptions = new Gu(), this.loading.displayOptions.resolve(this.displayOptions)), this.spine.unpack(this.packaging, this.resolve.bind(this), this.canonical.bind(this)), this.resources = new k8(this.packaging.manifest, {
      archive: this.archive,
      resolver: this.resolve.bind(this),
      request: this.request.bind(this),
      replacements: this.settings.replacements || (this.archived ? "blobUrl" : "base64")
    }), this.loadNavigation(this.packaging).then(() => {
      this.loading.navigation.resolve(this.navigation);
    }), this.packaging.coverPath && (this.cover = this.resolve(this.packaging.coverPath)), this.loading.manifest.resolve(this.packaging.manifest), this.loading.metadata.resolve(this.packaging.metadata), this.loading.spine.resolve(this.spine), this.loading.cover.resolve(this.cover), this.loading.resources.resolve(this.resources), this.loading.pageList.resolve(this.pageList), this.isOpen = !0, this.archived || this.settings.replacements && this.settings.replacements != "none" ? this.replacements().then(() => {
      this.loaded.displayOptions.then(() => {
        this.opening.resolve(this);
      });
    }).catch((n) => {
      console.error(n);
    }) : this.loaded.displayOptions.then(() => {
      this.opening.resolve(this);
    });
  }
  /**
   * Load Navigation and PageList from package
   * @private
   * @param {Packaging} packaging
   */
  loadNavigation(e) {
    let n = e.navPath || e.ncxPath, r = e.toc;
    return r ? new Promise((i, s) => {
      this.navigation = new Wu(r), e.pageList && (this.pageList = new Ku(e.pageList)), i(this.navigation);
    }) : n ? this.load(n, "xml").then((i) => (this.navigation = new Wu(i), this.pageList = new Ku(i), this.navigation)) : new Promise((i, s) => {
      this.navigation = new Wu(), this.pageList = new Ku(), i(this.navigation);
    });
  }
  /**
   * Gets a Section of the Book from the Spine
   * Alias for `book.spine.get`
   * @param {string} target
   * @return {Section}
   */
  section(e) {
    return this.spine.get(e);
  }
  /**
   * Sugar to render a book to an element
   * @param  {element | string} element element or string to add a rendition to
   * @param  {object} [options]
   * @return {Rendition}
   */
  renderTo(e, n) {
    return this.rendition = new Pf(this, n), this.rendition.attachTo(e), this.rendition;
  }
  /**
   * Set if request should use withCredentials
   * @param {boolean} credentials
   */
  setRequestCredentials(e) {
    this.settings.requestCredentials = e;
  }
  /**
   * Set headers request should use
   * @param {object} headers
   */
  setRequestHeaders(e) {
    this.settings.requestHeaders = e;
  }
  /**
   * Unarchive a zipped epub
   * @private
   * @param  {binary} input epub data
   * @param  {string} [encoding]
   * @return {Archive}
   */
  unarchive(e, n) {
    return this.archive = new Z6(), this.archive.open(e, n);
  }
  /**
   * Store the epubs contents
   * @private
   * @param  {binary} input epub data
   * @param  {string} [encoding]
   * @return {Store}
   */
  store(e) {
    let n = this.settings.replacements && this.settings.replacements !== "none", r = this.url, i = this.settings.requestMethod || Uo.bind(this);
    return this.storage = new P0(e, i, this.resolve.bind(this)), this.request = this.storage.request.bind(this.storage), this.opened.then(() => {
      this.archived && (this.storage.requester = this.archive.request.bind(this.archive));
      let s = (o, a) => {
        a.output = this.resources.substitute(o, a.url);
      };
      this.resources.settings.replacements = n || "blobUrl", this.resources.replacements().then(() => this.resources.replaceCss()), this.storage.on("offline", () => {
        this.url = new fr("/", ""), this.spine.hooks.serialize.register(s);
      }), this.storage.on("online", () => {
        this.url = r, this.spine.hooks.serialize.deregister(s);
      });
    }), this.storage;
  }
  /**
   * Get the cover url
   * @return {Promise<?string>} coverUrl
   */
  coverUrl() {
    return this.loaded.cover.then(() => this.cover ? this.archived ? this.archive.createUrl(this.cover) : this.cover : null);
  }
  /**
   * Load replacement urls
   * @private
   * @return {Promise} completed loading urls
   */
  replacements() {
    return this.spine.hooks.serialize.register((e, n) => {
      n.output = this.resources.substitute(e, n.url);
    }), this.resources.replacements().then(() => this.resources.replaceCss());
  }
  /**
   * Find a DOM Range for a given CFI Range
   * @param  {EpubCFI} cfiRange a epub cfi range
   * @return {Promise}
   */
  getRange(e) {
    var n = new gt(e), r = this.spine.get(n.spinePos), i = this.load.bind(this);
    return r ? r.load(i).then(function(s) {
      var o = n.toRange(r.document);
      return o;
    }) : new Promise((s, o) => {
      o("CFI could not be found");
    });
  }
  /**
   * Generates the Book Key using the identifier in the manifest or other string provided
   * @param  {string} [identifier] to use instead of metadata identifier
   * @return {string} key
   */
  key(e) {
    var n = e || this.packaging.metadata.identifier || this.url.filename;
    return `epubjs:${iu}:${n}`;
  }
  /**
   * Destroy the Book and all associated objects
   */
  destroy() {
    this.opened = void 0, this.loading = void 0, this.loaded = void 0, this.ready = void 0, this.isOpen = !1, this.isRendered = !1, this.spine && this.spine.destroy(), this.locations && this.locations.destroy(), this.pageList && this.pageList.destroy(), this.archive && this.archive.destroy(), this.resources && this.resources.destroy(), this.container && this.container.destroy(), this.packaging && this.packaging.destroy(), this.rendition && this.rendition.destroy(), this.displayOptions && this.displayOptions.destroy(), this.spine = void 0, this.locations = void 0, this.pageList = void 0, this.archive = void 0, this.resources = void 0, this.container = void 0, this.packaging = void 0, this.rendition = void 0, this.navigation = void 0, this.url = void 0, this.path = void 0, this.archived = !1;
  }
}
Lr(Bf.prototype);
function Xi(t, e) {
  return new Bf(t, e);
}
Xi.VERSION = iu;
typeof global < "u" && (global.EPUBJS_VERSION = iu);
Xi.Book = Bf;
Xi.Rendition = Pf;
Xi.Contents = If;
Xi.CFI = gt;
Xi.utils = p8;
function tM(t, e) {
  t.addEventListener(
    "keyup",
    (n) => {
      n.key === "ArrowUp" || n.key === "ArrowRight" ? e("next") : (n.key === "ArrowDown" || n.key === "ArrowLeft") && e("prev");
    },
    !1
  );
}
function nM(t, e) {
  let i = 0, s;
  t.addEventListener("wheel", (o) => {
    o.ignore || (o.ignore = !0, clearTimeout(s), i += o.deltaY, s = setTimeout(() => {
      if (Math.abs(i) >= 750) {
        let a = Math.sign(i) > 0 ? "next" : "prev";
        e(a), i = 0;
      }
      i = 0;
    }, 50));
  });
}
function rM(t, e) {
  let s, o, a;
  t.addEventListener(
    "touchstart",
    (l) => {
      l.ignore || (l.ignore = !0, s = l.changedTouches[0].pageX, o = l.changedTouches[0].pageY, a = Date.now());
    },
    !1
  ), t.addEventListener(
    "touchend",
    (l) => {
      var h, v;
      if (l.ignore)
        return;
      l.ignore = !0;
      const u = l.changedTouches[0].pageX - s, c = l.changedTouches[0].pageY - o;
      Date.now() - a <= 500 && (Math.abs(u) >= 50 && Math.abs(c) <= 200 ? e(u < 0 ? "prev" : "next") : Math.abs(c) >= 50 && Math.abs(u) <= 200 ? e(c < 0 ? "up" : "down") : ((v = (h = t == null ? void 0 : t.defaultView) == null ? void 0 : h.getSelection()) == null || v.removeAllRanges(), t.dispatchEvent(
        new MouseEvent("click", {
          clientX: s,
          clientY: o
        })
      ), l.preventDefault()));
    },
    !1
  );
}
function iM(t, e, n) {
  t.addEventListener("mousedown", () => {
    t.getSelection().removeAllRanges(), n("cleared");
  }), t.addEventListener("mouseup", (r) => {
    if (r.ignore)
      return;
    r.ignore = !0;
    const i = t.getSelection(), s = i.toString();
    if (s === "")
      return;
    const o = i.getRangeAt(0), [a] = e.getContents(), l = a.cfiFromRange(o), u = o.getBoundingClientRect(), c = e.manager.container.getBoundingClientRect();
    let d = {
      left: `${c.x + u.x - (e.manager.scrollLeft || 0)}px`,
      top: `${c.y + u.y}px`,
      width: `${u.width}px`,
      height: `${u.height}px`
    };
    n("selected", d, s, l);
  });
}
const B0 = be({
  name: "EpubView",
  model: {
    prop: "location",
    event: "update:location"
  },
  emits: {
    "update:location"(t) {
      return !0;
    },
    select(t, e) {
      return !0;
    },
    keyup(t) {
      return !0;
    }
  },
  props: {
    url: {
      required: !0
      // type: Object as PropType<Props['url']>,
    },
    location: {
      // type: [Number, String],
    },
    tocChanged: {
      type: Function
    },
    getRendition: {
      type: Function
    },
    epubInitOptions: {
      type: Object,
      default: () => ({})
    },
    epubOptions: {
      type: Object,
      default: () => ({})
    }
  },
  setup(t, e) {
    const { emit: n, slots: r, expose: i } = e, s = ht(), o = et.bind(s), { url: a, location: l } = hn(t), { tocChanged: u, getRendition: c, epubInitOptions: d, epubOptions: h } = t, v = $(null), y = $([]), b = $(!1);
    let p = null, f = null;
    const g = async () => {
      p && p.destroy(), a.value && (p = Xi(a.value, d), p.loaded.navigation.then(({ toc: N }) => {
        b.value = !0, y.value = N, u && u(N), m();
      }));
    }, m = () => {
      var B, M;
      const N = v.value || ((B = s == null ? void 0 : s.refs) == null ? void 0 : B.viewer);
      f = p.renderTo(N, {
        width: "100%",
        height: "100%",
        ...h
      }), _(), c && c(f), typeof (l == null ? void 0 : l.value) == "string" || typeof (l == null ? void 0 : l.value) == "number" ? f.display(l.value) : y.value.length > 0 && ((M = y == null ? void 0 : y.value[0]) != null && M.href) ? f.display(y.value[0].href) : f.display();
    }, w = (N) => {
      N === "next" ? C() : N === "prev" && k();
    }, _ = () => {
      f && (f.on("rendered", (N, B) => {
        var M, j;
        (M = B == null ? void 0 : B.iframe) == null || M.contentWindow.focus(), (j = h == null ? void 0 : h.flow) != null && j.includes("scrolled") || nM(B.document, w), rM(B.document, w), tM(B.document, w);
      }), f.on("locationChanged", S), f.on(
        "displayError",
        (N) => console.error("error rendering book", N)
      ), f.on(
        "selected",
        (N, B) => n("select", N, B)
      ), f.on("keyup", (N) => n("keyPress", N)));
    }, S = (N) => {
      const B = N.start;
      (l == null ? void 0 : l.value) !== B && n("update:location", B);
    };
    l && ke(
      l,
      ((N, B = 1e3) => {
        let M;
        return function(...q) {
          const X = () => {
            M = null, N(...q);
          };
          clearTimeout(M), M = setTimeout(X, B);
        };
      })((N, B) => {
        N && N === B || (typeof N == "string" && (f == null || f.display(N)), typeof N == "number" && (f == null || f.display(N)));
      }),
      {
        immediate: !0
      }
    ), ke(a, () => {
      g();
    });
    const C = () => {
      f == null || f.next();
    }, k = () => {
      f == null || f.prev();
    }, O = (N) => {
      typeof N == "string" && f.display(N), typeof N == "number" && f.display(N);
    };
    return Ct(() => {
      g();
    }), En(() => {
      p == null || p.destroy();
    }), i ? i({ nextPage: C, prevPage: k, setLocation: O }) : ((B) => {
      if (!s)
        throw new Error("expose should be called in setup().");
      const M = Object.keys(B);
      M.forEach((j) => {
        s.proxy[j] = B[j];
      }), En(() => {
        M.forEach((j) => {
          s.proxy[j] = void 0;
        });
      });
    })({ nextPage: C, prevPage: k, setLocation: O }), () => {
      var N;
      return o("div", { class: "reader" }, [
        o("div", { class: "viewHolder" }, [
          o("div", {
            ref: parseFloat(bv) >= 2.7 ? v : "viewer",
            class: "view",
            id: "viewer",
            attrs: { id: "viewer" },
            style: {
              display: b.value ? null : "none"
            }
          }),
          !b.value && o("div", (N = r.loadingView) == null ? void 0 : N.call(r))
        ])
      ]);
    };
  }
});
const D0 = be({
  name: "TocComponent",
  props: {
    toc: {
      type: Array,
      default: () => []
    },
    current: {
      type: [String, Number],
      default: ""
    },
    setLocation: {
      type: Function,
      required: !0
    },
    isSubmenu: {
      type: Boolean,
      default: !1,
      required: !1
    }
  },
  setup(t) {
    const e = ht(), n = et.bind(e), { setLocation: r, isSubmenu: i } = t, { toc: s, current: o } = hn(t);
    return () => n(
      "div",
      null,
      s.value.map((a, l) => n("div", { key: l }, [
        n(
          "button",
          {
            class: [
              "tocAreaButton",
              a.href === o.value ? "active" : ""
            ],
            on: {
              click: () => {
                a.subitems.length > 0 ? (a.expansion = !a.expansion, r(a.href, !1)) : r(a.href);
              }
            },
            onClick: () => {
              a.subitems.length > 0 ? (a.expansion = !a.expansion, r(a.href, !1)) : r(a.href);
            }
          },
          [
            `${i ? " ".repeat(4) : ""}${a.label}`,
            // 展开
            a.subitems && a.subitems.length > 0 && n("div", {
              class: `${a.expansion ? "open" : ""} expansion`
            })
          ]
        ),
        //多级目录
        a.subitems && a.subitems.length > 0 && n(
          mr,
          { name: "collapse-transition" },
          {
            default: () => n(
              "div",
              {
                style: {
                  display: a.expansion ? void 0 : "none"
                }
              },
              n(D0, {
                toc: a.subitems,
                current: o.value,
                setLocation: r,
                isSubmenu: !0,
                attrs: {
                  toc: s.value,
                  current: o.value,
                  setLocation: r,
                  isSubmenu: !0
                }
              })
            )
          }
        )
      ]))
    );
  }
});
be({
  name: "VueReader",
  props: {
    url: {
      required: !0
      // type: [string | ArrayBuffer],
    },
    title: String,
    showToc: {
      type: Boolean,
      default: !0
    },
    tocChanged: {
      type: Function
    },
    getRendition: {
      type: Function
    }
  },
  setup(t, e) {
    const { emit: n, slots: r, expose: i, attrs: s } = e, o = ht(), a = et.bind(o), l = $(null), u = $(null), c = $(""), { tocChanged: d, getRendition: h } = t, { title: v, url: y, showToc: b } = hn(t), p = Bn({
      toc: [],
      //目录
      expandedToc: !1
      //目录展开
    }), { toc: f, expandedToc: g } = hn(p), m = $(""), w = () => {
      g.value = !g.value;
    }, _ = (O) => {
      f.value = O.map((N) => ({ ...N, expansion: !1 })), d && d(O);
    }, S = (O) => {
      h && h(O), O.on("relocated", (B) => {
        u.value = B;
      });
      const N = O.book;
      N.ready.then(() => {
        const B = N.package.metadata;
        m.value = B.title;
      });
    }, A = (O, N = !0) => {
      const B = l.value || (o == null ? void 0 : o.refs.epubRef);
      B == null || B.setLocation(O), c.value = O, g.value = !N;
    }, C = () => {
      const O = l.value || (o == null ? void 0 : o.refs.epubRef);
      O == null || O.nextPage();
    }, k = () => {
      const O = l.value || (o == null ? void 0 : o.refs.epubRef);
      O == null || O.prevPage();
    };
    return i ? i({ setLocation: A, next: C, pre: k }) : ((N) => {
      if (!o)
        throw new Error("expose should be called in setup().");
      const B = Object.keys(N);
      B.forEach((M) => {
        o.proxy[M] = N[M];
      }), En(() => {
        B.forEach((M) => {
          o.proxy[M] = void 0;
        });
      });
    })({ setLocation: A, next: C, pre: k }), () => {
      var O, N, B, M, j;
      return a("div", { class: "container" }, [
        a(
          "div",
          { class: ["readerArea", { containerExpanded: g.value }] },
          [
            // 展开目录
            b.value && a(
              "button",
              {
                class: [
                  "tocButton",
                  { tocButtonExpanded: g.value }
                ],
                type: "button",
                on: {
                  click: w
                },
                onClick: w
              },
              [
                a("span", { class: "tocButtonBar", style: "top: 35%" }),
                a("span", { class: "tocButtonBar", style: "top: 66%" })
              ]
            ),
            // 书名
            a(
              "div",
              { class: "titleArea", title: m.value },
              r.title ? (O = r.title) == null ? void 0 : O.call(r) : v.value || m.value
            ),
            // 阅读区
            a(
              B0,
              {
                ref: parseFloat(bv) < 2.7 ? "epubRef" : l,
                url: y.value,
                tocChanged: _,
                getRendition: S,
                ...s,
                //vue2
                attrs: {
                  url: y.value,
                  tocChanged: _,
                  getRendition: S,
                  ...s
                },
                on: {
                  ...e.listeners
                }
              },
              {
                // loading
                loadingView: () => {
                  var q;
                  return a(
                    "div",
                    { class: "loadingView" },
                    r.loadingView ? (q = r.loadingView) == null ? void 0 : q.call(r) : "Loading..."
                  );
                }
              }
            ),
            // 翻页
            a(
              "button",
              {
                class: "arrow pre",
                on: {
                  click: k
                },
                onClick: k,
                domProps: {
                  disabled: (N = u.value) == null ? void 0 : N.atStart
                },
                disabled: (B = u.value) == null ? void 0 : B.atStart
              },
              "‹"
            ),
            a(
              "button",
              {
                class: "arrow next",
                on: {
                  click: C
                },
                onClick: C,
                domProps: {
                  disabled: (M = u.value) == null ? void 0 : M.atEnd
                },
                disabled: (j = u.value) == null ? void 0 : j.atEnd
              },
              "›"
            )
          ]
        ),
        // 目录
        b.value && a("div", [
          a(
            "div",
            { class: "tocArea" },
            a(D0, {
              toc: f.value,
              current: c.value,
              setLocation: A,
              attrs: {
                toc: f.value,
                current: c.value,
                setLocation: A
              }
            })
          ),
          // 目录遮罩
          g.value && a("div", {
            class: ["tocBackground"],
            onClick: w,
            on: {
              click: w
            }
          })
        ])
      ]);
    };
  }
});
const sM = (t) => (wv("data-v-3bf5a8c5"), t = t(), _v(), t), oM = /* @__PURE__ */ sM(() => /* @__PURE__ */ ae("div", { class: "el-popover__title" }, "Table of Content", -1)), aM = {
  __name: "TocMenu",
  props: {
    toc: {
      default: () => [],
      type: Array
    }
  },
  emits: ["node-click"],
  setup(t, { emit: e }) {
    const n = Ws(), r = t, i = e, s = (o) => {
      i("node-click", o);
    };
    return (o, a) => {
      const l = Yi, u = r3, c = ta;
      return V(), Ae(c, {
        "popper-class": `popper ${x(n).theme}`,
        placement: "bottom",
        width: 380,
        trigger: "hover",
        "popper-style": { height: "85%" }
      }, {
        reference: de(() => [
          ve(l, {
            size: "small",
            icon: x(tC),
            circle: ""
          }, null, 8, ["icon"])
        ]),
        default: de(() => [
          oM,
          ve(u, {
            data: r.toc,
            onNodeClick: s
          }, null, 8, ["data"])
        ]),
        _: 1
      }, 8, ["popper-class"]);
    };
  }
}, lM = /* @__PURE__ */ Qi(aM, [["__scopeId", "data-v-3bf5a8c5"]]);
const uM = { class: "el-popover__title" }, cM = {
  __name: "SearchMenu",
  props: {
    searchResult: {
      default: () => [],
      type: Array
    }
  },
  emits: ["search", "node-click"],
  setup(t, { emit: e }) {
    const n = Ws(), r = t, { searchResult: i } = hn(r), s = e, o = $(""), a = () => {
    }, l = () => {
      o.value;
    }, u = (d) => {
      s("node-click", d);
    };
    let c = null;
    return ke(o, (d) => {
      d.length !== 0 && (clearTimeout(c), c = setTimeout(() => {
        s("search", d);
      }, 1e3));
    }), ke(i, () => {
      l();
    }), (d, h) => {
      const v = Yi, y = Jl, b = UP, p = HP, f = ta;
      return V(), Ae(f, {
        "popper-class": `popper reader-${x(n).theme}`,
        width: "350",
        trigger: "hover",
        onShow: l,
        onHide: a
      }, {
        reference: de(() => [
          ve(v, {
            size: "small",
            icon: x(AC),
            circle: ""
          }, null, 8, ["icon"])
        ]),
        default: de(() => [
          ae("div", uM, [
            ve(y, {
              modelValue: o.value,
              "onUpdate:modelValue": h[0] || (h[0] = (g) => o.value = g),
              size: "small",
              width: "300",
              placeholder: "search"
            }, null, 8, ["modelValue"])
          ]),
          (V(), Ae(p, {
            key: x(i).length,
            "show-header": !1,
            data: x(i),
            onCellClick: u
          }, {
            default: de(() => [
              ve(b, {
                prop: "label",
                width: "350"
              })
            ]),
            _: 1
          }, 8, ["data"]))
        ]),
        _: 1
      }, 8, ["popper-class"]);
    };
  }
};
const Ks = (t) => (wv("data-v-b4a6d1f6"), t = t(), _v(), t), dM = { class: "table" }, fM = /* @__PURE__ */ Ks(() => /* @__PURE__ */ ae("td", null, "Flow", -1)), hM = /* @__PURE__ */ Ks(() => /* @__PURE__ */ ae("td", null, "Theme", -1)), pM = /* @__PURE__ */ Ks(() => /* @__PURE__ */ ae("td", null, "Line Spacing", -1)), vM = /* @__PURE__ */ Ks(() => /* @__PURE__ */ ae("td", null, "Font Size", -1)), gM = /* @__PURE__ */ Ks(() => /* @__PURE__ */ ae("td", null, "Font", -1)), mM = /* @__PURE__ */ Ks(() => /* @__PURE__ */ ae("td", null, "reset", -1)), yM = {
  __name: "ThemeMenu",
  emits: ["style-change", "theme-change", "flow-change"],
  setup(t, { emit: e }) {
    const n = Ws(), { lineSpacing: r, theme: i, flow: s, font: o, fontSize: a } = KB(n), l = e, u = () => {
      const c = {
        p: {
          "font-family": o.value !== "" ? `${o.value} !important` : "!invalid-hack",
          "font-size": a.value !== "" ? `${a.value} !important` : "!invalid-hack"
        },
        body: {
          "font-family": o.value !== "" ? `${o.value} !important` : "!invalid-hack"
          // "text-align": `${theme.ta} !important`,
        },
        "*": {
          "line-height": `${r.value} !important`,
          "font-size": a.value !== "" ? `${a.value}% !important` : "!invalid-hack"
        }
      };
      l("style-change", c);
    };
    return Ct(() => {
      u();
    }), ke(
      () => [r, o, a],
      () => {
        u();
      },
      {
        deep: !0
      }
    ), ke(i, (c) => {
      l("theme-change", c);
    }), ke(s, (c) => {
      l("flow-change", c);
    }), (c, d) => {
      const h = Yi, v = b4, y = y4, b = xm, p = HN, f = FN, g = ta;
      return V(), Ae(g, {
        "popper-class": x(i),
        trigger: "hover",
        width: 270
      }, {
        reference: de(() => [
          ve(h, {
            size: "small",
            icon: x(Mk),
            circle: ""
          }, null, 8, ["icon"])
        ]),
        default: de(() => [
          ae("table", dM, [
            ae("tr", null, [
              fM,
              ae("td", null, [
                ve(y, {
                  modelValue: x(s),
                  "onUpdate:modelValue": d[0] || (d[0] = (m) => on(s) ? s.value = m : null),
                  size: "small",
                  style: { "flex-wrap": "nowrap" }
                }, {
                  default: de(() => [
                    ve(v, {
                      label: "paginated",
                      border: ""
                    }, {
                      default: de(() => [
                        cn(" Paged ")
                      ]),
                      _: 1
                    }),
                    ve(v, {
                      label: "scrolled-doc",
                      border: ""
                    }, {
                      default: de(() => [
                        cn(" Scrolled ")
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["modelValue"])
              ])
            ]),
            ae("tr", null, [
              hM,
              ae("td", null, [
                ve(y, {
                  modelValue: x(i),
                  "onUpdate:modelValue": d[1] || (d[1] = (m) => on(i) ? i.value = m : null),
                  size: "small"
                }, {
                  default: de(() => [
                    ve(v, {
                      label: "default",
                      border: ""
                    }, {
                      default: de(() => [
                        cn(" Light ")
                      ]),
                      _: 1
                    }),
                    ve(v, {
                      label: "tan",
                      border: ""
                    }, {
                      default: de(() => [
                        cn(" Tan ")
                      ]),
                      _: 1
                    }),
                    ve(v, {
                      label: "dark",
                      border: ""
                    }, {
                      default: de(() => [
                        cn(" Dark ")
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["modelValue"])
              ])
            ]),
            ae("tr", null, [
              pM,
              ae("td", null, [
                ve(b, {
                  modelValue: x(r),
                  "onUpdate:modelValue": d[2] || (d[2] = (m) => on(r) ? r.value = m : null),
                  precision: 2,
                  step: 0.1,
                  min: 1.3,
                  max: 2,
                  size: "small"
                }, null, 8, ["modelValue"])
              ])
            ]),
            ae("tr", null, [
              vM,
              ae("td", null, [
                ve(b, {
                  modelValue: x(a),
                  "onUpdate:modelValue": d[3] || (d[3] = (m) => on(a) ? a.value = m : null),
                  step: 2,
                  min: 10,
                  max: 300,
                  size: "small"
                }, null, 8, ["modelValue"])
              ])
            ]),
            ae("tr", null, [
              gM,
              ae("td", null, [
                ve(f, {
                  teleported: !1,
                  modelValue: x(o),
                  "onUpdate:modelValue": d[4] || (d[4] = (m) => on(o) ? o.value = m : null),
                  class: "font-select",
                  width: "50",
                  size: "small"
                }, {
                  default: de(() => [
                    ve(p, {
                      label: "Default",
                      value: ""
                    }),
                    ve(p, {
                      label: "Arial",
                      value: "Arial"
                    }),
                    ve(p, {
                      label: "Times New Roman",
                      value: "Times New Roman"
                    })
                  ]),
                  _: 1
                }, 8, ["modelValue"])
              ])
            ]),
            ae("tr", null, [
              mM,
              ae("td", null, [
                ve(h, {
                  onClick: x(n).reset
                }, {
                  default: de(() => [
                    cn("reset all")
                  ]),
                  _: 1
                }, 8, ["onClick"])
              ])
            ])
          ])
        ]),
        _: 1
      }, 8, ["popper-class"]);
    };
  }
}, bM = /* @__PURE__ */ Qi(yM, [["__scopeId", "data-v-b4a6d1f6"]]);
const wM = {
  name: "BubleMenu",
  data() {
    return {
      isVisible: !1,
      translateTo: "gu",
      translatedText: "",
      text: ""
    };
  },
  methods: {
    setProps(t, e, n) {
      let r = this.$refs.popRef;
      r.style.left = t.left, r.style.top = t.top, r.style.width = t.width, r.style.height = t.height, console.log(t), this.text = e, this.cfiRange = n, this.translateText(), this.isVisible = !0;
    },
    hide() {
      this.isVisible = !1, this.text = "", this.translatedText = "No Data", this.cfiRange = "";
    },
    show() {
      this.isVisible = !0;
    },
    onHLBtn() {
      this.cfiRange !== "" && this.$emit("highlight-btn-click", this.cfiRange);
    },
    copyText() {
      const t = document.createElement("textarea");
      t.style.position = "absolute", t.style.left = "-9999px", t.value = this.text, document.body.appendChild(t), t.select(), document.execCommand("copy"), document.body.removeChild(t);
    },
    translateText() {
    }
  }
}, _M = { class: "el-popover__title" }, SM = /* @__PURE__ */ ae("template", { slot: "prepend" }, [
  /* @__PURE__ */ cn(" Translate to ")
], -1), EM = {
  ref: "popRef",
  style: { position: "absolute", visibility: "hidden" }
};
function xM(t, e, n, r, i, s) {
  const o = Yi, a = Qg, l = Jl, u = ta, c = Cm;
  return V(), Ae(u, {
    modelValue: i.isVisible,
    "onUpdate:modelValue": e[1] || (e[1] = (d) => i.isVisible = d),
    "popper-class": "buble",
    trigger: "manual"
  }, {
    reference: de(() => [
      ae("span", EM, null, 512)
    ]),
    default: de(() => [
      ve(a, null, {
        default: de(() => [
          ve(o, {
            size: "small",
            icon: "brush",
            onClick: s.onHLBtn
          }, null, 8, ["onClick"]),
          ve(o, {
            size: "small",
            icon: "copy-document",
            onClick: s.copyText
          }, null, 8, ["onClick"]),
          Dt(ve(o, {
            size: "small",
            icon: "collection"
          }, null, 512), [
            [c, void 0, "translatePop"]
          ])
        ]),
        _: 1
      }),
      ve(u, {
        ref: "translatePop",
        width: "200",
        trigger: "hover"
      }, {
        reference: de(() => [
          cn(st(i.translatedText), 1)
        ]),
        default: de(() => [
          ae("div", _M, [
            ve(l, {
              modelValue: i.translateTo,
              "onUpdate:modelValue": e[0] || (e[0] = (d) => i.translateTo = d),
              placeholder: "Language Code",
              width: "30",
              size: "small"
            }, {
              default: de(() => [
                SM
              ]),
              _: 1
            }, 8, ["modelValue"])
          ])
        ]),
        _: 1
      }, 512)
    ]),
    _: 1
  }, 8, ["modelValue"]);
}
const AM = /* @__PURE__ */ Qi(wM, [["render", xM]]), kM = async (t) => {
  const { toc: e } = t.navigation, { spine: n } = t, r = (l) => (l.startsWith("..") && (l = l.substring(2)), l.startsWith("/") && (l = l.substring(1)), l), i = (l) => l.split("#")[0], s = (l) => l.split("#")[1], o = [], a = async (l, u) => {
    for (let c = 0; c < l.length; c += 1) {
      const d = r(l[c].href), h = i(d), v = s(d), y = n.get(h);
      await y.load(t.load.bind(t));
      const b = y.document.getElementById(v), p = y.cfiFromElement(b), f = t.locations.percentageFromCfi(p);
      u[c] = {
        label: l[c].label.trim(),
        children: [],
        href: d,
        cfi: p,
        percentage: f
      }, l[c].subitems && await a(l[c].subitems, u[c].children);
    }
  };
  return await a(e, o), o;
}, CM = async (t, e, n) => {
  !t || typeof t != "string" || e.ready.then(() => e.locations.generate()).then(async (r) => {
    const i = e.package.metadata, s = {
      // id: key,
      title: i.title,
      author: i.creator,
      publisher: i.publisher,
      path: t,
      bookmarks: [],
      highlights: [],
      bgColorFromCover: "",
      toc: await kM(e),
      locations: r
    };
    n && n(s, e);
  });
}, TM = {
  body: {
    background: "#444 !important",
    color: "#fff !important"
  },
  "*": {
    color: "inherit !important",
    background: "inherit !important"
  },
  "a:link": {
    color: "#1e83d2 !important",
    "text-decoration": "none !important"
  },
  "a:link:hover": {
    background: "rgba(0, 0, 0, 0.1) !important"
  }
}, OM = {
  body: {
    background: "#fdf6e3 !important",
    color: "#002b36 !important"
  },
  "*": {
    color: "inherit !important",
    background: "inherit !important"
  },
  "a:link": {
    color: "#268bd2 !important",
    "text-decoration": "none !important"
  },
  "a:link:hover": {
    background: "rgba(0, 0, 0, 0.1) !important"
  }
};
const IM = {
  __name: "Reader",
  props: {
    bookInfo: {
      type: [Object, Number, ArrayBuffer]
    }
  },
  emits: ["update:showReader", "theme-change"],
  setup(t, { emit: e }) {
    const n = Ws(), r = t, i = $(!1), s = $({}), o = $(""), a = F(() => r.bookInfo.url ? `/books/${r.bookInfo.url}` : r.bookInfo);
    let l = null, u = null;
    const c = (J) => {
      l = J;
      const le = l.book;
      l.on("rendered", (ce, ge) => {
        iM(ge.document, l, re);
      }), l.on("relocated", (ce) => {
        S.value.push(ce.start.cfi), p.value = le.locations.percentageFromCfi(ce.start.cfi), b.value = Math.floor(p.value * 1e4) / 100;
      }), l.hooks.content.register(X), le.ready.then(() => {
        const ce = le.package.metadata;
        return console.log(le.package.metadata), o.value = ce.title, le.locations.generate();
      }).then(async (ce) => {
        l.themes.registerRules("dark", TM), l.themes.registerRules("tan", OM), l.ready = !0;
        const { theme: ge, flow: _e } = n;
        B(ge), M(_e), await CM(a.value, le, (je) => {
          s.value = je, u = function Te(Ze) {
            return [].concat(
              ...Ze.map((Le) => [Le].concat(...Te(Le.children)))
            );
          }(je.toc), u.sort((Te, Ze) => Te.percentage - Ze.percentage);
        });
      }).then(() => {
        i.value = !0;
      }).then(() => {
        i.value = !0;
      });
    }, d = $([]), h = $(""), v = (J, le) => {
      let ce = "n/a";
      return J.some((ge) => {
        if (ge.subitems.length > 0) {
          const _e = v(ge.subitems, le);
          if (_e !== "n/a")
            return ce = _e, !0;
        } else if (ge.href.includes(le))
          return ce = ge.label, !0;
      }), ce;
    }, y = (J) => {
      if (J) {
        const { displayed: le, href: ce } = l.location.start;
        if (l.location.end, ce !== "titlepage.xhtml") {
          const ge = v(d.value, ce);
          h.value = `${le.page}/${le.total} ${ge}`;
        }
      }
    };
    Ct(() => {
    });
    const b = $(0), p = $(0), f = (J) => {
      let le = g(J);
      return le ? le.label : "";
    }, g = (J) => {
      if (!u)
        return {};
      J /= 100;
      for (let le = 0; le < u.length; le += 1)
        if (u[le].percentage > J)
          return u[le - 1];
      return null;
    }, m = (J) => {
      let le = l.book.locations.cfiFromPercentage(J / 100);
      l.display(le);
    }, w = $(0);
    ((J) => {
      var le = XMLHttpRequest.prototype.open;
      XMLHttpRequest.prototype.open = function() {
        this.addEventListener(
          "progress",
          function(ce) {
            ce.lengthComputable && J(ce.loaded / ce.total);
          },
          !1
        ), le.apply(this, arguments);
      };
    })((J) => {
      w.value = Math.round(J * 100);
    });
    const S = $([]), A = () => {
      S.value.pop();
      let J = S.value.pop();
      J ? l.display(J) : C("update:showReader", !1);
    }, C = e, k = () => {
      C("update:showReader", !1);
    }, O = (J) => {
      console.log(J.cfi, J.href), l.display(J.cfi || J.href);
    }, N = $({}), B = (J) => {
      l.themes.select(J), n.theme = J, q(), C("theme-change", J);
    }, M = (J) => {
      l.ready && l.flow(J);
    }, j = (J) => {
      N.value = J, X(), q();
    }, q = () => {
      l && l.manager && l.start();
    }, X = () => {
      l && l.getContents().forEach((J) => {
        J.addStylesheetRules(N.value);
      });
    }, z = $([]), U = (J) => {
      const le = l.book;
      return Promise.all(
        le.spine.spineItems.map(
          (ce) => ce.load(le.load.bind(le)).then(ce.find.bind(ce, J)).finally(ce.unload.bind(ce))
        )
      ).then((ce) => ce.flat()).then((ce) => {
        z.value = ce.map((ge) => (ge.label = ge.excerpt, ge));
      }).then(() => {
      });
    }, H = $(null), re = (J, le, ce, ge) => {
      if (J === "cleared") {
        H.value.hide();
        return;
      }
      console.log(H.value), H.value.setProps(le, ce, ge), H.value.isBubleVisible = !0;
    }, fe = (J) => {
      l.annotations.highlight(J);
    };
    return (J, le) => {
      const ce = Yi, ge = Qg, _e = Tm, je = Em, Te = BR, Ze = j4, Le = Sm, Ke = H3;
      return V(), Ae(Le, { direction: "vertical" }, {
        default: de(() => [
          ve($m, { title: o.value }, {
            default: de(() => [
              ve(ge, null, {
                default: de(() => [
                  ve(ce, {
                    size: "small",
                    icon: x(cA),
                    circle: "",
                    onClick: A
                  }, null, 8, ["icon"]),
                  ve(ce, {
                    size: "small",
                    icon: x(fk),
                    circle: "",
                    onClick: k
                  }, null, 8, ["icon"])
                ]),
                _: 1
              }),
              ve(lM, {
                toc: s.value.toc,
                onNodeClick: O
              }, null, 8, ["toc"]),
              ve(cM, {
                "search-result": z.value,
                onNodeClick: O,
                onSearch: U
              }, null, 8, ["search-result"]),
              ve(bM, {
                onThemeChange: B,
                onFlowChange: M,
                onStyleChange: j
              })
            ]),
            _: 1
          }, 8, ["title"]),
          ve(je, { class: "container" }, {
            default: de(() => [
              Dt((V(), Ae(x(B0), {
                id: "reader",
                url: a.value,
                getRendition: c,
                title: h.value,
                epubOptions: {
                  allowPopups: !0,
                  allowScriptedContent: !0
                },
                "onUpdate:location": y
              }, {
                loadingView: de(() => [
                  ve(_e, { percentage: w.value }, null, 8, ["percentage"])
                ]),
                _: 1
              }, 8, ["url", "title"])), [
                [Ke, !i.value]
              ])
            ]),
            _: 1
          }),
          ve(Ze, { height: "45" }, {
            default: de(() => [
              ve(Te, {
                modelValue: b.value,
                "onUpdate:modelValue": le[0] || (le[0] = (ct) => b.value = ct),
                step: 0.01,
                "format-tooltip": f,
                onChange: m
              }, null, 8, ["modelValue"])
            ]),
            _: 1
          }),
          ve(AM, {
            ref_key: "bubleMenu",
            ref: H,
            onHighlightBtnClick: fe
          }, null, 512)
        ]),
        _: 1
      });
    };
  }
}, NM = /* @__PURE__ */ Qi(IM, [["__scopeId", "data-v-dc866de6"]]);
const RM = {
  name: "ReaderStart"
}, PM = Object.assign(RM, {
  setup(t) {
    const e = Ws(), n = $(!1), r = $({}), i = (s) => {
      r.value = s, n.value = !0;
    };
    return (s, o) => (V(), se("div", {
      id: "index",
      ref: "app",
      class: ee("reader-" + x(e).theme)
    }, [
      ve(mr, { name: "el-fade-in-linear" }, {
        default: de(() => [
          n.value ? ye("", !0) : (V(), Ae(rD, {
            key: 0,
            "onUpdate:currentBook": i,
            showReader: n.value,
            "onUpdate:showReader": o[0] || (o[0] = (a) => n.value = a)
          }, null, 8, ["showReader"]))
        ]),
        _: 1
      }),
      ve(mr, { name: "el-fade-in-linear" }, {
        default: de(() => [
          n.value ? (V(), Ae(NM, {
            key: 0,
            bookInfo: r.value,
            "onUpdate:showReader": o[1] || (o[1] = (a) => n.value = a)
          }, null, 8, ["bookInfo"])) : ye("", !0)
        ]),
        _: 1
      })
    ], 2));
  }
}), BM = /* @__PURE__ */ Qi(PM, [["__scopeId", "data-v-e6b91ae5"]]), LM = {
  install: (t) => {
    t.component("ReaderStart", BM);
  }
};
export {
  LM as default,
  Ws as useReaderStore
};
