import { effectScope as Ed, ref as K, markRaw as mr, toRaw as _r, getCurrentInstance as ft, inject as et, watch as Ae, unref as x, reactive as Mn, isRef as on, isReactive as Jl, toRef as On, nextTick as rt, computed as j, onUnmounted as ea, toRefs as pn, getCurrentScope as wb, onScopeDispose as _b, onMounted as Ct, openBlock as U, createElementBlock as oe, createElementVNode as le, warn as Sb, shallowRef as Fn, onBeforeUnmount as xn, onBeforeMount as xd, provide as qt, defineComponent as ye, mergeProps as Jn, renderSlot as Me, useAttrs as Rv, useSlots as ta, withDirectives as Bt, createCommentVNode as me, Fragment as Ft, normalizeClass as X, createBlock as xe, withCtx as fe, resolveDynamicComponent as Pn, withModifiers as dt, createVNode as ve, toDisplayString as st, normalizeStyle as it, vShow as Qn, Transition as Sr, onUpdated as Yl, cloneVNode as Eb, Text as Pv, Comment as Dv, Teleport as Bv, readonly as xb, onDeactivated as Ab, createTextVNode as cn, vModelCheckbox as vl, vModelRadio as Mv, toHandlers as kb, renderList as Yn, withKeys as gn, triggerRef as ro, resolveComponent as Mt, resolveDirective as Ad, vModelText as Cb, createSlots as ac, h as Xe, watchEffect as go, TransitionGroup as Tb, createApp as Ob, version as Lv, pushScopeId as zv, popScopeId as jv } from "vue";
var Fv = !1;
function Ea(t, e, n) {
  return Array.isArray(t) ? (t.length = Math.max(t.length, e), t.splice(e, 1, n), n) : (t[e] = n, n);
}
function ku(t, e) {
  if (Array.isArray(t)) {
    t.splice(e, 1);
    return;
  }
  delete t[e];
}
function Ib() {
  return Hv().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function Hv() {
  return typeof navigator < "u" && typeof window < "u" ? window : typeof global < "u" ? global : {};
}
const Nb = typeof Proxy == "function", Rb = "devtools-plugin:setup", Pb = "plugin:settings:set";
let cs, lc;
function Db() {
  var t;
  return cs !== void 0 || (typeof window < "u" && window.performance ? (cs = !0, lc = window.performance) : typeof global < "u" && (!((t = global.perf_hooks) === null || t === void 0) && t.performance) ? (cs = !0, lc = global.perf_hooks.performance) : cs = !1), cs;
}
function Bb() {
  return Db() ? lc.now() : Date.now();
}
class Mb {
  constructor(e, n) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = e, this.hook = n;
    const r = {};
    if (e.settings)
      for (const o in e.settings) {
        const a = e.settings[o];
        r[o] = a.defaultValue;
      }
    const i = `__vue-devtools-plugin-settings__${e.id}`;
    let s = Object.assign({}, r);
    try {
      const o = localStorage.getItem(i), a = JSON.parse(o);
      Object.assign(s, a);
    } catch {
    }
    this.fallbacks = {
      getSettings() {
        return s;
      },
      setSettings(o) {
        try {
          localStorage.setItem(i, JSON.stringify(o));
        } catch {
        }
        s = o;
      },
      now() {
        return Bb();
      }
    }, n && n.on(Pb, (o, a) => {
      o === this.plugin.id && this.fallbacks.setSettings(a);
    }), this.proxiedOn = new Proxy({}, {
      get: (o, a) => this.target ? this.target.on[a] : (...l) => {
        this.onQueue.push({
          method: a,
          args: l
        });
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (o, a) => this.target ? this.target[a] : a === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(a) ? (...l) => (this.targetQueue.push({
        method: a,
        args: l,
        resolve: () => {
        }
      }), this.fallbacks[a](...l)) : (...l) => new Promise((u) => {
        this.targetQueue.push({
          method: a,
          args: l,
          resolve: u
        });
      })
    });
  }
  async setRealTarget(e) {
    this.target = e;
    for (const n of this.onQueue)
      this.target.on[n.method](...n.args);
    for (const n of this.targetQueue)
      n.resolve(await this.target[n.method](...n.args));
  }
}
function Uv(t, e) {
  const n = t, r = Hv(), i = Ib(), s = Nb && n.enableEarlyProxy;
  if (i && (r.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !s))
    i.emit(Rb, t, e);
  else {
    const o = s ? new Mb(n, i) : null;
    (r.__VUE_DEVTOOLS_PLUGINS__ = r.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: n,
      setupFn: e,
      proxy: o
    }), o && e(o.proxiedTarget);
  }
}
/*!
  * pinia v2.0.23
  * (c) 2022 Eduardo San Martin Morote
  * @license MIT
  */
let ho;
const Oo = (t) => ho = t, Vv = process.env.NODE_ENV !== "production" ? Symbol("pinia") : (
  /* istanbul ignore next */
  Symbol()
);
function $i(t) {
  return t && typeof t == "object" && Object.prototype.toString.call(t) === "[object Object]" && typeof t.toJSON != "function";
}
var Tr;
(function(t) {
  t.direct = "direct", t.patchObject = "patch object", t.patchFunction = "patch function";
})(Tr || (Tr = {}));
const Ql = typeof window < "u", mo = (process.env.NODE_ENV !== "production" || !1) && process.env.NODE_ENV !== "test" && Ql, th = /* @__PURE__ */ (() => typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof global == "object" && global.global === global ? global : typeof globalThis == "object" ? globalThis : { HTMLElement: null })();
function Lb(t, { autoBom: e = !1 } = {}) {
  return e && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(t.type) ? new Blob([String.fromCharCode(65279), t], { type: t.type }) : t;
}
function kd(t, e, n) {
  const r = new XMLHttpRequest();
  r.open("GET", t), r.responseType = "blob", r.onload = function() {
    Kv(r.response, e, n);
  }, r.onerror = function() {
    console.error("could not download file");
  }, r.send();
}
function Wv(t) {
  const e = new XMLHttpRequest();
  e.open("HEAD", t, !1);
  try {
    e.send();
  } catch {
  }
  return e.status >= 200 && e.status <= 299;
}
function Va(t) {
  try {
    t.dispatchEvent(new MouseEvent("click"));
  } catch {
    const n = document.createEvent("MouseEvents");
    n.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), t.dispatchEvent(n);
  }
}
const Wa = typeof navigator == "object" ? navigator : { userAgent: "" }, $v = /* @__PURE__ */ (() => /Macintosh/.test(Wa.userAgent) && /AppleWebKit/.test(Wa.userAgent) && !/Safari/.test(Wa.userAgent))(), Kv = Ql ? (
  // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program
  typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype && !$v ? zb : (
    // Use msSaveOrOpenBlob as a second approach
    "msSaveOrOpenBlob" in Wa ? jb : (
      // Fallback to using FileReader and a popup
      Fb
    )
  )
) : () => {
};
function zb(t, e = "download", n) {
  const r = document.createElement("a");
  r.download = e, r.rel = "noopener", typeof t == "string" ? (r.href = t, r.origin !== location.origin ? Wv(r.href) ? kd(t, e, n) : (r.target = "_blank", Va(r)) : Va(r)) : (r.href = URL.createObjectURL(t), setTimeout(function() {
    URL.revokeObjectURL(r.href);
  }, 4e4), setTimeout(function() {
    Va(r);
  }, 0));
}
function jb(t, e = "download", n) {
  if (typeof t == "string")
    if (Wv(t))
      kd(t, e, n);
    else {
      const r = document.createElement("a");
      r.href = t, r.target = "_blank", setTimeout(function() {
        Va(r);
      });
    }
  else
    navigator.msSaveOrOpenBlob(Lb(t, n), e);
}
function Fb(t, e, n, r) {
  if (r = r || open("", "_blank"), r && (r.document.title = r.document.body.innerText = "downloading..."), typeof t == "string")
    return kd(t, e, n);
  const i = t.type === "application/octet-stream", s = /constructor/i.test(String(th.HTMLElement)) || "safari" in th, o = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((o || i && s || $v) && typeof FileReader < "u") {
    const a = new FileReader();
    a.onloadend = function() {
      let l = a.result;
      if (typeof l != "string")
        throw r = null, new Error("Wrong reader.result type");
      l = o ? l : l.replace(/^data:[^;]*;/, "data:attachment/file;"), r ? r.location.href = l : location.assign(l), r = null;
    }, a.readAsDataURL(t);
  } else {
    const a = URL.createObjectURL(t);
    r ? r.location.assign(a) : location.href = a, r = null, setTimeout(function() {
      URL.revokeObjectURL(a);
    }, 4e4);
  }
}
function hn(t, e) {
  const n = "🍍 " + t;
  typeof __VUE_DEVTOOLS_TOAST__ == "function" ? __VUE_DEVTOOLS_TOAST__(n, e) : e === "error" ? console.error(n) : e === "warn" ? console.warn(n) : console.log(n);
}
function Cd(t) {
  return "_a" in t && "install" in t;
}
function Gv() {
  if (!("clipboard" in navigator))
    return hn("Your browser doesn't support the Clipboard API", "error"), !0;
}
function qv(t) {
  return t instanceof Error && t.message.toLowerCase().includes("document is not focused") ? (hn('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn"), !0) : !1;
}
async function Hb(t) {
  if (!Gv())
    try {
      await navigator.clipboard.writeText(JSON.stringify(t.state.value)), hn("Global state copied to clipboard.");
    } catch (e) {
      if (qv(e))
        return;
      hn("Failed to serialize the state. Check the console for more details.", "error"), console.error(e);
    }
}
async function Ub(t) {
  if (!Gv())
    try {
      t.state.value = JSON.parse(await navigator.clipboard.readText()), hn("Global state pasted from clipboard.");
    } catch (e) {
      if (qv(e))
        return;
      hn("Failed to deserialize the state from clipboard. Check the console for more details.", "error"), console.error(e);
    }
}
async function Vb(t) {
  try {
    Kv(new Blob([JSON.stringify(t.state.value)], {
      type: "text/plain;charset=utf-8"
    }), "pinia-state.json");
  } catch (e) {
    hn("Failed to export the state as JSON. Check the console for more details.", "error"), console.error(e);
  }
}
let Wr;
function Wb() {
  Wr || (Wr = document.createElement("input"), Wr.type = "file", Wr.accept = ".json");
  function t() {
    return new Promise((e, n) => {
      Wr.onchange = async () => {
        const r = Wr.files;
        if (!r)
          return e(null);
        const i = r.item(0);
        return e(i ? { text: await i.text(), file: i } : null);
      }, Wr.oncancel = () => e(null), Wr.onerror = n, Wr.click();
    });
  }
  return t;
}
async function $b(t) {
  try {
    const n = await (await Wb())();
    if (!n)
      return;
    const { text: r, file: i } = n;
    t.state.value = JSON.parse(r), hn(`Global state imported from "${i.name}".`);
  } catch (e) {
    hn("Failed to export the state as JSON. Check the console for more details.", "error"), console.error(e);
  }
}
function hr(t) {
  return {
    _custom: {
      display: t
    }
  };
}
const Jv = "🍍 Pinia (root)", uc = "_root";
function Kb(t) {
  return Cd(t) ? {
    id: uc,
    label: Jv
  } : {
    id: t.$id,
    label: t.$id
  };
}
function Gb(t) {
  if (Cd(t)) {
    const n = Array.from(t._s.keys()), r = t._s;
    return {
      state: n.map((s) => ({
        editable: !0,
        key: s,
        value: t.state.value[s]
      })),
      getters: n.filter((s) => r.get(s)._getters).map((s) => {
        const o = r.get(s);
        return {
          editable: !1,
          key: s,
          value: o._getters.reduce((a, l) => (a[l] = o[l], a), {})
        };
      })
    };
  }
  const e = {
    state: Object.keys(t.$state).map((n) => ({
      editable: !0,
      key: n,
      value: t.$state[n]
    }))
  };
  return t._getters && t._getters.length && (e.getters = t._getters.map((n) => ({
    editable: !1,
    key: n,
    value: t[n]
  }))), t._customProperties.size && (e.customProperties = Array.from(t._customProperties).map((n) => ({
    editable: !0,
    key: n,
    value: t[n]
  }))), e;
}
function qb(t) {
  return t ? Array.isArray(t) ? t.reduce((e, n) => (e.keys.push(n.key), e.operations.push(n.type), e.oldValue[n.key] = n.oldValue, e.newValue[n.key] = n.newValue, e), {
    oldValue: {},
    keys: [],
    operations: [],
    newValue: {}
  }) : {
    operation: hr(t.type),
    key: hr(t.key),
    oldValue: t.oldValue,
    newValue: t.newValue
  } : {};
}
function Jb(t) {
  switch (t) {
    case Tr.direct:
      return "mutation";
    case Tr.patchFunction:
      return "$patch";
    case Tr.patchObject:
      return "$patch";
    default:
      return "unknown";
  }
}
let ks = !0;
const $a = [], Pi = "pinia:mutations", kn = "pinia", gl = (t) => "🍍 " + t;
function Yb(t, e) {
  Uv({
    id: "dev.esm.pinia",
    label: "Pinia 🍍",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes: $a,
    app: t
  }, (n) => {
    typeof n.now != "function" && hn("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."), n.addTimelineLayer({
      id: Pi,
      label: "Pinia 🍍",
      color: 15064968
    }), n.addInspector({
      id: kn,
      label: "Pinia 🍍",
      icon: "storage",
      treeFilterPlaceholder: "Search stores",
      actions: [
        {
          icon: "content_copy",
          action: () => {
            Hb(e);
          },
          tooltip: "Serialize and copy the state"
        },
        {
          icon: "content_paste",
          action: async () => {
            await Ub(e), n.sendInspectorTree(kn), n.sendInspectorState(kn);
          },
          tooltip: "Replace the state with the content of your clipboard"
        },
        {
          icon: "save",
          action: () => {
            Vb(e);
          },
          tooltip: "Save the state as a JSON file"
        },
        {
          icon: "folder_open",
          action: async () => {
            await $b(e), n.sendInspectorTree(kn), n.sendInspectorState(kn);
          },
          tooltip: "Import the state from a JSON file"
        }
      ],
      nodeActions: [
        {
          icon: "restore",
          tooltip: "Reset the state (option store only)",
          action: (r) => {
            const i = e._s.get(r);
            i ? i._isOptionsAPI ? (i.$reset(), hn(`Store "${r}" reset.`)) : hn(`Cannot reset "${r}" store because it's a setup store.`, "warn") : hn(`Cannot reset "${r}" store because it wasn't found.`, "warn");
          }
        }
      ]
    }), n.on.inspectComponent((r, i) => {
      const s = r.componentInstance && r.componentInstance.proxy;
      if (s && s._pStores) {
        const o = r.componentInstance.proxy._pStores;
        Object.values(o).forEach((a) => {
          r.instanceData.state.push({
            type: gl(a.$id),
            key: "state",
            editable: !0,
            value: a._isOptionsAPI ? {
              _custom: {
                value: _r(a.$state),
                actions: [
                  {
                    icon: "restore",
                    tooltip: "Reset the state of this store",
                    action: () => a.$reset()
                  }
                ]
              }
            } : (
              // NOTE: workaround to unwrap transferred refs
              Object.keys(a.$state).reduce((l, u) => (l[u] = a.$state[u], l), {})
            )
          }), a._getters && a._getters.length && r.instanceData.state.push({
            type: gl(a.$id),
            key: "getters",
            editable: !1,
            value: a._getters.reduce((l, u) => {
              try {
                l[u] = a[u];
              } catch (c) {
                l[u] = c;
              }
              return l;
            }, {})
          });
        });
      }
    }), n.on.getInspectorTree((r) => {
      if (r.app === t && r.inspectorId === kn) {
        let i = [e];
        i = i.concat(Array.from(e._s.values())), r.rootNodes = (r.filter ? i.filter((s) => "$id" in s ? s.$id.toLowerCase().includes(r.filter.toLowerCase()) : Jv.toLowerCase().includes(r.filter.toLowerCase())) : i).map(Kb);
      }
    }), n.on.getInspectorState((r) => {
      if (r.app === t && r.inspectorId === kn) {
        const i = r.nodeId === uc ? e : e._s.get(r.nodeId);
        if (!i)
          return;
        i && (r.state = Gb(i));
      }
    }), n.on.editInspectorState((r, i) => {
      if (r.app === t && r.inspectorId === kn) {
        const s = r.nodeId === uc ? e : e._s.get(r.nodeId);
        if (!s)
          return hn(`store "${r.nodeId}" not found`, "error");
        const { path: o } = r;
        Cd(s) ? o.unshift("state") : (o.length !== 1 || !s._customProperties.has(o[0]) || o[0] in s.$state) && o.unshift("$state"), ks = !1, r.set(s, o, r.state.value), ks = !0;
      }
    }), n.on.editComponentState((r) => {
      if (r.type.startsWith("🍍")) {
        const i = r.type.replace(/^🍍\s*/, ""), s = e._s.get(i);
        if (!s)
          return hn(`store "${i}" not found`, "error");
        const { path: o } = r;
        if (o[0] !== "state")
          return hn(`Invalid path for store "${i}":
${o}
Only state can be modified.`);
        o[0] = "$state", ks = !1, r.set(s, o, r.state.value), ks = !0;
      }
    });
  });
}
function Qb(t, e) {
  $a.includes(gl(e.$id)) || $a.push(gl(e.$id)), Uv({
    id: "dev.esm.pinia",
    label: "Pinia 🍍",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes: $a,
    app: t,
    settings: {
      logStoreChanges: {
        label: "Notify about new/deleted stores",
        type: "boolean",
        defaultValue: !0
      }
      // useEmojis: {
      //   label: 'Use emojis in messages ⚡️',
      //   type: 'boolean',
      //   defaultValue: true,
      // },
    }
  }, (n) => {
    const r = typeof n.now == "function" ? n.now.bind(n) : Date.now;
    e.$onAction(({ after: o, onError: a, name: l, args: u }) => {
      const c = Yv++;
      n.addTimelineEvent({
        layerId: Pi,
        event: {
          time: r(),
          title: "🛫 " + l,
          subtitle: "start",
          data: {
            store: hr(e.$id),
            action: hr(l),
            args: u
          },
          groupId: c
        }
      }), o((d) => {
        Bi = void 0, n.addTimelineEvent({
          layerId: Pi,
          event: {
            time: r(),
            title: "🛬 " + l,
            subtitle: "end",
            data: {
              store: hr(e.$id),
              action: hr(l),
              args: u,
              result: d
            },
            groupId: c
          }
        });
      }), a((d) => {
        Bi = void 0, n.addTimelineEvent({
          layerId: Pi,
          event: {
            time: r(),
            logType: "error",
            title: "💥 " + l,
            subtitle: "end",
            data: {
              store: hr(e.$id),
              action: hr(l),
              args: u,
              error: d
            },
            groupId: c
          }
        });
      });
    }, !0), e._customProperties.forEach((o) => {
      Ae(() => x(e[o]), (a, l) => {
        n.notifyComponentUpdate(), n.sendInspectorState(kn), ks && n.addTimelineEvent({
          layerId: Pi,
          event: {
            time: r(),
            title: "Change",
            subtitle: o,
            data: {
              newValue: a,
              oldValue: l
            },
            groupId: Bi
          }
        });
      }, { deep: !0 });
    }), e.$subscribe(({ events: o, type: a }, l) => {
      if (n.notifyComponentUpdate(), n.sendInspectorState(kn), !ks)
        return;
      const u = {
        time: r(),
        title: Jb(a),
        data: {
          store: hr(e.$id),
          ...qb(o)
        },
        groupId: Bi
      };
      Bi = void 0, a === Tr.patchFunction ? u.subtitle = "⤵️" : a === Tr.patchObject ? u.subtitle = "🧩" : o && !Array.isArray(o) && (u.subtitle = o.type), o && (u.data["rawEvent(s)"] = {
        _custom: {
          display: "DebuggerEvent",
          type: "object",
          tooltip: "raw DebuggerEvent[]",
          value: o
        }
      }), n.addTimelineEvent({
        layerId: Pi,
        event: u
      });
    }, { detached: !0, flush: "sync" });
    const i = e._hotUpdate;
    e._hotUpdate = mr((o) => {
      i(o), n.addTimelineEvent({
        layerId: Pi,
        event: {
          time: r(),
          title: "🔥 " + e.$id,
          subtitle: "HMR update",
          data: {
            store: hr(e.$id),
            info: hr("HMR update")
          }
        }
      }), n.notifyComponentUpdate(), n.sendInspectorTree(kn), n.sendInspectorState(kn);
    });
    const { $dispose: s } = e;
    e.$dispose = () => {
      s(), n.notifyComponentUpdate(), n.sendInspectorTree(kn), n.sendInspectorState(kn), n.getSettings().logStoreChanges && hn(`Disposed "${e.$id}" store 🗑`);
    }, n.notifyComponentUpdate(), n.sendInspectorTree(kn), n.sendInspectorState(kn), n.getSettings().logStoreChanges && hn(`"${e.$id}" store installed 🆕`);
  });
}
let Yv = 0, Bi;
function nh(t, e) {
  const n = e.reduce((r, i) => (r[i] = _r(t)[i], r), {});
  for (const r in n)
    t[r] = function() {
      const i = Yv, s = new Proxy(t, {
        get(...o) {
          return Bi = i, Reflect.get(...o);
        },
        set(...o) {
          return Bi = i, Reflect.set(...o);
        }
      });
      return n[r].apply(s, arguments);
    };
}
function Zb({ app: t, store: e, options: n }) {
  if (!e.$id.startsWith("__hot:")) {
    if (n.state && (e._isOptionsAPI = !0), typeof n.state == "function") {
      nh(
        // @ts-expect-error: can cast the store...
        e,
        Object.keys(n.actions)
      );
      const r = e._hotUpdate;
      _r(e)._hotUpdate = function(i) {
        r.apply(this, arguments), nh(e, Object.keys(i._hmrPayload.actions));
      };
    }
    Qb(
      t,
      // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?
      e
    );
  }
}
function Xb() {
  const t = Ed(!0), e = t.run(() => K({}));
  let n = [], r = [];
  const i = mr({
    install(s) {
      Oo(i), i._a = s, s.provide(Vv, i), s.config.globalProperties.$pinia = i, mo && Yb(s, i), r.forEach((o) => n.push(o)), r = [];
    },
    use(s) {
      return !this._a && !Fv ? r.push(s) : n.push(s), this;
    },
    _p: n,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: t,
    _s: /* @__PURE__ */ new Map(),
    state: e
  });
  return mo && typeof Proxy < "u" && i.use(Zb), i;
}
function Qv(t, e) {
  for (const n in e) {
    const r = e[n];
    if (!(n in t))
      continue;
    const i = t[n];
    $i(i) && $i(r) && !on(r) && !Jl(r) ? t[n] = Qv(i, r) : t[n] = r;
  }
  return t;
}
const Zv = () => {
};
function rh(t, e, n, r = Zv) {
  t.push(e);
  const i = () => {
    const s = t.indexOf(e);
    s > -1 && (t.splice(s, 1), r());
  };
  return !n && ft() && ea(i), i;
}
function ds(t, ...e) {
  t.slice().forEach((n) => {
    n(...e);
  });
}
function cc(t, e) {
  t instanceof Map && e instanceof Map && e.forEach((n, r) => t.set(r, n)), t instanceof Set && e instanceof Set && e.forEach(t.add, t);
  for (const n in e) {
    if (!e.hasOwnProperty(n))
      continue;
    const r = e[n], i = t[n];
    $i(i) && $i(r) && t.hasOwnProperty(n) && !on(r) && !Jl(r) ? t[n] = cc(i, r) : t[n] = r;
  }
  return t;
}
const ew = process.env.NODE_ENV !== "production" ? Symbol("pinia:skipHydration") : (
  /* istanbul ignore next */
  Symbol()
);
function tw(t) {
  return !$i(t) || !t.hasOwnProperty(ew);
}
const { assign: pr } = Object;
function ih(t) {
  return !!(on(t) && t.effect);
}
function sh(t, e, n, r) {
  const { state: i, actions: s, getters: o } = e, a = n.state.value[t];
  let l;
  function u() {
    !a && (process.env.NODE_ENV === "production" || !r) && (n.state.value[t] = i ? i() : {});
    const c = process.env.NODE_ENV !== "production" && r ? (
      // use ref() to unwrap refs inside state TODO: check if this is still necessary
      pn(K(i ? i() : {}).value)
    ) : pn(n.state.value[t]);
    return pr(c, s, Object.keys(o || {}).reduce((d, h) => (process.env.NODE_ENV !== "production" && h in c && console.warn(`[🍍]: A getter cannot have the same name as another state property. Rename one of them. Found with "${h}" in store "${t}".`), d[h] = mr(j(() => {
      Oo(n);
      const v = n._s.get(t);
      return o[h].call(v, v);
    })), d), {}));
  }
  return l = dc(t, u, e, n, r, !0), l.$reset = function() {
    const d = i ? i() : {};
    this.$patch((h) => {
      pr(h, d);
    });
  }, l;
}
function dc(t, e, n = {}, r, i, s) {
  let o;
  const a = pr({ actions: {} }, n);
  if (process.env.NODE_ENV !== "production" && !r._e.active)
    throw new Error("Pinia destroyed");
  const l = {
    deep: !0
    // flush: 'post',
  };
  process.env.NODE_ENV !== "production" && !Fv && (l.onTrigger = (k) => {
    u ? v = k : u == !1 && !A._hotUpdating && (Array.isArray(v) ? v.push(k) : console.error("🍍 debuggerEvents should be an array. This is most likely an internal Pinia bug."));
  });
  let u, c, d = mr([]), h = mr([]), v;
  const m = r.state.value[t];
  !s && !m && (process.env.NODE_ENV === "production" || !i) && (r.state.value[t] = {});
  const b = K({});
  let p;
  function f(k) {
    let O;
    u = c = !1, process.env.NODE_ENV !== "production" && (v = []), typeof k == "function" ? (k(r.state.value[t]), O = {
      type: Tr.patchFunction,
      storeId: t,
      events: v
    }) : (cc(r.state.value[t], k), O = {
      type: Tr.patchObject,
      payload: k,
      storeId: t,
      events: v
    });
    const N = p = Symbol();
    rt().then(() => {
      p === N && (u = !0);
    }), c = !0, ds(d, O, r.state.value[t]);
  }
  const g = process.env.NODE_ENV !== "production" ? () => {
    throw new Error(`🍍: Store "${t}" is built using the setup syntax and does not implement $reset().`);
  } : Zv;
  function y() {
    o.stop(), d = [], h = [], r._s.delete(t);
  }
  function w(k, O) {
    return function() {
      Oo(r);
      const N = Array.from(arguments), B = [], D = [];
      function F(L) {
        B.push(L);
      }
      function Z(L) {
        D.push(L);
      }
      ds(h, {
        args: N,
        name: k,
        store: A,
        after: F,
        onError: Z
      });
      let te;
      try {
        te = O.apply(this && this.$id === t ? this : A, N);
      } catch (L) {
        throw ds(D, L), L;
      }
      return te instanceof Promise ? te.then((L) => (ds(B, L), L)).catch((L) => (ds(D, L), Promise.reject(L))) : (ds(B, te), te);
    };
  }
  const _ = /* @__PURE__ */ mr({
    actions: {},
    getters: {},
    state: [],
    hotState: b
  }), S = {
    _p: r,
    // _s: scope,
    $id: t,
    $onAction: rh.bind(null, h),
    $patch: f,
    $reset: g,
    $subscribe(k, O = {}) {
      const N = rh(d, k, O.detached, () => B()), B = o.run(() => Ae(() => r.state.value[t], (D) => {
        (O.flush === "sync" ? c : u) && k({
          storeId: t,
          type: Tr.direct,
          events: v
        }, D);
      }, pr({}, l, O)));
      return N;
    },
    $dispose: y
  }, A = Mn(process.env.NODE_ENV !== "production" || mo ? pr(
    {
      _hmrPayload: _,
      _customProperties: mr(/* @__PURE__ */ new Set())
      // devtools custom properties
    },
    S
    // must be added later
    // setupStore
  ) : S);
  r._s.set(t, A);
  const C = r._e.run(() => (o = Ed(), o.run(() => e())));
  for (const k in C) {
    const O = C[k];
    if (on(O) && !ih(O) || Jl(O))
      process.env.NODE_ENV !== "production" && i ? Ea(b.value, k, On(C, k)) : s || (m && tw(O) && (on(O) ? O.value = m[k] : cc(O, m[k])), r.state.value[t][k] = O), process.env.NODE_ENV !== "production" && _.state.push(k);
    else if (typeof O == "function") {
      const N = process.env.NODE_ENV !== "production" && i ? O : w(k, O);
      C[k] = N, process.env.NODE_ENV !== "production" && (_.actions[k] = O), a.actions[k] = O;
    } else
      process.env.NODE_ENV !== "production" && ih(O) && (_.getters[k] = s ? (
        // @ts-expect-error
        n.getters[k]
      ) : O, Ql && (C._getters || // @ts-expect-error: same
      (C._getters = mr([]))).push(k));
  }
  if (pr(A, C), pr(_r(A), C), Object.defineProperty(A, "$state", {
    get: () => process.env.NODE_ENV !== "production" && i ? b.value : r.state.value[t],
    set: (k) => {
      if (process.env.NODE_ENV !== "production" && i)
        throw new Error("cannot set hotState");
      f((O) => {
        pr(O, k);
      });
    }
  }), process.env.NODE_ENV !== "production" && (A._hotUpdate = mr((k) => {
    A._hotUpdating = !0, k._hmrPayload.state.forEach((O) => {
      if (O in A.$state) {
        const N = k.$state[O], B = A.$state[O];
        typeof N == "object" && $i(N) && $i(B) ? Qv(N, B) : k.$state[O] = B;
      }
      Ea(A, O, On(k.$state, O));
    }), Object.keys(A.$state).forEach((O) => {
      O in k.$state || ku(A, O);
    }), u = !1, c = !1, r.state.value[t] = On(k._hmrPayload, "hotState"), c = !0, rt().then(() => {
      u = !0;
    });
    for (const O in k._hmrPayload.actions) {
      const N = k[O];
      Ea(A, O, w(O, N));
    }
    for (const O in k._hmrPayload.getters) {
      const N = k._hmrPayload.getters[O], B = s ? (
        // special handling of options api
        j(() => (Oo(r), N.call(A, A)))
      ) : N;
      Ea(A, O, B);
    }
    Object.keys(A._hmrPayload.getters).forEach((O) => {
      O in k._hmrPayload.getters || ku(A, O);
    }), Object.keys(A._hmrPayload.actions).forEach((O) => {
      O in k._hmrPayload.actions || ku(A, O);
    }), A._hmrPayload = k._hmrPayload, A._getters = k._getters, A._hotUpdating = !1;
  })), mo) {
    const k = {
      writable: !0,
      configurable: !0,
      // avoid warning on devtools trying to display this property
      enumerable: !1
    };
    ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach((O) => {
      Object.defineProperty(A, O, {
        value: A[O],
        ...k
      });
    });
  }
  return r._p.forEach((k) => {
    if (mo) {
      const O = o.run(() => k({
        store: A,
        app: r._a,
        pinia: r,
        options: a
      }));
      Object.keys(O || {}).forEach((N) => A._customProperties.add(N)), pr(A, O);
    } else
      pr(A, o.run(() => k({
        store: A,
        app: r._a,
        pinia: r,
        options: a
      })));
  }), process.env.NODE_ENV !== "production" && A.$state && typeof A.$state == "object" && typeof A.$state.constructor == "function" && !A.$state.constructor.toString().includes("[native code]") && console.warn(`[🍍]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${A.$id}".`), m && s && n.hydrate && n.hydrate(A.$state, m), u = !0, c = !0, A;
}
function nw(t, e, n) {
  let r, i;
  const s = typeof e == "function";
  typeof t == "string" ? (r = t, i = s ? n : e) : (i = t, r = t.id);
  function o(a, l) {
    const u = ft();
    if (a = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    (process.env.NODE_ENV === "test" && ho && ho._testing ? null : a) || u && et(Vv), a && Oo(a), process.env.NODE_ENV !== "production" && !ho)
      throw new Error(`[🍍]: getActivePinia was called with no active Pinia. Did you forget to install pinia?
	const pinia = createPinia()
	app.use(pinia)
This will fail in production.`);
    a = ho, a._s.has(r) || (s ? dc(r, e, i, a) : sh(r, i, a), process.env.NODE_ENV !== "production" && (o._pinia = a));
    const c = a._s.get(r);
    if (process.env.NODE_ENV !== "production" && l) {
      const d = "__hot:" + r, h = s ? dc(d, e, i, a, !0) : sh(d, pr({}, i), a, !0);
      l._hotUpdate(h), delete a.state.value[d], a._s.delete(d);
    }
    if (process.env.NODE_ENV !== "production" && Ql && u && u.proxy && // avoid adding stores that are just built for hot module replacement
    !l) {
      const d = u.proxy, h = "_pStores" in d ? d._pStores : d._pStores = {};
      h[r] = c;
    }
    return c;
  }
  return o.$id = r, o;
}
function rw(t) {
  {
    t = _r(t);
    const e = {};
    for (const n in t) {
      const r = t[n];
      (on(r) || Jl(r)) && (e[n] = // ---
      On(t, n));
    }
    return e;
  }
}
const qr = (t, e, { checkForDefaultPrevented: n = !0 } = {}) => (i) => {
  const s = t == null ? void 0 : t(i);
  if (n === !1 || !s)
    return e == null ? void 0 : e(i);
};
var oh;
const St = typeof window < "u", iw = (t) => typeof t < "u", sw = (t) => typeof t == "function", ow = (t) => typeof t == "string", ml = () => {
}, Xv = St && ((oh = window == null ? void 0 : window.navigator) == null ? void 0 : oh.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function Td(t) {
  return typeof t == "function" ? t() : x(t);
}
function aw(t, e) {
  function n(...r) {
    return new Promise((i, s) => {
      Promise.resolve(t(() => e.apply(this, r), { fn: e, thisArg: this, args: r })).then(i).catch(s);
    });
  }
  return n;
}
function lw(t, e = !0, n = !0, r = !1) {
  let i = 0, s, o = !0, a = ml, l;
  const u = () => {
    s && (clearTimeout(s), s = void 0, a(), a = ml);
  };
  return (d) => {
    const h = Td(t), v = Date.now() - i, m = () => l = d();
    return u(), h <= 0 ? (i = Date.now(), m()) : (v > h && (n || !o) ? (i = Date.now(), m()) : e && (l = new Promise((b, p) => {
      a = r ? p : b, s = setTimeout(() => {
        i = Date.now(), o = !0, b(m()), u();
      }, Math.max(0, h - v));
    })), !n && !s && (s = setTimeout(() => o = !0, h)), o = !1, l);
  };
}
function uw(t) {
  return t;
}
function Od(t) {
  return wb() ? (_b(t), !0) : !1;
}
function cw(t, e = 200, n = !1, r = !0, i = !1) {
  return aw(lw(e, n, r, i), t);
}
function dw(t, e = !0) {
  ft() ? Ct(t) : e ? t() : rt(t);
}
function wi(t) {
  var e;
  const n = Td(t);
  return (e = n == null ? void 0 : n.$el) != null ? e : n;
}
const Id = St ? window : void 0;
function wn(...t) {
  let e, n, r, i;
  if (ow(t[0]) || Array.isArray(t[0]) ? ([n, r, i] = t, e = Id) : [e, n, r, i] = t, !e)
    return ml;
  Array.isArray(n) || (n = [n]), Array.isArray(r) || (r = [r]);
  const s = [], o = () => {
    s.forEach((c) => c()), s.length = 0;
  }, a = (c, d, h, v) => (c.addEventListener(d, h, v), () => c.removeEventListener(d, h, v)), l = Ae(() => [wi(e), Td(i)], ([c, d]) => {
    o(), c && s.push(...n.flatMap((h) => r.map((v) => a(c, h, v, d))));
  }, { immediate: !0, flush: "post" }), u = () => {
    l(), o();
  };
  return Od(u), u;
}
let ah = !1;
function fw(t, e, n = {}) {
  const { window: r = Id, ignore: i = [], capture: s = !0, detectIframe: o = !1 } = n;
  if (!r)
    return;
  Xv && !ah && (ah = !0, Array.from(r.document.body.children).forEach((h) => h.addEventListener("click", ml)));
  let a = !0;
  const l = (h) => i.some((v) => {
    if (typeof v == "string")
      return Array.from(r.document.querySelectorAll(v)).some((m) => m === h.target || h.composedPath().includes(m));
    {
      const m = wi(v);
      return m && (h.target === m || h.composedPath().includes(m));
    }
  }), c = [
    wn(r, "click", (h) => {
      const v = wi(t);
      if (!(!v || v === h.target || h.composedPath().includes(v))) {
        if (h.detail === 0 && (a = !l(h)), !a) {
          a = !0;
          return;
        }
        e(h);
      }
    }, { passive: !0, capture: s }),
    wn(r, "pointerdown", (h) => {
      const v = wi(t);
      v && (a = !h.composedPath().includes(v) && !l(h));
    }, { passive: !0 }),
    o && wn(r, "blur", (h) => {
      var v;
      const m = wi(t);
      ((v = r.document.activeElement) == null ? void 0 : v.tagName) === "IFRAME" && !(m != null && m.contains(r.document.activeElement)) && e(h);
    })
  ].filter(Boolean);
  return () => c.forEach((h) => h());
}
function hw(t, e = !1) {
  const n = K(), r = () => n.value = !!t();
  return r(), dw(r, e), n;
}
function pw(t) {
  return JSON.parse(JSON.stringify(t));
}
const lh = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, uh = "__vueuse_ssr_handlers__";
lh[uh] = lh[uh] || {};
var ch = Object.getOwnPropertySymbols, vw = Object.prototype.hasOwnProperty, gw = Object.prototype.propertyIsEnumerable, mw = (t, e) => {
  var n = {};
  for (var r in t)
    vw.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && ch)
    for (var r of ch(t))
      e.indexOf(r) < 0 && gw.call(t, r) && (n[r] = t[r]);
  return n;
};
function Ds(t, e, n = {}) {
  const r = n, { window: i = Id } = r, s = mw(r, ["window"]);
  let o;
  const a = hw(() => i && "ResizeObserver" in i), l = () => {
    o && (o.disconnect(), o = void 0);
  }, u = Ae(() => wi(t), (d) => {
    l(), a.value && i && d && (o = new ResizeObserver(e), o.observe(d, s));
  }, { immediate: !0, flush: "post" }), c = () => {
    l(), u();
  };
  return Od(c), {
    isSupported: a,
    stop: c
  };
}
var dh;
(function(t) {
  t.UP = "UP", t.RIGHT = "RIGHT", t.DOWN = "DOWN", t.LEFT = "LEFT", t.NONE = "NONE";
})(dh || (dh = {}));
var yw = Object.defineProperty, fh = Object.getOwnPropertySymbols, bw = Object.prototype.hasOwnProperty, ww = Object.prototype.propertyIsEnumerable, hh = (t, e, n) => e in t ? yw(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, _w = (t, e) => {
  for (var n in e || (e = {}))
    bw.call(e, n) && hh(t, n, e[n]);
  if (fh)
    for (var n of fh(e))
      ww.call(e, n) && hh(t, n, e[n]);
  return t;
};
const Sw = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
_w({
  linear: uw
}, Sw);
function Ew(t, e, n, r = {}) {
  var i, s, o;
  const {
    clone: a = !1,
    passive: l = !1,
    eventName: u,
    deep: c = !1,
    defaultValue: d
  } = r, h = ft(), v = n || (h == null ? void 0 : h.emit) || ((i = h == null ? void 0 : h.$emit) == null ? void 0 : i.bind(h)) || ((o = (s = h == null ? void 0 : h.proxy) == null ? void 0 : s.$emit) == null ? void 0 : o.bind(h == null ? void 0 : h.proxy));
  let m = u;
  e || (e = "modelValue"), m = u || m || `update:${e.toString()}`;
  const b = (f) => a ? sw(a) ? a(f) : pw(f) : f, p = () => iw(t[e]) ? b(t[e]) : d;
  if (l) {
    const f = p(), g = K(f);
    return Ae(() => t[e], (y) => g.value = b(y)), Ae(g, (y) => {
      (y !== t[e] || c) && v(m, y);
    }, { deep: c }), g;
  } else
    return j({
      get() {
        return p();
      },
      set(f) {
        v(m, f);
      }
    });
}
const xw = () => St && /firefox/i.test(window.navigator.userAgent), Aw = (t, e) => {
  if (!St || !t || !e)
    return !1;
  const n = t.getBoundingClientRect();
  let r;
  return e instanceof Element ? r = e.getBoundingClientRect() : r = {
    top: 0,
    right: window.innerWidth,
    bottom: window.innerHeight,
    left: 0
  }, n.top < r.bottom && n.bottom > r.top && n.right > r.left && n.left < r.right;
};
process.env.NODE_ENV !== "production" && Object.freeze({});
process.env.NODE_ENV !== "production" && Object.freeze([]);
const en = () => {
}, kw = Object.prototype.hasOwnProperty, Dr = (t, e) => kw.call(t, e), Br = Array.isArray, mn = (t) => typeof t == "function", Gt = (t) => typeof t == "string", _n = (t) => t !== null && typeof t == "object", Cw = Object.prototype.toString, eg = (t) => Cw.call(t), Cu = (t) => eg(t).slice(8, -1), ph = (t) => eg(t) === "[object Object]", tg = (t) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (n) => e[n] || (e[n] = t(n));
}, Tw = /-(\w)/g, Ow = tg((t) => t.replace(Tw, (e, n) => n ? n.toUpperCase() : "")), Iw = /\B([A-Z])/g, Nw = tg((t) => t.replace(Iw, "-$1").toLowerCase());
var Rw = typeof global == "object" && global && global.Object === Object && global;
const ng = Rw;
var Pw = typeof self == "object" && self && self.Object === Object && self, Dw = ng || Pw || Function("return this")();
const Er = Dw;
var Bw = Er.Symbol;
const ir = Bw;
var rg = Object.prototype, Mw = rg.hasOwnProperty, Lw = rg.toString, io = ir ? ir.toStringTag : void 0;
function zw(t) {
  var e = Mw.call(t, io), n = t[io];
  try {
    t[io] = void 0;
    var r = !0;
  } catch {
  }
  var i = Lw.call(t);
  return r && (e ? t[io] = n : delete t[io]), i;
}
var jw = Object.prototype, Fw = jw.toString;
function Hw(t) {
  return Fw.call(t);
}
var Uw = "[object Null]", Vw = "[object Undefined]", vh = ir ? ir.toStringTag : void 0;
function Zi(t) {
  return t == null ? t === void 0 ? Vw : Uw : vh && vh in Object(t) ? zw(t) : Hw(t);
}
function Mr(t) {
  return t != null && typeof t == "object";
}
var Ww = "[object Symbol]";
function Zl(t) {
  return typeof t == "symbol" || Mr(t) && Zi(t) == Ww;
}
function ig(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length, i = Array(r); ++n < r; )
    i[n] = e(t[n], n, t);
  return i;
}
var $w = Array.isArray;
const Vn = $w;
var Kw = 1 / 0, gh = ir ? ir.prototype : void 0, mh = gh ? gh.toString : void 0;
function sg(t) {
  if (typeof t == "string")
    return t;
  if (Vn(t))
    return ig(t, sg) + "";
  if (Zl(t))
    return mh ? mh.call(t) : "";
  var e = t + "";
  return e == "0" && 1 / t == -Kw ? "-0" : e;
}
var Gw = /\s/;
function qw(t) {
  for (var e = t.length; e-- && Gw.test(t.charAt(e)); )
    ;
  return e;
}
var Jw = /^\s+/;
function Yw(t) {
  return t && t.slice(0, qw(t) + 1).replace(Jw, "");
}
function Dn(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var yh = 0 / 0, Qw = /^[-+]0x[0-9a-f]+$/i, Zw = /^0b[01]+$/i, Xw = /^0o[0-7]+$/i, e1 = parseInt;
function fc(t) {
  if (typeof t == "number")
    return t;
  if (Zl(t))
    return yh;
  if (Dn(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = Dn(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = Yw(t);
  var n = Zw.test(t);
  return n || Xw.test(t) ? e1(t.slice(2), n ? 2 : 8) : Qw.test(t) ? yh : +t;
}
var bh = 1 / 0, t1 = 17976931348623157e292;
function n1(t) {
  if (!t)
    return t === 0 ? t : 0;
  if (t = fc(t), t === bh || t === -bh) {
    var e = t < 0 ? -1 : 1;
    return e * t1;
  }
  return t === t ? t : 0;
}
function r1(t) {
  var e = n1(t), n = e % 1;
  return e === e ? n ? e - n : e : 0;
}
function Nd(t) {
  return t;
}
var i1 = "[object AsyncFunction]", s1 = "[object Function]", o1 = "[object GeneratorFunction]", a1 = "[object Proxy]";
function Rd(t) {
  if (!Dn(t))
    return !1;
  var e = Zi(t);
  return e == s1 || e == o1 || e == i1 || e == a1;
}
var l1 = Er["__core-js_shared__"];
const Tu = l1;
var wh = function() {
  var t = /[^.]+$/.exec(Tu && Tu.keys && Tu.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
}();
function u1(t) {
  return !!wh && wh in t;
}
var c1 = Function.prototype, d1 = c1.toString;
function Xi(t) {
  if (t != null) {
    try {
      return d1.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
var f1 = /[\\^$.*+?()[\]{}|]/g, h1 = /^\[object .+?Constructor\]$/, p1 = Function.prototype, v1 = Object.prototype, g1 = p1.toString, m1 = v1.hasOwnProperty, y1 = RegExp(
  "^" + g1.call(m1).replace(f1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function b1(t) {
  if (!Dn(t) || u1(t))
    return !1;
  var e = Rd(t) ? y1 : h1;
  return e.test(Xi(t));
}
function w1(t, e) {
  return t == null ? void 0 : t[e];
}
function es(t, e) {
  var n = w1(t, e);
  return b1(n) ? n : void 0;
}
var _1 = es(Er, "WeakMap");
const hc = _1;
var _h = Object.create, S1 = function() {
  function t() {
  }
  return function(e) {
    if (!Dn(e))
      return {};
    if (_h)
      return _h(e);
    t.prototype = e;
    var n = new t();
    return t.prototype = void 0, n;
  };
}();
const E1 = S1;
function x1(t, e, n) {
  switch (n.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, n[0]);
    case 2:
      return t.call(e, n[0], n[1]);
    case 3:
      return t.call(e, n[0], n[1], n[2]);
  }
  return t.apply(e, n);
}
function og(t, e) {
  var n = -1, r = t.length;
  for (e || (e = Array(r)); ++n < r; )
    e[n] = t[n];
  return e;
}
var A1 = 800, k1 = 16, C1 = Date.now;
function T1(t) {
  var e = 0, n = 0;
  return function() {
    var r = C1(), i = k1 - (r - n);
    if (n = r, i > 0) {
      if (++e >= A1)
        return arguments[0];
    } else
      e = 0;
    return t.apply(void 0, arguments);
  };
}
function O1(t) {
  return function() {
    return t;
  };
}
var I1 = function() {
  try {
    var t = es(Object, "defineProperty");
    return t({}, "", {}), t;
  } catch {
  }
}();
const yl = I1;
var N1 = yl ? function(t, e) {
  return yl(t, "toString", {
    configurable: !0,
    enumerable: !1,
    value: O1(e),
    writable: !0
  });
} : Nd;
const R1 = N1;
var P1 = T1(R1);
const ag = P1;
function D1(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length; ++n < r && e(t[n], n, t) !== !1; )
    ;
  return t;
}
function B1(t, e, n, r) {
  for (var i = t.length, s = n + (r ? 1 : -1); r ? s-- : ++s < i; )
    if (e(t[s], s, t))
      return s;
  return -1;
}
var M1 = 9007199254740991, L1 = /^(?:0|[1-9]\d*)$/;
function Xl(t, e) {
  var n = typeof t;
  return e = e ?? M1, !!e && (n == "number" || n != "symbol" && L1.test(t)) && t > -1 && t % 1 == 0 && t < e;
}
function Pd(t, e, n) {
  e == "__proto__" && yl ? yl(t, e, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : t[e] = n;
}
function na(t, e) {
  return t === e || t !== t && e !== e;
}
var z1 = Object.prototype, j1 = z1.hasOwnProperty;
function Dd(t, e, n) {
  var r = t[e];
  (!(j1.call(t, e) && na(r, n)) || n === void 0 && !(e in t)) && Pd(t, e, n);
}
function ra(t, e, n, r) {
  var i = !n;
  n || (n = {});
  for (var s = -1, o = e.length; ++s < o; ) {
    var a = e[s], l = r ? r(n[a], t[a], a, n, t) : void 0;
    l === void 0 && (l = t[a]), i ? Pd(n, a, l) : Dd(n, a, l);
  }
  return n;
}
var Sh = Math.max;
function lg(t, e, n) {
  return e = Sh(e === void 0 ? t.length - 1 : e, 0), function() {
    for (var r = arguments, i = -1, s = Sh(r.length - e, 0), o = Array(s); ++i < s; )
      o[i] = r[e + i];
    i = -1;
    for (var a = Array(e + 1); ++i < e; )
      a[i] = r[i];
    return a[e] = n(o), x1(t, this, a);
  };
}
function F1(t, e) {
  return ag(lg(t, e, Nd), t + "");
}
var H1 = 9007199254740991;
function Bd(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= H1;
}
function qs(t) {
  return t != null && Bd(t.length) && !Rd(t);
}
function U1(t, e, n) {
  if (!Dn(n))
    return !1;
  var r = typeof e;
  return (r == "number" ? qs(n) && Xl(e, n.length) : r == "string" && e in n) ? na(n[e], t) : !1;
}
function V1(t) {
  return F1(function(e, n) {
    var r = -1, i = n.length, s = i > 1 ? n[i - 1] : void 0, o = i > 2 ? n[2] : void 0;
    for (s = t.length > 3 && typeof s == "function" ? (i--, s) : void 0, o && U1(n[0], n[1], o) && (s = i < 3 ? void 0 : s, i = 1), e = Object(e); ++r < i; ) {
      var a = n[r];
      a && t(e, a, r, s);
    }
    return e;
  });
}
var W1 = Object.prototype;
function Md(t) {
  var e = t && t.constructor, n = typeof e == "function" && e.prototype || W1;
  return t === n;
}
function $1(t, e) {
  for (var n = -1, r = Array(t); ++n < t; )
    r[n] = e(n);
  return r;
}
var K1 = "[object Arguments]";
function Eh(t) {
  return Mr(t) && Zi(t) == K1;
}
var ug = Object.prototype, G1 = ug.hasOwnProperty, q1 = ug.propertyIsEnumerable, J1 = Eh(function() {
  return arguments;
}()) ? Eh : function(t) {
  return Mr(t) && G1.call(t, "callee") && !q1.call(t, "callee");
};
const Io = J1;
function Y1() {
  return !1;
}
var cg = typeof exports == "object" && exports && !exports.nodeType && exports, xh = cg && typeof module == "object" && module && !module.nodeType && module, Q1 = xh && xh.exports === cg, Ah = Q1 ? Er.Buffer : void 0, Z1 = Ah ? Ah.isBuffer : void 0, X1 = Z1 || Y1;
const No = X1;
var e_ = "[object Arguments]", t_ = "[object Array]", n_ = "[object Boolean]", r_ = "[object Date]", i_ = "[object Error]", s_ = "[object Function]", o_ = "[object Map]", a_ = "[object Number]", l_ = "[object Object]", u_ = "[object RegExp]", c_ = "[object Set]", d_ = "[object String]", f_ = "[object WeakMap]", h_ = "[object ArrayBuffer]", p_ = "[object DataView]", v_ = "[object Float32Array]", g_ = "[object Float64Array]", m_ = "[object Int8Array]", y_ = "[object Int16Array]", b_ = "[object Int32Array]", w_ = "[object Uint8Array]", __ = "[object Uint8ClampedArray]", S_ = "[object Uint16Array]", E_ = "[object Uint32Array]", Ht = {};
Ht[v_] = Ht[g_] = Ht[m_] = Ht[y_] = Ht[b_] = Ht[w_] = Ht[__] = Ht[S_] = Ht[E_] = !0;
Ht[e_] = Ht[t_] = Ht[h_] = Ht[n_] = Ht[p_] = Ht[r_] = Ht[i_] = Ht[s_] = Ht[o_] = Ht[a_] = Ht[l_] = Ht[u_] = Ht[c_] = Ht[d_] = Ht[f_] = !1;
function x_(t) {
  return Mr(t) && Bd(t.length) && !!Ht[Zi(t)];
}
function Ld(t) {
  return function(e) {
    return t(e);
  };
}
var dg = typeof exports == "object" && exports && !exports.nodeType && exports, yo = dg && typeof module == "object" && module && !module.nodeType && module, A_ = yo && yo.exports === dg, Ou = A_ && ng.process, k_ = function() {
  try {
    var t = yo && yo.require && yo.require("util").types;
    return t || Ou && Ou.binding && Ou.binding("util");
  } catch {
  }
}();
const Bs = k_;
var kh = Bs && Bs.isTypedArray, C_ = kh ? Ld(kh) : x_;
const zd = C_;
var T_ = Object.prototype, O_ = T_.hasOwnProperty;
function fg(t, e) {
  var n = Vn(t), r = !n && Io(t), i = !n && !r && No(t), s = !n && !r && !i && zd(t), o = n || r || i || s, a = o ? $1(t.length, String) : [], l = a.length;
  for (var u in t)
    (e || O_.call(t, u)) && !(o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (u == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (u == "offset" || u == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (u == "buffer" || u == "byteLength" || u == "byteOffset") || // Skip index properties.
    Xl(u, l))) && a.push(u);
  return a;
}
function hg(t, e) {
  return function(n) {
    return t(e(n));
  };
}
var I_ = hg(Object.keys, Object);
const N_ = I_;
var R_ = Object.prototype, P_ = R_.hasOwnProperty;
function D_(t) {
  if (!Md(t))
    return N_(t);
  var e = [];
  for (var n in Object(t))
    P_.call(t, n) && n != "constructor" && e.push(n);
  return e;
}
function ia(t) {
  return qs(t) ? fg(t) : D_(t);
}
function B_(t) {
  var e = [];
  if (t != null)
    for (var n in Object(t))
      e.push(n);
  return e;
}
var M_ = Object.prototype, L_ = M_.hasOwnProperty;
function z_(t) {
  if (!Dn(t))
    return B_(t);
  var e = Md(t), n = [];
  for (var r in t)
    r == "constructor" && (e || !L_.call(t, r)) || n.push(r);
  return n;
}
function sa(t) {
  return qs(t) ? fg(t, !0) : z_(t);
}
var j_ = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, F_ = /^\w*$/;
function jd(t, e) {
  if (Vn(t))
    return !1;
  var n = typeof t;
  return n == "number" || n == "symbol" || n == "boolean" || t == null || Zl(t) ? !0 : F_.test(t) || !j_.test(t) || e != null && t in Object(e);
}
var H_ = es(Object, "create");
const Ro = H_;
function U_() {
  this.__data__ = Ro ? Ro(null) : {}, this.size = 0;
}
function V_(t) {
  var e = this.has(t) && delete this.__data__[t];
  return this.size -= e ? 1 : 0, e;
}
var W_ = "__lodash_hash_undefined__", $_ = Object.prototype, K_ = $_.hasOwnProperty;
function G_(t) {
  var e = this.__data__;
  if (Ro) {
    var n = e[t];
    return n === W_ ? void 0 : n;
  }
  return K_.call(e, t) ? e[t] : void 0;
}
var q_ = Object.prototype, J_ = q_.hasOwnProperty;
function Y_(t) {
  var e = this.__data__;
  return Ro ? e[t] !== void 0 : J_.call(e, t);
}
var Q_ = "__lodash_hash_undefined__";
function Z_(t, e) {
  var n = this.__data__;
  return this.size += this.has(t) ? 0 : 1, n[t] = Ro && e === void 0 ? Q_ : e, this;
}
function Ki(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
Ki.prototype.clear = U_;
Ki.prototype.delete = V_;
Ki.prototype.get = G_;
Ki.prototype.has = Y_;
Ki.prototype.set = Z_;
function X_() {
  this.__data__ = [], this.size = 0;
}
function eu(t, e) {
  for (var n = t.length; n--; )
    if (na(t[n][0], e))
      return n;
  return -1;
}
var eS = Array.prototype, tS = eS.splice;
function nS(t) {
  var e = this.__data__, n = eu(e, t);
  if (n < 0)
    return !1;
  var r = e.length - 1;
  return n == r ? e.pop() : tS.call(e, n, 1), --this.size, !0;
}
function rS(t) {
  var e = this.__data__, n = eu(e, t);
  return n < 0 ? void 0 : e[n][1];
}
function iS(t) {
  return eu(this.__data__, t) > -1;
}
function sS(t, e) {
  var n = this.__data__, r = eu(n, t);
  return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this;
}
function ci(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
ci.prototype.clear = X_;
ci.prototype.delete = nS;
ci.prototype.get = rS;
ci.prototype.has = iS;
ci.prototype.set = sS;
var oS = es(Er, "Map");
const Po = oS;
function aS() {
  this.size = 0, this.__data__ = {
    hash: new Ki(),
    map: new (Po || ci)(),
    string: new Ki()
  };
}
function lS(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
function tu(t, e) {
  var n = t.__data__;
  return lS(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map;
}
function uS(t) {
  var e = tu(this, t).delete(t);
  return this.size -= e ? 1 : 0, e;
}
function cS(t) {
  return tu(this, t).get(t);
}
function dS(t) {
  return tu(this, t).has(t);
}
function fS(t, e) {
  var n = tu(this, t), r = n.size;
  return n.set(t, e), this.size += n.size == r ? 0 : 1, this;
}
function di(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
di.prototype.clear = aS;
di.prototype.delete = uS;
di.prototype.get = cS;
di.prototype.has = dS;
di.prototype.set = fS;
var hS = "Expected a function";
function Fd(t, e) {
  if (typeof t != "function" || e != null && typeof e != "function")
    throw new TypeError(hS);
  var n = function() {
    var r = arguments, i = e ? e.apply(this, r) : r[0], s = n.cache;
    if (s.has(i))
      return s.get(i);
    var o = t.apply(this, r);
    return n.cache = s.set(i, o) || s, o;
  };
  return n.cache = new (Fd.Cache || di)(), n;
}
Fd.Cache = di;
var pS = 500;
function vS(t) {
  var e = Fd(t, function(r) {
    return n.size === pS && n.clear(), r;
  }), n = e.cache;
  return e;
}
var gS = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, mS = /\\(\\)?/g, yS = vS(function(t) {
  var e = [];
  return t.charCodeAt(0) === 46 && e.push(""), t.replace(gS, function(n, r, i, s) {
    e.push(i ? s.replace(mS, "$1") : r || n);
  }), e;
});
const bS = yS;
function wS(t) {
  return t == null ? "" : sg(t);
}
function nu(t, e) {
  return Vn(t) ? t : jd(t, e) ? [t] : bS(wS(t));
}
var _S = 1 / 0;
function oa(t) {
  if (typeof t == "string" || Zl(t))
    return t;
  var e = t + "";
  return e == "0" && 1 / t == -_S ? "-0" : e;
}
function Hd(t, e) {
  e = nu(e, t);
  for (var n = 0, r = e.length; t != null && n < r; )
    t = t[oa(e[n++])];
  return n && n == r ? t : void 0;
}
function Cn(t, e, n) {
  var r = t == null ? void 0 : Hd(t, e);
  return r === void 0 ? n : r;
}
function Ud(t, e) {
  for (var n = -1, r = e.length, i = t.length; ++n < r; )
    t[i + n] = e[n];
  return t;
}
var Ch = ir ? ir.isConcatSpreadable : void 0;
function SS(t) {
  return Vn(t) || Io(t) || !!(Ch && t && t[Ch]);
}
function Vd(t, e, n, r, i) {
  var s = -1, o = t.length;
  for (n || (n = SS), i || (i = []); ++s < o; ) {
    var a = t[s];
    e > 0 && n(a) ? e > 1 ? Vd(a, e - 1, n, r, i) : Ud(i, a) : r || (i[i.length] = a);
  }
  return i;
}
function ES(t) {
  var e = t == null ? 0 : t.length;
  return e ? Vd(t, 1) : [];
}
function xS(t) {
  return ag(lg(t, void 0, ES), t + "");
}
var AS = hg(Object.getPrototypeOf, Object);
const Wd = AS;
var kS = "[object Object]", CS = Function.prototype, TS = Object.prototype, pg = CS.toString, OS = TS.hasOwnProperty, IS = pg.call(Object);
function NS(t) {
  if (!Mr(t) || Zi(t) != kS)
    return !1;
  var e = Wd(t);
  if (e === null)
    return !0;
  var n = OS.call(e, "constructor") && e.constructor;
  return typeof n == "function" && n instanceof n && pg.call(n) == IS;
}
function RS() {
  this.__data__ = new ci(), this.size = 0;
}
function PS(t) {
  var e = this.__data__, n = e.delete(t);
  return this.size = e.size, n;
}
function DS(t) {
  return this.__data__.get(t);
}
function BS(t) {
  return this.__data__.has(t);
}
var MS = 200;
function LS(t, e) {
  var n = this.__data__;
  if (n instanceof ci) {
    var r = n.__data__;
    if (!Po || r.length < MS - 1)
      return r.push([t, e]), this.size = ++n.size, this;
    n = this.__data__ = new di(r);
  }
  return n.set(t, e), this.size = n.size, this;
}
function yr(t) {
  var e = this.__data__ = new ci(t);
  this.size = e.size;
}
yr.prototype.clear = RS;
yr.prototype.delete = PS;
yr.prototype.get = DS;
yr.prototype.has = BS;
yr.prototype.set = LS;
function zS(t, e) {
  return t && ra(e, ia(e), t);
}
function jS(t, e) {
  return t && ra(e, sa(e), t);
}
var vg = typeof exports == "object" && exports && !exports.nodeType && exports, Th = vg && typeof module == "object" && module && !module.nodeType && module, FS = Th && Th.exports === vg, Oh = FS ? Er.Buffer : void 0, Ih = Oh ? Oh.allocUnsafe : void 0;
function gg(t, e) {
  if (e)
    return t.slice();
  var n = t.length, r = Ih ? Ih(n) : new t.constructor(n);
  return t.copy(r), r;
}
function HS(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length, i = 0, s = []; ++n < r; ) {
    var o = t[n];
    e(o, n, t) && (s[i++] = o);
  }
  return s;
}
function mg() {
  return [];
}
var US = Object.prototype, VS = US.propertyIsEnumerable, Nh = Object.getOwnPropertySymbols, WS = Nh ? function(t) {
  return t == null ? [] : (t = Object(t), HS(Nh(t), function(e) {
    return VS.call(t, e);
  }));
} : mg;
const $d = WS;
function $S(t, e) {
  return ra(t, $d(t), e);
}
var KS = Object.getOwnPropertySymbols, GS = KS ? function(t) {
  for (var e = []; t; )
    Ud(e, $d(t)), t = Wd(t);
  return e;
} : mg;
const yg = GS;
function qS(t, e) {
  return ra(t, yg(t), e);
}
function bg(t, e, n) {
  var r = e(t);
  return Vn(t) ? r : Ud(r, n(t));
}
function pc(t) {
  return bg(t, ia, $d);
}
function JS(t) {
  return bg(t, sa, yg);
}
var YS = es(Er, "DataView");
const vc = YS;
var QS = es(Er, "Promise");
const gc = QS;
var ZS = es(Er, "Set");
const mc = ZS;
var Rh = "[object Map]", XS = "[object Object]", Ph = "[object Promise]", Dh = "[object Set]", Bh = "[object WeakMap]", Mh = "[object DataView]", eE = Xi(vc), tE = Xi(Po), nE = Xi(gc), rE = Xi(mc), iE = Xi(hc), Di = Zi;
(vc && Di(new vc(new ArrayBuffer(1))) != Mh || Po && Di(new Po()) != Rh || gc && Di(gc.resolve()) != Ph || mc && Di(new mc()) != Dh || hc && Di(new hc()) != Bh) && (Di = function(t) {
  var e = Zi(t), n = e == XS ? t.constructor : void 0, r = n ? Xi(n) : "";
  if (r)
    switch (r) {
      case eE:
        return Mh;
      case tE:
        return Rh;
      case nE:
        return Ph;
      case rE:
        return Dh;
      case iE:
        return Bh;
    }
  return e;
});
const Do = Di;
var sE = Object.prototype, oE = sE.hasOwnProperty;
function aE(t) {
  var e = t.length, n = new t.constructor(e);
  return e && typeof t[0] == "string" && oE.call(t, "index") && (n.index = t.index, n.input = t.input), n;
}
var lE = Er.Uint8Array;
const bl = lE;
function Kd(t) {
  var e = new t.constructor(t.byteLength);
  return new bl(e).set(new bl(t)), e;
}
function uE(t, e) {
  var n = e ? Kd(t.buffer) : t.buffer;
  return new t.constructor(n, t.byteOffset, t.byteLength);
}
var cE = /\w*$/;
function dE(t) {
  var e = new t.constructor(t.source, cE.exec(t));
  return e.lastIndex = t.lastIndex, e;
}
var Lh = ir ? ir.prototype : void 0, zh = Lh ? Lh.valueOf : void 0;
function fE(t) {
  return zh ? Object(zh.call(t)) : {};
}
function wg(t, e) {
  var n = e ? Kd(t.buffer) : t.buffer;
  return new t.constructor(n, t.byteOffset, t.length);
}
var hE = "[object Boolean]", pE = "[object Date]", vE = "[object Map]", gE = "[object Number]", mE = "[object RegExp]", yE = "[object Set]", bE = "[object String]", wE = "[object Symbol]", _E = "[object ArrayBuffer]", SE = "[object DataView]", EE = "[object Float32Array]", xE = "[object Float64Array]", AE = "[object Int8Array]", kE = "[object Int16Array]", CE = "[object Int32Array]", TE = "[object Uint8Array]", OE = "[object Uint8ClampedArray]", IE = "[object Uint16Array]", NE = "[object Uint32Array]";
function RE(t, e, n) {
  var r = t.constructor;
  switch (e) {
    case _E:
      return Kd(t);
    case hE:
    case pE:
      return new r(+t);
    case SE:
      return uE(t, n);
    case EE:
    case xE:
    case AE:
    case kE:
    case CE:
    case TE:
    case OE:
    case IE:
    case NE:
      return wg(t, n);
    case vE:
      return new r();
    case gE:
    case bE:
      return new r(t);
    case mE:
      return dE(t);
    case yE:
      return new r();
    case wE:
      return fE(t);
  }
}
function _g(t) {
  return typeof t.constructor == "function" && !Md(t) ? E1(Wd(t)) : {};
}
var PE = "[object Map]";
function DE(t) {
  return Mr(t) && Do(t) == PE;
}
var jh = Bs && Bs.isMap, BE = jh ? Ld(jh) : DE;
const ME = BE;
var LE = "[object Set]";
function zE(t) {
  return Mr(t) && Do(t) == LE;
}
var Fh = Bs && Bs.isSet, jE = Fh ? Ld(Fh) : zE;
const FE = jE;
var HE = 1, UE = 2, VE = 4, Sg = "[object Arguments]", WE = "[object Array]", $E = "[object Boolean]", KE = "[object Date]", GE = "[object Error]", Eg = "[object Function]", qE = "[object GeneratorFunction]", JE = "[object Map]", YE = "[object Number]", xg = "[object Object]", QE = "[object RegExp]", ZE = "[object Set]", XE = "[object String]", ex = "[object Symbol]", tx = "[object WeakMap]", nx = "[object ArrayBuffer]", rx = "[object DataView]", ix = "[object Float32Array]", sx = "[object Float64Array]", ox = "[object Int8Array]", ax = "[object Int16Array]", lx = "[object Int32Array]", ux = "[object Uint8Array]", cx = "[object Uint8ClampedArray]", dx = "[object Uint16Array]", fx = "[object Uint32Array]", jt = {};
jt[Sg] = jt[WE] = jt[nx] = jt[rx] = jt[$E] = jt[KE] = jt[ix] = jt[sx] = jt[ox] = jt[ax] = jt[lx] = jt[JE] = jt[YE] = jt[xg] = jt[QE] = jt[ZE] = jt[XE] = jt[ex] = jt[ux] = jt[cx] = jt[dx] = jt[fx] = !0;
jt[GE] = jt[Eg] = jt[tx] = !1;
function Ka(t, e, n, r, i, s) {
  var o, a = e & HE, l = e & UE, u = e & VE;
  if (n && (o = i ? n(t, r, i, s) : n(t)), o !== void 0)
    return o;
  if (!Dn(t))
    return t;
  var c = Vn(t);
  if (c) {
    if (o = aE(t), !a)
      return og(t, o);
  } else {
    var d = Do(t), h = d == Eg || d == qE;
    if (No(t))
      return gg(t, a);
    if (d == xg || d == Sg || h && !i) {
      if (o = l || h ? {} : _g(t), !a)
        return l ? qS(t, jS(o, t)) : $S(t, zS(o, t));
    } else {
      if (!jt[d])
        return i ? t : {};
      o = RE(t, d, a);
    }
  }
  s || (s = new yr());
  var v = s.get(t);
  if (v)
    return v;
  s.set(t, o), FE(t) ? t.forEach(function(p) {
    o.add(Ka(p, e, n, p, t, s));
  }) : ME(t) && t.forEach(function(p, f) {
    o.set(f, Ka(p, e, n, f, t, s));
  });
  var m = u ? l ? JS : pc : l ? sa : ia, b = c ? void 0 : m(t);
  return D1(b || t, function(p, f) {
    b && (f = p, p = t[f]), Dd(o, f, Ka(p, e, n, f, t, s));
  }), o;
}
var hx = 1, px = 4;
function Hh(t) {
  return Ka(t, hx | px);
}
var vx = "__lodash_hash_undefined__";
function gx(t) {
  return this.__data__.set(t, vx), this;
}
function mx(t) {
  return this.__data__.has(t);
}
function wl(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.__data__ = new di(); ++e < n; )
    this.add(t[e]);
}
wl.prototype.add = wl.prototype.push = gx;
wl.prototype.has = mx;
function yx(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length; ++n < r; )
    if (e(t[n], n, t))
      return !0;
  return !1;
}
function bx(t, e) {
  return t.has(e);
}
var wx = 1, _x = 2;
function Ag(t, e, n, r, i, s) {
  var o = n & wx, a = t.length, l = e.length;
  if (a != l && !(o && l > a))
    return !1;
  var u = s.get(t), c = s.get(e);
  if (u && c)
    return u == e && c == t;
  var d = -1, h = !0, v = n & _x ? new wl() : void 0;
  for (s.set(t, e), s.set(e, t); ++d < a; ) {
    var m = t[d], b = e[d];
    if (r)
      var p = o ? r(b, m, d, e, t, s) : r(m, b, d, t, e, s);
    if (p !== void 0) {
      if (p)
        continue;
      h = !1;
      break;
    }
    if (v) {
      if (!yx(e, function(f, g) {
        if (!bx(v, g) && (m === f || i(m, f, n, r, s)))
          return v.push(g);
      })) {
        h = !1;
        break;
      }
    } else if (!(m === b || i(m, b, n, r, s))) {
      h = !1;
      break;
    }
  }
  return s.delete(t), s.delete(e), h;
}
function Sx(t) {
  var e = -1, n = Array(t.size);
  return t.forEach(function(r, i) {
    n[++e] = [i, r];
  }), n;
}
function Ex(t) {
  var e = -1, n = Array(t.size);
  return t.forEach(function(r) {
    n[++e] = r;
  }), n;
}
var xx = 1, Ax = 2, kx = "[object Boolean]", Cx = "[object Date]", Tx = "[object Error]", Ox = "[object Map]", Ix = "[object Number]", Nx = "[object RegExp]", Rx = "[object Set]", Px = "[object String]", Dx = "[object Symbol]", Bx = "[object ArrayBuffer]", Mx = "[object DataView]", Uh = ir ? ir.prototype : void 0, Iu = Uh ? Uh.valueOf : void 0;
function Lx(t, e, n, r, i, s, o) {
  switch (n) {
    case Mx:
      if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
        return !1;
      t = t.buffer, e = e.buffer;
    case Bx:
      return !(t.byteLength != e.byteLength || !s(new bl(t), new bl(e)));
    case kx:
    case Cx:
    case Ix:
      return na(+t, +e);
    case Tx:
      return t.name == e.name && t.message == e.message;
    case Nx:
    case Px:
      return t == e + "";
    case Ox:
      var a = Sx;
    case Rx:
      var l = r & xx;
      if (a || (a = Ex), t.size != e.size && !l)
        return !1;
      var u = o.get(t);
      if (u)
        return u == e;
      r |= Ax, o.set(t, e);
      var c = Ag(a(t), a(e), r, i, s, o);
      return o.delete(t), c;
    case Dx:
      if (Iu)
        return Iu.call(t) == Iu.call(e);
  }
  return !1;
}
var zx = 1, jx = Object.prototype, Fx = jx.hasOwnProperty;
function Hx(t, e, n, r, i, s) {
  var o = n & zx, a = pc(t), l = a.length, u = pc(e), c = u.length;
  if (l != c && !o)
    return !1;
  for (var d = l; d--; ) {
    var h = a[d];
    if (!(o ? h in e : Fx.call(e, h)))
      return !1;
  }
  var v = s.get(t), m = s.get(e);
  if (v && m)
    return v == e && m == t;
  var b = !0;
  s.set(t, e), s.set(e, t);
  for (var p = o; ++d < l; ) {
    h = a[d];
    var f = t[h], g = e[h];
    if (r)
      var y = o ? r(g, f, h, e, t, s) : r(f, g, h, t, e, s);
    if (!(y === void 0 ? f === g || i(f, g, n, r, s) : y)) {
      b = !1;
      break;
    }
    p || (p = h == "constructor");
  }
  if (b && !p) {
    var w = t.constructor, _ = e.constructor;
    w != _ && "constructor" in t && "constructor" in e && !(typeof w == "function" && w instanceof w && typeof _ == "function" && _ instanceof _) && (b = !1);
  }
  return s.delete(t), s.delete(e), b;
}
var Ux = 1, Vh = "[object Arguments]", Wh = "[object Array]", xa = "[object Object]", Vx = Object.prototype, $h = Vx.hasOwnProperty;
function Wx(t, e, n, r, i, s) {
  var o = Vn(t), a = Vn(e), l = o ? Wh : Do(t), u = a ? Wh : Do(e);
  l = l == Vh ? xa : l, u = u == Vh ? xa : u;
  var c = l == xa, d = u == xa, h = l == u;
  if (h && No(t)) {
    if (!No(e))
      return !1;
    o = !0, c = !1;
  }
  if (h && !c)
    return s || (s = new yr()), o || zd(t) ? Ag(t, e, n, r, i, s) : Lx(t, e, l, n, r, i, s);
  if (!(n & Ux)) {
    var v = c && $h.call(t, "__wrapped__"), m = d && $h.call(e, "__wrapped__");
    if (v || m) {
      var b = v ? t.value() : t, p = m ? e.value() : e;
      return s || (s = new yr()), i(b, p, n, r, s);
    }
  }
  return h ? (s || (s = new yr()), Hx(t, e, n, r, i, s)) : !1;
}
function ru(t, e, n, r, i) {
  return t === e ? !0 : t == null || e == null || !Mr(t) && !Mr(e) ? t !== t && e !== e : Wx(t, e, n, r, ru, i);
}
var $x = 1, Kx = 2;
function Gx(t, e, n, r) {
  var i = n.length, s = i, o = !r;
  if (t == null)
    return !s;
  for (t = Object(t); i--; ) {
    var a = n[i];
    if (o && a[2] ? a[1] !== t[a[0]] : !(a[0] in t))
      return !1;
  }
  for (; ++i < s; ) {
    a = n[i];
    var l = a[0], u = t[l], c = a[1];
    if (o && a[2]) {
      if (u === void 0 && !(l in t))
        return !1;
    } else {
      var d = new yr();
      if (r)
        var h = r(u, c, l, t, e, d);
      if (!(h === void 0 ? ru(c, u, $x | Kx, r, d) : h))
        return !1;
    }
  }
  return !0;
}
function kg(t) {
  return t === t && !Dn(t);
}
function qx(t) {
  for (var e = ia(t), n = e.length; n--; ) {
    var r = e[n], i = t[r];
    e[n] = [r, i, kg(i)];
  }
  return e;
}
function Cg(t, e) {
  return function(n) {
    return n == null ? !1 : n[t] === e && (e !== void 0 || t in Object(n));
  };
}
function Jx(t) {
  var e = qx(t);
  return e.length == 1 && e[0][2] ? Cg(e[0][0], e[0][1]) : function(n) {
    return n === t || Gx(n, t, e);
  };
}
function Yx(t, e) {
  return t != null && e in Object(t);
}
function Qx(t, e, n) {
  e = nu(e, t);
  for (var r = -1, i = e.length, s = !1; ++r < i; ) {
    var o = oa(e[r]);
    if (!(s = t != null && n(t, o)))
      break;
    t = t[o];
  }
  return s || ++r != i ? s : (i = t == null ? 0 : t.length, !!i && Bd(i) && Xl(o, i) && (Vn(t) || Io(t)));
}
function Tg(t, e) {
  return t != null && Qx(t, e, Yx);
}
var Zx = 1, Xx = 2;
function eA(t, e) {
  return jd(t) && kg(e) ? Cg(oa(t), e) : function(n) {
    var r = Cn(n, t);
    return r === void 0 && r === e ? Tg(n, t) : ru(e, r, Zx | Xx);
  };
}
function tA(t) {
  return function(e) {
    return e == null ? void 0 : e[t];
  };
}
function nA(t) {
  return function(e) {
    return Hd(e, t);
  };
}
function rA(t) {
  return jd(t) ? tA(oa(t)) : nA(t);
}
function Og(t) {
  return typeof t == "function" ? t : t == null ? Nd : typeof t == "object" ? Vn(t) ? eA(t[0], t[1]) : Jx(t) : rA(t);
}
function iA(t) {
  return function(e, n, r) {
    for (var i = -1, s = Object(e), o = r(e), a = o.length; a--; ) {
      var l = o[t ? a : ++i];
      if (n(s[l], l, s) === !1)
        break;
    }
    return e;
  };
}
var sA = iA();
const Ig = sA;
function oA(t, e) {
  return t && Ig(t, e, ia);
}
function aA(t, e) {
  return function(n, r) {
    if (n == null)
      return n;
    if (!qs(n))
      return t(n, r);
    for (var i = n.length, s = e ? i : -1, o = Object(n); (e ? s-- : ++s < i) && r(o[s], s, o) !== !1; )
      ;
    return n;
  };
}
var lA = aA(oA);
const uA = lA;
var cA = function() {
  return Er.Date.now();
};
const Nu = cA;
var dA = "Expected a function", fA = Math.max, hA = Math.min;
function ni(t, e, n) {
  var r, i, s, o, a, l, u = 0, c = !1, d = !1, h = !0;
  if (typeof t != "function")
    throw new TypeError(dA);
  e = fc(e) || 0, Dn(n) && (c = !!n.leading, d = "maxWait" in n, s = d ? fA(fc(n.maxWait) || 0, e) : s, h = "trailing" in n ? !!n.trailing : h);
  function v(S) {
    var A = r, C = i;
    return r = i = void 0, u = S, o = t.apply(C, A), o;
  }
  function m(S) {
    return u = S, a = setTimeout(f, e), c ? v(S) : o;
  }
  function b(S) {
    var A = S - l, C = S - u, k = e - A;
    return d ? hA(k, s - C) : k;
  }
  function p(S) {
    var A = S - l, C = S - u;
    return l === void 0 || A >= e || A < 0 || d && C >= s;
  }
  function f() {
    var S = Nu();
    if (p(S))
      return g(S);
    a = setTimeout(f, b(S));
  }
  function g(S) {
    return a = void 0, h && r ? v(S) : (r = i = void 0, o);
  }
  function y() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = i = a = void 0;
  }
  function w() {
    return a === void 0 ? o : g(Nu());
  }
  function _() {
    var S = Nu(), A = p(S);
    if (r = arguments, i = this, l = S, A) {
      if (a === void 0)
        return m(l);
      if (d)
        return clearTimeout(a), a = setTimeout(f, e), v(l);
    }
    return a === void 0 && (a = setTimeout(f, e)), o;
  }
  return _.cancel = y, _.flush = w, _;
}
function yc(t, e, n) {
  (n !== void 0 && !na(t[e], n) || n === void 0 && !(e in t)) && Pd(t, e, n);
}
function pA(t) {
  return Mr(t) && qs(t);
}
function bc(t, e) {
  if (!(e === "constructor" && typeof t[e] == "function") && e != "__proto__")
    return t[e];
}
function vA(t) {
  return ra(t, sa(t));
}
function gA(t, e, n, r, i, s, o) {
  var a = bc(t, n), l = bc(e, n), u = o.get(l);
  if (u) {
    yc(t, n, u);
    return;
  }
  var c = s ? s(a, l, n + "", t, e, o) : void 0, d = c === void 0;
  if (d) {
    var h = Vn(l), v = !h && No(l), m = !h && !v && zd(l);
    c = l, h || v || m ? Vn(a) ? c = a : pA(a) ? c = og(a) : v ? (d = !1, c = gg(l, !0)) : m ? (d = !1, c = wg(l, !0)) : c = [] : NS(l) || Io(l) ? (c = a, Io(a) ? c = vA(a) : (!Dn(a) || Rd(a)) && (c = _g(l))) : d = !1;
  }
  d && (o.set(l, c), i(c, l, r, s, o), o.delete(l)), yc(t, n, c);
}
function Ng(t, e, n, r, i) {
  t !== e && Ig(e, function(s, o) {
    if (i || (i = new yr()), Dn(s))
      gA(t, e, o, n, Ng, r, i);
    else {
      var a = r ? r(bc(t, o), s, o + "", t, e, i) : void 0;
      a === void 0 && (a = s), yc(t, o, a);
    }
  }, sa);
}
var mA = Math.max, yA = Math.min;
function bA(t, e, n) {
  var r = t == null ? 0 : t.length;
  if (!r)
    return -1;
  var i = r - 1;
  return n !== void 0 && (i = r1(n), i = n < 0 ? mA(r + i, 0) : yA(i, r - 1)), B1(t, Og(e), i, !0);
}
function wA(t, e) {
  var n = -1, r = qs(t) ? Array(t.length) : [];
  return uA(t, function(i, s, o) {
    r[++n] = e(i, s, o);
  }), r;
}
function _A(t, e) {
  var n = Vn(t) ? ig : wA;
  return n(t, Og(e));
}
function SA(t, e) {
  return Vd(_A(t, e), 1);
}
function _l(t) {
  for (var e = -1, n = t == null ? 0 : t.length, r = {}; ++e < n; ) {
    var i = t[e];
    r[i[0]] = i[1];
  }
  return r;
}
function Sl(t, e) {
  return ru(t, e);
}
function nr(t) {
  return t == null;
}
function EA(t) {
  return t === void 0;
}
var xA = V1(function(t, e, n) {
  Ng(t, e, n);
});
const Rg = xA;
function Pg(t, e, n, r) {
  if (!Dn(t))
    return t;
  e = nu(e, t);
  for (var i = -1, s = e.length, o = s - 1, a = t; a != null && ++i < s; ) {
    var l = oa(e[i]), u = n;
    if (l === "__proto__" || l === "constructor" || l === "prototype")
      return t;
    if (i != o) {
      var c = a[l];
      u = r ? r(c, l, a) : void 0, u === void 0 && (u = Dn(c) ? c : Xl(e[i + 1]) ? [] : {});
    }
    Dd(a, l, u), a = a[l];
  }
  return t;
}
function AA(t, e, n) {
  for (var r = -1, i = e.length, s = {}; ++r < i; ) {
    var o = e[r], a = Hd(t, o);
    n(a, o) && Pg(s, nu(o, t), a);
  }
  return s;
}
function kA(t, e) {
  return AA(t, e, function(n, r) {
    return Tg(t, r);
  });
}
var CA = xS(function(t, e) {
  return t == null ? {} : kA(t, e);
});
const TA = CA;
function OA(t, e, n) {
  return t == null ? t : Pg(t, e, n);
}
var IA = "Expected a function";
function Ru(t, e, n) {
  var r = !0, i = !0;
  if (typeof t != "function")
    throw new TypeError(IA);
  return Dn(n) && (r = "leading" in n ? !!n.leading : r, i = "trailing" in n ? !!n.trailing : i), ni(t, e, {
    leading: r,
    maxWait: e,
    trailing: i
  });
}
const Cr = (t) => t === void 0, ri = (t) => typeof t == "boolean", mt = (t) => typeof t == "number", Gi = (t) => typeof Element > "u" ? !1 : t instanceof Element, NA = (t) => Gt(t) ? !Number.isNaN(Number(t)) : !1, RA = (t = "") => t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d"), wc = (t) => Object.keys(t), PA = (t) => Object.entries(t), DA = (t, e, n) => ({
  get value() {
    return Cn(t, e, n);
  },
  set value(r) {
    OA(t, e, r);
  }
});
class Dg extends Error {
  constructor(e) {
    super(e), this.name = "ElementPlusError";
  }
}
function ts(t, e) {
  throw new Dg(`[${t}] ${e}`);
}
function Vt(t, e) {
  if (process.env.NODE_ENV !== "production") {
    const n = Gt(t) ? new Dg(`[${t}] ${e}`) : t;
    console.warn(n);
  }
}
const BA = "utils/dom/style", Bg = (t = "") => t.split(" ").filter((e) => !!e.trim()), Ga = (t, e) => {
  if (!t || !e)
    return !1;
  if (e.includes(" "))
    throw new Error("className should not contain space.");
  return t.classList.contains(e);
}, Bo = (t, e) => {
  !t || !e.trim() || t.classList.add(...Bg(e));
}, Or = (t, e) => {
  !t || !e.trim() || t.classList.remove(...Bg(e));
}, ws = (t, e) => {
  var n;
  if (!St || !t || !e)
    return "";
  let r = Ow(e);
  r === "float" && (r = "cssFloat");
  try {
    const i = t.style[r];
    if (i)
      return i;
    const s = (n = document.defaultView) == null ? void 0 : n.getComputedStyle(t, "");
    return s ? s[r] : "";
  } catch {
    return t.style[r];
  }
};
function El(t, e = "px") {
  if (!t)
    return "";
  if (mt(t) || NA(t))
    return `${t}${e}`;
  if (Gt(t))
    return t;
  Vt(BA, "binding value must be a string or number");
}
const MA = (t, e) => {
  if (!St)
    return !1;
  const n = {
    undefined: "overflow",
    true: "overflow-y",
    false: "overflow-x"
  }[String(e)], r = ws(t, n);
  return ["scroll", "auto", "overlay"].some((i) => r.includes(i));
}, LA = (t, e) => {
  if (!St)
    return;
  let n = t;
  for (; n; ) {
    if ([window, document, document.documentElement].includes(n))
      return window;
    if (MA(n, e))
      return n;
    n = n.parentNode;
  }
  return n;
};
function zA(t, e) {
  if (!St)
    return;
  if (!e) {
    t.scrollTop = 0;
    return;
  }
  const n = [];
  let r = e.offsetParent;
  for (; r !== null && t !== r && t.contains(r); )
    n.push(r), r = r.offsetParent;
  const i = e.offsetTop + n.reduce((l, u) => l + u.offsetTop, 0), s = i + e.offsetHeight, o = t.scrollTop, a = o + t.clientHeight;
  i < o ? t.scrollTop = i : s > a && (t.scrollTop = s - t.clientHeight);
}
/*! Element Plus Icons Vue v2.1.0 */
var Tt = (t, e) => {
  let n = t.__vccOpts || t;
  for (let [r, i] of e)
    n[r] = i;
  return n;
}, jA = {
  name: "ArrowDown"
}, FA = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, HA = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
  },
  null,
  -1
  /* HOISTED */
), UA = [
  HA
];
function VA(t, e, n, r, i, s) {
  return U(), oe("svg", FA, UA);
}
var Gd = /* @__PURE__ */ Tt(jA, [["render", VA], ["__file", "arrow-down.vue"]]), WA = {
  name: "ArrowLeft"
}, $A = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, KA = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
  },
  null,
  -1
  /* HOISTED */
), GA = [
  KA
];
function qA(t, e, n, r, i, s) {
  return U(), oe("svg", $A, GA);
}
var JA = /* @__PURE__ */ Tt(WA, [["render", qA], ["__file", "arrow-left.vue"]]), YA = {
  name: "ArrowRight"
}, QA = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, ZA = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
  },
  null,
  -1
  /* HOISTED */
), XA = [
  ZA
];
function ek(t, e, n, r, i, s) {
  return U(), oe("svg", QA, XA);
}
var qd = /* @__PURE__ */ Tt(YA, [["render", ek], ["__file", "arrow-right.vue"]]), tk = {
  name: "ArrowUp"
}, nk = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, rk = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0z"
  },
  null,
  -1
  /* HOISTED */
), ik = [
  rk
];
function sk(t, e, n, r, i, s) {
  return U(), oe("svg", nk, ik);
}
var Mg = /* @__PURE__ */ Tt(tk, [["render", sk], ["__file", "arrow-up.vue"]]), ok = {
  name: "Back"
}, ak = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, lk = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M224 480h640a32 32 0 1 1 0 64H224a32 32 0 0 1 0-64z"
  },
  null,
  -1
  /* HOISTED */
), uk = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "m237.248 512 265.408 265.344a32 32 0 0 1-45.312 45.312l-288-288a32 32 0 0 1 0-45.312l288-288a32 32 0 1 1 45.312 45.312L237.248 512z"
  },
  null,
  -1
  /* HOISTED */
), ck = [
  lk,
  uk
];
function dk(t, e, n, r, i, s) {
  return U(), oe("svg", ak, ck);
}
var fk = /* @__PURE__ */ Tt(ok, [["render", dk], ["__file", "back.vue"]]), hk = {
  name: "CaretRight"
}, pk = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, vk = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M384 192v640l384-320.064z"
  },
  null,
  -1
  /* HOISTED */
), gk = [
  vk
];
function mk(t, e, n, r, i, s) {
  return U(), oe("svg", pk, gk);
}
var yk = /* @__PURE__ */ Tt(hk, [["render", mk], ["__file", "caret-right.vue"]]), bk = {
  name: "Check"
}, wk = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, _k = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
  },
  null,
  -1
  /* HOISTED */
), Sk = [
  _k
];
function Ek(t, e, n, r, i, s) {
  return U(), oe("svg", wk, Sk);
}
var Lg = /* @__PURE__ */ Tt(bk, [["render", Ek], ["__file", "check.vue"]]), xk = {
  name: "CircleCheck"
}, Ak = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, kk = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
  },
  null,
  -1
  /* HOISTED */
), Ck = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
  },
  null,
  -1
  /* HOISTED */
), Tk = [
  kk,
  Ck
];
function Ok(t, e, n, r, i, s) {
  return U(), oe("svg", Ak, Tk);
}
var Jd = /* @__PURE__ */ Tt(xk, [["render", Ok], ["__file", "circle-check.vue"]]), Ik = {
  name: "CircleClose"
}, Nk = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, Rk = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248L466.752 512z"
  },
  null,
  -1
  /* HOISTED */
), Pk = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
  },
  null,
  -1
  /* HOISTED */
), Dk = [
  Rk,
  Pk
];
function Bk(t, e, n, r, i, s) {
  return U(), oe("svg", Nk, Dk);
}
var iu = /* @__PURE__ */ Tt(Ik, [["render", Bk], ["__file", "circle-close.vue"]]), Mk = {
  name: "Close"
}, Lk = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, zk = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
  },
  null,
  -1
  /* HOISTED */
), jk = [
  zk
];
function Fk(t, e, n, r, i, s) {
  return U(), oe("svg", Lk, jk);
}
var Mo = /* @__PURE__ */ Tt(Mk, [["render", Fk], ["__file", "close.vue"]]), Hk = {
  name: "Delete"
}, Uk = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, Vk = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V256zm448-64v-64H416v64h192zM224 896h576V256H224v640zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32zm192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32z"
  },
  null,
  -1
  /* HOISTED */
), Wk = [
  Vk
];
function $k(t, e, n, r, i, s) {
  return U(), oe("svg", Uk, Wk);
}
var zg = /* @__PURE__ */ Tt(Hk, [["render", $k], ["__file", "delete.vue"]]), Kk = {
  name: "Document"
}, Gk = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, qk = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M832 384H576V128H192v768h640V384zm-26.496-64L640 154.496V320h165.504zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32zm160 448h384v64H320v-64zm0-192h160v64H320v-64zm0 384h384v64H320v-64z"
  },
  null,
  -1
  /* HOISTED */
), Jk = [
  qk
];
function Yk(t, e, n, r, i, s) {
  return U(), oe("svg", Gk, Jk);
}
var Qk = /* @__PURE__ */ Tt(Kk, [["render", Yk], ["__file", "document.vue"]]), Zk = {
  name: "Download"
}, Xk = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, eC = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M160 832h704a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64zm384-253.696 236.288-236.352 45.248 45.248L508.8 704 192 387.2l45.248-45.248L480 584.704V128h64v450.304z"
  },
  null,
  -1
  /* HOISTED */
), tC = [
  eC
];
function nC(t, e, n, r, i, s) {
  return U(), oe("svg", Xk, tC);
}
var rC = /* @__PURE__ */ Tt(Zk, [["render", nC], ["__file", "download.vue"]]), iC = {
  name: "FullScreen"
}, sC = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, oC = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64v.064zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64l-192 .192zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64l192-.192zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64v-.064z"
  },
  null,
  -1
  /* HOISTED */
), aC = [
  oC
];
function lC(t, e, n, r, i, s) {
  return U(), oe("svg", sC, aC);
}
var jg = /* @__PURE__ */ Tt(iC, [["render", lC], ["__file", "full-screen.vue"]]), uC = {
  name: "Grid"
}, cC = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, dC = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M640 384v256H384V384h256zm64 0h192v256H704V384zm-64 512H384V704h256v192zm64 0V704h192v192H704zm-64-768v192H384V128h256zm64 0h192v192H704V128zM320 384v256H128V384h192zm0 512H128V704h192v192zm0-768v192H128V128h192z"
  },
  null,
  -1
  /* HOISTED */
), fC = [
  dC
];
function hC(t, e, n, r, i, s) {
  return U(), oe("svg", cC, fC);
}
var pC = /* @__PURE__ */ Tt(uC, [["render", hC], ["__file", "grid.vue"]]), vC = {
  name: "Hide"
}, gC = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, mC = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2L371.2 588.8ZM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
  },
  null,
  -1
  /* HOISTED */
), yC = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
  },
  null,
  -1
  /* HOISTED */
), bC = [
  mC,
  yC
];
function wC(t, e, n, r, i, s) {
  return U(), oe("svg", gC, bC);
}
var _C = /* @__PURE__ */ Tt(vC, [["render", wC], ["__file", "hide.vue"]]), SC = {
  name: "Loading"
}, EC = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, xC = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32zm0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32zm448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32zm-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32zM195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0zm-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
  },
  null,
  -1
  /* HOISTED */
), AC = [
  xC
];
function kC(t, e, n, r, i, s) {
  return U(), oe("svg", EC, AC);
}
var su = /* @__PURE__ */ Tt(SC, [["render", kC], ["__file", "loading.vue"]]), CC = {
  name: "Minus"
}, TC = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, OC = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64z"
  },
  null,
  -1
  /* HOISTED */
), IC = [
  OC
];
function NC(t, e, n, r, i, s) {
  return U(), oe("svg", TC, IC);
}
var RC = /* @__PURE__ */ Tt(CC, [["render", NC], ["__file", "minus.vue"]]), PC = {
  name: "Operation"
}, DC = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, BC = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M389.44 768a96.064 96.064 0 0 1 181.12 0H896v64H570.56a96.064 96.064 0 0 1-181.12 0H128v-64h261.44zm192-288a96.064 96.064 0 0 1 181.12 0H896v64H762.56a96.064 96.064 0 0 1-181.12 0H128v-64h453.44zm-320-288a96.064 96.064 0 0 1 181.12 0H896v64H442.56a96.064 96.064 0 0 1-181.12 0H128v-64h133.44z"
  },
  null,
  -1
  /* HOISTED */
), MC = [
  BC
];
function LC(t, e, n, r, i, s) {
  return U(), oe("svg", DC, MC);
}
var zC = /* @__PURE__ */ Tt(PC, [["render", LC], ["__file", "operation.vue"]]), jC = {
  name: "Picture"
}, FC = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, HC = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M160 160v704h704V160H160zm-32-64h768a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H128a32 32 0 0 1-32-32V128a32 32 0 0 1 32-32z"
  },
  null,
  -1
  /* HOISTED */
), UC = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M384 288q64 0 64 64t-64 64q-64 0-64-64t64-64zM185.408 876.992l-50.816-38.912L350.72 556.032a96 96 0 0 1 134.592-17.856l1.856 1.472 122.88 99.136a32 32 0 0 0 44.992-4.864l216-269.888 49.92 39.936-215.808 269.824-.256.32a96 96 0 0 1-135.04 14.464l-122.88-99.072-.64-.512a32 32 0 0 0-44.8 5.952L185.408 876.992z"
  },
  null,
  -1
  /* HOISTED */
), VC = [
  HC,
  UC
];
function WC(t, e, n, r, i, s) {
  return U(), oe("svg", FC, VC);
}
var $C = /* @__PURE__ */ Tt(jC, [["render", WC], ["__file", "picture.vue"]]), KC = {
  name: "Plus"
}, GC = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, qC = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64h352z"
  },
  null,
  -1
  /* HOISTED */
), JC = [
  qC
];
function YC(t, e, n, r, i, s) {
  return U(), oe("svg", GC, JC);
}
var Fg = /* @__PURE__ */ Tt(KC, [["render", YC], ["__file", "plus.vue"]]), QC = {
  name: "Reading"
}, ZC = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, XC = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "m512 863.36 384-54.848v-638.72L525.568 222.72a96 96 0 0 1-27.136 0L128 169.792v638.72l384 54.848zM137.024 106.432l370.432 52.928a32 32 0 0 0 9.088 0l370.432-52.928A64 64 0 0 1 960 169.792v638.72a64 64 0 0 1-54.976 63.36l-388.48 55.488a32 32 0 0 1-9.088 0l-388.48-55.488A64 64 0 0 1 64 808.512v-638.72a64 64 0 0 1 73.024-63.36z"
  },
  null,
  -1
  /* HOISTED */
), e2 = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M480 192h64v704h-64z"
  },
  null,
  -1
  /* HOISTED */
), t2 = [
  XC,
  e2
];
function n2(t, e, n, r, i, s) {
  return U(), oe("svg", ZC, t2);
}
var r2 = /* @__PURE__ */ Tt(QC, [["render", n2], ["__file", "reading.vue"]]), i2 = {
  name: "RefreshLeft"
}, s2 = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, o2 = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z"
  },
  null,
  -1
  /* HOISTED */
), a2 = [
  o2
];
function l2(t, e, n, r, i, s) {
  return U(), oe("svg", s2, a2);
}
var u2 = /* @__PURE__ */ Tt(i2, [["render", l2], ["__file", "refresh-left.vue"]]), c2 = {
  name: "RefreshRight"
}, d2 = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, f2 = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z"
  },
  null,
  -1
  /* HOISTED */
), h2 = [
  f2
];
function p2(t, e, n, r, i, s) {
  return U(), oe("svg", d2, h2);
}
var v2 = /* @__PURE__ */ Tt(c2, [["render", p2], ["__file", "refresh-right.vue"]]), g2 = {
  name: "ScaleToOriginal"
}, m2 = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, y2 = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M813.176 180.706a60.235 60.235 0 0 1 60.236 60.235v481.883a60.235 60.235 0 0 1-60.236 60.235H210.824a60.235 60.235 0 0 1-60.236-60.235V240.94a60.235 60.235 0 0 1 60.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0 0 90.353 240.94v481.883a120.47 120.47 0 0 0 120.47 120.47h602.353a120.47 120.47 0 0 0 120.471-120.47V240.94a120.47 120.47 0 0 0-120.47-120.47zm-120.47 180.705a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 0 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zm-361.412 0a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 1 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zM512 361.412a30.118 30.118 0 0 0-30.118 30.117v30.118a30.118 30.118 0 0 0 60.236 0V391.53A30.118 30.118 0 0 0 512 361.412zM512 512a30.118 30.118 0 0 0-30.118 30.118v30.117a30.118 30.118 0 0 0 60.236 0v-30.117A30.118 30.118 0 0 0 512 512z"
  },
  null,
  -1
  /* HOISTED */
), b2 = [
  y2
];
function w2(t, e, n, r, i, s) {
  return U(), oe("svg", m2, b2);
}
var _2 = /* @__PURE__ */ Tt(g2, [["render", w2], ["__file", "scale-to-original.vue"]]), S2 = {
  name: "Search"
}, E2 = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, x2 = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704z"
  },
  null,
  -1
  /* HOISTED */
), A2 = [
  x2
];
function k2(t, e, n, r, i, s) {
  return U(), oe("svg", E2, A2);
}
var C2 = /* @__PURE__ */ Tt(S2, [["render", k2], ["__file", "search.vue"]]), T2 = {
  name: "View"
}, O2 = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, I2 = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352zm0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448zm0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160z"
  },
  null,
  -1
  /* HOISTED */
), N2 = [
  I2
];
function R2(t, e, n, r, i, s) {
  return U(), oe("svg", O2, N2);
}
var P2 = /* @__PURE__ */ Tt(T2, [["render", R2], ["__file", "view.vue"]]), D2 = {
  name: "WarningFilled"
}, B2 = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, M2 = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256zm0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4z"
  },
  null,
  -1
  /* HOISTED */
), L2 = [
  M2
];
function z2(t, e, n, r, i, s) {
  return U(), oe("svg", B2, L2);
}
var j2 = /* @__PURE__ */ Tt(D2, [["render", z2], ["__file", "warning-filled.vue"]]), F2 = {
  name: "ZoomIn"
}, H2 = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, U2 = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zm-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64h96z"
  },
  null,
  -1
  /* HOISTED */
), V2 = [
  U2
];
function W2(t, e, n, r, i, s) {
  return U(), oe("svg", H2, V2);
}
var Hg = /* @__PURE__ */ Tt(F2, [["render", W2], ["__file", "zoom-in.vue"]]), $2 = {
  name: "ZoomOut"
}, K2 = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, G2 = /* @__PURE__ */ le(
  "path",
  {
    fill: "currentColor",
    d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zM352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64z"
  },
  null,
  -1
  /* HOISTED */
), q2 = [
  G2
];
function J2(t, e, n, r, i, s) {
  return U(), oe("svg", K2, q2);
}
var Y2 = /* @__PURE__ */ Tt($2, [["render", J2], ["__file", "zoom-out.vue"]]);
const Ug = "__epPropKey", De = (t) => t, Q2 = (t) => _n(t) && !!t[Ug], ou = (t, e) => {
  if (!_n(t) || Q2(t))
    return t;
  const { values: n, required: r, default: i, type: s, validator: o } = t, l = {
    type: s,
    required: !!r,
    validator: n || o ? (u) => {
      let c = !1, d = [];
      if (n && (d = Array.from(n), Dr(t, "default") && d.push(i), c || (c = d.includes(u))), o && (c || (c = o(u))), !c && d.length > 0) {
        const h = [...new Set(d)].map((v) => JSON.stringify(v)).join(", ");
        Sb(`Invalid prop: validation failed${e ? ` for prop "${e}"` : ""}. Expected one of [${h}], got value ${JSON.stringify(u)}.`);
      }
      return c;
    } : void 0,
    [Ug]: !0
  };
  return Dr(t, "default") && (l.default = i), l;
}, ut = (t) => _l(Object.entries(t).map(([e, n]) => [
  e,
  ou(n, e)
])), xi = De([
  String,
  Object,
  Function
]), Vg = {
  validating: su,
  success: Jd,
  error: iu
}, nn = (t, e) => {
  if (t.install = (n) => {
    for (const r of [t, ...Object.values(e ?? {})])
      n.component(r.name, r);
  }, e)
    for (const [n, r] of Object.entries(e))
      t[n] = r;
  return t;
}, Z2 = (t, e) => (t.install = (n) => {
  n.directive(e, t);
}, t), ar = (t) => (t.install = en, t), sn = {
  tab: "Tab",
  enter: "Enter",
  space: "Space",
  left: "ArrowLeft",
  up: "ArrowUp",
  right: "ArrowRight",
  down: "ArrowDown",
  esc: "Escape",
  delete: "Delete",
  backspace: "Backspace",
  numpadEnter: "NumpadEnter",
  pageUp: "PageUp",
  pageDown: "PageDown",
  home: "Home",
  end: "End"
}, Dt = "update:modelValue", ns = "change", Fi = "input", Yd = ["", "default", "small", "large"], X2 = {
  large: 40,
  default: 32,
  small: 24
}, eT = (t) => X2[t || "default"], tT = (t) => ["", ...Yd].includes(t), Wg = (t) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(t), nT = (t) => St ? window.requestAnimationFrame(t) : setTimeout(t, 16), Ms = (t) => t, rT = ["class", "style"], iT = /^on[A-Z]/, $g = (t = {}) => {
  const { excludeListeners: e = !1, excludeKeys: n } = t, r = j(() => ((n == null ? void 0 : n.value) || []).concat(rT)), i = ft();
  return i ? j(() => {
    var s;
    return _l(Object.entries((s = i.proxy) == null ? void 0 : s.$attrs).filter(([o]) => !r.value.includes(o) && !(e && iT.test(o))));
  }) : (Vt("use-attrs", "getCurrentInstance() returned null. useAttrs() must be called at the top of a setup function"), j(() => ({})));
}, Kg = ({ from: t, replacement: e, scope: n, version: r, ref: i, type: s = "API" }, o) => {
  Ae(() => x(o), (a) => {
    a && Vt(n, `[${s}] ${t} is about to be deprecated in version ${r}, please use ${e} instead.
For more detail, please visit: ${i}
`);
  }, {
    immediate: !0
  });
};
var sT = {
  name: "en",
  el: {
    colorpicker: {
      confirm: "OK",
      clear: "Clear",
      defaultLabel: "color picker",
      description: "current color is {color}. press enter to select a new color."
    },
    datepicker: {
      now: "Now",
      today: "Today",
      cancel: "Cancel",
      clear: "Clear",
      confirm: "OK",
      dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
      monthTablePrompt: "Use the arrow keys and enter to select the month",
      yearTablePrompt: "Use the arrow keys and enter to select the year",
      selectedDate: "Selected date",
      selectDate: "Select date",
      selectTime: "Select time",
      startDate: "Start Date",
      startTime: "Start Time",
      endDate: "End Date",
      endTime: "End Time",
      prevYear: "Previous Year",
      nextYear: "Next Year",
      prevMonth: "Previous Month",
      nextMonth: "Next Month",
      year: "",
      month1: "January",
      month2: "February",
      month3: "March",
      month4: "April",
      month5: "May",
      month6: "June",
      month7: "July",
      month8: "August",
      month9: "September",
      month10: "October",
      month11: "November",
      month12: "December",
      week: "week",
      weeks: {
        sun: "Sun",
        mon: "Mon",
        tue: "Tue",
        wed: "Wed",
        thu: "Thu",
        fri: "Fri",
        sat: "Sat"
      },
      weeksFull: {
        sun: "Sunday",
        mon: "Monday",
        tue: "Tuesday",
        wed: "Wednesday",
        thu: "Thursday",
        fri: "Friday",
        sat: "Saturday"
      },
      months: {
        jan: "Jan",
        feb: "Feb",
        mar: "Mar",
        apr: "Apr",
        may: "May",
        jun: "Jun",
        jul: "Jul",
        aug: "Aug",
        sep: "Sep",
        oct: "Oct",
        nov: "Nov",
        dec: "Dec"
      }
    },
    inputNumber: {
      decrease: "decrease number",
      increase: "increase number"
    },
    select: {
      loading: "Loading",
      noMatch: "No matching data",
      noData: "No data",
      placeholder: "Select"
    },
    dropdown: {
      toggleDropdown: "Toggle Dropdown"
    },
    cascader: {
      noMatch: "No matching data",
      loading: "Loading",
      placeholder: "Select",
      noData: "No data"
    },
    pagination: {
      goto: "Go to",
      pagesize: "/page",
      total: "Total {total}",
      pageClassifier: "",
      page: "Page",
      prev: "Go to previous page",
      next: "Go to next page",
      currentPage: "page {pager}",
      prevPages: "Previous {pager} pages",
      nextPages: "Next {pager} pages",
      deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
    },
    dialog: {
      close: "Close this dialog"
    },
    drawer: {
      close: "Close this dialog"
    },
    messagebox: {
      title: "Message",
      confirm: "OK",
      cancel: "Cancel",
      error: "Illegal input",
      close: "Close this dialog"
    },
    upload: {
      deleteTip: "press delete to remove",
      delete: "Delete",
      preview: "Preview",
      continue: "Continue"
    },
    slider: {
      defaultLabel: "slider between {min} and {max}",
      defaultRangeStartLabel: "pick start value",
      defaultRangeEndLabel: "pick end value"
    },
    table: {
      emptyText: "No Data",
      confirmFilter: "Confirm",
      resetFilter: "Reset",
      clearFilter: "All",
      sumText: "Sum"
    },
    tree: {
      emptyText: "No Data"
    },
    transfer: {
      noMatch: "No matching data",
      noData: "No data",
      titles: ["List 1", "List 2"],
      filterPlaceholder: "Enter keyword",
      noCheckedFormat: "{total} items",
      hasCheckedFormat: "{checked}/{total} checked"
    },
    image: {
      error: "FAILED"
    },
    pageHeader: {
      title: "Back"
    },
    popconfirm: {
      confirmButtonText: "Yes",
      cancelButtonText: "No"
    }
  }
};
const oT = (t) => (e, n) => aT(e, n, x(t)), aT = (t, e, n) => Cn(n, t, t).replace(/\{(\w+)\}/g, (r, i) => {
  var s;
  return `${(s = e == null ? void 0 : e[i]) != null ? s : `{${i}}`}`;
}), lT = (t) => {
  const e = j(() => x(t).name), n = on(t) ? t : K(t);
  return {
    lang: e,
    locale: n,
    t: oT(t)
  };
}, Gg = Symbol("localeContextKey"), lr = (t) => {
  const e = t || et(Gg, K());
  return lT(j(() => e.value || sT));
}, qa = "el", uT = "is-", Ni = (t, e, n, r, i) => {
  let s = `${t}-${e}`;
  return n && (s += `-${n}`), r && (s += `__${r}`), i && (s += `--${i}`), s;
}, qg = Symbol("namespaceContextKey"), Qd = (t) => {
  const e = t || (ft() ? et(qg, K(qa)) : K(qa));
  return j(() => x(e) || qa);
}, ze = (t, e) => {
  const n = Qd(e);
  return {
    namespace: n,
    b: (b = "") => Ni(n.value, t, b, "", ""),
    e: (b) => b ? Ni(n.value, t, "", b, "") : "",
    m: (b) => b ? Ni(n.value, t, "", "", b) : "",
    be: (b, p) => b && p ? Ni(n.value, t, b, p, "") : "",
    em: (b, p) => b && p ? Ni(n.value, t, "", b, p) : "",
    bm: (b, p) => b && p ? Ni(n.value, t, b, "", p) : "",
    bem: (b, p, f) => b && p && f ? Ni(n.value, t, b, p, f) : "",
    is: (b, ...p) => {
      const f = p.length >= 1 ? p[0] : !0;
      return b && f ? `${uT}${b}` : "";
    },
    cssVar: (b) => {
      const p = {};
      for (const f in b)
        b[f] && (p[`--${n.value}-${f}`] = b[f]);
      return p;
    },
    cssVarName: (b) => `--${n.value}-${b}`,
    cssVarBlock: (b) => {
      const p = {};
      for (const f in b)
        b[f] && (p[`--${n.value}-${t}-${f}`] = b[f]);
      return p;
    },
    cssVarBlockName: (b) => `--${n.value}-${t}-${b}`
  };
}, cT = ou({
  type: De(Boolean),
  default: null
}), dT = ou({
  type: De(Function)
}), Jg = (t) => {
  const e = `update:${t}`, n = `onUpdate:${t}`, r = [e], i = {
    [t]: cT,
    [n]: dT
  };
  return {
    useModelToggle: ({
      indicator: o,
      toggleReason: a,
      shouldHideWhenRouteChanges: l,
      shouldProceed: u,
      onShow: c,
      onHide: d
    }) => {
      const h = ft(), { emit: v } = h, m = h.props, b = j(() => mn(m[n])), p = j(() => m[t] === null), f = (A) => {
        o.value !== !0 && (o.value = !0, a && (a.value = A), mn(c) && c(A));
      }, g = (A) => {
        o.value !== !1 && (o.value = !1, a && (a.value = A), mn(d) && d(A));
      }, y = (A) => {
        if (m.disabled === !0 || mn(u) && !u())
          return;
        const C = b.value && St;
        C && v(e, !0), (p.value || !C) && f(A);
      }, w = (A) => {
        if (m.disabled === !0 || !St)
          return;
        const C = b.value && St;
        C && v(e, !1), (p.value || !C) && g(A);
      }, _ = (A) => {
        ri(A) && (m.disabled && A ? b.value && v(e, !1) : o.value !== A && (A ? f() : g()));
      }, S = () => {
        o.value ? w() : y();
      };
      return Ae(() => m[t], _), l && h.appContext.config.globalProperties.$route !== void 0 && Ae(() => ({
        ...h.proxy.$route
      }), () => {
        l.value && o.value && w();
      }), Ct(() => {
        _(m[t]);
      }), {
        hide: w,
        show: y,
        toggle: S,
        hasUpdateHandler: b
      };
    },
    useModelToggleProps: i,
    useModelToggleEmits: r
  };
};
Jg("modelValue");
const Yg = (t) => {
  const e = ft();
  return j(() => {
    var n, r;
    return (r = (n = e == null ? void 0 : e.proxy) == null ? void 0 : n.$props) == null ? void 0 : r[t];
  });
};
var Hn = "top", sr = "bottom", or = "right", Un = "left", Zd = "auto", aa = [Hn, sr, or, Un], Ls = "start", Lo = "end", fT = "clippingParents", Qg = "viewport", so = "popper", hT = "reference", Kh = aa.reduce(function(t, e) {
  return t.concat([e + "-" + Ls, e + "-" + Lo]);
}, []), Js = [].concat(aa, [Zd]).reduce(function(t, e) {
  return t.concat([e, e + "-" + Ls, e + "-" + Lo]);
}, []), pT = "beforeRead", vT = "read", gT = "afterRead", mT = "beforeMain", yT = "main", bT = "afterMain", wT = "beforeWrite", _T = "write", ST = "afterWrite", ET = [pT, vT, gT, mT, yT, bT, wT, _T, ST];
function Lr(t) {
  return t ? (t.nodeName || "").toLowerCase() : null;
}
function xr(t) {
  if (t == null)
    return window;
  if (t.toString() !== "[object Window]") {
    var e = t.ownerDocument;
    return e && e.defaultView || window;
  }
  return t;
}
function zs(t) {
  var e = xr(t).Element;
  return t instanceof e || t instanceof Element;
}
function rr(t) {
  var e = xr(t).HTMLElement;
  return t instanceof e || t instanceof HTMLElement;
}
function Xd(t) {
  if (typeof ShadowRoot > "u")
    return !1;
  var e = xr(t).ShadowRoot;
  return t instanceof e || t instanceof ShadowRoot;
}
function xT(t) {
  var e = t.state;
  Object.keys(e.elements).forEach(function(n) {
    var r = e.styles[n] || {}, i = e.attributes[n] || {}, s = e.elements[n];
    !rr(s) || !Lr(s) || (Object.assign(s.style, r), Object.keys(i).forEach(function(o) {
      var a = i[o];
      a === !1 ? s.removeAttribute(o) : s.setAttribute(o, a === !0 ? "" : a);
    }));
  });
}
function AT(t) {
  var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
  return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
    Object.keys(e.elements).forEach(function(r) {
      var i = e.elements[r], s = e.attributes[r] || {}, o = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), a = o.reduce(function(l, u) {
        return l[u] = "", l;
      }, {});
      !rr(i) || !Lr(i) || (Object.assign(i.style, a), Object.keys(s).forEach(function(l) {
        i.removeAttribute(l);
      }));
    });
  };
}
var Zg = { name: "applyStyles", enabled: !0, phase: "write", fn: xT, effect: AT, requires: ["computeStyles"] };
function Ir(t) {
  return t.split("-")[0];
}
var Hi = Math.max, xl = Math.min, js = Math.round;
function Fs(t, e) {
  e === void 0 && (e = !1);
  var n = t.getBoundingClientRect(), r = 1, i = 1;
  if (rr(t) && e) {
    var s = t.offsetHeight, o = t.offsetWidth;
    o > 0 && (r = js(n.width) / o || 1), s > 0 && (i = js(n.height) / s || 1);
  }
  return { width: n.width / r, height: n.height / i, top: n.top / i, right: n.right / r, bottom: n.bottom / i, left: n.left / r, x: n.left / r, y: n.top / i };
}
function ef(t) {
  var e = Fs(t), n = t.offsetWidth, r = t.offsetHeight;
  return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), { x: t.offsetLeft, y: t.offsetTop, width: n, height: r };
}
function Xg(t, e) {
  var n = e.getRootNode && e.getRootNode();
  if (t.contains(e))
    return !0;
  if (n && Xd(n)) {
    var r = e;
    do {
      if (r && t.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function ii(t) {
  return xr(t).getComputedStyle(t);
}
function kT(t) {
  return ["table", "td", "th"].indexOf(Lr(t)) >= 0;
}
function Ti(t) {
  return ((zs(t) ? t.ownerDocument : t.document) || window.document).documentElement;
}
function au(t) {
  return Lr(t) === "html" ? t : t.assignedSlot || t.parentNode || (Xd(t) ? t.host : null) || Ti(t);
}
function Gh(t) {
  return !rr(t) || ii(t).position === "fixed" ? null : t.offsetParent;
}
function CT(t) {
  var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
  if (n && rr(t)) {
    var r = ii(t);
    if (r.position === "fixed")
      return null;
  }
  var i = au(t);
  for (Xd(i) && (i = i.host); rr(i) && ["html", "body"].indexOf(Lr(i)) < 0; ) {
    var s = ii(i);
    if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || e && s.willChange === "filter" || e && s.filter && s.filter !== "none")
      return i;
    i = i.parentNode;
  }
  return null;
}
function la(t) {
  for (var e = xr(t), n = Gh(t); n && kT(n) && ii(n).position === "static"; )
    n = Gh(n);
  return n && (Lr(n) === "html" || Lr(n) === "body" && ii(n).position === "static") ? e : n || CT(t) || e;
}
function tf(t) {
  return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
}
function bo(t, e, n) {
  return Hi(t, xl(e, n));
}
function TT(t, e, n) {
  var r = bo(t, e, n);
  return r > n ? n : r;
}
function em() {
  return { top: 0, right: 0, bottom: 0, left: 0 };
}
function tm(t) {
  return Object.assign({}, em(), t);
}
function nm(t, e) {
  return e.reduce(function(n, r) {
    return n[r] = t, n;
  }, {});
}
var OT = function(t, e) {
  return t = typeof t == "function" ? t(Object.assign({}, e.rects, { placement: e.placement })) : t, tm(typeof t != "number" ? t : nm(t, aa));
};
function IT(t) {
  var e, n = t.state, r = t.name, i = t.options, s = n.elements.arrow, o = n.modifiersData.popperOffsets, a = Ir(n.placement), l = tf(a), u = [Un, or].indexOf(a) >= 0, c = u ? "height" : "width";
  if (!(!s || !o)) {
    var d = OT(i.padding, n), h = ef(s), v = l === "y" ? Hn : Un, m = l === "y" ? sr : or, b = n.rects.reference[c] + n.rects.reference[l] - o[l] - n.rects.popper[c], p = o[l] - n.rects.reference[l], f = la(s), g = f ? l === "y" ? f.clientHeight || 0 : f.clientWidth || 0 : 0, y = b / 2 - p / 2, w = d[v], _ = g - h[c] - d[m], S = g / 2 - h[c] / 2 + y, A = bo(w, S, _), C = l;
    n.modifiersData[r] = (e = {}, e[C] = A, e.centerOffset = A - S, e);
  }
}
function NT(t) {
  var e = t.state, n = t.options, r = n.element, i = r === void 0 ? "[data-popper-arrow]" : r;
  i != null && (typeof i == "string" && (i = e.elements.popper.querySelector(i), !i) || !Xg(e.elements.popper, i) || (e.elements.arrow = i));
}
var RT = { name: "arrow", enabled: !0, phase: "main", fn: IT, effect: NT, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
function Hs(t) {
  return t.split("-")[1];
}
var PT = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
function DT(t) {
  var e = t.x, n = t.y, r = window, i = r.devicePixelRatio || 1;
  return { x: js(e * i) / i || 0, y: js(n * i) / i || 0 };
}
function qh(t) {
  var e, n = t.popper, r = t.popperRect, i = t.placement, s = t.variation, o = t.offsets, a = t.position, l = t.gpuAcceleration, u = t.adaptive, c = t.roundOffsets, d = t.isFixed, h = o.x, v = h === void 0 ? 0 : h, m = o.y, b = m === void 0 ? 0 : m, p = typeof c == "function" ? c({ x: v, y: b }) : { x: v, y: b };
  v = p.x, b = p.y;
  var f = o.hasOwnProperty("x"), g = o.hasOwnProperty("y"), y = Un, w = Hn, _ = window;
  if (u) {
    var S = la(n), A = "clientHeight", C = "clientWidth";
    if (S === xr(n) && (S = Ti(n), ii(S).position !== "static" && a === "absolute" && (A = "scrollHeight", C = "scrollWidth")), S = S, i === Hn || (i === Un || i === or) && s === Lo) {
      w = sr;
      var k = d && S === _ && _.visualViewport ? _.visualViewport.height : S[A];
      b -= k - r.height, b *= l ? 1 : -1;
    }
    if (i === Un || (i === Hn || i === sr) && s === Lo) {
      y = or;
      var O = d && S === _ && _.visualViewport ? _.visualViewport.width : S[C];
      v -= O - r.width, v *= l ? 1 : -1;
    }
  }
  var N = Object.assign({ position: a }, u && PT), B = c === !0 ? DT({ x: v, y: b }) : { x: v, y: b };
  if (v = B.x, b = B.y, l) {
    var D;
    return Object.assign({}, N, (D = {}, D[w] = g ? "0" : "", D[y] = f ? "0" : "", D.transform = (_.devicePixelRatio || 1) <= 1 ? "translate(" + v + "px, " + b + "px)" : "translate3d(" + v + "px, " + b + "px, 0)", D));
  }
  return Object.assign({}, N, (e = {}, e[w] = g ? b + "px" : "", e[y] = f ? v + "px" : "", e.transform = "", e));
}
function BT(t) {
  var e = t.state, n = t.options, r = n.gpuAcceleration, i = r === void 0 ? !0 : r, s = n.adaptive, o = s === void 0 ? !0 : s, a = n.roundOffsets, l = a === void 0 ? !0 : a, u = { placement: Ir(e.placement), variation: Hs(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: i, isFixed: e.options.strategy === "fixed" };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, qh(Object.assign({}, u, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: o, roundOffsets: l })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, qh(Object.assign({}, u, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: l })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement });
}
var rm = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: BT, data: {} }, Aa = { passive: !0 };
function MT(t) {
  var e = t.state, n = t.instance, r = t.options, i = r.scroll, s = i === void 0 ? !0 : i, o = r.resize, a = o === void 0 ? !0 : o, l = xr(e.elements.popper), u = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return s && u.forEach(function(c) {
    c.addEventListener("scroll", n.update, Aa);
  }), a && l.addEventListener("resize", n.update, Aa), function() {
    s && u.forEach(function(c) {
      c.removeEventListener("scroll", n.update, Aa);
    }), a && l.removeEventListener("resize", n.update, Aa);
  };
}
var im = { name: "eventListeners", enabled: !0, phase: "write", fn: function() {
}, effect: MT, data: {} }, LT = { left: "right", right: "left", bottom: "top", top: "bottom" };
function Ja(t) {
  return t.replace(/left|right|bottom|top/g, function(e) {
    return LT[e];
  });
}
var zT = { start: "end", end: "start" };
function Jh(t) {
  return t.replace(/start|end/g, function(e) {
    return zT[e];
  });
}
function nf(t) {
  var e = xr(t), n = e.pageXOffset, r = e.pageYOffset;
  return { scrollLeft: n, scrollTop: r };
}
function rf(t) {
  return Fs(Ti(t)).left + nf(t).scrollLeft;
}
function jT(t) {
  var e = xr(t), n = Ti(t), r = e.visualViewport, i = n.clientWidth, s = n.clientHeight, o = 0, a = 0;
  return r && (i = r.width, s = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (o = r.offsetLeft, a = r.offsetTop)), { width: i, height: s, x: o + rf(t), y: a };
}
function FT(t) {
  var e, n = Ti(t), r = nf(t), i = (e = t.ownerDocument) == null ? void 0 : e.body, s = Hi(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), o = Hi(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), a = -r.scrollLeft + rf(t), l = -r.scrollTop;
  return ii(i || n).direction === "rtl" && (a += Hi(n.clientWidth, i ? i.clientWidth : 0) - s), { width: s, height: o, x: a, y: l };
}
function sf(t) {
  var e = ii(t), n = e.overflow, r = e.overflowX, i = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + i + r);
}
function sm(t) {
  return ["html", "body", "#document"].indexOf(Lr(t)) >= 0 ? t.ownerDocument.body : rr(t) && sf(t) ? t : sm(au(t));
}
function wo(t, e) {
  var n;
  e === void 0 && (e = []);
  var r = sm(t), i = r === ((n = t.ownerDocument) == null ? void 0 : n.body), s = xr(r), o = i ? [s].concat(s.visualViewport || [], sf(r) ? r : []) : r, a = e.concat(o);
  return i ? a : a.concat(wo(au(o)));
}
function _c(t) {
  return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height });
}
function HT(t) {
  var e = Fs(t);
  return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e;
}
function Yh(t, e) {
  return e === Qg ? _c(jT(t)) : zs(e) ? HT(e) : _c(FT(Ti(t)));
}
function UT(t) {
  var e = wo(au(t)), n = ["absolute", "fixed"].indexOf(ii(t).position) >= 0, r = n && rr(t) ? la(t) : t;
  return zs(r) ? e.filter(function(i) {
    return zs(i) && Xg(i, r) && Lr(i) !== "body";
  }) : [];
}
function VT(t, e, n) {
  var r = e === "clippingParents" ? UT(t) : [].concat(e), i = [].concat(r, [n]), s = i[0], o = i.reduce(function(a, l) {
    var u = Yh(t, l);
    return a.top = Hi(u.top, a.top), a.right = xl(u.right, a.right), a.bottom = xl(u.bottom, a.bottom), a.left = Hi(u.left, a.left), a;
  }, Yh(t, s));
  return o.width = o.right - o.left, o.height = o.bottom - o.top, o.x = o.left, o.y = o.top, o;
}
function om(t) {
  var e = t.reference, n = t.element, r = t.placement, i = r ? Ir(r) : null, s = r ? Hs(r) : null, o = e.x + e.width / 2 - n.width / 2, a = e.y + e.height / 2 - n.height / 2, l;
  switch (i) {
    case Hn:
      l = { x: o, y: e.y - n.height };
      break;
    case sr:
      l = { x: o, y: e.y + e.height };
      break;
    case or:
      l = { x: e.x + e.width, y: a };
      break;
    case Un:
      l = { x: e.x - n.width, y: a };
      break;
    default:
      l = { x: e.x, y: e.y };
  }
  var u = i ? tf(i) : null;
  if (u != null) {
    var c = u === "y" ? "height" : "width";
    switch (s) {
      case Ls:
        l[u] = l[u] - (e[c] / 2 - n[c] / 2);
        break;
      case Lo:
        l[u] = l[u] + (e[c] / 2 - n[c] / 2);
        break;
    }
  }
  return l;
}
function zo(t, e) {
  e === void 0 && (e = {});
  var n = e, r = n.placement, i = r === void 0 ? t.placement : r, s = n.boundary, o = s === void 0 ? fT : s, a = n.rootBoundary, l = a === void 0 ? Qg : a, u = n.elementContext, c = u === void 0 ? so : u, d = n.altBoundary, h = d === void 0 ? !1 : d, v = n.padding, m = v === void 0 ? 0 : v, b = tm(typeof m != "number" ? m : nm(m, aa)), p = c === so ? hT : so, f = t.rects.popper, g = t.elements[h ? p : c], y = VT(zs(g) ? g : g.contextElement || Ti(t.elements.popper), o, l), w = Fs(t.elements.reference), _ = om({ reference: w, element: f, strategy: "absolute", placement: i }), S = _c(Object.assign({}, f, _)), A = c === so ? S : w, C = { top: y.top - A.top + b.top, bottom: A.bottom - y.bottom + b.bottom, left: y.left - A.left + b.left, right: A.right - y.right + b.right }, k = t.modifiersData.offset;
  if (c === so && k) {
    var O = k[i];
    Object.keys(C).forEach(function(N) {
      var B = [or, sr].indexOf(N) >= 0 ? 1 : -1, D = [Hn, sr].indexOf(N) >= 0 ? "y" : "x";
      C[N] += O[D] * B;
    });
  }
  return C;
}
function WT(t, e) {
  e === void 0 && (e = {});
  var n = e, r = n.placement, i = n.boundary, s = n.rootBoundary, o = n.padding, a = n.flipVariations, l = n.allowedAutoPlacements, u = l === void 0 ? Js : l, c = Hs(r), d = c ? a ? Kh : Kh.filter(function(m) {
    return Hs(m) === c;
  }) : aa, h = d.filter(function(m) {
    return u.indexOf(m) >= 0;
  });
  h.length === 0 && (h = d);
  var v = h.reduce(function(m, b) {
    return m[b] = zo(t, { placement: b, boundary: i, rootBoundary: s, padding: o })[Ir(b)], m;
  }, {});
  return Object.keys(v).sort(function(m, b) {
    return v[m] - v[b];
  });
}
function $T(t) {
  if (Ir(t) === Zd)
    return [];
  var e = Ja(t);
  return [Jh(t), e, Jh(e)];
}
function KT(t) {
  var e = t.state, n = t.options, r = t.name;
  if (!e.modifiersData[r]._skip) {
    for (var i = n.mainAxis, s = i === void 0 ? !0 : i, o = n.altAxis, a = o === void 0 ? !0 : o, l = n.fallbackPlacements, u = n.padding, c = n.boundary, d = n.rootBoundary, h = n.altBoundary, v = n.flipVariations, m = v === void 0 ? !0 : v, b = n.allowedAutoPlacements, p = e.options.placement, f = Ir(p), g = f === p, y = l || (g || !m ? [Ja(p)] : $T(p)), w = [p].concat(y).reduce(function(ue, Te) {
      return ue.concat(Ir(Te) === Zd ? WT(e, { placement: Te, boundary: c, rootBoundary: d, padding: u, flipVariations: m, allowedAutoPlacements: b }) : Te);
    }, []), _ = e.rects.reference, S = e.rects.popper, A = /* @__PURE__ */ new Map(), C = !0, k = w[0], O = 0; O < w.length; O++) {
      var N = w[O], B = Ir(N), D = Hs(N) === Ls, F = [Hn, sr].indexOf(B) >= 0, Z = F ? "width" : "height", te = zo(e, { placement: N, boundary: c, rootBoundary: d, altBoundary: h, padding: u }), L = F ? D ? or : Un : D ? sr : Hn;
      _[Z] > S[Z] && (L = Ja(L));
      var V = Ja(L), H = [];
      if (s && H.push(te[B] <= 0), a && H.push(te[L] <= 0, te[V] <= 0), H.every(function(ue) {
        return ue;
      })) {
        k = N, C = !1;
        break;
      }
      A.set(N, H);
    }
    if (C)
      for (var ie = m ? 3 : 1, ne = function(ue) {
        var Te = w.find(function(_e) {
          var Fe = A.get(_e);
          if (Fe)
            return Fe.slice(0, ue).every(function(Ce) {
              return Ce;
            });
        });
        if (Te)
          return k = Te, "break";
      }, Y = ie; Y > 0; Y--) {
        var de = ne(Y);
        if (de === "break")
          break;
      }
    e.placement !== k && (e.modifiersData[r]._skip = !0, e.placement = k, e.reset = !0);
  }
}
var GT = { name: "flip", enabled: !0, phase: "main", fn: KT, requiresIfExists: ["offset"], data: { _skip: !1 } };
function Qh(t, e, n) {
  return n === void 0 && (n = { x: 0, y: 0 }), { top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x };
}
function Zh(t) {
  return [Hn, or, sr, Un].some(function(e) {
    return t[e] >= 0;
  });
}
function qT(t) {
  var e = t.state, n = t.name, r = e.rects.reference, i = e.rects.popper, s = e.modifiersData.preventOverflow, o = zo(e, { elementContext: "reference" }), a = zo(e, { altBoundary: !0 }), l = Qh(o, r), u = Qh(a, i, s), c = Zh(l), d = Zh(u);
  e.modifiersData[n] = { referenceClippingOffsets: l, popperEscapeOffsets: u, isReferenceHidden: c, hasPopperEscaped: d }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": c, "data-popper-escaped": d });
}
var JT = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: qT };
function YT(t, e, n) {
  var r = Ir(t), i = [Un, Hn].indexOf(r) >= 0 ? -1 : 1, s = typeof n == "function" ? n(Object.assign({}, e, { placement: t })) : n, o = s[0], a = s[1];
  return o = o || 0, a = (a || 0) * i, [Un, or].indexOf(r) >= 0 ? { x: a, y: o } : { x: o, y: a };
}
function QT(t) {
  var e = t.state, n = t.options, r = t.name, i = n.offset, s = i === void 0 ? [0, 0] : i, o = Js.reduce(function(c, d) {
    return c[d] = YT(d, e.rects, s), c;
  }, {}), a = o[e.placement], l = a.x, u = a.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += u), e.modifiersData[r] = o;
}
var ZT = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: QT };
function XT(t) {
  var e = t.state, n = t.name;
  e.modifiersData[n] = om({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement });
}
var am = { name: "popperOffsets", enabled: !0, phase: "read", fn: XT, data: {} };
function eO(t) {
  return t === "x" ? "y" : "x";
}
function tO(t) {
  var e = t.state, n = t.options, r = t.name, i = n.mainAxis, s = i === void 0 ? !0 : i, o = n.altAxis, a = o === void 0 ? !1 : o, l = n.boundary, u = n.rootBoundary, c = n.altBoundary, d = n.padding, h = n.tether, v = h === void 0 ? !0 : h, m = n.tetherOffset, b = m === void 0 ? 0 : m, p = zo(e, { boundary: l, rootBoundary: u, padding: d, altBoundary: c }), f = Ir(e.placement), g = Hs(e.placement), y = !g, w = tf(f), _ = eO(w), S = e.modifiersData.popperOffsets, A = e.rects.reference, C = e.rects.popper, k = typeof b == "function" ? b(Object.assign({}, e.rects, { placement: e.placement })) : b, O = typeof k == "number" ? { mainAxis: k, altAxis: k } : Object.assign({ mainAxis: 0, altAxis: 0 }, k), N = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, B = { x: 0, y: 0 };
  if (S) {
    if (s) {
      var D, F = w === "y" ? Hn : Un, Z = w === "y" ? sr : or, te = w === "y" ? "height" : "width", L = S[w], V = L + p[F], H = L - p[Z], ie = v ? -C[te] / 2 : 0, ne = g === Ls ? A[te] : C[te], Y = g === Ls ? -C[te] : -A[te], de = e.elements.arrow, ue = v && de ? ef(de) : { width: 0, height: 0 }, Te = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : em(), _e = Te[F], Fe = Te[Z], Ce = bo(0, A[te], ue[te]), tt = y ? A[te] / 2 - ie - Ce - _e - O.mainAxis : ne - Ce - _e - O.mainAxis, je = y ? -A[te] / 2 + ie + Ce + Fe + O.mainAxis : Y + Ce + Fe + O.mainAxis, $e = e.elements.arrow && la(e.elements.arrow), ht = $e ? w === "y" ? $e.clientTop || 0 : $e.clientLeft || 0 : 0, nt = (D = N == null ? void 0 : N[w]) != null ? D : 0, Et = L + tt - nt - ht, yt = L + je - nt, Nt = bo(v ? xl(V, Et) : V, L, v ? Hi(H, yt) : H);
      S[w] = Nt, B[w] = Nt - L;
    }
    if (a) {
      var ot, bt = w === "x" ? Hn : Un, Kt = w === "x" ? sr : or, wt = S[_], xt = _ === "y" ? "height" : "width", lt = wt + p[bt], qe = wt - p[Kt], Rt = [Hn, Un].indexOf(f) !== -1, be = (ot = N == null ? void 0 : N[_]) != null ? ot : 0, Ue = Rt ? lt : wt - A[xt] - C[xt] - be + O.altAxis, at = Rt ? wt + A[xt] + C[xt] - be - O.altAxis : qe, Pt = v && Rt ? TT(Ue, wt, at) : bo(v ? Ue : lt, wt, v ? at : qe);
      S[_] = Pt, B[_] = Pt - wt;
    }
    e.modifiersData[r] = B;
  }
}
var nO = { name: "preventOverflow", enabled: !0, phase: "main", fn: tO, requiresIfExists: ["offset"] };
function rO(t) {
  return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop };
}
function iO(t) {
  return t === xr(t) || !rr(t) ? nf(t) : rO(t);
}
function sO(t) {
  var e = t.getBoundingClientRect(), n = js(e.width) / t.offsetWidth || 1, r = js(e.height) / t.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function oO(t, e, n) {
  n === void 0 && (n = !1);
  var r = rr(e), i = rr(e) && sO(e), s = Ti(e), o = Fs(t, i), a = { scrollLeft: 0, scrollTop: 0 }, l = { x: 0, y: 0 };
  return (r || !r && !n) && ((Lr(e) !== "body" || sf(s)) && (a = iO(e)), rr(e) ? (l = Fs(e, !0), l.x += e.clientLeft, l.y += e.clientTop) : s && (l.x = rf(s))), { x: o.left + a.scrollLeft - l.x, y: o.top + a.scrollTop - l.y, width: o.width, height: o.height };
}
function aO(t) {
  var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
  t.forEach(function(s) {
    e.set(s.name, s);
  });
  function i(s) {
    n.add(s.name);
    var o = [].concat(s.requires || [], s.requiresIfExists || []);
    o.forEach(function(a) {
      if (!n.has(a)) {
        var l = e.get(a);
        l && i(l);
      }
    }), r.push(s);
  }
  return t.forEach(function(s) {
    n.has(s.name) || i(s);
  }), r;
}
function lO(t) {
  var e = aO(t);
  return ET.reduce(function(n, r) {
    return n.concat(e.filter(function(i) {
      return i.phase === r;
    }));
  }, []);
}
function uO(t) {
  var e;
  return function() {
    return e || (e = new Promise(function(n) {
      Promise.resolve().then(function() {
        e = void 0, n(t());
      });
    })), e;
  };
}
function cO(t) {
  var e = t.reduce(function(n, r) {
    var i = n[r.name];
    return n[r.name] = i ? Object.assign({}, i, r, { options: Object.assign({}, i.options, r.options), data: Object.assign({}, i.data, r.data) }) : r, n;
  }, {});
  return Object.keys(e).map(function(n) {
    return e[n];
  });
}
var Xh = { placement: "bottom", modifiers: [], strategy: "absolute" };
function ep() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return !e.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function of(t) {
  t === void 0 && (t = {});
  var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, i = e.defaultOptions, s = i === void 0 ? Xh : i;
  return function(o, a, l) {
    l === void 0 && (l = s);
    var u = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Xh, s), modifiersData: {}, elements: { reference: o, popper: a }, attributes: {}, styles: {} }, c = [], d = !1, h = { state: u, setOptions: function(b) {
      var p = typeof b == "function" ? b(u.options) : b;
      m(), u.options = Object.assign({}, s, u.options, p), u.scrollParents = { reference: zs(o) ? wo(o) : o.contextElement ? wo(o.contextElement) : [], popper: wo(a) };
      var f = lO(cO([].concat(r, u.options.modifiers)));
      return u.orderedModifiers = f.filter(function(g) {
        return g.enabled;
      }), v(), h.update();
    }, forceUpdate: function() {
      if (!d) {
        var b = u.elements, p = b.reference, f = b.popper;
        if (ep(p, f)) {
          u.rects = { reference: oO(p, la(f), u.options.strategy === "fixed"), popper: ef(f) }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function(C) {
            return u.modifiersData[C.name] = Object.assign({}, C.data);
          });
          for (var g = 0; g < u.orderedModifiers.length; g++) {
            if (u.reset === !0) {
              u.reset = !1, g = -1;
              continue;
            }
            var y = u.orderedModifiers[g], w = y.fn, _ = y.options, S = _ === void 0 ? {} : _, A = y.name;
            typeof w == "function" && (u = w({ state: u, options: S, name: A, instance: h }) || u);
          }
        }
      }
    }, update: uO(function() {
      return new Promise(function(b) {
        h.forceUpdate(), b(u);
      });
    }), destroy: function() {
      m(), d = !0;
    } };
    if (!ep(o, a))
      return h;
    h.setOptions(l).then(function(b) {
      !d && l.onFirstUpdate && l.onFirstUpdate(b);
    });
    function v() {
      u.orderedModifiers.forEach(function(b) {
        var p = b.name, f = b.options, g = f === void 0 ? {} : f, y = b.effect;
        if (typeof y == "function") {
          var w = y({ state: u, name: p, instance: h, options: g }), _ = function() {
          };
          c.push(w || _);
        }
      });
    }
    function m() {
      c.forEach(function(b) {
        return b();
      }), c = [];
    }
    return h;
  };
}
of();
var dO = [im, am, rm, Zg];
of({ defaultModifiers: dO });
var fO = [im, am, rm, Zg, ZT, GT, nO, RT, JT], lm = of({ defaultModifiers: fO });
const hO = (t, e, n = {}) => {
  const r = {
    name: "updateState",
    enabled: !0,
    phase: "write",
    fn: ({ state: l }) => {
      const u = pO(l);
      Object.assign(o.value, u);
    },
    requires: ["computeStyles"]
  }, i = j(() => {
    const { onFirstUpdate: l, placement: u, strategy: c, modifiers: d } = x(n);
    return {
      onFirstUpdate: l,
      placement: u || "bottom",
      strategy: c || "absolute",
      modifiers: [
        ...d || [],
        r,
        { name: "applyStyles", enabled: !1 }
      ]
    };
  }), s = Fn(), o = K({
    styles: {
      popper: {
        position: x(i).strategy,
        left: "0",
        top: "0"
      },
      arrow: {
        position: "absolute"
      }
    },
    attributes: {}
  }), a = () => {
    s.value && (s.value.destroy(), s.value = void 0);
  };
  return Ae(i, (l) => {
    const u = x(s);
    u && u.setOptions(l);
  }, {
    deep: !0
  }), Ae([t, e], ([l, u]) => {
    a(), !(!l || !u) && (s.value = lm(l, u, x(i)));
  }), xn(() => {
    a();
  }), {
    state: j(() => {
      var l;
      return { ...((l = x(s)) == null ? void 0 : l.state) || {} };
    }),
    styles: j(() => x(o).styles),
    attributes: j(() => x(o).attributes),
    update: () => {
      var l;
      return (l = x(s)) == null ? void 0 : l.update();
    },
    forceUpdate: () => {
      var l;
      return (l = x(s)) == null ? void 0 : l.forceUpdate();
    },
    instanceRef: j(() => x(s))
  };
};
function pO(t) {
  const e = Object.keys(t.elements), n = _l(e.map((i) => [i, t.styles[i] || {}])), r = _l(e.map((i) => [i, t.attributes[i]]));
  return {
    styles: n,
    attributes: r
  };
}
function tp() {
  let t;
  const e = (r, i) => {
    n(), t = window.setTimeout(r, i);
  }, n = () => window.clearTimeout(t);
  return Od(() => n()), {
    registerTimeout: e,
    cancelTimeout: n
  };
}
const Sc = {
  prefix: Math.floor(Math.random() * 1e4),
  current: 0
}, vO = Symbol("elIdInjection"), um = () => ft() ? et(vO, Sc) : Sc, ua = (t) => {
  const e = um();
  !St && e === Sc && Vt("IdInjection", `Looks like you are using server rendering, you must provide a id provider to ensure the hydration process to be succeed
usage: app.provide(ID_INJECTION_KEY, {
  prefix: number,
  current: number,
})`);
  const n = Qd();
  return j(() => x(t) || `${n.value}-id-${e.prefix}-${e.current++}`);
};
let _s = [];
const np = (t) => {
  const e = t;
  e.key === sn.esc && _s.forEach((n) => n(e));
}, gO = (t) => {
  Ct(() => {
    _s.length === 0 && document.addEventListener("keydown", np), St && _s.push(t);
  }), xn(() => {
    _s = _s.filter((e) => e !== t), _s.length === 0 && St && document.removeEventListener("keydown", np);
  });
};
let rp;
const cm = () => {
  const t = Qd(), e = um(), n = j(() => `${t.value}-popper-container-${e.prefix}`), r = j(() => `#${n.value}`);
  return {
    id: n,
    selector: r
  };
}, mO = (t) => {
  const e = document.createElement("div");
  return e.id = t, document.body.appendChild(e), e;
}, yO = () => {
  const { id: t, selector: e } = cm();
  return xd(() => {
    St && (process.env.NODE_ENV === "test" || !rp && !document.body.querySelector(e.value)) && (rp = mO(t.value));
  }), {
    id: t,
    selector: e
  };
}, bO = ut({
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  autoClose: {
    type: Number,
    default: 0
  }
}), dm = ({
  showAfter: t,
  hideAfter: e,
  autoClose: n,
  open: r,
  close: i
}) => {
  const { registerTimeout: s } = tp(), {
    registerTimeout: o,
    cancelTimeout: a
  } = tp();
  return {
    onOpen: (c) => {
      s(() => {
        r(c);
        const d = x(n);
        mt(d) && d > 0 && o(() => {
          i(c);
        }, d);
      }, x(t));
    },
    onClose: (c) => {
      a(), s(() => {
        i(c);
      }, x(e));
    }
  };
}, fm = Symbol("elForwardRef"), wO = (t) => {
  qt(fm, {
    setForwardRef: (n) => {
      t.value = n;
    }
  });
}, _O = (t) => ({
  mounted(e) {
    t(e);
  },
  updated(e) {
    t(e);
  },
  unmounted() {
    t(null);
  }
}), ip = K(0), hm = 2e3, pm = Symbol("zIndexContextKey"), lu = (t) => {
  const e = t || (ft() ? et(pm, void 0) : void 0), n = j(() => {
    const s = x(e);
    return mt(s) ? s : hm;
  }), r = j(() => n.value + ip.value);
  return {
    initialZIndex: n,
    currentZIndex: r,
    nextZIndex: () => (ip.value++, r.value)
  };
};
function SO(t) {
  const e = K();
  function n() {
    if (t.value == null)
      return;
    const { selectionStart: i, selectionEnd: s, value: o } = t.value;
    if (i == null || s == null)
      return;
    const a = o.slice(0, Math.max(0, i)), l = o.slice(Math.max(0, s));
    e.value = {
      selectionStart: i,
      selectionEnd: s,
      value: o,
      beforeTxt: a,
      afterTxt: l
    };
  }
  function r() {
    if (t.value == null || e.value == null)
      return;
    const { value: i } = t.value, { beforeTxt: s, afterTxt: o, selectionStart: a } = e.value;
    if (s == null || o == null || a == null)
      return;
    let l = i.length;
    if (i.endsWith(o))
      l = i.length - o.length;
    else if (i.startsWith(s))
      l = s.length;
    else {
      const u = s[a - 1], c = i.indexOf(u, a - 1);
      c !== -1 && (l = c + 1);
    }
    t.value.setSelectionRange(l, l);
  }
  return [n, r];
}
const zr = ou({
  type: String,
  values: Yd,
  required: !1
}), vm = Symbol("size"), EO = () => {
  const t = et(vm, {});
  return j(() => x(t.size) || "");
};
function xO(t, { afterFocus: e, beforeBlur: n, afterBlur: r } = {}) {
  const i = ft(), { emit: s } = i, o = Fn(), a = K(!1), l = (d) => {
    a.value || (a.value = !0, s("focus", d), e == null || e());
  }, u = (d) => {
    var h;
    mn(n) && n(d) || d.relatedTarget && ((h = o.value) != null && h.contains(d.relatedTarget)) || (a.value = !1, s("blur", d), r == null || r());
  }, c = () => {
    var d;
    (d = t.value) == null || d.focus();
  };
  return Ae(o, (d) => {
    d && d.setAttribute("tabindex", "-1");
  }), wn(o, "click", c), {
    wrapperRef: o,
    isFocused: a,
    handleFocus: l,
    handleBlur: u
  };
}
const gm = Symbol(), Al = K();
function af(t, e = void 0) {
  const n = ft() ? et(gm, Al) : Al;
  return t ? j(() => {
    var r, i;
    return (i = (r = n.value) == null ? void 0 : r[t]) != null ? i : e;
  }) : n;
}
function AO(t, e) {
  const n = af(), r = ze(t, j(() => {
    var a;
    return ((a = n.value) == null ? void 0 : a.namespace) || qa;
  })), i = lr(j(() => {
    var a;
    return (a = n.value) == null ? void 0 : a.locale;
  })), s = lu(j(() => {
    var a;
    return ((a = n.value) == null ? void 0 : a.zIndex) || hm;
  })), o = j(() => {
    var a;
    return x(e) || ((a = n.value) == null ? void 0 : a.size) || "";
  });
  return kO(j(() => x(n) || {})), {
    ns: r,
    locale: i,
    zIndex: s,
    size: o
  };
}
const kO = (t, e, n = !1) => {
  var r;
  const i = !!ft(), s = i ? af() : void 0, o = (r = e == null ? void 0 : e.provide) != null ? r : i ? qt : void 0;
  if (!o) {
    Vt("provideGlobalConfig", "provideGlobalConfig() can only be used inside setup().");
    return;
  }
  const a = j(() => {
    const l = x(t);
    return s != null && s.value ? CO(s.value, l) : l;
  });
  return o(gm, a), o(Gg, j(() => a.value.locale)), o(qg, j(() => a.value.namespace)), o(pm, j(() => a.value.zIndex)), o(vm, {
    size: j(() => a.value.size || "")
  }), (n || !Al.value) && (Al.value = a.value), a;
}, CO = (t, e) => {
  var n;
  const r = [.../* @__PURE__ */ new Set([...wc(t), ...wc(e)])], i = {};
  for (const s of r)
    i[s] = (n = e[s]) != null ? n : t[s];
  return i;
};
var Ge = (t, e) => {
  const n = t.__vccOpts || t;
  for (const [r, i] of e)
    n[r] = i;
  return n;
};
const TO = ut({
  size: {
    type: De([Number, String])
  },
  color: {
    type: String
  }
}), OO = ye({
  name: "ElIcon",
  inheritAttrs: !1
}), IO = /* @__PURE__ */ ye({
  ...OO,
  props: TO,
  setup(t) {
    const e = t, n = ze("icon"), r = j(() => {
      const { size: i, color: s } = e;
      return !i && !s ? {} : {
        fontSize: Cr(i) ? void 0 : El(i),
        "--color": s
      };
    });
    return (i, s) => (U(), oe("i", Jn({
      class: x(n).b(),
      style: x(r)
    }, i.$attrs), [
      Me(i.$slots, "default")
    ], 16));
  }
});
var NO = /* @__PURE__ */ Ge(IO, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/icon/src/icon.vue"]]);
const _t = nn(NO), lf = Symbol("formContextKey"), jo = Symbol("formItemContextKey"), jr = (t, e = {}) => {
  const n = K(void 0), r = e.prop ? n : Yg("size"), i = e.global ? n : EO(), s = e.form ? { size: void 0 } : et(lf, void 0), o = e.formItem ? { size: void 0 } : et(jo, void 0);
  return j(() => r.value || x(t) || (o == null ? void 0 : o.size) || (s == null ? void 0 : s.size) || i.value || "");
}, Fr = (t) => {
  const e = Yg("disabled"), n = et(lf, void 0);
  return j(() => e.value || x(t) || (n == null ? void 0 : n.disabled) || !1);
}, fi = () => {
  const t = et(lf, void 0), e = et(jo, void 0);
  return {
    form: t,
    formItem: e
  };
}, ca = (t, {
  formItemContext: e,
  disableIdGeneration: n,
  disableIdManagement: r
}) => {
  n || (n = K(!1)), r || (r = K(!1));
  const i = K();
  let s;
  const o = j(() => {
    var a;
    return !!(!t.label && e && e.inputIds && ((a = e.inputIds) == null ? void 0 : a.length) <= 1);
  });
  return Ct(() => {
    s = Ae([On(t, "id"), n], ([a, l]) => {
      const u = a ?? (l ? void 0 : ua().value);
      u !== i.value && (e != null && e.removeInputId && (i.value && e.removeInputId(i.value), !(r != null && r.value) && !l && u && e.addInputId(u)), i.value = u);
    }, { immediate: !0 });
  }), ea(() => {
    s && s(), e != null && e.removeInputId && i.value && e.removeInputId(i.value);
  }), {
    isLabeledByFormItem: o,
    inputId: i
  };
};
let cr;
const RO = `
  height:0 !important;
  visibility:hidden !important;
  ${xw() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`, PO = [
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "font-family",
  "font-weight",
  "font-size",
  "text-rendering",
  "text-transform",
  "width",
  "text-indent",
  "padding-left",
  "padding-right",
  "border-width",
  "box-sizing"
];
function DO(t) {
  const e = window.getComputedStyle(t), n = e.getPropertyValue("box-sizing"), r = Number.parseFloat(e.getPropertyValue("padding-bottom")) + Number.parseFloat(e.getPropertyValue("padding-top")), i = Number.parseFloat(e.getPropertyValue("border-bottom-width")) + Number.parseFloat(e.getPropertyValue("border-top-width"));
  return { contextStyle: PO.map((o) => `${o}:${e.getPropertyValue(o)}`).join(";"), paddingSize: r, borderSize: i, boxSizing: n };
}
function sp(t, e = 1, n) {
  var r;
  cr || (cr = document.createElement("textarea"), document.body.appendChild(cr));
  const { paddingSize: i, borderSize: s, boxSizing: o, contextStyle: a } = DO(t);
  cr.setAttribute("style", `${a};${RO}`), cr.value = t.value || t.placeholder || "";
  let l = cr.scrollHeight;
  const u = {};
  o === "border-box" ? l = l + s : o === "content-box" && (l = l - i), cr.value = "";
  const c = cr.scrollHeight - i;
  if (mt(e)) {
    let d = c * e;
    o === "border-box" && (d = d + i + s), l = Math.max(d, l), u.minHeight = `${d}px`;
  }
  if (mt(n)) {
    let d = c * n;
    o === "border-box" && (d = d + i + s), l = Math.min(d, l);
  }
  return u.height = `${l}px`, (r = cr.parentNode) == null || r.removeChild(cr), cr = void 0, u;
}
const BO = ut({
  id: {
    type: String,
    default: void 0
  },
  size: zr,
  disabled: Boolean,
  modelValue: {
    type: De([
      String,
      Number,
      Object
    ]),
    default: ""
  },
  type: {
    type: String,
    default: "text"
  },
  resize: {
    type: String,
    values: ["none", "both", "horizontal", "vertical"]
  },
  autosize: {
    type: De([Boolean, Object]),
    default: !1
  },
  autocomplete: {
    type: String,
    default: "off"
  },
  formatter: {
    type: Function
  },
  parser: {
    type: Function
  },
  placeholder: {
    type: String
  },
  form: {
    type: String
  },
  readonly: {
    type: Boolean,
    default: !1
  },
  clearable: {
    type: Boolean,
    default: !1
  },
  showPassword: {
    type: Boolean,
    default: !1
  },
  showWordLimit: {
    type: Boolean,
    default: !1
  },
  suffixIcon: {
    type: xi
  },
  prefixIcon: {
    type: xi
  },
  containerRole: {
    type: String,
    default: void 0
  },
  label: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  inputStyle: {
    type: De([Object, Array, String]),
    default: () => Ms({})
  },
  autofocus: {
    type: Boolean,
    default: !1
  }
}), MO = {
  [Dt]: (t) => Gt(t),
  input: (t) => Gt(t),
  change: (t) => Gt(t),
  focus: (t) => t instanceof FocusEvent,
  blur: (t) => t instanceof FocusEvent,
  clear: () => !0,
  mouseleave: (t) => t instanceof MouseEvent,
  mouseenter: (t) => t instanceof MouseEvent,
  keydown: (t) => t instanceof Event,
  compositionstart: (t) => t instanceof CompositionEvent,
  compositionupdate: (t) => t instanceof CompositionEvent,
  compositionend: (t) => t instanceof CompositionEvent
}, LO = ["role"], zO = ["id", "type", "disabled", "formatter", "parser", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus"], jO = ["id", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus"], FO = ye({
  name: "ElInput",
  inheritAttrs: !1
}), HO = /* @__PURE__ */ ye({
  ...FO,
  props: BO,
  emits: MO,
  setup(t, { expose: e, emit: n }) {
    const r = t, i = Rv(), s = ta(), o = j(() => {
      const be = {};
      return r.containerRole === "combobox" && (be["aria-haspopup"] = i["aria-haspopup"], be["aria-owns"] = i["aria-owns"], be["aria-expanded"] = i["aria-expanded"]), be;
    }), a = j(() => [
      r.type === "textarea" ? p.b() : b.b(),
      b.m(v.value),
      b.is("disabled", m.value),
      b.is("exceed", ue.value),
      {
        [b.b("group")]: s.prepend || s.append,
        [b.bm("group", "append")]: s.append,
        [b.bm("group", "prepend")]: s.prepend,
        [b.m("prefix")]: s.prefix || r.prefixIcon,
        [b.m("suffix")]: s.suffix || r.suffixIcon || r.clearable || r.showPassword,
        [b.bm("suffix", "password-clear")]: ie.value && ne.value
      },
      i.class
    ]), l = j(() => [
      b.e("wrapper"),
      b.is("focus", O.value)
    ]), u = $g({
      excludeKeys: j(() => Object.keys(o.value))
    }), { form: c, formItem: d } = fi(), { inputId: h } = ca(r, {
      formItemContext: d
    }), v = jr(), m = Fr(), b = ze("input"), p = ze("textarea"), f = Fn(), g = Fn(), y = K(!1), w = K(!1), _ = K(!1), S = K(), A = Fn(r.inputStyle), C = j(() => f.value || g.value), { wrapperRef: k, isFocused: O, handleFocus: N, handleBlur: B } = xO(C, {
      afterBlur() {
        var be;
        r.validateEvent && ((be = d == null ? void 0 : d.validate) == null || be.call(d, "blur").catch((Ue) => Vt(Ue)));
      }
    }), D = j(() => {
      var be;
      return (be = c == null ? void 0 : c.statusIcon) != null ? be : !1;
    }), F = j(() => (d == null ? void 0 : d.validateState) || ""), Z = j(() => F.value && Vg[F.value]), te = j(() => _.value ? P2 : _C), L = j(() => [
      i.style,
      r.inputStyle
    ]), V = j(() => [
      r.inputStyle,
      A.value,
      { resize: r.resize }
    ]), H = j(() => nr(r.modelValue) ? "" : String(r.modelValue)), ie = j(() => r.clearable && !m.value && !r.readonly && !!H.value && (O.value || y.value)), ne = j(() => r.showPassword && !m.value && !r.readonly && !!H.value && (!!H.value || O.value)), Y = j(() => r.showWordLimit && !!u.value.maxlength && (r.type === "text" || r.type === "textarea") && !m.value && !r.readonly && !r.showPassword), de = j(() => H.value.length), ue = j(() => !!Y.value && de.value > Number(u.value.maxlength)), Te = j(() => !!s.suffix || !!r.suffixIcon || ie.value || r.showPassword || Y.value || !!F.value && D.value), [_e, Fe] = SO(f);
    Ds(g, (be) => {
      if (je(), !Y.value || r.resize !== "both")
        return;
      const Ue = be[0], { width: at } = Ue.contentRect;
      S.value = {
        right: `calc(100% - ${at + 15 + 6}px)`
      };
    });
    const Ce = () => {
      const { type: be, autosize: Ue } = r;
      if (!(!St || be !== "textarea" || !g.value))
        if (Ue) {
          const at = _n(Ue) ? Ue.minRows : void 0, Pt = _n(Ue) ? Ue.maxRows : void 0, Qt = sp(g.value, at, Pt);
          A.value = {
            overflowY: "hidden",
            ...Qt
          }, rt(() => {
            g.value.offsetHeight, A.value = Qt;
          });
        } else
          A.value = {
            minHeight: sp(g.value).minHeight
          };
    }, je = ((be) => {
      let Ue = !1;
      return () => {
        var at;
        if (Ue || !r.autosize)
          return;
        ((at = g.value) == null ? void 0 : at.offsetParent) === null || (be(), Ue = !0);
      };
    })(Ce), $e = () => {
      const be = C.value, Ue = r.formatter ? r.formatter(H.value) : H.value;
      !be || be.value === Ue || (be.value = Ue);
    }, ht = async (be) => {
      _e();
      let { value: Ue } = be.target;
      if (r.formatter && (Ue = r.parser ? r.parser(Ue) : Ue), !w.value) {
        if (Ue === H.value) {
          $e();
          return;
        }
        n(Dt, Ue), n("input", Ue), await rt(), $e(), Fe();
      }
    }, nt = (be) => {
      n("change", be.target.value);
    }, Et = (be) => {
      n("compositionstart", be), w.value = !0;
    }, yt = (be) => {
      var Ue;
      n("compositionupdate", be);
      const at = (Ue = be.target) == null ? void 0 : Ue.value, Pt = at[at.length - 1] || "";
      w.value = !Wg(Pt);
    }, Nt = (be) => {
      n("compositionend", be), w.value && (w.value = !1, ht(be));
    }, ot = () => {
      _.value = !_.value, bt();
    }, bt = async () => {
      var be;
      await rt(), (be = C.value) == null || be.focus();
    }, Kt = () => {
      var be;
      return (be = C.value) == null ? void 0 : be.blur();
    }, wt = (be) => {
      y.value = !1, n("mouseleave", be);
    }, xt = (be) => {
      y.value = !0, n("mouseenter", be);
    }, lt = (be) => {
      n("keydown", be);
    }, qe = () => {
      var be;
      (be = C.value) == null || be.select();
    }, Rt = () => {
      n(Dt, ""), n("change", ""), n("clear"), n("input", "");
    };
    return Ae(() => r.modelValue, () => {
      var be;
      rt(() => Ce()), r.validateEvent && ((be = d == null ? void 0 : d.validate) == null || be.call(d, "change").catch((Ue) => Vt(Ue)));
    }), Ae(H, () => $e()), Ae(() => r.type, async () => {
      await rt(), $e(), Ce();
    }), Ct(() => {
      !r.formatter && r.parser && Vt("ElInput", "If you set the parser, you also need to set the formatter."), $e(), rt(Ce);
    }), e({
      input: f,
      textarea: g,
      ref: C,
      textareaStyle: V,
      autosize: On(r, "autosize"),
      focus: bt,
      blur: Kt,
      select: qe,
      clear: Rt,
      resizeTextarea: Ce
    }), (be, Ue) => Bt((U(), oe("div", Jn(x(o), {
      class: x(a),
      style: x(L),
      role: be.containerRole,
      onMouseenter: xt,
      onMouseleave: wt
    }), [
      me(" input "),
      be.type !== "textarea" ? (U(), oe(Ft, { key: 0 }, [
        me(" prepend slot "),
        be.$slots.prepend ? (U(), oe("div", {
          key: 0,
          class: X(x(b).be("group", "prepend"))
        }, [
          Me(be.$slots, "prepend")
        ], 2)) : me("v-if", !0),
        le("div", {
          ref_key: "wrapperRef",
          ref: k,
          class: X(x(l))
        }, [
          me(" prefix slot "),
          be.$slots.prefix || be.prefixIcon ? (U(), oe("span", {
            key: 0,
            class: X(x(b).e("prefix"))
          }, [
            le("span", {
              class: X(x(b).e("prefix-inner"))
            }, [
              Me(be.$slots, "prefix"),
              be.prefixIcon ? (U(), xe(x(_t), {
                key: 0,
                class: X(x(b).e("icon"))
              }, {
                default: fe(() => [
                  (U(), xe(Pn(be.prefixIcon)))
                ]),
                _: 1
              }, 8, ["class"])) : me("v-if", !0)
            ], 2)
          ], 2)) : me("v-if", !0),
          le("input", Jn({
            id: x(h),
            ref_key: "input",
            ref: f,
            class: x(b).e("inner")
          }, x(u), {
            type: be.showPassword ? _.value ? "text" : "password" : be.type,
            disabled: x(m),
            formatter: be.formatter,
            parser: be.parser,
            readonly: be.readonly,
            autocomplete: be.autocomplete,
            tabindex: be.tabindex,
            "aria-label": be.label,
            placeholder: be.placeholder,
            style: be.inputStyle,
            form: r.form,
            autofocus: r.autofocus,
            onCompositionstart: Et,
            onCompositionupdate: yt,
            onCompositionend: Nt,
            onInput: ht,
            onFocus: Ue[0] || (Ue[0] = (...at) => x(N) && x(N)(...at)),
            onBlur: Ue[1] || (Ue[1] = (...at) => x(B) && x(B)(...at)),
            onChange: nt,
            onKeydown: lt
          }), null, 16, zO),
          me(" suffix slot "),
          x(Te) ? (U(), oe("span", {
            key: 1,
            class: X(x(b).e("suffix"))
          }, [
            le("span", {
              class: X(x(b).e("suffix-inner"))
            }, [
              !x(ie) || !x(ne) || !x(Y) ? (U(), oe(Ft, { key: 0 }, [
                Me(be.$slots, "suffix"),
                be.suffixIcon ? (U(), xe(x(_t), {
                  key: 0,
                  class: X(x(b).e("icon"))
                }, {
                  default: fe(() => [
                    (U(), xe(Pn(be.suffixIcon)))
                  ]),
                  _: 1
                }, 8, ["class"])) : me("v-if", !0)
              ], 64)) : me("v-if", !0),
              x(ie) ? (U(), xe(x(_t), {
                key: 1,
                class: X([x(b).e("icon"), x(b).e("clear")]),
                onMousedown: dt(x(en), ["prevent"]),
                onClick: Rt
              }, {
                default: fe(() => [
                  ve(x(iu))
                ]),
                _: 1
              }, 8, ["class", "onMousedown"])) : me("v-if", !0),
              x(ne) ? (U(), xe(x(_t), {
                key: 2,
                class: X([x(b).e("icon"), x(b).e("password")]),
                onClick: ot
              }, {
                default: fe(() => [
                  (U(), xe(Pn(x(te))))
                ]),
                _: 1
              }, 8, ["class"])) : me("v-if", !0),
              x(Y) ? (U(), oe("span", {
                key: 3,
                class: X(x(b).e("count"))
              }, [
                le("span", {
                  class: X(x(b).e("count-inner"))
                }, st(x(de)) + " / " + st(x(u).maxlength), 3)
              ], 2)) : me("v-if", !0),
              x(F) && x(Z) && x(D) ? (U(), xe(x(_t), {
                key: 4,
                class: X([
                  x(b).e("icon"),
                  x(b).e("validateIcon"),
                  x(b).is("loading", x(F) === "validating")
                ])
              }, {
                default: fe(() => [
                  (U(), xe(Pn(x(Z))))
                ]),
                _: 1
              }, 8, ["class"])) : me("v-if", !0)
            ], 2)
          ], 2)) : me("v-if", !0)
        ], 2),
        me(" append slot "),
        be.$slots.append ? (U(), oe("div", {
          key: 1,
          class: X(x(b).be("group", "append"))
        }, [
          Me(be.$slots, "append")
        ], 2)) : me("v-if", !0)
      ], 64)) : (U(), oe(Ft, { key: 1 }, [
        me(" textarea "),
        le("textarea", Jn({
          id: x(h),
          ref_key: "textarea",
          ref: g,
          class: x(p).e("inner")
        }, x(u), {
          tabindex: be.tabindex,
          disabled: x(m),
          readonly: be.readonly,
          autocomplete: be.autocomplete,
          style: x(V),
          "aria-label": be.label,
          placeholder: be.placeholder,
          form: r.form,
          autofocus: r.autofocus,
          onCompositionstart: Et,
          onCompositionupdate: yt,
          onCompositionend: Nt,
          onInput: ht,
          onFocus: Ue[2] || (Ue[2] = (...at) => x(N) && x(N)(...at)),
          onBlur: Ue[3] || (Ue[3] = (...at) => x(B) && x(B)(...at)),
          onChange: nt,
          onKeydown: lt
        }), null, 16, jO),
        x(Y) ? (U(), oe("span", {
          key: 0,
          style: it(S.value),
          class: X(x(b).e("count"))
        }, st(x(de)) + " / " + st(x(u).maxlength), 7)) : me("v-if", !0)
      ], 64))
    ], 16, LO)), [
      [Qn, be.type !== "hidden"]
    ]);
  }
});
var UO = /* @__PURE__ */ Ge(HO, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input/src/input.vue"]]);
const uu = nn(UO), Cs = 4, VO = {
  vertical: {
    offset: "offsetHeight",
    scroll: "scrollTop",
    scrollSize: "scrollHeight",
    size: "height",
    key: "vertical",
    axis: "Y",
    client: "clientY",
    direction: "top"
  },
  horizontal: {
    offset: "offsetWidth",
    scroll: "scrollLeft",
    scrollSize: "scrollWidth",
    size: "width",
    key: "horizontal",
    axis: "X",
    client: "clientX",
    direction: "left"
  }
}, WO = ({
  move: t,
  size: e,
  bar: n
}) => ({
  [n.size]: e,
  transform: `translate${n.axis}(${t}%)`
}), mm = Symbol("scrollbarContextKey"), $O = ut({
  vertical: Boolean,
  size: String,
  move: Number,
  ratio: {
    type: Number,
    required: !0
  },
  always: Boolean
}), KO = "Thumb", GO = /* @__PURE__ */ ye({
  __name: "thumb",
  props: $O,
  setup(t) {
    const e = t, n = et(mm), r = ze("scrollbar");
    n || ts(KO, "can not inject scrollbar context");
    const i = K(), s = K(), o = K({}), a = K(!1);
    let l = !1, u = !1, c = St ? document.onselectstart : null;
    const d = j(() => VO[e.vertical ? "vertical" : "horizontal"]), h = j(() => WO({
      size: e.size,
      move: e.move,
      bar: d.value
    })), v = j(() => i.value[d.value.offset] ** 2 / n.wrapElement[d.value.scrollSize] / e.ratio / s.value[d.value.offset]), m = (S) => {
      var A;
      if (S.stopPropagation(), S.ctrlKey || [1, 2].includes(S.button))
        return;
      (A = window.getSelection()) == null || A.removeAllRanges(), p(S);
      const C = S.currentTarget;
      C && (o.value[d.value.axis] = C[d.value.offset] - (S[d.value.client] - C.getBoundingClientRect()[d.value.direction]));
    }, b = (S) => {
      if (!s.value || !i.value || !n.wrapElement)
        return;
      const A = Math.abs(S.target.getBoundingClientRect()[d.value.direction] - S[d.value.client]), C = s.value[d.value.offset] / 2, k = (A - C) * 100 * v.value / i.value[d.value.offset];
      n.wrapElement[d.value.scroll] = k * n.wrapElement[d.value.scrollSize] / 100;
    }, p = (S) => {
      S.stopImmediatePropagation(), l = !0, document.addEventListener("mousemove", f), document.addEventListener("mouseup", g), c = document.onselectstart, document.onselectstart = () => !1;
    }, f = (S) => {
      if (!i.value || !s.value || l === !1)
        return;
      const A = o.value[d.value.axis];
      if (!A)
        return;
      const C = (i.value.getBoundingClientRect()[d.value.direction] - S[d.value.client]) * -1, k = s.value[d.value.offset] - A, O = (C - k) * 100 * v.value / i.value[d.value.offset];
      n.wrapElement[d.value.scroll] = O * n.wrapElement[d.value.scrollSize] / 100;
    }, g = () => {
      l = !1, o.value[d.value.axis] = 0, document.removeEventListener("mousemove", f), document.removeEventListener("mouseup", g), _(), u && (a.value = !1);
    }, y = () => {
      u = !1, a.value = !!e.size;
    }, w = () => {
      u = !0, a.value = l;
    };
    xn(() => {
      _(), document.removeEventListener("mouseup", g);
    });
    const _ = () => {
      document.onselectstart !== c && (document.onselectstart = c);
    };
    return wn(On(n, "scrollbarElement"), "mousemove", y), wn(On(n, "scrollbarElement"), "mouseleave", w), (S, A) => (U(), xe(Sr, {
      name: x(r).b("fade"),
      persisted: ""
    }, {
      default: fe(() => [
        Bt(le("div", {
          ref_key: "instance",
          ref: i,
          class: X([x(r).e("bar"), x(r).is(x(d).key)]),
          onMousedown: b
        }, [
          le("div", {
            ref_key: "thumb",
            ref: s,
            class: X(x(r).e("thumb")),
            style: it(x(h)),
            onMousedown: m
          }, null, 38)
        ], 34), [
          [Qn, S.always || a.value]
        ])
      ]),
      _: 1
    }, 8, ["name"]));
  }
});
var op = /* @__PURE__ */ Ge(GO, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/thumb.vue"]]);
const qO = ut({
  always: {
    type: Boolean,
    default: !0
  },
  width: String,
  height: String,
  ratioX: {
    type: Number,
    default: 1
  },
  ratioY: {
    type: Number,
    default: 1
  }
}), JO = /* @__PURE__ */ ye({
  __name: "bar",
  props: qO,
  setup(t, { expose: e }) {
    const n = t, r = K(0), i = K(0);
    return e({
      handleScroll: (o) => {
        if (o) {
          const a = o.offsetHeight - Cs, l = o.offsetWidth - Cs;
          i.value = o.scrollTop * 100 / a * n.ratioY, r.value = o.scrollLeft * 100 / l * n.ratioX;
        }
      }
    }), (o, a) => (U(), oe(Ft, null, [
      ve(op, {
        move: r.value,
        ratio: o.ratioX,
        size: o.width,
        always: o.always
      }, null, 8, ["move", "ratio", "size", "always"]),
      ve(op, {
        move: i.value,
        ratio: o.ratioY,
        size: o.height,
        vertical: "",
        always: o.always
      }, null, 8, ["move", "ratio", "size", "always"])
    ], 64));
  }
});
var YO = /* @__PURE__ */ Ge(JO, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/bar.vue"]]);
const QO = ut({
  height: {
    type: [String, Number],
    default: ""
  },
  maxHeight: {
    type: [String, Number],
    default: ""
  },
  native: {
    type: Boolean,
    default: !1
  },
  wrapStyle: {
    type: De([String, Object, Array]),
    default: ""
  },
  wrapClass: {
    type: [String, Array],
    default: ""
  },
  viewClass: {
    type: [String, Array],
    default: ""
  },
  viewStyle: {
    type: [String, Array, Object],
    default: ""
  },
  noresize: Boolean,
  tag: {
    type: String,
    default: "div"
  },
  always: Boolean,
  minSize: {
    type: Number,
    default: 20
  },
  id: String,
  role: String,
  ariaLabel: String,
  ariaOrientation: {
    type: String,
    values: ["horizontal", "vertical"]
  }
}), ZO = {
  scroll: ({
    scrollTop: t,
    scrollLeft: e
  }) => [t, e].every(mt)
}, Ec = "ElScrollbar", XO = ye({
  name: Ec
}), eI = /* @__PURE__ */ ye({
  ...XO,
  props: QO,
  emits: ZO,
  setup(t, { expose: e, emit: n }) {
    const r = t, i = ze("scrollbar");
    let s, o;
    const a = K(), l = K(), u = K(), c = K("0"), d = K("0"), h = K(), v = K(1), m = K(1), b = j(() => {
      const A = {};
      return r.height && (A.height = El(r.height)), r.maxHeight && (A.maxHeight = El(r.maxHeight)), [r.wrapStyle, A];
    }), p = j(() => [
      r.wrapClass,
      i.e("wrap"),
      { [i.em("wrap", "hidden-default")]: !r.native }
    ]), f = j(() => [i.e("view"), r.viewClass]), g = () => {
      var A;
      l.value && ((A = h.value) == null || A.handleScroll(l.value), n("scroll", {
        scrollTop: l.value.scrollTop,
        scrollLeft: l.value.scrollLeft
      }));
    };
    function y(A, C) {
      _n(A) ? l.value.scrollTo(A) : mt(A) && mt(C) && l.value.scrollTo(A, C);
    }
    const w = (A) => {
      if (!mt(A)) {
        Vt(Ec, "value must be a number");
        return;
      }
      l.value.scrollTop = A;
    }, _ = (A) => {
      if (!mt(A)) {
        Vt(Ec, "value must be a number");
        return;
      }
      l.value.scrollLeft = A;
    }, S = () => {
      if (!l.value)
        return;
      const A = l.value.offsetHeight - Cs, C = l.value.offsetWidth - Cs, k = A ** 2 / l.value.scrollHeight, O = C ** 2 / l.value.scrollWidth, N = Math.max(k, r.minSize), B = Math.max(O, r.minSize);
      v.value = k / (A - k) / (N / (A - N)), m.value = O / (C - O) / (B / (C - B)), d.value = N + Cs < A ? `${N}px` : "", c.value = B + Cs < C ? `${B}px` : "";
    };
    return Ae(() => r.noresize, (A) => {
      A ? (s == null || s(), o == null || o()) : ({ stop: s } = Ds(u, S), o = wn("resize", S));
    }, { immediate: !0 }), Ae(() => [r.maxHeight, r.height], () => {
      r.native || rt(() => {
        var A;
        S(), l.value && ((A = h.value) == null || A.handleScroll(l.value));
      });
    }), qt(mm, Mn({
      scrollbarElement: a,
      wrapElement: l
    })), Ct(() => {
      r.native || rt(() => {
        S();
      });
    }), Yl(() => S()), e({
      wrapRef: l,
      update: S,
      scrollTo: y,
      setScrollTop: w,
      setScrollLeft: _,
      handleScroll: g
    }), (A, C) => (U(), oe("div", {
      ref_key: "scrollbarRef",
      ref: a,
      class: X(x(i).b())
    }, [
      le("div", {
        ref_key: "wrapRef",
        ref: l,
        class: X(x(p)),
        style: it(x(b)),
        onScroll: g
      }, [
        (U(), xe(Pn(A.tag), {
          id: A.id,
          ref_key: "resizeRef",
          ref: u,
          class: X(x(f)),
          style: it(A.viewStyle),
          role: A.role,
          "aria-label": A.ariaLabel,
          "aria-orientation": A.ariaOrientation
        }, {
          default: fe(() => [
            Me(A.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "class", "style", "role", "aria-label", "aria-orientation"]))
      ], 38),
      A.native ? me("v-if", !0) : (U(), xe(YO, {
        key: 0,
        ref_key: "barRef",
        ref: h,
        height: d.value,
        width: c.value,
        always: A.always,
        "ratio-x": m.value,
        "ratio-y": v.value
      }, null, 8, ["height", "width", "always", "ratio-x", "ratio-y"]))
    ], 2));
  }
});
var tI = /* @__PURE__ */ Ge(eI, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/scrollbar.vue"]]);
const uf = nn(tI), cf = Symbol("popper"), ym = Symbol("popperContent"), nI = [
  "dialog",
  "grid",
  "group",
  "listbox",
  "menu",
  "navigation",
  "tooltip",
  "tree"
], bm = ut({
  role: {
    type: String,
    values: nI,
    default: "tooltip"
  }
}), rI = ye({
  name: "ElPopper",
  inheritAttrs: !1
}), iI = /* @__PURE__ */ ye({
  ...rI,
  props: bm,
  setup(t, { expose: e }) {
    const n = t, r = K(), i = K(), s = K(), o = K(), a = j(() => n.role), l = {
      triggerRef: r,
      popperInstanceRef: i,
      contentRef: s,
      referenceRef: o,
      role: a
    };
    return e(l), qt(cf, l), (u, c) => Me(u.$slots, "default");
  }
});
var sI = /* @__PURE__ */ Ge(iI, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/popper.vue"]]);
const wm = ut({
  arrowOffset: {
    type: Number,
    default: 5
  }
}), oI = ye({
  name: "ElPopperArrow",
  inheritAttrs: !1
}), aI = /* @__PURE__ */ ye({
  ...oI,
  props: wm,
  setup(t, { expose: e }) {
    const n = t, r = ze("popper"), { arrowOffset: i, arrowRef: s, arrowStyle: o } = et(ym, void 0);
    return Ae(() => n.arrowOffset, (a) => {
      i.value = a;
    }), xn(() => {
      s.value = void 0;
    }), e({
      arrowRef: s
    }), (a, l) => (U(), oe("span", {
      ref_key: "arrowRef",
      ref: s,
      class: X(x(r).e("arrow")),
      style: it(x(o)),
      "data-popper-arrow": ""
    }, null, 6));
  }
});
var lI = /* @__PURE__ */ Ge(aI, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/arrow.vue"]]);
const Pu = "ElOnlyChild", uI = ye({
  name: Pu,
  setup(t, {
    slots: e,
    attrs: n
  }) {
    var r;
    const i = et(fm), s = _O((r = i == null ? void 0 : i.setForwardRef) != null ? r : en);
    return () => {
      var o;
      const a = (o = e.default) == null ? void 0 : o.call(e, n);
      if (!a)
        return null;
      if (a.length > 1)
        return Vt(Pu, "requires exact only one valid child."), null;
      const l = _m(a);
      return l ? Bt(Eb(l, n), [[s]]) : (Vt(Pu, "no valid child node found"), null);
    };
  }
});
function _m(t) {
  if (!t)
    return null;
  const e = t;
  for (const n of e) {
    if (_n(n))
      switch (n.type) {
        case Dv:
          continue;
        case Pv:
        case "svg":
          return ap(n);
        case Ft:
          return _m(n.children);
        default:
          return n;
      }
    return ap(n);
  }
  return null;
}
function ap(t) {
  const e = ze("only-child");
  return ve("span", {
    class: e.e("content")
  }, [t]);
}
const Sm = ut({
  virtualRef: {
    type: De(Object)
  },
  virtualTriggering: Boolean,
  onMouseenter: {
    type: De(Function)
  },
  onMouseleave: {
    type: De(Function)
  },
  onClick: {
    type: De(Function)
  },
  onKeydown: {
    type: De(Function)
  },
  onFocus: {
    type: De(Function)
  },
  onBlur: {
    type: De(Function)
  },
  onContextmenu: {
    type: De(Function)
  },
  id: String,
  open: Boolean
}), cI = ye({
  name: "ElPopperTrigger",
  inheritAttrs: !1
}), dI = /* @__PURE__ */ ye({
  ...cI,
  props: Sm,
  setup(t, { expose: e }) {
    const n = t, { role: r, triggerRef: i } = et(cf, void 0);
    wO(i);
    const s = j(() => a.value ? n.id : void 0), o = j(() => {
      if (r && r.value === "tooltip")
        return n.open && n.id ? n.id : void 0;
    }), a = j(() => {
      if (r && r.value !== "tooltip")
        return r.value;
    }), l = j(() => a.value ? `${n.open}` : void 0);
    let u;
    return Ct(() => {
      Ae(() => n.virtualRef, (c) => {
        c && (i.value = wi(c));
      }, {
        immediate: !0
      }), Ae(i, (c, d) => {
        u == null || u(), u = void 0, Gi(c) && ([
          "onMouseenter",
          "onMouseleave",
          "onClick",
          "onKeydown",
          "onFocus",
          "onBlur",
          "onContextmenu"
        ].forEach((h) => {
          var v;
          const m = n[h];
          m && (c.addEventListener(h.slice(2).toLowerCase(), m), (v = d == null ? void 0 : d.removeEventListener) == null || v.call(d, h.slice(2).toLowerCase(), m));
        }), u = Ae([s, o, a, l], (h) => {
          [
            "aria-controls",
            "aria-describedby",
            "aria-haspopup",
            "aria-expanded"
          ].forEach((v, m) => {
            nr(h[m]) ? c.removeAttribute(v) : c.setAttribute(v, h[m]);
          });
        }, { immediate: !0 })), Gi(d) && [
          "aria-controls",
          "aria-describedby",
          "aria-haspopup",
          "aria-expanded"
        ].forEach((h) => d.removeAttribute(h));
      }, {
        immediate: !0
      });
    }), xn(() => {
      u == null || u(), u = void 0;
    }), e({
      triggerRef: i
    }), (c, d) => c.virtualTriggering ? me("v-if", !0) : (U(), xe(x(uI), Jn({ key: 0 }, c.$attrs, {
      "aria-controls": x(s),
      "aria-describedby": x(o),
      "aria-expanded": x(l),
      "aria-haspopup": x(a)
    }), {
      default: fe(() => [
        Me(c.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"]));
  }
});
var fI = /* @__PURE__ */ Ge(dI, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/trigger.vue"]]);
const Du = "focus-trap.focus-after-trapped", Bu = "focus-trap.focus-after-released", hI = "focus-trap.focusout-prevented", lp = {
  cancelable: !0,
  bubbles: !1
}, pI = {
  cancelable: !0,
  bubbles: !1
}, up = "focusAfterTrapped", cp = "focusAfterReleased", vI = Symbol("elFocusTrap"), df = K(), cu = K(0), ff = K(0);
let ka = 0;
const Em = (t) => {
  const e = [], n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 || r === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); )
    e.push(n.currentNode);
  return e;
}, dp = (t, e) => {
  for (const n of t)
    if (!gI(n, e))
      return n;
}, gI = (t, e) => {
  if (process.env.NODE_ENV === "test")
    return !1;
  if (getComputedStyle(t).visibility === "hidden")
    return !0;
  for (; t; ) {
    if (e && t === e)
      return !1;
    if (getComputedStyle(t).display === "none")
      return !0;
    t = t.parentElement;
  }
  return !1;
}, mI = (t) => {
  const e = Em(t), n = dp(e, t), r = dp(e.reverse(), t);
  return [n, r];
}, yI = (t) => t instanceof HTMLInputElement && "select" in t, vi = (t, e) => {
  if (t && t.focus) {
    const n = document.activeElement;
    t.focus({ preventScroll: !0 }), ff.value = window.performance.now(), t !== n && yI(t) && e && t.select();
  }
};
function fp(t, e) {
  const n = [...t], r = t.indexOf(e);
  return r !== -1 && n.splice(r, 1), n;
}
const bI = () => {
  let t = [];
  return {
    push: (r) => {
      const i = t[0];
      i && r !== i && i.pause(), t = fp(t, r), t.unshift(r);
    },
    remove: (r) => {
      var i, s;
      t = fp(t, r), (s = (i = t[0]) == null ? void 0 : i.resume) == null || s.call(i);
    }
  };
}, wI = (t, e = !1) => {
  const n = document.activeElement;
  for (const r of t)
    if (vi(r, e), document.activeElement !== n)
      return;
}, hp = bI(), _I = () => cu.value > ff.value, Ca = () => {
  df.value = "pointer", cu.value = window.performance.now();
}, pp = () => {
  df.value = "keyboard", cu.value = window.performance.now();
}, SI = () => (Ct(() => {
  ka === 0 && (document.addEventListener("mousedown", Ca), document.addEventListener("touchstart", Ca), document.addEventListener("keydown", pp)), ka++;
}), xn(() => {
  ka--, ka <= 0 && (document.removeEventListener("mousedown", Ca), document.removeEventListener("touchstart", Ca), document.removeEventListener("keydown", pp));
}), {
  focusReason: df,
  lastUserFocusTimestamp: cu,
  lastAutomatedFocusTimestamp: ff
}), Ta = (t) => new CustomEvent(hI, {
  ...pI,
  detail: t
}), EI = ye({
  name: "ElFocusTrap",
  inheritAttrs: !1,
  props: {
    loop: Boolean,
    trapped: Boolean,
    focusTrapEl: Object,
    focusStartEl: {
      type: [Object, String],
      default: "first"
    }
  },
  emits: [
    up,
    cp,
    "focusin",
    "focusout",
    "focusout-prevented",
    "release-requested"
  ],
  setup(t, { emit: e }) {
    const n = K();
    let r, i;
    const { focusReason: s } = SI();
    gO((m) => {
      t.trapped && !o.paused && e("release-requested", m);
    });
    const o = {
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    }, a = (m) => {
      if (!t.loop && !t.trapped || o.paused)
        return;
      const { key: b, altKey: p, ctrlKey: f, metaKey: g, currentTarget: y, shiftKey: w } = m, { loop: _ } = t, S = b === sn.tab && !p && !f && !g, A = document.activeElement;
      if (S && A) {
        const C = y, [k, O] = mI(C);
        if (k && O) {
          if (!w && A === O) {
            const B = Ta({
              focusReason: s.value
            });
            e("focusout-prevented", B), B.defaultPrevented || (m.preventDefault(), _ && vi(k, !0));
          } else if (w && [k, C].includes(A)) {
            const B = Ta({
              focusReason: s.value
            });
            e("focusout-prevented", B), B.defaultPrevented || (m.preventDefault(), _ && vi(O, !0));
          }
        } else if (A === C) {
          const B = Ta({
            focusReason: s.value
          });
          e("focusout-prevented", B), B.defaultPrevented || m.preventDefault();
        }
      }
    };
    qt(vI, {
      focusTrapRef: n,
      onKeydown: a
    }), Ae(() => t.focusTrapEl, (m) => {
      m && (n.value = m);
    }, { immediate: !0 }), Ae([n], ([m], [b]) => {
      m && (m.addEventListener("keydown", a), m.addEventListener("focusin", c), m.addEventListener("focusout", d)), b && (b.removeEventListener("keydown", a), b.removeEventListener("focusin", c), b.removeEventListener("focusout", d));
    });
    const l = (m) => {
      e(up, m);
    }, u = (m) => e(cp, m), c = (m) => {
      const b = x(n);
      if (!b)
        return;
      const p = m.target, f = m.relatedTarget, g = p && b.contains(p);
      t.trapped || f && b.contains(f) || (r = f), g && e("focusin", m), !o.paused && t.trapped && (g ? i = p : vi(i, !0));
    }, d = (m) => {
      const b = x(n);
      if (!(o.paused || !b))
        if (t.trapped) {
          const p = m.relatedTarget;
          !nr(p) && !b.contains(p) && setTimeout(() => {
            if (!o.paused && t.trapped) {
              const f = Ta({
                focusReason: s.value
              });
              e("focusout-prevented", f), f.defaultPrevented || vi(i, !0);
            }
          }, 0);
        } else {
          const p = m.target;
          p && b.contains(p) || e("focusout", m);
        }
    };
    async function h() {
      await rt();
      const m = x(n);
      if (m) {
        hp.push(o);
        const b = m.contains(document.activeElement) ? r : document.activeElement;
        if (r = b, !m.contains(b)) {
          const f = new Event(Du, lp);
          m.addEventListener(Du, l), m.dispatchEvent(f), f.defaultPrevented || rt(() => {
            let g = t.focusStartEl;
            Gt(g) || (vi(g), document.activeElement !== g && (g = "first")), g === "first" && wI(Em(m), !0), (document.activeElement === b || g === "container") && vi(m);
          });
        }
      }
    }
    function v() {
      const m = x(n);
      if (m) {
        m.removeEventListener(Du, l);
        const b = new CustomEvent(Bu, {
          ...lp,
          detail: {
            focusReason: s.value
          }
        });
        m.addEventListener(Bu, u), m.dispatchEvent(b), !b.defaultPrevented && (s.value == "keyboard" || !_I() || m.contains(document.activeElement)) && vi(r ?? document.body), m.removeEventListener(Bu, u), hp.remove(o);
      }
    }
    return Ct(() => {
      t.trapped && h(), Ae(() => t.trapped, (m) => {
        m ? h() : v();
      });
    }), xn(() => {
      t.trapped && v();
    }), {
      onKeydown: a
    };
  }
});
function xI(t, e, n, r, i, s) {
  return Me(t.$slots, "default", { handleKeydown: t.onKeydown });
}
var AI = /* @__PURE__ */ Ge(EI, [["render", xI], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue"]]);
const kI = ["fixed", "absolute"], CI = ut({
  boundariesPadding: {
    type: Number,
    default: 0
  },
  fallbackPlacements: {
    type: De(Array),
    default: void 0
  },
  gpuAcceleration: {
    type: Boolean,
    default: !0
  },
  offset: {
    type: Number,
    default: 12
  },
  placement: {
    type: String,
    values: Js,
    default: "bottom"
  },
  popperOptions: {
    type: De(Object),
    default: () => ({})
  },
  strategy: {
    type: String,
    values: kI,
    default: "absolute"
  }
}), xm = ut({
  ...CI,
  id: String,
  style: {
    type: De([String, Array, Object])
  },
  className: {
    type: De([String, Array, Object])
  },
  effect: {
    type: String,
    default: "dark"
  },
  visible: Boolean,
  enterable: {
    type: Boolean,
    default: !0
  },
  pure: Boolean,
  focusOnShow: {
    type: Boolean,
    default: !1
  },
  trapping: {
    type: Boolean,
    default: !1
  },
  popperClass: {
    type: De([String, Array, Object])
  },
  popperStyle: {
    type: De([String, Array, Object])
  },
  referenceEl: {
    type: De(Object)
  },
  triggerTargetEl: {
    type: De(Object)
  },
  stopPopperMouseEvent: {
    type: Boolean,
    default: !0
  },
  ariaLabel: {
    type: String,
    default: void 0
  },
  virtualTriggering: Boolean,
  zIndex: Number
}), TI = {
  mouseenter: (t) => t instanceof MouseEvent,
  mouseleave: (t) => t instanceof MouseEvent,
  focus: () => !0,
  blur: () => !0,
  close: () => !0
}, OI = (t, e = []) => {
  const { placement: n, strategy: r, popperOptions: i } = t, s = {
    placement: n,
    strategy: r,
    ...i,
    modifiers: [...NI(t), ...e]
  };
  return RI(s, i == null ? void 0 : i.modifiers), s;
}, II = (t) => {
  if (St)
    return wi(t);
};
function NI(t) {
  const { offset: e, gpuAcceleration: n, fallbackPlacements: r } = t;
  return [
    {
      name: "offset",
      options: {
        offset: [0, e ?? 12]
      }
    },
    {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    },
    {
      name: "flip",
      options: {
        padding: 5,
        fallbackPlacements: r
      }
    },
    {
      name: "computeStyles",
      options: {
        gpuAcceleration: n
      }
    }
  ];
}
function RI(t, e) {
  e && (t.modifiers = [...t.modifiers, ...e ?? []]);
}
const PI = 0, DI = (t) => {
  const { popperInstanceRef: e, contentRef: n, triggerRef: r, role: i } = et(cf, void 0), s = K(), o = K(), a = j(() => ({
    name: "eventListeners",
    enabled: !!t.visible
  })), l = j(() => {
    var f;
    const g = x(s), y = (f = x(o)) != null ? f : PI;
    return {
      name: "arrow",
      enabled: !EA(g),
      options: {
        element: g,
        padding: y
      }
    };
  }), u = j(() => ({
    onFirstUpdate: () => {
      m();
    },
    ...OI(t, [
      x(l),
      x(a)
    ])
  })), c = j(() => II(t.referenceEl) || x(r)), { attributes: d, state: h, styles: v, update: m, forceUpdate: b, instanceRef: p } = hO(c, n, u);
  return Ae(p, (f) => e.value = f), Ct(() => {
    Ae(() => {
      var f;
      return (f = x(c)) == null ? void 0 : f.getBoundingClientRect();
    }, () => {
      m();
    });
  }), {
    attributes: d,
    arrowRef: s,
    contentRef: n,
    instanceRef: p,
    state: h,
    styles: v,
    role: i,
    forceUpdate: b,
    update: m
  };
}, BI = (t, {
  attributes: e,
  styles: n,
  role: r
}) => {
  const { nextZIndex: i } = lu(), s = ze("popper"), o = j(() => x(e).popper), a = K(mt(t.zIndex) ? t.zIndex : i()), l = j(() => [
    s.b(),
    s.is("pure", t.pure),
    s.is(t.effect),
    t.popperClass
  ]), u = j(() => [
    { zIndex: x(a) },
    x(n).popper,
    t.popperStyle || {}
  ]), c = j(() => r.value === "dialog" ? "false" : void 0), d = j(() => x(n).arrow || {});
  return {
    ariaModal: c,
    arrowStyle: d,
    contentAttrs: o,
    contentClass: l,
    contentStyle: u,
    contentZIndex: a,
    updateZIndex: () => {
      a.value = mt(t.zIndex) ? t.zIndex : i();
    }
  };
}, MI = (t, e) => {
  const n = K(!1), r = K();
  return {
    focusStartRef: r,
    trapped: n,
    onFocusAfterReleased: (u) => {
      var c;
      ((c = u.detail) == null ? void 0 : c.focusReason) !== "pointer" && (r.value = "first", e("blur"));
    },
    onFocusAfterTrapped: () => {
      e("focus");
    },
    onFocusInTrap: (u) => {
      t.visible && !n.value && (u.target && (r.value = u.target), n.value = !0);
    },
    onFocusoutPrevented: (u) => {
      t.trapping || (u.detail.focusReason === "pointer" && u.preventDefault(), n.value = !1);
    },
    onReleaseRequested: () => {
      n.value = !1, e("close");
    }
  };
}, LI = ye({
  name: "ElPopperContent"
}), zI = /* @__PURE__ */ ye({
  ...LI,
  props: xm,
  emits: TI,
  setup(t, { expose: e, emit: n }) {
    const r = t, {
      focusStartRef: i,
      trapped: s,
      onFocusAfterReleased: o,
      onFocusAfterTrapped: a,
      onFocusInTrap: l,
      onFocusoutPrevented: u,
      onReleaseRequested: c
    } = MI(r, n), { attributes: d, arrowRef: h, contentRef: v, styles: m, instanceRef: b, role: p, update: f } = DI(r), {
      ariaModal: g,
      arrowStyle: y,
      contentAttrs: w,
      contentClass: _,
      contentStyle: S,
      updateZIndex: A
    } = BI(r, {
      styles: m,
      attributes: d,
      role: p
    }), C = et(jo, void 0), k = K();
    qt(ym, {
      arrowStyle: y,
      arrowRef: h,
      arrowOffset: k
    }), C && (C.addInputId || C.removeInputId) && qt(jo, {
      ...C,
      addInputId: en,
      removeInputId: en
    });
    let O;
    const N = (D = !0) => {
      f(), D && A();
    }, B = () => {
      N(!1), r.visible && r.focusOnShow ? s.value = !0 : r.visible === !1 && (s.value = !1);
    };
    return Ct(() => {
      Ae(() => r.triggerTargetEl, (D, F) => {
        O == null || O(), O = void 0;
        const Z = x(D || v.value), te = x(F || v.value);
        Gi(Z) && (O = Ae([p, () => r.ariaLabel, g, () => r.id], (L) => {
          ["role", "aria-label", "aria-modal", "id"].forEach((V, H) => {
            nr(L[H]) ? Z.removeAttribute(V) : Z.setAttribute(V, L[H]);
          });
        }, { immediate: !0 })), te !== Z && Gi(te) && ["role", "aria-label", "aria-modal", "id"].forEach((L) => {
          te.removeAttribute(L);
        });
      }, { immediate: !0 }), Ae(() => r.visible, B, { immediate: !0 });
    }), xn(() => {
      O == null || O(), O = void 0;
    }), e({
      popperContentRef: v,
      popperInstanceRef: b,
      updatePopper: N,
      contentStyle: S
    }), (D, F) => (U(), oe("div", Jn({
      ref_key: "contentRef",
      ref: v
    }, x(w), {
      style: x(S),
      class: x(_),
      tabindex: "-1",
      onMouseenter: F[0] || (F[0] = (Z) => D.$emit("mouseenter", Z)),
      onMouseleave: F[1] || (F[1] = (Z) => D.$emit("mouseleave", Z))
    }), [
      ve(x(AI), {
        trapped: x(s),
        "trap-on-focus-in": !0,
        "focus-trap-el": x(v),
        "focus-start-el": x(i),
        onFocusAfterTrapped: x(a),
        onFocusAfterReleased: x(o),
        onFocusin: x(l),
        onFocusoutPrevented: x(u),
        onReleaseRequested: x(c)
      }, {
        default: fe(() => [
          Me(D.$slots, "default")
        ]),
        _: 3
      }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
    ], 16));
  }
});
var jI = /* @__PURE__ */ Ge(zI, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/content.vue"]]);
const FI = nn(sI), hf = Symbol("elTooltip"), qn = ut({
  ...bO,
  ...xm,
  appendTo: {
    type: De([String, Object])
  },
  content: {
    type: String,
    default: ""
  },
  rawContent: {
    type: Boolean,
    default: !1
  },
  persistent: Boolean,
  ariaLabel: String,
  visible: {
    type: De(Boolean),
    default: null
  },
  transition: String,
  teleported: {
    type: Boolean,
    default: !0
  },
  disabled: Boolean
}), Fo = ut({
  ...Sm,
  disabled: Boolean,
  trigger: {
    type: De([String, Array]),
    default: "hover"
  },
  triggerKeys: {
    type: De(Array),
    default: () => [sn.enter, sn.space]
  }
}), {
  useModelToggleProps: HI,
  useModelToggleEmits: UI,
  useModelToggle: VI
} = Jg("visible"), WI = ut({
  ...bm,
  ...HI,
  ...qn,
  ...Fo,
  ...wm,
  showArrow: {
    type: Boolean,
    default: !0
  }
}), $I = [
  ...UI,
  "before-show",
  "before-hide",
  "show",
  "hide",
  "open",
  "close"
], KI = (t, e) => Br(t) ? t.includes(e) : t === e, fs = (t, e, n) => (r) => {
  KI(x(t), e) && n(r);
}, GI = ye({
  name: "ElTooltipTrigger"
}), qI = /* @__PURE__ */ ye({
  ...GI,
  props: Fo,
  setup(t, { expose: e }) {
    const n = t, r = ze("tooltip"), { controlled: i, id: s, open: o, onOpen: a, onClose: l, onToggle: u } = et(hf, void 0), c = K(null), d = () => {
      if (x(i) || n.disabled)
        return !0;
    }, h = On(n, "trigger"), v = qr(d, fs(h, "hover", a)), m = qr(d, fs(h, "hover", l)), b = qr(d, fs(h, "click", (w) => {
      w.button === 0 && u(w);
    })), p = qr(d, fs(h, "focus", a)), f = qr(d, fs(h, "focus", l)), g = qr(d, fs(h, "contextmenu", (w) => {
      w.preventDefault(), u(w);
    })), y = qr(d, (w) => {
      const { code: _ } = w;
      n.triggerKeys.includes(_) && (w.preventDefault(), u(w));
    });
    return e({
      triggerRef: c
    }), (w, _) => (U(), xe(x(fI), {
      id: x(s),
      "virtual-ref": w.virtualRef,
      open: x(o),
      "virtual-triggering": w.virtualTriggering,
      class: X(x(r).e("trigger")),
      onBlur: x(f),
      onClick: x(b),
      onContextmenu: x(g),
      onFocus: x(p),
      onMouseenter: x(v),
      onMouseleave: x(m),
      onKeydown: x(y)
    }, {
      default: fe(() => [
        Me(w.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]));
  }
});
var JI = /* @__PURE__ */ Ge(qI, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/trigger.vue"]]);
const YI = ye({
  name: "ElTooltipContent",
  inheritAttrs: !1
}), QI = /* @__PURE__ */ ye({
  ...YI,
  props: qn,
  setup(t, { expose: e }) {
    const n = t, { selector: r } = cm(), i = ze("tooltip"), s = K(null), o = K(!1), {
      controlled: a,
      id: l,
      open: u,
      trigger: c,
      onClose: d,
      onOpen: h,
      onShow: v,
      onHide: m,
      onBeforeShow: b,
      onBeforeHide: p
    } = et(hf, void 0), f = j(() => n.transition || `${i.namespace.value}-fade-in-linear`), g = j(() => process.env.NODE_ENV === "test" ? !0 : n.persistent);
    xn(() => {
      o.value = !0;
    });
    const y = j(() => x(g) ? !0 : x(u)), w = j(() => n.disabled ? !1 : x(u)), _ = j(() => n.appendTo || r.value), S = j(() => {
      var L;
      return (L = n.style) != null ? L : {};
    }), A = j(() => !x(u)), C = () => {
      m();
    }, k = () => {
      if (x(a))
        return !0;
    }, O = qr(k, () => {
      n.enterable && x(c) === "hover" && h();
    }), N = qr(k, () => {
      x(c) === "hover" && d();
    }), B = () => {
      var L, V;
      (V = (L = s.value) == null ? void 0 : L.updatePopper) == null || V.call(L), b == null || b();
    }, D = () => {
      p == null || p();
    }, F = () => {
      v(), te = fw(j(() => {
        var L;
        return (L = s.value) == null ? void 0 : L.popperContentRef;
      }), () => {
        if (x(a))
          return;
        x(c) !== "hover" && d();
      });
    }, Z = () => {
      n.virtualTriggering || d();
    };
    let te;
    return Ae(() => x(u), (L) => {
      L || te == null || te();
    }, {
      flush: "post"
    }), Ae(() => n.content, () => {
      var L, V;
      (V = (L = s.value) == null ? void 0 : L.updatePopper) == null || V.call(L);
    }), e({
      contentRef: s
    }), (L, V) => (U(), xe(Bv, {
      disabled: !L.teleported,
      to: x(_)
    }, [
      ve(Sr, {
        name: x(f),
        onAfterLeave: C,
        onBeforeEnter: B,
        onAfterEnter: F,
        onBeforeLeave: D
      }, {
        default: fe(() => [
          x(y) ? Bt((U(), xe(x(jI), Jn({
            key: 0,
            id: x(l),
            ref_key: "contentRef",
            ref: s
          }, L.$attrs, {
            "aria-label": L.ariaLabel,
            "aria-hidden": x(A),
            "boundaries-padding": L.boundariesPadding,
            "fallback-placements": L.fallbackPlacements,
            "gpu-acceleration": L.gpuAcceleration,
            offset: L.offset,
            placement: L.placement,
            "popper-options": L.popperOptions,
            strategy: L.strategy,
            effect: L.effect,
            enterable: L.enterable,
            pure: L.pure,
            "popper-class": L.popperClass,
            "popper-style": [L.popperStyle, x(S)],
            "reference-el": L.referenceEl,
            "trigger-target-el": L.triggerTargetEl,
            visible: x(w),
            "z-index": L.zIndex,
            onMouseenter: x(O),
            onMouseleave: x(N),
            onBlur: Z,
            onClose: x(d)
          }), {
            default: fe(() => [
              o.value ? me("v-if", !0) : Me(L.$slots, "default", { key: 0 })
            ]),
            _: 3
          }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
            [Qn, x(w)]
          ]) : me("v-if", !0)
        ]),
        _: 3
      }, 8, ["name"])
    ], 8, ["disabled", "to"]));
  }
});
var ZI = /* @__PURE__ */ Ge(QI, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/content.vue"]]);
const XI = ["innerHTML"], eN = { key: 1 }, tN = ye({
  name: "ElTooltip"
}), nN = /* @__PURE__ */ ye({
  ...tN,
  props: WI,
  emits: $I,
  setup(t, { expose: e, emit: n }) {
    const r = t;
    yO();
    const i = ua(), s = K(), o = K(), a = () => {
      var f;
      const g = x(s);
      g && ((f = g.popperInstanceRef) == null || f.update());
    }, l = K(!1), u = K(), { show: c, hide: d, hasUpdateHandler: h } = VI({
      indicator: l,
      toggleReason: u
    }), { onOpen: v, onClose: m } = dm({
      showAfter: On(r, "showAfter"),
      hideAfter: On(r, "hideAfter"),
      autoClose: On(r, "autoClose"),
      open: c,
      close: d
    }), b = j(() => ri(r.visible) && !h.value);
    qt(hf, {
      controlled: b,
      id: i,
      open: xb(l),
      trigger: On(r, "trigger"),
      onOpen: (f) => {
        v(f);
      },
      onClose: (f) => {
        m(f);
      },
      onToggle: (f) => {
        x(l) ? m(f) : v(f);
      },
      onShow: () => {
        n("show", u.value);
      },
      onHide: () => {
        n("hide", u.value);
      },
      onBeforeShow: () => {
        n("before-show", u.value);
      },
      onBeforeHide: () => {
        n("before-hide", u.value);
      },
      updatePopper: a
    }), Ae(() => r.disabled, (f) => {
      f && l.value && (l.value = !1);
    });
    const p = (f) => {
      var g, y;
      const w = (y = (g = o.value) == null ? void 0 : g.contentRef) == null ? void 0 : y.popperContentRef, _ = (f == null ? void 0 : f.relatedTarget) || document.activeElement;
      return w && w.contains(_);
    };
    return Ab(() => l.value && d()), e({
      popperRef: s,
      contentRef: o,
      isFocusInsideContent: p,
      updatePopper: a,
      onOpen: v,
      onClose: m,
      hide: d
    }), (f, g) => (U(), xe(x(FI), {
      ref_key: "popperRef",
      ref: s,
      role: f.role
    }, {
      default: fe(() => [
        ve(JI, {
          disabled: f.disabled,
          trigger: f.trigger,
          "trigger-keys": f.triggerKeys,
          "virtual-ref": f.virtualRef,
          "virtual-triggering": f.virtualTriggering
        }, {
          default: fe(() => [
            f.$slots.default ? Me(f.$slots, "default", { key: 0 }) : me("v-if", !0)
          ]),
          _: 3
        }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
        ve(ZI, {
          ref_key: "contentRef",
          ref: o,
          "aria-label": f.ariaLabel,
          "boundaries-padding": f.boundariesPadding,
          content: f.content,
          disabled: f.disabled,
          effect: f.effect,
          enterable: f.enterable,
          "fallback-placements": f.fallbackPlacements,
          "hide-after": f.hideAfter,
          "gpu-acceleration": f.gpuAcceleration,
          offset: f.offset,
          persistent: f.persistent,
          "popper-class": f.popperClass,
          "popper-style": f.popperStyle,
          placement: f.placement,
          "popper-options": f.popperOptions,
          pure: f.pure,
          "raw-content": f.rawContent,
          "reference-el": f.referenceEl,
          "trigger-target-el": f.triggerTargetEl,
          "show-after": f.showAfter,
          strategy: f.strategy,
          teleported: f.teleported,
          transition: f.transition,
          "virtual-triggering": f.virtualTriggering,
          "z-index": f.zIndex,
          "append-to": f.appendTo
        }, {
          default: fe(() => [
            Me(f.$slots, "content", {}, () => [
              f.rawContent ? (U(), oe("span", {
                key: 0,
                innerHTML: f.content
              }, null, 8, XI)) : (U(), oe("span", eN, st(f.content), 1))
            ]),
            f.showArrow ? (U(), xe(x(lI), {
              key: 0,
              "arrow-offset": f.arrowOffset
            }, null, 8, ["arrow-offset"])) : me("v-if", !0)
          ]),
          _: 3
        }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
      ]),
      _: 3
    }, 8, ["role"]));
  }
});
var rN = /* @__PURE__ */ Ge(nN, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/tooltip.vue"]]);
const du = nn(rN), Am = Symbol("buttonGroupContextKey"), iN = (t, e) => {
  Kg({
    from: "type.text",
    replacement: "link",
    version: "3.0.0",
    scope: "props",
    ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
  }, j(() => t.type === "text"));
  const n = et(Am, void 0), r = af("button"), { form: i } = fi(), s = jr(j(() => n == null ? void 0 : n.size)), o = Fr(), a = K(), l = ta(), u = j(() => t.type || (n == null ? void 0 : n.type) || ""), c = j(() => {
    var m, b, p;
    return (p = (b = t.autoInsertSpace) != null ? b : (m = r.value) == null ? void 0 : m.autoInsertSpace) != null ? p : !1;
  }), d = j(() => t.tag === "button" ? {
    ariaDisabled: o.value || t.loading,
    disabled: o.value || t.loading,
    autofocus: t.autofocus,
    type: t.nativeType
  } : {}), h = j(() => {
    var m;
    const b = (m = l.default) == null ? void 0 : m.call(l);
    if (c.value && (b == null ? void 0 : b.length) === 1) {
      const p = b[0];
      if ((p == null ? void 0 : p.type) === Pv) {
        const f = p.children;
        return /^\p{Unified_Ideograph}{2}$/u.test(f.trim());
      }
    }
    return !1;
  });
  return {
    _disabled: o,
    _size: s,
    _type: u,
    _ref: a,
    _props: d,
    shouldAddSpace: h,
    handleClick: (m) => {
      t.nativeType === "reset" && (i == null || i.resetFields()), e("click", m);
    }
  };
}, sN = [
  "default",
  "primary",
  "success",
  "warning",
  "info",
  "danger",
  "text",
  ""
], oN = ["button", "submit", "reset"], xc = ut({
  size: zr,
  disabled: Boolean,
  type: {
    type: String,
    values: sN,
    default: ""
  },
  icon: {
    type: xi
  },
  nativeType: {
    type: String,
    values: oN,
    default: "button"
  },
  loading: Boolean,
  loadingIcon: {
    type: xi,
    default: () => su
  },
  plain: Boolean,
  text: Boolean,
  link: Boolean,
  bg: Boolean,
  autofocus: Boolean,
  round: Boolean,
  circle: Boolean,
  color: String,
  dark: Boolean,
  autoInsertSpace: {
    type: Boolean,
    default: void 0
  },
  tag: {
    type: De([String, Object]),
    default: "button"
  }
}), aN = {
  click: (t) => t instanceof MouseEvent
};
function Sn(t, e) {
  lN(t) && (t = "100%");
  var n = uN(t);
  return t = e === 360 ? t : Math.min(e, Math.max(0, parseFloat(t))), n && (t = parseInt(String(t * e), 10) / 100), Math.abs(t - e) < 1e-6 ? 1 : (e === 360 ? t = (t < 0 ? t % e + e : t % e) / parseFloat(String(e)) : t = t % e / parseFloat(String(e)), t);
}
function Oa(t) {
  return Math.min(1, Math.max(0, t));
}
function lN(t) {
  return typeof t == "string" && t.indexOf(".") !== -1 && parseFloat(t) === 1;
}
function uN(t) {
  return typeof t == "string" && t.indexOf("%") !== -1;
}
function km(t) {
  return t = parseFloat(t), (isNaN(t) || t < 0 || t > 1) && (t = 1), t;
}
function Ia(t) {
  return t <= 1 ? "".concat(Number(t) * 100, "%") : t;
}
function Li(t) {
  return t.length === 1 ? "0" + t : String(t);
}
function cN(t, e, n) {
  return {
    r: Sn(t, 255) * 255,
    g: Sn(e, 255) * 255,
    b: Sn(n, 255) * 255
  };
}
function vp(t, e, n) {
  t = Sn(t, 255), e = Sn(e, 255), n = Sn(n, 255);
  var r = Math.max(t, e, n), i = Math.min(t, e, n), s = 0, o = 0, a = (r + i) / 2;
  if (r === i)
    o = 0, s = 0;
  else {
    var l = r - i;
    switch (o = a > 0.5 ? l / (2 - r - i) : l / (r + i), r) {
      case t:
        s = (e - n) / l + (e < n ? 6 : 0);
        break;
      case e:
        s = (n - t) / l + 2;
        break;
      case n:
        s = (t - e) / l + 4;
        break;
    }
    s /= 6;
  }
  return { h: s, s: o, l: a };
}
function Mu(t, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * (6 * n) : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t;
}
function dN(t, e, n) {
  var r, i, s;
  if (t = Sn(t, 360), e = Sn(e, 100), n = Sn(n, 100), e === 0)
    i = n, s = n, r = n;
  else {
    var o = n < 0.5 ? n * (1 + e) : n + e - n * e, a = 2 * n - o;
    r = Mu(a, o, t + 1 / 3), i = Mu(a, o, t), s = Mu(a, o, t - 1 / 3);
  }
  return { r: r * 255, g: i * 255, b: s * 255 };
}
function gp(t, e, n) {
  t = Sn(t, 255), e = Sn(e, 255), n = Sn(n, 255);
  var r = Math.max(t, e, n), i = Math.min(t, e, n), s = 0, o = r, a = r - i, l = r === 0 ? 0 : a / r;
  if (r === i)
    s = 0;
  else {
    switch (r) {
      case t:
        s = (e - n) / a + (e < n ? 6 : 0);
        break;
      case e:
        s = (n - t) / a + 2;
        break;
      case n:
        s = (t - e) / a + 4;
        break;
    }
    s /= 6;
  }
  return { h: s, s: l, v: o };
}
function fN(t, e, n) {
  t = Sn(t, 360) * 6, e = Sn(e, 100), n = Sn(n, 100);
  var r = Math.floor(t), i = t - r, s = n * (1 - e), o = n * (1 - i * e), a = n * (1 - (1 - i) * e), l = r % 6, u = [n, o, s, s, a, n][l], c = [a, n, n, o, s, s][l], d = [s, s, a, n, n, o][l];
  return { r: u * 255, g: c * 255, b: d * 255 };
}
function mp(t, e, n, r) {
  var i = [
    Li(Math.round(t).toString(16)),
    Li(Math.round(e).toString(16)),
    Li(Math.round(n).toString(16))
  ];
  return r && i[0].startsWith(i[0].charAt(1)) && i[1].startsWith(i[1].charAt(1)) && i[2].startsWith(i[2].charAt(1)) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("");
}
function hN(t, e, n, r, i) {
  var s = [
    Li(Math.round(t).toString(16)),
    Li(Math.round(e).toString(16)),
    Li(Math.round(n).toString(16)),
    Li(pN(r))
  ];
  return i && s[0].startsWith(s[0].charAt(1)) && s[1].startsWith(s[1].charAt(1)) && s[2].startsWith(s[2].charAt(1)) && s[3].startsWith(s[3].charAt(1)) ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0) + s[3].charAt(0) : s.join("");
}
function pN(t) {
  return Math.round(parseFloat(t) * 255).toString(16);
}
function yp(t) {
  return Kn(t) / 255;
}
function Kn(t) {
  return parseInt(t, 16);
}
function vN(t) {
  return {
    r: t >> 16,
    g: (t & 65280) >> 8,
    b: t & 255
  };
}
var Ac = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function gN(t) {
  var e = { r: 0, g: 0, b: 0 }, n = 1, r = null, i = null, s = null, o = !1, a = !1;
  return typeof t == "string" && (t = bN(t)), typeof t == "object" && ($r(t.r) && $r(t.g) && $r(t.b) ? (e = cN(t.r, t.g, t.b), o = !0, a = String(t.r).substr(-1) === "%" ? "prgb" : "rgb") : $r(t.h) && $r(t.s) && $r(t.v) ? (r = Ia(t.s), i = Ia(t.v), e = fN(t.h, r, i), o = !0, a = "hsv") : $r(t.h) && $r(t.s) && $r(t.l) && (r = Ia(t.s), s = Ia(t.l), e = dN(t.h, r, s), o = !0, a = "hsl"), Object.prototype.hasOwnProperty.call(t, "a") && (n = t.a)), n = km(n), {
    ok: o,
    format: t.format || a,
    r: Math.min(255, Math.max(e.r, 0)),
    g: Math.min(255, Math.max(e.g, 0)),
    b: Math.min(255, Math.max(e.b, 0)),
    a: n
  };
}
var mN = "[-\\+]?\\d+%?", yN = "[-\\+]?\\d*\\.\\d+%?", _i = "(?:".concat(yN, ")|(?:").concat(mN, ")"), Lu = "[\\s|\\(]+(".concat(_i, ")[,|\\s]+(").concat(_i, ")[,|\\s]+(").concat(_i, ")\\s*\\)?"), zu = "[\\s|\\(]+(".concat(_i, ")[,|\\s]+(").concat(_i, ")[,|\\s]+(").concat(_i, ")[,|\\s]+(").concat(_i, ")\\s*\\)?"), fr = {
  CSS_UNIT: new RegExp(_i),
  rgb: new RegExp("rgb" + Lu),
  rgba: new RegExp("rgba" + zu),
  hsl: new RegExp("hsl" + Lu),
  hsla: new RegExp("hsla" + zu),
  hsv: new RegExp("hsv" + Lu),
  hsva: new RegExp("hsva" + zu),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function bN(t) {
  if (t = t.trim().toLowerCase(), t.length === 0)
    return !1;
  var e = !1;
  if (Ac[t])
    t = Ac[t], e = !0;
  else if (t === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  var n = fr.rgb.exec(t);
  return n ? { r: n[1], g: n[2], b: n[3] } : (n = fr.rgba.exec(t), n ? { r: n[1], g: n[2], b: n[3], a: n[4] } : (n = fr.hsl.exec(t), n ? { h: n[1], s: n[2], l: n[3] } : (n = fr.hsla.exec(t), n ? { h: n[1], s: n[2], l: n[3], a: n[4] } : (n = fr.hsv.exec(t), n ? { h: n[1], s: n[2], v: n[3] } : (n = fr.hsva.exec(t), n ? { h: n[1], s: n[2], v: n[3], a: n[4] } : (n = fr.hex8.exec(t), n ? {
    r: Kn(n[1]),
    g: Kn(n[2]),
    b: Kn(n[3]),
    a: yp(n[4]),
    format: e ? "name" : "hex8"
  } : (n = fr.hex6.exec(t), n ? {
    r: Kn(n[1]),
    g: Kn(n[2]),
    b: Kn(n[3]),
    format: e ? "name" : "hex"
  } : (n = fr.hex4.exec(t), n ? {
    r: Kn(n[1] + n[1]),
    g: Kn(n[2] + n[2]),
    b: Kn(n[3] + n[3]),
    a: yp(n[4] + n[4]),
    format: e ? "name" : "hex8"
  } : (n = fr.hex3.exec(t), n ? {
    r: Kn(n[1] + n[1]),
    g: Kn(n[2] + n[2]),
    b: Kn(n[3] + n[3]),
    format: e ? "name" : "hex"
  } : !1)))))))));
}
function $r(t) {
  return !!fr.CSS_UNIT.exec(String(t));
}
var wN = (
  /** @class */
  function() {
    function t(e, n) {
      e === void 0 && (e = ""), n === void 0 && (n = {});
      var r;
      if (e instanceof t)
        return e;
      typeof e == "number" && (e = vN(e)), this.originalInput = e;
      var i = gN(e);
      this.originalInput = e, this.r = i.r, this.g = i.g, this.b = i.b, this.a = i.a, this.roundA = Math.round(100 * this.a) / 100, this.format = (r = n.format) !== null && r !== void 0 ? r : i.format, this.gradientType = n.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = i.ok;
    }
    return t.prototype.isDark = function() {
      return this.getBrightness() < 128;
    }, t.prototype.isLight = function() {
      return !this.isDark();
    }, t.prototype.getBrightness = function() {
      var e = this.toRgb();
      return (e.r * 299 + e.g * 587 + e.b * 114) / 1e3;
    }, t.prototype.getLuminance = function() {
      var e = this.toRgb(), n, r, i, s = e.r / 255, o = e.g / 255, a = e.b / 255;
      return s <= 0.03928 ? n = s / 12.92 : n = Math.pow((s + 0.055) / 1.055, 2.4), o <= 0.03928 ? r = o / 12.92 : r = Math.pow((o + 0.055) / 1.055, 2.4), a <= 0.03928 ? i = a / 12.92 : i = Math.pow((a + 0.055) / 1.055, 2.4), 0.2126 * n + 0.7152 * r + 0.0722 * i;
    }, t.prototype.getAlpha = function() {
      return this.a;
    }, t.prototype.setAlpha = function(e) {
      return this.a = km(e), this.roundA = Math.round(100 * this.a) / 100, this;
    }, t.prototype.isMonochrome = function() {
      var e = this.toHsl().s;
      return e === 0;
    }, t.prototype.toHsv = function() {
      var e = gp(this.r, this.g, this.b);
      return { h: e.h * 360, s: e.s, v: e.v, a: this.a };
    }, t.prototype.toHsvString = function() {
      var e = gp(this.r, this.g, this.b), n = Math.round(e.h * 360), r = Math.round(e.s * 100), i = Math.round(e.v * 100);
      return this.a === 1 ? "hsv(".concat(n, ", ").concat(r, "%, ").concat(i, "%)") : "hsva(".concat(n, ", ").concat(r, "%, ").concat(i, "%, ").concat(this.roundA, ")");
    }, t.prototype.toHsl = function() {
      var e = vp(this.r, this.g, this.b);
      return { h: e.h * 360, s: e.s, l: e.l, a: this.a };
    }, t.prototype.toHslString = function() {
      var e = vp(this.r, this.g, this.b), n = Math.round(e.h * 360), r = Math.round(e.s * 100), i = Math.round(e.l * 100);
      return this.a === 1 ? "hsl(".concat(n, ", ").concat(r, "%, ").concat(i, "%)") : "hsla(".concat(n, ", ").concat(r, "%, ").concat(i, "%, ").concat(this.roundA, ")");
    }, t.prototype.toHex = function(e) {
      return e === void 0 && (e = !1), mp(this.r, this.g, this.b, e);
    }, t.prototype.toHexString = function(e) {
      return e === void 0 && (e = !1), "#" + this.toHex(e);
    }, t.prototype.toHex8 = function(e) {
      return e === void 0 && (e = !1), hN(this.r, this.g, this.b, this.a, e);
    }, t.prototype.toHex8String = function(e) {
      return e === void 0 && (e = !1), "#" + this.toHex8(e);
    }, t.prototype.toHexShortString = function(e) {
      return e === void 0 && (e = !1), this.a === 1 ? this.toHexString(e) : this.toHex8String(e);
    }, t.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    }, t.prototype.toRgbString = function() {
      var e = Math.round(this.r), n = Math.round(this.g), r = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(e, ", ").concat(n, ", ").concat(r, ")") : "rgba(".concat(e, ", ").concat(n, ", ").concat(r, ", ").concat(this.roundA, ")");
    }, t.prototype.toPercentageRgb = function() {
      var e = function(n) {
        return "".concat(Math.round(Sn(n, 255) * 100), "%");
      };
      return {
        r: e(this.r),
        g: e(this.g),
        b: e(this.b),
        a: this.a
      };
    }, t.prototype.toPercentageRgbString = function() {
      var e = function(n) {
        return Math.round(Sn(n, 255) * 100);
      };
      return this.a === 1 ? "rgb(".concat(e(this.r), "%, ").concat(e(this.g), "%, ").concat(e(this.b), "%)") : "rgba(".concat(e(this.r), "%, ").concat(e(this.g), "%, ").concat(e(this.b), "%, ").concat(this.roundA, ")");
    }, t.prototype.toName = function() {
      if (this.a === 0)
        return "transparent";
      if (this.a < 1)
        return !1;
      for (var e = "#" + mp(this.r, this.g, this.b, !1), n = 0, r = Object.entries(Ac); n < r.length; n++) {
        var i = r[n], s = i[0], o = i[1];
        if (e === o)
          return s;
      }
      return !1;
    }, t.prototype.toString = function(e) {
      var n = !!e;
      e = e ?? this.format;
      var r = !1, i = this.a < 1 && this.a >= 0, s = !n && i && (e.startsWith("hex") || e === "name");
      return s ? e === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (e === "rgb" && (r = this.toRgbString()), e === "prgb" && (r = this.toPercentageRgbString()), (e === "hex" || e === "hex6") && (r = this.toHexString()), e === "hex3" && (r = this.toHexString(!0)), e === "hex4" && (r = this.toHex8String(!0)), e === "hex8" && (r = this.toHex8String()), e === "name" && (r = this.toName()), e === "hsl" && (r = this.toHslString()), e === "hsv" && (r = this.toHsvString()), r || this.toHexString());
    }, t.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    }, t.prototype.clone = function() {
      return new t(this.toString());
    }, t.prototype.lighten = function(e) {
      e === void 0 && (e = 10);
      var n = this.toHsl();
      return n.l += e / 100, n.l = Oa(n.l), new t(n);
    }, t.prototype.brighten = function(e) {
      e === void 0 && (e = 10);
      var n = this.toRgb();
      return n.r = Math.max(0, Math.min(255, n.r - Math.round(255 * -(e / 100)))), n.g = Math.max(0, Math.min(255, n.g - Math.round(255 * -(e / 100)))), n.b = Math.max(0, Math.min(255, n.b - Math.round(255 * -(e / 100)))), new t(n);
    }, t.prototype.darken = function(e) {
      e === void 0 && (e = 10);
      var n = this.toHsl();
      return n.l -= e / 100, n.l = Oa(n.l), new t(n);
    }, t.prototype.tint = function(e) {
      return e === void 0 && (e = 10), this.mix("white", e);
    }, t.prototype.shade = function(e) {
      return e === void 0 && (e = 10), this.mix("black", e);
    }, t.prototype.desaturate = function(e) {
      e === void 0 && (e = 10);
      var n = this.toHsl();
      return n.s -= e / 100, n.s = Oa(n.s), new t(n);
    }, t.prototype.saturate = function(e) {
      e === void 0 && (e = 10);
      var n = this.toHsl();
      return n.s += e / 100, n.s = Oa(n.s), new t(n);
    }, t.prototype.greyscale = function() {
      return this.desaturate(100);
    }, t.prototype.spin = function(e) {
      var n = this.toHsl(), r = (n.h + e) % 360;
      return n.h = r < 0 ? 360 + r : r, new t(n);
    }, t.prototype.mix = function(e, n) {
      n === void 0 && (n = 50);
      var r = this.toRgb(), i = new t(e).toRgb(), s = n / 100, o = {
        r: (i.r - r.r) * s + r.r,
        g: (i.g - r.g) * s + r.g,
        b: (i.b - r.b) * s + r.b,
        a: (i.a - r.a) * s + r.a
      };
      return new t(o);
    }, t.prototype.analogous = function(e, n) {
      e === void 0 && (e = 6), n === void 0 && (n = 30);
      var r = this.toHsl(), i = 360 / n, s = [this];
      for (r.h = (r.h - (i * e >> 1) + 720) % 360; --e; )
        r.h = (r.h + i) % 360, s.push(new t(r));
      return s;
    }, t.prototype.complement = function() {
      var e = this.toHsl();
      return e.h = (e.h + 180) % 360, new t(e);
    }, t.prototype.monochromatic = function(e) {
      e === void 0 && (e = 6);
      for (var n = this.toHsv(), r = n.h, i = n.s, s = n.v, o = [], a = 1 / e; e--; )
        o.push(new t({ h: r, s: i, v: s })), s = (s + a) % 1;
      return o;
    }, t.prototype.splitcomplement = function() {
      var e = this.toHsl(), n = e.h;
      return [
        this,
        new t({ h: (n + 72) % 360, s: e.s, l: e.l }),
        new t({ h: (n + 216) % 360, s: e.s, l: e.l })
      ];
    }, t.prototype.onBackground = function(e) {
      var n = this.toRgb(), r = new t(e).toRgb(), i = n.a + r.a * (1 - n.a);
      return new t({
        r: (n.r * n.a + r.r * r.a * (1 - n.a)) / i,
        g: (n.g * n.a + r.g * r.a * (1 - n.a)) / i,
        b: (n.b * n.a + r.b * r.a * (1 - n.a)) / i,
        a: i
      });
    }, t.prototype.triad = function() {
      return this.polyad(3);
    }, t.prototype.tetrad = function() {
      return this.polyad(4);
    }, t.prototype.polyad = function(e) {
      for (var n = this.toHsl(), r = n.h, i = [this], s = 360 / e, o = 1; o < e; o++)
        i.push(new t({ h: (r + o * s) % 360, s: n.s, l: n.l }));
      return i;
    }, t.prototype.equals = function(e) {
      return this.toRgbString() === new t(e).toRgbString();
    }, t;
  }()
);
function hi(t, e = 20) {
  return t.mix("#141414", e).toString();
}
function _N(t) {
  const e = Fr(), n = ze("button");
  return j(() => {
    let r = {};
    const i = t.color;
    if (i) {
      const s = new wN(i), o = t.dark ? s.tint(20).toString() : hi(s, 20);
      if (t.plain)
        r = n.cssVarBlock({
          "bg-color": t.dark ? hi(s, 90) : s.tint(90).toString(),
          "text-color": i,
          "border-color": t.dark ? hi(s, 50) : s.tint(50).toString(),
          "hover-text-color": `var(${n.cssVarName("color-white")})`,
          "hover-bg-color": i,
          "hover-border-color": i,
          "active-bg-color": o,
          "active-text-color": `var(${n.cssVarName("color-white")})`,
          "active-border-color": o
        }), e.value && (r[n.cssVarBlockName("disabled-bg-color")] = t.dark ? hi(s, 90) : s.tint(90).toString(), r[n.cssVarBlockName("disabled-text-color")] = t.dark ? hi(s, 50) : s.tint(50).toString(), r[n.cssVarBlockName("disabled-border-color")] = t.dark ? hi(s, 80) : s.tint(80).toString());
      else {
        const a = t.dark ? hi(s, 30) : s.tint(30).toString(), l = s.isDark() ? `var(${n.cssVarName("color-white")})` : `var(${n.cssVarName("color-black")})`;
        if (r = n.cssVarBlock({
          "bg-color": i,
          "text-color": l,
          "border-color": i,
          "hover-bg-color": a,
          "hover-text-color": l,
          "hover-border-color": a,
          "active-bg-color": o,
          "active-border-color": o
        }), e.value) {
          const u = t.dark ? hi(s, 50) : s.tint(50).toString();
          r[n.cssVarBlockName("disabled-bg-color")] = u, r[n.cssVarBlockName("disabled-text-color")] = t.dark ? "rgba(255, 255, 255, 0.5)" : `var(${n.cssVarName("color-white")})`, r[n.cssVarBlockName("disabled-border-color")] = u;
        }
      }
    }
    return r;
  });
}
const SN = ye({
  name: "ElButton"
}), EN = /* @__PURE__ */ ye({
  ...SN,
  props: xc,
  emits: aN,
  setup(t, { expose: e, emit: n }) {
    const r = t, i = _N(r), s = ze("button"), { _ref: o, _size: a, _type: l, _disabled: u, _props: c, shouldAddSpace: d, handleClick: h } = iN(r, n);
    return e({
      ref: o,
      size: a,
      type: l,
      disabled: u,
      shouldAddSpace: d
    }), (v, m) => (U(), xe(Pn(v.tag), Jn({
      ref_key: "_ref",
      ref: o
    }, x(c), {
      class: [
        x(s).b(),
        x(s).m(x(l)),
        x(s).m(x(a)),
        x(s).is("disabled", x(u)),
        x(s).is("loading", v.loading),
        x(s).is("plain", v.plain),
        x(s).is("round", v.round),
        x(s).is("circle", v.circle),
        x(s).is("text", v.text),
        x(s).is("link", v.link),
        x(s).is("has-bg", v.bg)
      ],
      style: x(i),
      onClick: x(h)
    }), {
      default: fe(() => [
        v.loading ? (U(), oe(Ft, { key: 0 }, [
          v.$slots.loading ? Me(v.$slots, "loading", { key: 0 }) : (U(), xe(x(_t), {
            key: 1,
            class: X(x(s).is("loading"))
          }, {
            default: fe(() => [
              (U(), xe(Pn(v.loadingIcon)))
            ]),
            _: 1
          }, 8, ["class"]))
        ], 64)) : v.icon || v.$slots.icon ? (U(), xe(x(_t), { key: 1 }, {
          default: fe(() => [
            v.icon ? (U(), xe(Pn(v.icon), { key: 0 })) : Me(v.$slots, "icon", { key: 1 })
          ]),
          _: 3
        })) : me("v-if", !0),
        v.$slots.default ? (U(), oe("span", {
          key: 2,
          class: X({ [x(s).em("text", "expand")]: x(d) })
        }, [
          Me(v.$slots, "default")
        ], 2)) : me("v-if", !0)
      ]),
      _: 3
    }, 16, ["class", "style", "onClick"]));
  }
});
var xN = /* @__PURE__ */ Ge(EN, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button.vue"]]);
const AN = {
  size: xc.size,
  type: xc.type
}, kN = ye({
  name: "ElButtonGroup"
}), CN = /* @__PURE__ */ ye({
  ...kN,
  props: AN,
  setup(t) {
    const e = t;
    qt(Am, Mn({
      size: On(e, "size"),
      type: On(e, "type")
    }));
    const n = ze("button");
    return (r, i) => (U(), oe("div", {
      class: X(`${x(n).b("group")}`)
    }, [
      Me(r.$slots, "default")
    ], 2));
  }
});
var Cm = /* @__PURE__ */ Ge(CN, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button-group.vue"]]);
const rs = nn(xN, {
  ButtonGroup: Cm
}), Tm = ar(Cm);
var yn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
const gi = /* @__PURE__ */ new Map();
let bp;
St && (document.addEventListener("mousedown", (t) => bp = t), document.addEventListener("mouseup", (t) => {
  for (const e of gi.values())
    for (const { documentHandler: n } of e)
      n(t, bp);
}));
function wp(t, e) {
  let n = [];
  return Array.isArray(e.arg) ? n = e.arg : Gi(e.arg) && n.push(e.arg), function(r, i) {
    const s = e.instance.popperRef, o = r.target, a = i == null ? void 0 : i.target, l = !e || !e.instance, u = !o || !a, c = t.contains(o) || t.contains(a), d = t === o, h = n.length && n.some((m) => m == null ? void 0 : m.contains(o)) || n.length && n.includes(a), v = s && (s.contains(o) || s.contains(a));
    l || u || c || d || h || v || e.value(r, i);
  };
}
const Om = {
  beforeMount(t, e) {
    gi.has(t) || gi.set(t, []), gi.get(t).push({
      documentHandler: wp(t, e),
      bindingFn: e.value
    });
  },
  updated(t, e) {
    gi.has(t) || gi.set(t, []);
    const n = gi.get(t), r = n.findIndex((s) => s.bindingFn === e.oldValue), i = {
      documentHandler: wp(t, e),
      bindingFn: e.value
    };
    r >= 0 ? n.splice(r, 1, i) : n.push(i);
  },
  unmounted(t) {
    gi.delete(t);
  }
}, TN = 100, ON = 600, _p = {
  beforeMount(t, e) {
    const n = e.value, { interval: r = TN, delay: i = ON } = mn(n) ? {} : n;
    let s, o;
    const a = () => mn(n) ? n() : n.handler(), l = () => {
      o && (clearTimeout(o), o = void 0), s && (clearInterval(s), s = void 0);
    };
    t.addEventListener("mousedown", (u) => {
      u.button === 0 && (l(), a(), document.addEventListener("mouseup", () => l(), {
        once: !0
      }), o = setTimeout(() => {
        s = setInterval(() => {
          a();
        }, r);
      }, i));
    });
  }
};
var Sp = !1, Mi, kc, Cc, Ya, Qa, Im, Za, Tc, Oc, Ic, Nm, Nc, Rc, Rm, Pm;
function zn() {
  if (!Sp) {
    Sp = !0;
    var t = navigator.userAgent, e = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(t), n = /(Mac OS X)|(Windows)|(Linux)/.exec(t);
    if (Nc = /\b(iPhone|iP[ao]d)/.exec(t), Rc = /\b(iP[ao]d)/.exec(t), Ic = /Android/i.exec(t), Rm = /FBAN\/\w+;/i.exec(t), Pm = /Mobile/i.exec(t), Nm = !!/Win64/.exec(t), e) {
      Mi = e[1] ? parseFloat(e[1]) : e[5] ? parseFloat(e[5]) : NaN, Mi && document && document.documentMode && (Mi = document.documentMode);
      var r = /(?:Trident\/(\d+.\d+))/.exec(t);
      Im = r ? parseFloat(r[1]) + 4 : Mi, kc = e[2] ? parseFloat(e[2]) : NaN, Cc = e[3] ? parseFloat(e[3]) : NaN, Ya = e[4] ? parseFloat(e[4]) : NaN, Ya ? (e = /(?:Chrome\/(\d+\.\d+))/.exec(t), Qa = e && e[1] ? parseFloat(e[1]) : NaN) : Qa = NaN;
    } else
      Mi = kc = Cc = Qa = Ya = NaN;
    if (n) {
      if (n[1]) {
        var i = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(t);
        Za = i ? parseFloat(i[1].replace("_", ".")) : !0;
      } else
        Za = !1;
      Tc = !!n[2], Oc = !!n[3];
    } else
      Za = Tc = Oc = !1;
  }
}
var Pc = { ie: function() {
  return zn() || Mi;
}, ieCompatibilityMode: function() {
  return zn() || Im > Mi;
}, ie64: function() {
  return Pc.ie() && Nm;
}, firefox: function() {
  return zn() || kc;
}, opera: function() {
  return zn() || Cc;
}, webkit: function() {
  return zn() || Ya;
}, safari: function() {
  return Pc.webkit();
}, chrome: function() {
  return zn() || Qa;
}, windows: function() {
  return zn() || Tc;
}, osx: function() {
  return zn() || Za;
}, linux: function() {
  return zn() || Oc;
}, iphone: function() {
  return zn() || Nc;
}, mobile: function() {
  return zn() || Nc || Rc || Ic || Pm;
}, nativeApp: function() {
  return zn() || Rm;
}, android: function() {
  return zn() || Ic;
}, ipad: function() {
  return zn() || Rc;
} }, IN = Pc, Na = !!(typeof window < "u" && window.document && window.document.createElement), NN = { canUseDOM: Na, canUseWorkers: typeof Worker < "u", canUseEventListeners: Na && !!(window.addEventListener || window.attachEvent), canUseViewport: Na && !!window.screen, isInWorker: !Na }, Dm = NN, Bm;
Dm.canUseDOM && (Bm = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== !0);
function RN(t, e) {
  if (!Dm.canUseDOM || e && !("addEventListener" in document))
    return !1;
  var n = "on" + t, r = n in document;
  if (!r) {
    var i = document.createElement("div");
    i.setAttribute(n, "return;"), r = typeof i[n] == "function";
  }
  return !r && Bm && t === "wheel" && (r = document.implementation.hasFeature("Events.wheel", "3.0")), r;
}
var PN = RN, Ep = 10, xp = 40, Ap = 800;
function Mm(t) {
  var e = 0, n = 0, r = 0, i = 0;
  return "detail" in t && (n = t.detail), "wheelDelta" in t && (n = -t.wheelDelta / 120), "wheelDeltaY" in t && (n = -t.wheelDeltaY / 120), "wheelDeltaX" in t && (e = -t.wheelDeltaX / 120), "axis" in t && t.axis === t.HORIZONTAL_AXIS && (e = n, n = 0), r = e * Ep, i = n * Ep, "deltaY" in t && (i = t.deltaY), "deltaX" in t && (r = t.deltaX), (r || i) && t.deltaMode && (t.deltaMode == 1 ? (r *= xp, i *= xp) : (r *= Ap, i *= Ap)), r && !e && (e = r < 1 ? -1 : 1), i && !n && (n = i < 1 ? -1 : 1), { spinX: e, spinY: n, pixelX: r, pixelY: i };
}
Mm.getEventType = function() {
  return IN.firefox() ? "DOMMouseScroll" : PN("wheel") ? "wheel" : "mousewheel";
};
var DN = Mm;
/**
* Checks if an event is supported in the current execution environment.
*
* NOTE: This will not work correctly for non-generic events such as `change`,
* `reset`, `load`, `error`, and `select`.
*
* Borrows from Modernizr.
*
* @param {string} eventNameSuffix Event name, e.g. "click".
* @param {?boolean} capture Check if the capture phase is supported.
* @return {boolean} True if the event is supported.
* @internal
* @license Modernizr 3.0.0pre (Custom Build) | MIT
*/
const BN = function(t, e) {
  if (t && t.addEventListener) {
    const n = function(r) {
      const i = DN(r);
      e && Reflect.apply(e, this, [r, i]);
    };
    t.addEventListener("wheel", n, { passive: !0 });
  }
}, MN = {
  beforeMount(t, e) {
    BN(t, e.value);
  }
}, LN = ut({
  header: {
    type: String,
    default: ""
  },
  bodyStyle: {
    type: De([String, Object, Array]),
    default: ""
  },
  bodyClass: String,
  shadow: {
    type: String,
    values: ["always", "hover", "never"],
    default: "always"
  }
}), zN = ye({
  name: "ElCard"
}), jN = /* @__PURE__ */ ye({
  ...zN,
  props: LN,
  setup(t) {
    const e = ze("card");
    return (n, r) => (U(), oe("div", {
      class: X([x(e).b(), x(e).is(`${n.shadow}-shadow`)])
    }, [
      n.$slots.header || n.header ? (U(), oe("div", {
        key: 0,
        class: X(x(e).e("header"))
      }, [
        Me(n.$slots, "header", {}, () => [
          cn(st(n.header), 1)
        ])
      ], 2)) : me("v-if", !0),
      le("div", {
        class: X([x(e).e("body"), n.bodyClass]),
        style: it(n.bodyStyle)
      }, [
        Me(n.$slots, "default")
      ], 6)
    ], 2));
  }
});
var FN = /* @__PURE__ */ Ge(jN, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/card/src/card.vue"]]);
const HN = nn(FN), Lm = {
  modelValue: {
    type: [Number, String, Boolean],
    default: void 0
  },
  label: {
    type: [String, Boolean, Number, Object],
    default: void 0
  },
  indeterminate: Boolean,
  disabled: Boolean,
  checked: Boolean,
  name: {
    type: String,
    default: void 0
  },
  trueLabel: {
    type: [String, Number],
    default: void 0
  },
  falseLabel: {
    type: [String, Number],
    default: void 0
  },
  id: {
    type: String,
    default: void 0
  },
  controls: {
    type: String,
    default: void 0
  },
  border: Boolean,
  size: zr,
  tabindex: [String, Number],
  validateEvent: {
    type: Boolean,
    default: !0
  }
}, zm = {
  [Dt]: (t) => Gt(t) || mt(t) || ri(t),
  change: (t) => Gt(t) || mt(t) || ri(t)
}, Ys = Symbol("checkboxGroupContextKey"), UN = ({
  model: t,
  isChecked: e
}) => {
  const n = et(Ys, void 0), r = j(() => {
    var s, o;
    const a = (s = n == null ? void 0 : n.max) == null ? void 0 : s.value, l = (o = n == null ? void 0 : n.min) == null ? void 0 : o.value;
    return !Cr(a) && t.value.length >= a && !e.value || !Cr(l) && t.value.length <= l && e.value;
  });
  return {
    isDisabled: Fr(j(() => (n == null ? void 0 : n.disabled.value) || r.value)),
    isLimitDisabled: r
  };
}, VN = (t, {
  model: e,
  isLimitExceeded: n,
  hasOwnLabel: r,
  isDisabled: i,
  isLabeledByFormItem: s
}) => {
  const o = et(Ys, void 0), { formItem: a } = fi(), { emit: l } = ft();
  function u(m) {
    var b, p;
    return m === t.trueLabel || m === !0 ? (b = t.trueLabel) != null ? b : !0 : (p = t.falseLabel) != null ? p : !1;
  }
  function c(m, b) {
    l("change", u(m), b);
  }
  function d(m) {
    if (n.value)
      return;
    const b = m.target;
    l("change", u(b.checked), m);
  }
  async function h(m) {
    n.value || !r.value && !i.value && s.value && (m.composedPath().some((f) => f.tagName === "LABEL") || (e.value = u([!1, t.falseLabel].includes(e.value)), await rt(), c(e.value, m)));
  }
  const v = j(() => (o == null ? void 0 : o.validateEvent) || t.validateEvent);
  return Ae(() => t.modelValue, () => {
    v.value && (a == null || a.validate("change").catch((m) => Vt(m)));
  }), {
    handleChange: d,
    onClickRoot: h
  };
}, WN = (t) => {
  const e = K(!1), { emit: n } = ft(), r = et(Ys, void 0), i = j(() => Cr(r) === !1), s = K(!1);
  return {
    model: j({
      get() {
        var a, l;
        return i.value ? (a = r == null ? void 0 : r.modelValue) == null ? void 0 : a.value : (l = t.modelValue) != null ? l : e.value;
      },
      set(a) {
        var l, u;
        i.value && Br(a) ? (s.value = ((l = r == null ? void 0 : r.max) == null ? void 0 : l.value) !== void 0 && a.length > (r == null ? void 0 : r.max.value), s.value === !1 && ((u = r == null ? void 0 : r.changeEvent) == null || u.call(r, a))) : (n(Dt, a), e.value = a);
      }
    }),
    isGroup: i,
    isLimitExceeded: s
  };
}, $N = (t, e, { model: n }) => {
  const r = et(Ys, void 0), i = K(!1), s = j(() => {
    const u = n.value;
    return ri(u) ? u : Br(u) ? _n(t.label) ? u.map(_r).some((c) => Sl(c, t.label)) : u.map(_r).includes(t.label) : u != null ? u === t.trueLabel : !!u;
  }), o = jr(j(() => {
    var u;
    return (u = r == null ? void 0 : r.size) == null ? void 0 : u.value;
  }), {
    prop: !0
  }), a = jr(j(() => {
    var u;
    return (u = r == null ? void 0 : r.size) == null ? void 0 : u.value;
  })), l = j(() => !!e.default || !nr(t.label));
  return {
    checkboxButtonSize: o,
    isChecked: s,
    isFocused: i,
    checkboxSize: a,
    hasOwnLabel: l
  };
}, KN = (t, { model: e }) => {
  function n() {
    Br(e.value) && !e.value.includes(t.label) ? e.value.push(t.label) : e.value = t.trueLabel || !0;
  }
  t.checked && n();
}, jm = (t, e) => {
  const { formItem: n } = fi(), { model: r, isGroup: i, isLimitExceeded: s } = WN(t), {
    isFocused: o,
    isChecked: a,
    checkboxButtonSize: l,
    checkboxSize: u,
    hasOwnLabel: c
  } = $N(t, e, { model: r }), { isDisabled: d } = UN({ model: r, isChecked: a }), { inputId: h, isLabeledByFormItem: v } = ca(t, {
    formItemContext: n,
    disableIdGeneration: c,
    disableIdManagement: i
  }), { handleChange: m, onClickRoot: b } = VN(t, {
    model: r,
    isLimitExceeded: s,
    hasOwnLabel: c,
    isDisabled: d,
    isLabeledByFormItem: v
  });
  return KN(t, { model: r }), {
    inputId: h,
    isLabeledByFormItem: v,
    isChecked: a,
    isDisabled: d,
    isFocused: o,
    checkboxButtonSize: l,
    checkboxSize: u,
    hasOwnLabel: c,
    model: r,
    handleChange: m,
    onClickRoot: b
  };
}, GN = ["id", "indeterminate", "name", "tabindex", "disabled", "true-value", "false-value"], qN = ["id", "indeterminate", "disabled", "value", "name", "tabindex"], JN = ye({
  name: "ElCheckbox"
}), YN = /* @__PURE__ */ ye({
  ...JN,
  props: Lm,
  emits: zm,
  setup(t) {
    const e = t, n = ta(), {
      inputId: r,
      isLabeledByFormItem: i,
      isChecked: s,
      isDisabled: o,
      isFocused: a,
      checkboxSize: l,
      hasOwnLabel: u,
      model: c,
      handleChange: d,
      onClickRoot: h
    } = jm(e, n), v = ze("checkbox"), m = j(() => [
      v.b(),
      v.m(l.value),
      v.is("disabled", o.value),
      v.is("bordered", e.border),
      v.is("checked", s.value)
    ]), b = j(() => [
      v.e("input"),
      v.is("disabled", o.value),
      v.is("checked", s.value),
      v.is("indeterminate", e.indeterminate),
      v.is("focus", a.value)
    ]);
    return (p, f) => (U(), xe(Pn(!x(u) && x(i) ? "span" : "label"), {
      class: X(x(m)),
      "aria-controls": p.indeterminate ? p.controls : null,
      onClick: x(h)
    }, {
      default: fe(() => [
        le("span", {
          class: X(x(b))
        }, [
          p.trueLabel || p.falseLabel ? Bt((U(), oe("input", {
            key: 0,
            id: x(r),
            "onUpdate:modelValue": f[0] || (f[0] = (g) => on(c) ? c.value = g : null),
            class: X(x(v).e("original")),
            type: "checkbox",
            indeterminate: p.indeterminate,
            name: p.name,
            tabindex: p.tabindex,
            disabled: x(o),
            "true-value": p.trueLabel,
            "false-value": p.falseLabel,
            onChange: f[1] || (f[1] = (...g) => x(d) && x(d)(...g)),
            onFocus: f[2] || (f[2] = (g) => a.value = !0),
            onBlur: f[3] || (f[3] = (g) => a.value = !1),
            onClick: f[4] || (f[4] = dt(() => {
            }, ["stop"]))
          }, null, 42, GN)), [
            [vl, x(c)]
          ]) : Bt((U(), oe("input", {
            key: 1,
            id: x(r),
            "onUpdate:modelValue": f[5] || (f[5] = (g) => on(c) ? c.value = g : null),
            class: X(x(v).e("original")),
            type: "checkbox",
            indeterminate: p.indeterminate,
            disabled: x(o),
            value: p.label,
            name: p.name,
            tabindex: p.tabindex,
            onChange: f[6] || (f[6] = (...g) => x(d) && x(d)(...g)),
            onFocus: f[7] || (f[7] = (g) => a.value = !0),
            onBlur: f[8] || (f[8] = (g) => a.value = !1),
            onClick: f[9] || (f[9] = dt(() => {
            }, ["stop"]))
          }, null, 42, qN)), [
            [vl, x(c)]
          ]),
          le("span", {
            class: X(x(v).e("inner"))
          }, null, 2)
        ], 2),
        x(u) ? (U(), oe("span", {
          key: 0,
          class: X(x(v).e("label"))
        }, [
          Me(p.$slots, "default"),
          p.$slots.default ? me("v-if", !0) : (U(), oe(Ft, { key: 0 }, [
            cn(st(p.label), 1)
          ], 64))
        ], 2)) : me("v-if", !0)
      ]),
      _: 3
    }, 8, ["class", "aria-controls", "onClick"]));
  }
});
var QN = /* @__PURE__ */ Ge(YN, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox.vue"]]);
const ZN = ["name", "tabindex", "disabled", "true-value", "false-value"], XN = ["name", "tabindex", "disabled", "value"], e4 = ye({
  name: "ElCheckboxButton"
}), t4 = /* @__PURE__ */ ye({
  ...e4,
  props: Lm,
  emits: zm,
  setup(t) {
    const e = t, n = ta(), {
      isFocused: r,
      isChecked: i,
      isDisabled: s,
      checkboxButtonSize: o,
      model: a,
      handleChange: l
    } = jm(e, n), u = et(Ys, void 0), c = ze("checkbox"), d = j(() => {
      var v, m, b, p;
      const f = (m = (v = u == null ? void 0 : u.fill) == null ? void 0 : v.value) != null ? m : "";
      return {
        backgroundColor: f,
        borderColor: f,
        color: (p = (b = u == null ? void 0 : u.textColor) == null ? void 0 : b.value) != null ? p : "",
        boxShadow: f ? `-1px 0 0 0 ${f}` : void 0
      };
    }), h = j(() => [
      c.b("button"),
      c.bm("button", o.value),
      c.is("disabled", s.value),
      c.is("checked", i.value),
      c.is("focus", r.value)
    ]);
    return (v, m) => (U(), oe("label", {
      class: X(x(h))
    }, [
      v.trueLabel || v.falseLabel ? Bt((U(), oe("input", {
        key: 0,
        "onUpdate:modelValue": m[0] || (m[0] = (b) => on(a) ? a.value = b : null),
        class: X(x(c).be("button", "original")),
        type: "checkbox",
        name: v.name,
        tabindex: v.tabindex,
        disabled: x(s),
        "true-value": v.trueLabel,
        "false-value": v.falseLabel,
        onChange: m[1] || (m[1] = (...b) => x(l) && x(l)(...b)),
        onFocus: m[2] || (m[2] = (b) => r.value = !0),
        onBlur: m[3] || (m[3] = (b) => r.value = !1),
        onClick: m[4] || (m[4] = dt(() => {
        }, ["stop"]))
      }, null, 42, ZN)), [
        [vl, x(a)]
      ]) : Bt((U(), oe("input", {
        key: 1,
        "onUpdate:modelValue": m[5] || (m[5] = (b) => on(a) ? a.value = b : null),
        class: X(x(c).be("button", "original")),
        type: "checkbox",
        name: v.name,
        tabindex: v.tabindex,
        disabled: x(s),
        value: v.label,
        onChange: m[6] || (m[6] = (...b) => x(l) && x(l)(...b)),
        onFocus: m[7] || (m[7] = (b) => r.value = !0),
        onBlur: m[8] || (m[8] = (b) => r.value = !1),
        onClick: m[9] || (m[9] = dt(() => {
        }, ["stop"]))
      }, null, 42, XN)), [
        [vl, x(a)]
      ]),
      v.$slots.default || v.label ? (U(), oe("span", {
        key: 2,
        class: X(x(c).be("button", "inner")),
        style: it(x(i) ? x(d) : void 0)
      }, [
        Me(v.$slots, "default", {}, () => [
          cn(st(v.label), 1)
        ])
      ], 6)) : me("v-if", !0)
    ], 2));
  }
});
var Fm = /* @__PURE__ */ Ge(t4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-button.vue"]]);
const n4 = ut({
  modelValue: {
    type: De(Array),
    default: () => []
  },
  disabled: Boolean,
  min: Number,
  max: Number,
  size: zr,
  label: String,
  fill: String,
  textColor: String,
  tag: {
    type: String,
    default: "div"
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), r4 = {
  [Dt]: (t) => Br(t),
  change: (t) => Br(t)
}, i4 = ye({
  name: "ElCheckboxGroup"
}), s4 = /* @__PURE__ */ ye({
  ...i4,
  props: n4,
  emits: r4,
  setup(t, { emit: e }) {
    const n = t, r = ze("checkbox"), { formItem: i } = fi(), { inputId: s, isLabeledByFormItem: o } = ca(n, {
      formItemContext: i
    }), a = async (u) => {
      e(Dt, u), await rt(), e("change", u);
    }, l = j({
      get() {
        return n.modelValue;
      },
      set(u) {
        a(u);
      }
    });
    return qt(Ys, {
      ...TA(pn(n), [
        "size",
        "min",
        "max",
        "disabled",
        "validateEvent",
        "fill",
        "textColor"
      ]),
      modelValue: l,
      changeEvent: a
    }), Ae(() => n.modelValue, () => {
      n.validateEvent && (i == null || i.validate("change").catch((u) => Vt(u)));
    }), (u, c) => {
      var d;
      return U(), xe(Pn(u.tag), {
        id: x(s),
        class: X(x(r).b("group")),
        role: "group",
        "aria-label": x(o) ? void 0 : u.label || "checkbox-group",
        "aria-labelledby": x(o) ? (d = x(i)) == null ? void 0 : d.labelId : void 0
      }, {
        default: fe(() => [
          Me(u.$slots, "default")
        ]),
        _: 3
      }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
    };
  }
});
var Hm = /* @__PURE__ */ Ge(s4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-group.vue"]]);
const qi = nn(QN, {
  CheckboxButton: Fm,
  CheckboxGroup: Hm
});
ar(Fm);
ar(Hm);
const Um = ut({
  size: zr,
  disabled: Boolean,
  label: {
    type: [String, Number, Boolean],
    default: ""
  }
}), o4 = ut({
  ...Um,
  modelValue: {
    type: [String, Number, Boolean],
    default: ""
  },
  name: {
    type: String,
    default: ""
  },
  border: Boolean
}), Vm = {
  [Dt]: (t) => Gt(t) || mt(t) || ri(t),
  [ns]: (t) => Gt(t) || mt(t) || ri(t)
}, Wm = Symbol("radioGroupKey"), $m = (t, e) => {
  const n = K(), r = et(Wm, void 0), i = j(() => !!r), s = j({
    get() {
      return i.value ? r.modelValue : t.modelValue;
    },
    set(c) {
      i.value ? r.changeEvent(c) : e && e(Dt, c), n.value.checked = t.modelValue === t.label;
    }
  }), o = jr(j(() => r == null ? void 0 : r.size)), a = Fr(j(() => r == null ? void 0 : r.disabled)), l = K(!1), u = j(() => a.value || i.value && s.value !== t.label ? -1 : 0);
  return {
    radioRef: n,
    isGroup: i,
    radioGroup: r,
    focus: l,
    size: o,
    disabled: a,
    tabIndex: u,
    modelValue: s
  };
}, a4 = ["value", "name", "disabled"], l4 = ye({
  name: "ElRadio"
}), u4 = /* @__PURE__ */ ye({
  ...l4,
  props: o4,
  emits: Vm,
  setup(t, { emit: e }) {
    const n = t, r = ze("radio"), { radioRef: i, radioGroup: s, focus: o, size: a, disabled: l, modelValue: u } = $m(n, e);
    function c() {
      rt(() => e("change", u.value));
    }
    return (d, h) => {
      var v;
      return U(), oe("label", {
        class: X([
          x(r).b(),
          x(r).is("disabled", x(l)),
          x(r).is("focus", x(o)),
          x(r).is("bordered", d.border),
          x(r).is("checked", x(u) === d.label),
          x(r).m(x(a))
        ])
      }, [
        le("span", {
          class: X([
            x(r).e("input"),
            x(r).is("disabled", x(l)),
            x(r).is("checked", x(u) === d.label)
          ])
        }, [
          Bt(le("input", {
            ref_key: "radioRef",
            ref: i,
            "onUpdate:modelValue": h[0] || (h[0] = (m) => on(u) ? u.value = m : null),
            class: X(x(r).e("original")),
            value: d.label,
            name: d.name || ((v = x(s)) == null ? void 0 : v.name),
            disabled: x(l),
            type: "radio",
            onFocus: h[1] || (h[1] = (m) => o.value = !0),
            onBlur: h[2] || (h[2] = (m) => o.value = !1),
            onChange: c,
            onClick: h[3] || (h[3] = dt(() => {
            }, ["stop"]))
          }, null, 42, a4), [
            [Mv, x(u)]
          ]),
          le("span", {
            class: X(x(r).e("inner"))
          }, null, 2)
        ], 2),
        le("span", {
          class: X(x(r).e("label")),
          onKeydown: h[4] || (h[4] = dt(() => {
          }, ["stop"]))
        }, [
          Me(d.$slots, "default", {}, () => [
            cn(st(d.label), 1)
          ])
        ], 34)
      ], 2);
    };
  }
});
var c4 = /* @__PURE__ */ Ge(u4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio.vue"]]);
const d4 = ut({
  ...Um,
  name: {
    type: String,
    default: ""
  }
}), f4 = ["value", "name", "disabled"], h4 = ye({
  name: "ElRadioButton"
}), p4 = /* @__PURE__ */ ye({
  ...h4,
  props: d4,
  setup(t) {
    const e = t, n = ze("radio"), { radioRef: r, focus: i, size: s, disabled: o, modelValue: a, radioGroup: l } = $m(e), u = j(() => ({
      backgroundColor: (l == null ? void 0 : l.fill) || "",
      borderColor: (l == null ? void 0 : l.fill) || "",
      boxShadow: l != null && l.fill ? `-1px 0 0 0 ${l.fill}` : "",
      color: (l == null ? void 0 : l.textColor) || ""
    }));
    return (c, d) => {
      var h;
      return U(), oe("label", {
        class: X([
          x(n).b("button"),
          x(n).is("active", x(a) === c.label),
          x(n).is("disabled", x(o)),
          x(n).is("focus", x(i)),
          x(n).bm("button", x(s))
        ])
      }, [
        Bt(le("input", {
          ref_key: "radioRef",
          ref: r,
          "onUpdate:modelValue": d[0] || (d[0] = (v) => on(a) ? a.value = v : null),
          class: X(x(n).be("button", "original-radio")),
          value: c.label,
          type: "radio",
          name: c.name || ((h = x(l)) == null ? void 0 : h.name),
          disabled: x(o),
          onFocus: d[1] || (d[1] = (v) => i.value = !0),
          onBlur: d[2] || (d[2] = (v) => i.value = !1),
          onClick: d[3] || (d[3] = dt(() => {
          }, ["stop"]))
        }, null, 42, f4), [
          [Mv, x(a)]
        ]),
        le("span", {
          class: X(x(n).be("button", "inner")),
          style: it(x(a) === c.label ? x(u) : {}),
          onKeydown: d[4] || (d[4] = dt(() => {
          }, ["stop"]))
        }, [
          Me(c.$slots, "default", {}, () => [
            cn(st(c.label), 1)
          ])
        ], 38)
      ], 2);
    };
  }
});
var Km = /* @__PURE__ */ Ge(p4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio-button.vue"]]);
const v4 = ut({
  id: {
    type: String,
    default: void 0
  },
  size: zr,
  disabled: Boolean,
  modelValue: {
    type: [String, Number, Boolean],
    default: ""
  },
  fill: {
    type: String,
    default: ""
  },
  label: {
    type: String,
    default: void 0
  },
  textColor: {
    type: String,
    default: ""
  },
  name: {
    type: String,
    default: void 0
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), g4 = Vm, m4 = ["id", "aria-label", "aria-labelledby"], y4 = ye({
  name: "ElRadioGroup"
}), b4 = /* @__PURE__ */ ye({
  ...y4,
  props: v4,
  emits: g4,
  setup(t, { emit: e }) {
    const n = t, r = ze("radio"), i = ua(), s = K(), { formItem: o } = fi(), { inputId: a, isLabeledByFormItem: l } = ca(n, {
      formItemContext: o
    }), u = (d) => {
      e(Dt, d), rt(() => e("change", d));
    };
    Ct(() => {
      const d = s.value.querySelectorAll("[type=radio]"), h = d[0];
      !Array.from(d).some((v) => v.checked) && h && (h.tabIndex = 0);
    });
    const c = j(() => n.name || i.value);
    return qt(Wm, Mn({
      ...pn(n),
      changeEvent: u,
      name: c
    })), Ae(() => n.modelValue, () => {
      n.validateEvent && (o == null || o.validate("change").catch((d) => Vt(d)));
    }), (d, h) => (U(), oe("div", {
      id: x(a),
      ref_key: "radioGroupRef",
      ref: s,
      class: X(x(r).b("group")),
      role: "radiogroup",
      "aria-label": x(l) ? void 0 : d.label || "radio-group",
      "aria-labelledby": x(l) ? x(o).labelId : void 0
    }, [
      Me(d.$slots, "default")
    ], 10, m4));
  }
});
var Gm = /* @__PURE__ */ Ge(b4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio-group.vue"]]);
nn(c4, {
  RadioButton: Km,
  RadioGroup: Gm
});
const w4 = ar(Gm), _4 = ar(Km), qm = ut({
  type: {
    type: String,
    values: ["success", "info", "warning", "danger", ""],
    default: ""
  },
  closable: Boolean,
  disableTransitions: Boolean,
  hit: Boolean,
  color: {
    type: String,
    default: ""
  },
  size: {
    type: String,
    values: Yd,
    default: ""
  },
  effect: {
    type: String,
    values: ["dark", "light", "plain"],
    default: "light"
  },
  round: Boolean
}), S4 = {
  close: (t) => t instanceof MouseEvent,
  click: (t) => t instanceof MouseEvent
}, E4 = ye({
  name: "ElTag"
}), x4 = /* @__PURE__ */ ye({
  ...E4,
  props: qm,
  emits: S4,
  setup(t, { emit: e }) {
    const n = t, r = jr(), i = ze("tag"), s = j(() => {
      const { type: l, hit: u, effect: c, closable: d, round: h } = n;
      return [
        i.b(),
        i.is("closable", d),
        i.m(l),
        i.m(r.value),
        i.m(c),
        i.is("hit", u),
        i.is("round", h)
      ];
    }), o = (l) => {
      e("close", l);
    }, a = (l) => {
      e("click", l);
    };
    return (l, u) => l.disableTransitions ? (U(), oe("span", {
      key: 0,
      class: X(x(s)),
      style: it({ backgroundColor: l.color }),
      onClick: a
    }, [
      le("span", {
        class: X(x(i).e("content"))
      }, [
        Me(l.$slots, "default")
      ], 2),
      l.closable ? (U(), xe(x(_t), {
        key: 0,
        class: X(x(i).e("close")),
        onClick: dt(o, ["stop"])
      }, {
        default: fe(() => [
          ve(x(Mo))
        ]),
        _: 1
      }, 8, ["class", "onClick"])) : me("v-if", !0)
    ], 6)) : (U(), xe(Sr, {
      key: 1,
      name: `${x(i).namespace.value}-zoom-in-center`,
      appear: ""
    }, {
      default: fe(() => [
        le("span", {
          class: X(x(s)),
          style: it({ backgroundColor: l.color }),
          onClick: a
        }, [
          le("span", {
            class: X(x(i).e("content"))
          }, [
            Me(l.$slots, "default")
          ], 2),
          l.closable ? (U(), xe(x(_t), {
            key: 0,
            class: X(x(i).e("close")),
            onClick: dt(o, ["stop"])
          }, {
            default: fe(() => [
              ve(x(Mo))
            ]),
            _: 1
          }, 8, ["class", "onClick"])) : me("v-if", !0)
        ], 6)
      ]),
      _: 3
    }, 8, ["name"]));
  }
});
var A4 = /* @__PURE__ */ Ge(x4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tag/src/tag.vue"]]);
const k4 = nn(A4), C4 = ye({
  name: "ElCollapseTransition"
}), T4 = /* @__PURE__ */ ye({
  ...C4,
  setup(t) {
    const e = ze("collapse-transition"), n = (i) => {
      i.style.maxHeight = "", i.style.overflow = i.dataset.oldOverflow, i.style.paddingTop = i.dataset.oldPaddingTop, i.style.paddingBottom = i.dataset.oldPaddingBottom;
    }, r = {
      beforeEnter(i) {
        i.dataset || (i.dataset = {}), i.dataset.oldPaddingTop = i.style.paddingTop, i.dataset.oldPaddingBottom = i.style.paddingBottom, i.style.maxHeight = 0, i.style.paddingTop = 0, i.style.paddingBottom = 0;
      },
      enter(i) {
        i.dataset.oldOverflow = i.style.overflow, i.scrollHeight !== 0 ? i.style.maxHeight = `${i.scrollHeight}px` : i.style.maxHeight = 0, i.style.paddingTop = i.dataset.oldPaddingTop, i.style.paddingBottom = i.dataset.oldPaddingBottom, i.style.overflow = "hidden";
      },
      afterEnter(i) {
        i.style.maxHeight = "", i.style.overflow = i.dataset.oldOverflow;
      },
      enterCancelled(i) {
        n(i);
      },
      beforeLeave(i) {
        i.dataset || (i.dataset = {}), i.dataset.oldPaddingTop = i.style.paddingTop, i.dataset.oldPaddingBottom = i.style.paddingBottom, i.dataset.oldOverflow = i.style.overflow, i.style.maxHeight = `${i.scrollHeight}px`, i.style.overflow = "hidden";
      },
      leave(i) {
        i.scrollHeight !== 0 && (i.style.maxHeight = 0, i.style.paddingTop = 0, i.style.paddingBottom = 0);
      },
      afterLeave(i) {
        n(i);
      },
      leaveCancelled(i) {
        n(i);
      }
    };
    return (i, s) => (U(), xe(Sr, Jn({
      name: x(e).b()
    }, kb(r)), {
      default: fe(() => [
        Me(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["name"]));
  }
});
var Xa = /* @__PURE__ */ Ge(T4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/collapse-transition/src/collapse-transition.vue"]]);
Xa.install = (t) => {
  t.component(Xa.name, Xa);
};
const O4 = Xa, I4 = ye({
  name: "ElContainer"
}), N4 = /* @__PURE__ */ ye({
  ...I4,
  props: {
    direction: {
      type: String
    }
  },
  setup(t) {
    const e = t, n = ta(), r = ze("container"), i = j(() => e.direction === "vertical" ? !0 : e.direction === "horizontal" ? !1 : n && n.default ? n.default().some((o) => {
      const a = o.type.name;
      return a === "ElHeader" || a === "ElFooter";
    }) : !1);
    return (s, o) => (U(), oe("section", {
      class: X([x(r).b(), x(r).is("vertical", x(i))])
    }, [
      Me(s.$slots, "default")
    ], 2));
  }
});
var R4 = /* @__PURE__ */ Ge(N4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/container.vue"]]);
const P4 = ye({
  name: "ElAside"
}), D4 = /* @__PURE__ */ ye({
  ...P4,
  props: {
    width: {
      type: String,
      default: null
    }
  },
  setup(t) {
    const e = t, n = ze("aside"), r = j(() => e.width ? n.cssVarBlock({ width: e.width }) : {});
    return (i, s) => (U(), oe("aside", {
      class: X(x(n).b()),
      style: it(x(r))
    }, [
      Me(i.$slots, "default")
    ], 6));
  }
});
var Jm = /* @__PURE__ */ Ge(D4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/aside.vue"]]);
const B4 = ye({
  name: "ElFooter"
}), M4 = /* @__PURE__ */ ye({
  ...B4,
  props: {
    height: {
      type: String,
      default: null
    }
  },
  setup(t) {
    const e = t, n = ze("footer"), r = j(() => e.height ? n.cssVarBlock({ height: e.height }) : {});
    return (i, s) => (U(), oe("footer", {
      class: X(x(n).b()),
      style: it(x(r))
    }, [
      Me(i.$slots, "default")
    ], 6));
  }
});
var Ym = /* @__PURE__ */ Ge(M4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/footer.vue"]]);
const L4 = ye({
  name: "ElHeader"
}), z4 = /* @__PURE__ */ ye({
  ...L4,
  props: {
    height: {
      type: String,
      default: null
    }
  },
  setup(t) {
    const e = t, n = ze("header"), r = j(() => e.height ? n.cssVarBlock({
      height: e.height
    }) : {});
    return (i, s) => (U(), oe("header", {
      class: X(x(n).b()),
      style: it(x(r))
    }, [
      Me(i.$slots, "default")
    ], 6));
  }
});
var Qm = /* @__PURE__ */ Ge(z4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/header.vue"]]);
const j4 = ye({
  name: "ElMain"
}), F4 = /* @__PURE__ */ ye({
  ...j4,
  setup(t) {
    const e = ze("main");
    return (n, r) => (U(), oe("main", {
      class: X(x(e).b())
    }, [
      Me(n.$slots, "default")
    ], 2));
  }
});
var Zm = /* @__PURE__ */ Ge(F4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/main.vue"]]);
const Xm = nn(R4, {
  Aside: Jm,
  Footer: Ym,
  Header: Qm,
  Main: Zm
});
ar(Jm);
const H4 = ar(Ym), U4 = ar(Qm), ey = ar(Zm), V4 = ut({
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  contentPosition: {
    type: String,
    values: ["left", "center", "right"],
    default: "center"
  },
  borderStyle: {
    type: De(String),
    default: "solid"
  }
}), W4 = ye({
  name: "ElDivider"
}), $4 = /* @__PURE__ */ ye({
  ...W4,
  props: V4,
  setup(t) {
    const e = t, n = ze("divider"), r = j(() => n.cssVar({
      "border-style": e.borderStyle
    }));
    return (i, s) => (U(), oe("div", {
      class: X([x(n).b(), x(n).m(i.direction)]),
      style: it(x(r)),
      role: "separator"
    }, [
      i.$slots.default && i.direction !== "vertical" ? (U(), oe("div", {
        key: 0,
        class: X([x(n).e("text"), x(n).is(i.contentPosition)])
      }, [
        Me(i.$slots, "default")
      ], 2)) : me("v-if", !0)
    ], 6));
  }
});
var K4 = /* @__PURE__ */ Ge($4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/divider/src/divider.vue"]]);
const G4 = nn(K4), q4 = /* @__PURE__ */ ye({
  inheritAttrs: !1
});
function J4(t, e, n, r, i, s) {
  return Me(t.$slots, "default");
}
var Y4 = /* @__PURE__ */ Ge(q4, [["render", J4], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection.vue"]]);
const Q4 = /* @__PURE__ */ ye({
  name: "ElCollectionItem",
  inheritAttrs: !1
});
function Z4(t, e, n, r, i, s) {
  return Me(t.$slots, "default");
}
var X4 = /* @__PURE__ */ Ge(Q4, [["render", Z4], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection-item.vue"]]);
const eR = "data-el-collection-item", tR = (t) => {
  const e = `El${t}Collection`, n = `${e}Item`, r = Symbol(e), i = Symbol(n), s = {
    ...Y4,
    name: e,
    setup() {
      const a = K(null), l = /* @__PURE__ */ new Map();
      qt(r, {
        itemMap: l,
        getItems: () => {
          const c = x(a);
          if (!c)
            return [];
          const d = Array.from(c.querySelectorAll(`[${eR}]`));
          return [...l.values()].sort((v, m) => d.indexOf(v.ref) - d.indexOf(m.ref));
        },
        collectionRef: a
      });
    }
  }, o = {
    ...X4,
    name: n,
    setup(a, { attrs: l }) {
      const u = K(null), c = et(r, void 0);
      qt(i, {
        collectionItemRef: u
      }), Ct(() => {
        const d = x(u);
        d && c.itemMap.set(d, {
          ref: d,
          ...l
        });
      }), xn(() => {
        const d = x(u);
        c.itemMap.delete(d);
      });
    }
  };
  return {
    COLLECTION_INJECTION_KEY: r,
    COLLECTION_ITEM_INJECTION_KEY: i,
    ElCollection: s,
    ElCollectionItem: o
  };
}, ju = ut({
  trigger: Fo.trigger,
  effect: {
    ...qn.effect,
    default: "light"
  },
  type: {
    type: De(String)
  },
  placement: {
    type: De(String),
    default: "bottom"
  },
  popperOptions: {
    type: De(Object),
    default: () => ({})
  },
  id: String,
  size: {
    type: String,
    default: ""
  },
  splitButton: Boolean,
  hideOnClick: {
    type: Boolean,
    default: !0
  },
  loop: {
    type: Boolean,
    default: !0
  },
  showTimeout: {
    type: Number,
    default: 150
  },
  hideTimeout: {
    type: Number,
    default: 150
  },
  tabindex: {
    type: De([Number, String]),
    default: 0
  },
  maxHeight: {
    type: De([Number, String]),
    default: ""
  },
  popperClass: {
    type: String,
    default: ""
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  role: {
    type: String,
    default: "menu"
  },
  buttonProps: {
    type: De(Object)
  },
  teleported: qn.teleported
});
ut({
  command: {
    type: [Object, String, Number],
    default: () => ({})
  },
  disabled: Boolean,
  divided: Boolean,
  textValue: String,
  icon: {
    type: xi
  }
});
ut({
  onKeydown: { type: De(Function) }
});
tR("Dropdown");
const nR = ut({
  urlList: {
    type: De(Array),
    default: () => Ms([])
  },
  zIndex: {
    type: Number
  },
  initialIndex: {
    type: Number,
    default: 0
  },
  infinite: {
    type: Boolean,
    default: !0
  },
  hideOnClickModal: Boolean,
  teleported: Boolean,
  closeOnPressEscape: {
    type: Boolean,
    default: !0
  },
  zoomRate: {
    type: Number,
    default: 1.2
  },
  minScale: {
    type: Number,
    default: 0.2
  },
  maxScale: {
    type: Number,
    default: 7
  }
}), rR = {
  close: () => !0,
  switch: (t) => mt(t),
  rotate: (t) => mt(t)
}, iR = ["src"], sR = ye({
  name: "ElImageViewer"
}), oR = /* @__PURE__ */ ye({
  ...sR,
  props: nR,
  emits: rR,
  setup(t, { expose: e, emit: n }) {
    const r = t, i = {
      CONTAIN: {
        name: "contain",
        icon: mr(jg)
      },
      ORIGINAL: {
        name: "original",
        icon: mr(_2)
      }
    }, { t: s } = lr(), o = ze("image-viewer"), { nextZIndex: a } = lu(), l = K(), u = K([]), c = Ed(), d = K(!0), h = K(r.initialIndex), v = Fn(i.CONTAIN), m = K({
      scale: 1,
      deg: 0,
      offsetX: 0,
      offsetY: 0,
      enableTransition: !1
    }), b = j(() => {
      const { urlList: H } = r;
      return H.length <= 1;
    }), p = j(() => h.value === 0), f = j(() => h.value === r.urlList.length - 1), g = j(() => r.urlList[h.value]), y = j(() => [
      o.e("btn"),
      o.e("prev"),
      o.is("disabled", !r.infinite && p.value)
    ]), w = j(() => [
      o.e("btn"),
      o.e("next"),
      o.is("disabled", !r.infinite && f.value)
    ]), _ = j(() => {
      const { scale: H, deg: ie, offsetX: ne, offsetY: Y, enableTransition: de } = m.value;
      let ue = ne / H, Te = Y / H;
      switch (ie % 360) {
        case 90:
        case -270:
          [ue, Te] = [Te, -ue];
          break;
        case 180:
        case -180:
          [ue, Te] = [-ue, -Te];
          break;
        case 270:
        case -90:
          [ue, Te] = [-Te, ue];
          break;
      }
      const _e = {
        transform: `scale(${H}) rotate(${ie}deg) translate(${ue}px, ${Te}px)`,
        transition: de ? "transform .3s" : ""
      };
      return v.value.name === i.CONTAIN.name && (_e.maxWidth = _e.maxHeight = "100%"), _e;
    }), S = j(() => mt(r.zIndex) ? r.zIndex : a());
    function A() {
      k(), n("close");
    }
    function C() {
      const H = Ru((ne) => {
        switch (ne.code) {
          case sn.esc:
            r.closeOnPressEscape && A();
            break;
          case sn.space:
            F();
            break;
          case sn.left:
            te();
            break;
          case sn.up:
            V("zoomIn");
            break;
          case sn.right:
            L();
            break;
          case sn.down:
            V("zoomOut");
            break;
        }
      }), ie = Ru((ne) => {
        const Y = ne.deltaY || ne.deltaX;
        V(Y < 0 ? "zoomIn" : "zoomOut", {
          zoomRate: r.zoomRate,
          enableTransition: !1
        });
      });
      c.run(() => {
        wn(document, "keydown", H), wn(document, "wheel", ie);
      });
    }
    function k() {
      c.stop();
    }
    function O() {
      d.value = !1;
    }
    function N(H) {
      d.value = !1, H.target.alt = s("el.image.error");
    }
    function B(H) {
      if (d.value || H.button !== 0 || !l.value)
        return;
      m.value.enableTransition = !1;
      const { offsetX: ie, offsetY: ne } = m.value, Y = H.pageX, de = H.pageY, ue = Ru((_e) => {
        m.value = {
          ...m.value,
          offsetX: ie + _e.pageX - Y,
          offsetY: ne + _e.pageY - de
        };
      }), Te = wn(document, "mousemove", ue);
      wn(document, "mouseup", () => {
        Te();
      }), H.preventDefault();
    }
    function D() {
      m.value = {
        scale: 1,
        deg: 0,
        offsetX: 0,
        offsetY: 0,
        enableTransition: !1
      };
    }
    function F() {
      if (d.value)
        return;
      const H = wc(i), ie = Object.values(i), ne = v.value.name, de = (ie.findIndex((ue) => ue.name === ne) + 1) % H.length;
      v.value = i[H[de]], D();
    }
    function Z(H) {
      const ie = r.urlList.length;
      h.value = (H + ie) % ie;
    }
    function te() {
      p.value && !r.infinite || Z(h.value - 1);
    }
    function L() {
      f.value && !r.infinite || Z(h.value + 1);
    }
    function V(H, ie = {}) {
      if (d.value)
        return;
      const { minScale: ne, maxScale: Y } = r, { zoomRate: de, rotateDeg: ue, enableTransition: Te } = {
        zoomRate: r.zoomRate,
        rotateDeg: 90,
        enableTransition: !0,
        ...ie
      };
      switch (H) {
        case "zoomOut":
          m.value.scale > ne && (m.value.scale = Number.parseFloat((m.value.scale / de).toFixed(3)));
          break;
        case "zoomIn":
          m.value.scale < Y && (m.value.scale = Number.parseFloat((m.value.scale * de).toFixed(3)));
          break;
        case "clockwise":
          m.value.deg += ue, n("rotate", m.value.deg);
          break;
        case "anticlockwise":
          m.value.deg -= ue, n("rotate", m.value.deg);
          break;
      }
      m.value.enableTransition = Te;
    }
    return Ae(g, () => {
      rt(() => {
        const H = u.value[0];
        H != null && H.complete || (d.value = !0);
      });
    }), Ae(h, (H) => {
      D(), n("switch", H);
    }), Ct(() => {
      var H, ie;
      C(), (ie = (H = l.value) == null ? void 0 : H.focus) == null || ie.call(H);
    }), e({
      setActiveItem: Z
    }), (H, ie) => (U(), xe(Bv, {
      to: "body",
      disabled: !H.teleported
    }, [
      ve(Sr, {
        name: "viewer-fade",
        appear: ""
      }, {
        default: fe(() => [
          le("div", {
            ref_key: "wrapper",
            ref: l,
            tabindex: -1,
            class: X(x(o).e("wrapper")),
            style: it({ zIndex: x(S) })
          }, [
            le("div", {
              class: X(x(o).e("mask")),
              onClick: ie[0] || (ie[0] = dt((ne) => H.hideOnClickModal && A(), ["self"]))
            }, null, 2),
            me(" CLOSE "),
            le("span", {
              class: X([x(o).e("btn"), x(o).e("close")]),
              onClick: A
            }, [
              ve(x(_t), null, {
                default: fe(() => [
                  ve(x(Mo))
                ]),
                _: 1
              })
            ], 2),
            me(" ARROW "),
            x(b) ? me("v-if", !0) : (U(), oe(Ft, { key: 0 }, [
              le("span", {
                class: X(x(y)),
                onClick: te
              }, [
                ve(x(_t), null, {
                  default: fe(() => [
                    ve(x(JA))
                  ]),
                  _: 1
                })
              ], 2),
              le("span", {
                class: X(x(w)),
                onClick: L
              }, [
                ve(x(_t), null, {
                  default: fe(() => [
                    ve(x(qd))
                  ]),
                  _: 1
                })
              ], 2)
            ], 64)),
            me(" ACTIONS "),
            le("div", {
              class: X([x(o).e("btn"), x(o).e("actions")])
            }, [
              le("div", {
                class: X(x(o).e("actions__inner"))
              }, [
                ve(x(_t), {
                  onClick: ie[1] || (ie[1] = (ne) => V("zoomOut"))
                }, {
                  default: fe(() => [
                    ve(x(Y2))
                  ]),
                  _: 1
                }),
                ve(x(_t), {
                  onClick: ie[2] || (ie[2] = (ne) => V("zoomIn"))
                }, {
                  default: fe(() => [
                    ve(x(Hg))
                  ]),
                  _: 1
                }),
                le("i", {
                  class: X(x(o).e("actions__divider"))
                }, null, 2),
                ve(x(_t), { onClick: F }, {
                  default: fe(() => [
                    (U(), xe(Pn(x(v).icon)))
                  ]),
                  _: 1
                }),
                le("i", {
                  class: X(x(o).e("actions__divider"))
                }, null, 2),
                ve(x(_t), {
                  onClick: ie[3] || (ie[3] = (ne) => V("anticlockwise"))
                }, {
                  default: fe(() => [
                    ve(x(u2))
                  ]),
                  _: 1
                }),
                ve(x(_t), {
                  onClick: ie[4] || (ie[4] = (ne) => V("clockwise"))
                }, {
                  default: fe(() => [
                    ve(x(v2))
                  ]),
                  _: 1
                })
              ], 2)
            ], 2),
            me(" CANVAS "),
            le("div", {
              class: X(x(o).e("canvas"))
            }, [
              (U(!0), oe(Ft, null, Yn(H.urlList, (ne, Y) => Bt((U(), oe("img", {
                ref_for: !0,
                ref: (de) => u.value[Y] = de,
                key: ne,
                src: ne,
                style: it(x(_)),
                class: X(x(o).e("img")),
                onLoad: O,
                onError: N,
                onMousedown: B
              }, null, 46, iR)), [
                [Qn, Y === h.value]
              ])), 128))
            ], 2),
            Me(H.$slots, "default")
          ], 6)
        ]),
        _: 3
      })
    ], 8, ["disabled"]));
  }
});
var aR = /* @__PURE__ */ Ge(oR, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/image-viewer/src/image-viewer.vue"]]);
const lR = nn(aR), uR = ut({
  hideOnClickModal: Boolean,
  src: {
    type: String,
    default: ""
  },
  fit: {
    type: String,
    values: ["", "contain", "cover", "fill", "none", "scale-down"],
    default: ""
  },
  loading: {
    type: String,
    values: ["eager", "lazy"]
  },
  lazy: Boolean,
  scrollContainer: {
    type: De([String, Object])
  },
  previewSrcList: {
    type: De(Array),
    default: () => Ms([])
  },
  previewTeleported: Boolean,
  zIndex: {
    type: Number
  },
  initialIndex: {
    type: Number,
    default: 0
  },
  infinite: {
    type: Boolean,
    default: !0
  },
  closeOnPressEscape: {
    type: Boolean,
    default: !0
  },
  zoomRate: {
    type: Number,
    default: 1.2
  },
  minScale: {
    type: Number,
    default: 0.2
  },
  maxScale: {
    type: Number,
    default: 7
  }
}), cR = {
  load: (t) => t instanceof Event,
  error: (t) => t instanceof Event,
  switch: (t) => mt(t),
  close: () => !0,
  show: () => !0
}, dR = ["src", "loading"], fR = { key: 0 }, hR = ye({
  name: "ElImage",
  inheritAttrs: !1
}), pR = /* @__PURE__ */ ye({
  ...hR,
  props: uR,
  emits: cR,
  setup(t, { emit: e }) {
    const n = t;
    let r = "";
    const { t: i } = lr(), s = ze("image"), o = Rv(), a = $g(), l = K(), u = K(!1), c = K(!0), d = K(!1), h = K(), v = K(), m = St && "loading" in HTMLImageElement.prototype;
    let b, p;
    const f = j(() => [
      s.e("inner"),
      w.value && s.e("preview"),
      c.value && s.is("loading")
    ]), g = j(() => o.style), y = j(() => {
      const { fit: V } = n;
      return St && V ? { objectFit: V } : {};
    }), w = j(() => {
      const { previewSrcList: V } = n;
      return Array.isArray(V) && V.length > 0;
    }), _ = j(() => {
      const { previewSrcList: V, initialIndex: H } = n;
      let ie = H;
      return H > V.length - 1 && (ie = 0), ie;
    }), S = j(() => n.loading === "eager" ? !1 : !m && n.loading === "lazy" || n.lazy), A = () => {
      St && (c.value = !0, u.value = !1, l.value = n.src);
    };
    function C(V) {
      c.value = !1, u.value = !1, e("load", V);
    }
    function k(V) {
      c.value = !1, u.value = !0, e("error", V);
    }
    function O() {
      Aw(h.value, v.value) && (A(), D());
    }
    const N = cw(O, 200, !0);
    async function B() {
      var V;
      if (!St)
        return;
      await rt();
      const { scrollContainer: H } = n;
      Gi(H) ? v.value = H : Gt(H) && H !== "" ? v.value = (V = document.querySelector(H)) != null ? V : void 0 : h.value && (v.value = LA(h.value)), v.value && (b = wn(v, "scroll", N), setTimeout(() => O(), 100));
    }
    function D() {
      !St || !v.value || !N || (b == null || b(), v.value = void 0);
    }
    function F(V) {
      if (V.ctrlKey) {
        if (V.deltaY < 0)
          return V.preventDefault(), !1;
        if (V.deltaY > 0)
          return V.preventDefault(), !1;
      }
    }
    function Z() {
      w.value && (p = wn("wheel", F, {
        passive: !1
      }), r = document.body.style.overflow, document.body.style.overflow = "hidden", d.value = !0, e("show"));
    }
    function te() {
      p == null || p(), document.body.style.overflow = r, d.value = !1, e("close");
    }
    function L(V) {
      e("switch", V);
    }
    return Ae(() => n.src, () => {
      S.value ? (c.value = !0, u.value = !1, D(), B()) : A();
    }), Ct(() => {
      S.value ? B() : A();
    }), (V, H) => (U(), oe("div", {
      ref_key: "container",
      ref: h,
      class: X([x(s).b(), V.$attrs.class]),
      style: it(x(g))
    }, [
      u.value ? Me(V.$slots, "error", { key: 0 }, () => [
        le("div", {
          class: X(x(s).e("error"))
        }, st(x(i)("el.image.error")), 3)
      ]) : (U(), oe(Ft, { key: 1 }, [
        l.value !== void 0 ? (U(), oe("img", Jn({ key: 0 }, x(a), {
          src: l.value,
          loading: V.loading,
          style: x(y),
          class: x(f),
          onClick: Z,
          onLoad: C,
          onError: k
        }), null, 16, dR)) : me("v-if", !0),
        c.value ? (U(), oe("div", {
          key: 1,
          class: X(x(s).e("wrapper"))
        }, [
          Me(V.$slots, "placeholder", {}, () => [
            le("div", {
              class: X(x(s).e("placeholder"))
            }, null, 2)
          ])
        ], 2)) : me("v-if", !0)
      ], 64)),
      x(w) ? (U(), oe(Ft, { key: 2 }, [
        d.value ? (U(), xe(x(lR), {
          key: 0,
          "z-index": V.zIndex,
          "initial-index": x(_),
          infinite: V.infinite,
          "zoom-rate": V.zoomRate,
          "min-scale": V.minScale,
          "max-scale": V.maxScale,
          "url-list": V.previewSrcList,
          "hide-on-click-modal": V.hideOnClickModal,
          teleported: V.previewTeleported,
          "close-on-press-escape": V.closeOnPressEscape,
          onClose: te,
          onSwitch: L
        }, {
          default: fe(() => [
            V.$slots.viewer ? (U(), oe("div", fR, [
              Me(V.$slots, "viewer")
            ])) : me("v-if", !0)
          ]),
          _: 3
        }, 8, ["z-index", "initial-index", "infinite", "zoom-rate", "min-scale", "max-scale", "url-list", "hide-on-click-modal", "teleported", "close-on-press-escape"])) : me("v-if", !0)
      ], 64)) : me("v-if", !0)
    ], 6));
  }
});
var vR = /* @__PURE__ */ Ge(pR, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/image/src/image.vue"]]);
const gR = nn(vR), mR = ut({
  id: {
    type: String,
    default: void 0
  },
  step: {
    type: Number,
    default: 1
  },
  stepStrictly: Boolean,
  max: {
    type: Number,
    default: Number.POSITIVE_INFINITY
  },
  min: {
    type: Number,
    default: Number.NEGATIVE_INFINITY
  },
  modelValue: Number,
  readonly: Boolean,
  disabled: Boolean,
  size: zr,
  controls: {
    type: Boolean,
    default: !0
  },
  controlsPosition: {
    type: String,
    default: "",
    values: ["", "right"]
  },
  valueOnClear: {
    type: [String, Number, null],
    validator: (t) => t === null || mt(t) || ["min", "max"].includes(t),
    default: null
  },
  name: String,
  label: String,
  placeholder: String,
  precision: {
    type: Number,
    validator: (t) => t >= 0 && t === Number.parseInt(`${t}`, 10)
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), yR = {
  [ns]: (t, e) => e !== t,
  blur: (t) => t instanceof FocusEvent,
  focus: (t) => t instanceof FocusEvent,
  [Fi]: (t) => mt(t) || nr(t),
  [Dt]: (t) => mt(t) || nr(t)
}, bR = ["aria-label", "onKeydown"], wR = ["aria-label", "onKeydown"], _R = ye({
  name: "ElInputNumber"
}), SR = /* @__PURE__ */ ye({
  ..._R,
  props: mR,
  emits: yR,
  setup(t, { expose: e, emit: n }) {
    const r = t, { t: i } = lr(), s = ze("input-number"), o = K(), a = Mn({
      currentValue: r.modelValue,
      userInput: null
    }), { formItem: l } = fi(), u = j(() => mt(r.modelValue) && r.modelValue <= r.min), c = j(() => mt(r.modelValue) && r.modelValue >= r.max), d = j(() => {
      const D = f(r.step);
      return Cr(r.precision) ? Math.max(f(r.modelValue), D) : (D > r.precision && Vt("InputNumber", "precision should not be less than the decimal places of step"), r.precision);
    }), h = j(() => r.controls && r.controlsPosition === "right"), v = jr(), m = Fr(), b = j(() => {
      if (a.userInput !== null)
        return a.userInput;
      let D = a.currentValue;
      if (nr(D))
        return "";
      if (mt(D)) {
        if (Number.isNaN(D))
          return "";
        Cr(r.precision) || (D = D.toFixed(r.precision));
      }
      return D;
    }), p = (D, F) => {
      if (Cr(F) && (F = d.value), F === 0)
        return Math.round(D);
      let Z = String(D);
      const te = Z.indexOf(".");
      if (te === -1 || !Z.replace(".", "").split("")[te + F])
        return D;
      const H = Z.length;
      return Z.charAt(H - 1) === "5" && (Z = `${Z.slice(0, Math.max(0, H - 1))}6`), Number.parseFloat(Number(Z).toFixed(F));
    }, f = (D) => {
      if (nr(D))
        return 0;
      const F = D.toString(), Z = F.indexOf(".");
      let te = 0;
      return Z !== -1 && (te = F.length - Z - 1), te;
    }, g = (D, F = 1) => mt(D) ? p(D + r.step * F) : a.currentValue, y = () => {
      if (r.readonly || m.value || c.value)
        return;
      const D = Number(b.value) || 0, F = g(D);
      S(F), n(Fi, a.currentValue);
    }, w = () => {
      if (r.readonly || m.value || u.value)
        return;
      const D = Number(b.value) || 0, F = g(D, -1);
      S(F), n(Fi, a.currentValue);
    }, _ = (D, F) => {
      const { max: Z, min: te, step: L, precision: V, stepStrictly: H, valueOnClear: ie } = r;
      Z < te && ts("InputNumber", "min should not be greater than max.");
      let ne = Number(D);
      if (nr(D) || Number.isNaN(ne))
        return null;
      if (D === "") {
        if (ie === null)
          return null;
        ne = Gt(ie) ? { min: te, max: Z }[ie] : ie;
      }
      return H && (ne = p(Math.round(ne / L) * L, V)), Cr(V) || (ne = p(ne, V)), (ne > Z || ne < te) && (ne = ne > Z ? Z : te, F && n(Dt, ne)), ne;
    }, S = (D, F = !0) => {
      var Z;
      const te = a.currentValue, L = _(D);
      if (!F) {
        n(Dt, L);
        return;
      }
      te !== L && (a.userInput = null, n(Dt, L), n(ns, L, te), r.validateEvent && ((Z = l == null ? void 0 : l.validate) == null || Z.call(l, "change").catch((V) => Vt(V))), a.currentValue = L);
    }, A = (D) => {
      a.userInput = D;
      const F = D === "" ? null : Number(D);
      n(Fi, F), S(F, !1);
    }, C = (D) => {
      const F = D !== "" ? Number(D) : "";
      (mt(F) && !Number.isNaN(F) || D === "") && S(F), a.userInput = null;
    }, k = () => {
      var D, F;
      (F = (D = o.value) == null ? void 0 : D.focus) == null || F.call(D);
    }, O = () => {
      var D, F;
      (F = (D = o.value) == null ? void 0 : D.blur) == null || F.call(D);
    }, N = (D) => {
      n("focus", D);
    }, B = (D) => {
      var F;
      n("blur", D), r.validateEvent && ((F = l == null ? void 0 : l.validate) == null || F.call(l, "blur").catch((Z) => Vt(Z)));
    };
    return Ae(() => r.modelValue, (D) => {
      const F = _(a.userInput), Z = _(D, !0);
      !mt(F) && (!F || F !== Z) && (a.currentValue = Z, a.userInput = null);
    }, { immediate: !0 }), Ct(() => {
      var D;
      const { min: F, max: Z, modelValue: te } = r, L = (D = o.value) == null ? void 0 : D.input;
      if (L.setAttribute("role", "spinbutton"), Number.isFinite(Z) ? L.setAttribute("aria-valuemax", String(Z)) : L.removeAttribute("aria-valuemax"), Number.isFinite(F) ? L.setAttribute("aria-valuemin", String(F)) : L.removeAttribute("aria-valuemin"), L.setAttribute("aria-valuenow", a.currentValue || a.currentValue === 0 ? String(a.currentValue) : ""), L.setAttribute("aria-disabled", String(m.value)), !mt(te) && te != null) {
        let V = Number(te);
        Number.isNaN(V) && (V = null), n(Dt, V);
      }
    }), Yl(() => {
      var D, F;
      const Z = (D = o.value) == null ? void 0 : D.input;
      Z == null || Z.setAttribute("aria-valuenow", `${(F = a.currentValue) != null ? F : ""}`);
    }), e({
      focus: k,
      blur: O
    }), (D, F) => (U(), oe("div", {
      class: X([
        x(s).b(),
        x(s).m(x(v)),
        x(s).is("disabled", x(m)),
        x(s).is("without-controls", !D.controls),
        x(s).is("controls-right", x(h))
      ]),
      onDragstart: F[1] || (F[1] = dt(() => {
      }, ["prevent"]))
    }, [
      D.controls ? Bt((U(), oe("span", {
        key: 0,
        role: "button",
        "aria-label": x(i)("el.inputNumber.decrease"),
        class: X([x(s).e("decrease"), x(s).is("disabled", x(u))]),
        onKeydown: gn(w, ["enter"])
      }, [
        ve(x(_t), null, {
          default: fe(() => [
            x(h) ? (U(), xe(x(Gd), { key: 0 })) : (U(), xe(x(RC), { key: 1 }))
          ]),
          _: 1
        })
      ], 42, bR)), [
        [x(_p), w]
      ]) : me("v-if", !0),
      D.controls ? Bt((U(), oe("span", {
        key: 1,
        role: "button",
        "aria-label": x(i)("el.inputNumber.increase"),
        class: X([x(s).e("increase"), x(s).is("disabled", x(c))]),
        onKeydown: gn(y, ["enter"])
      }, [
        ve(x(_t), null, {
          default: fe(() => [
            x(h) ? (U(), xe(x(Mg), { key: 0 })) : (U(), xe(x(Fg), { key: 1 }))
          ]),
          _: 1
        })
      ], 42, wR)), [
        [x(_p), y]
      ]) : me("v-if", !0),
      ve(x(uu), {
        id: D.id,
        ref_key: "input",
        ref: o,
        type: "number",
        step: D.step,
        "model-value": x(b),
        placeholder: D.placeholder,
        readonly: D.readonly,
        disabled: x(m),
        size: x(v),
        max: D.max,
        min: D.min,
        name: D.name,
        label: D.label,
        "validate-event": !1,
        onWheel: F[0] || (F[0] = dt(() => {
        }, ["prevent"])),
        onKeydown: [
          gn(dt(y, ["prevent"]), ["up"]),
          gn(dt(w, ["prevent"]), ["down"])
        ],
        onBlur: B,
        onFocus: N,
        onInput: A,
        onChange: C
      }, null, 8, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "label", "onKeydown"])
    ], 34));
  }
});
var ER = /* @__PURE__ */ Ge(SR, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input-number/src/input-number.vue"]]);
const ty = nn(ER), ny = Symbol("ElSelectGroup"), fu = Symbol("ElSelect");
function xR(t, e) {
  const n = et(fu), r = et(ny, { disabled: !1 }), i = j(() => _n(t.value)), s = j(() => n.props.multiple ? d(n.props.modelValue, t.value) : h(t.value, n.props.modelValue)), o = j(() => {
    if (n.props.multiple) {
      const b = n.props.modelValue || [];
      return !s.value && b.length >= n.props.multipleLimit && n.props.multipleLimit > 0;
    } else
      return !1;
  }), a = j(() => t.label || (i.value ? "" : t.value)), l = j(() => t.value || t.label || ""), u = j(() => t.disabled || e.groupDisabled || o.value), c = ft(), d = (b = [], p) => {
    if (i.value) {
      const f = n.props.valueKey;
      return b && b.some((g) => _r(Cn(g, f)) === Cn(p, f));
    } else
      return b && b.includes(p);
  }, h = (b, p) => {
    if (i.value) {
      const { valueKey: f } = n.props;
      return Cn(b, f) === Cn(p, f);
    } else
      return b === p;
  }, v = () => {
    !t.disabled && !r.disabled && (n.hoverIndex = n.optionsArray.indexOf(c.proxy));
  };
  Ae(() => a.value, () => {
    !t.created && !n.props.remote && n.setSelected();
  }), Ae(() => t.value, (b, p) => {
    const { remote: f, valueKey: g } = n.props;
    if (Object.is(b, p) || (n.onOptionDestroy(p, c.proxy), n.onOptionCreate(c.proxy)), !t.created && !f) {
      if (g && _n(b) && _n(p) && b[g] === p[g])
        return;
      n.setSelected();
    }
  }), Ae(() => r.disabled, () => {
    e.groupDisabled = r.disabled;
  }, { immediate: !0 });
  const { queryChange: m } = _r(n);
  return Ae(m, (b) => {
    const { query: p } = x(b), f = new RegExp(RA(p), "i");
    e.visible = f.test(a.value) || t.created, e.visible || n.filteredOptionsCount--;
  }, { immediate: !0 }), {
    select: n,
    currentLabel: a,
    currentValue: l,
    itemSelected: s,
    isDisabled: u,
    hoverItem: v
  };
}
const AR = ye({
  name: "ElOption",
  componentName: "ElOption",
  props: {
    value: {
      required: !0,
      type: [String, Number, Boolean, Object]
    },
    label: [String, Number],
    created: Boolean,
    disabled: Boolean
  },
  setup(t) {
    const e = ze("select"), n = ua(), r = j(() => [
      e.be("dropdown", "item"),
      e.is("disabled", x(a)),
      {
        selected: x(o),
        hover: x(d)
      }
    ]), i = Mn({
      index: -1,
      groupDisabled: !1,
      visible: !0,
      hitState: !1,
      hover: !1
    }), { currentLabel: s, itemSelected: o, isDisabled: a, select: l, hoverItem: u } = xR(t, i), { visible: c, hover: d } = pn(i), h = ft().proxy;
    l.onOptionCreate(h), xn(() => {
      const m = h.value, { selected: b } = l, f = (l.props.multiple ? b : [b]).some((g) => g.value === h.value);
      rt(() => {
        l.cachedOptions.get(m) === h && !f && l.cachedOptions.delete(m);
      }), l.onOptionDestroy(m, h);
    });
    function v() {
      t.disabled !== !0 && i.groupDisabled !== !0 && l.handleOptionSelect(h);
    }
    return {
      ns: e,
      id: n,
      containerKls: r,
      currentLabel: s,
      itemSelected: o,
      isDisabled: a,
      select: l,
      hoverItem: u,
      visible: c,
      hover: d,
      selectOptionClick: v,
      states: i
    };
  }
}), kR = ["id", "aria-disabled", "aria-selected"];
function CR(t, e, n, r, i, s) {
  return Bt((U(), oe("li", {
    id: t.id,
    class: X(t.containerKls),
    role: "option",
    "aria-disabled": t.isDisabled || void 0,
    "aria-selected": t.itemSelected,
    onMouseenter: e[0] || (e[0] = (...o) => t.hoverItem && t.hoverItem(...o)),
    onClick: e[1] || (e[1] = dt((...o) => t.selectOptionClick && t.selectOptionClick(...o), ["stop"]))
  }, [
    Me(t.$slots, "default", {}, () => [
      le("span", null, st(t.currentLabel), 1)
    ])
  ], 42, kR)), [
    [Qn, t.visible]
  ]);
}
var pf = /* @__PURE__ */ Ge(AR, [["render", CR], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option.vue"]]);
const TR = ye({
  name: "ElSelectDropdown",
  componentName: "ElSelectDropdown",
  setup() {
    const t = et(fu), e = ze("select"), n = j(() => t.props.popperClass), r = j(() => t.props.multiple), i = j(() => t.props.fitInputWidth), s = K("");
    function o() {
      var a;
      s.value = `${(a = t.selectWrapper) == null ? void 0 : a.offsetWidth}px`;
    }
    return Ct(() => {
      o(), Ds(t.selectWrapper, o);
    }), {
      ns: e,
      minWidth: s,
      popperClass: n,
      isMultiple: r,
      isFitInputWidth: i
    };
  }
});
function OR(t, e, n, r, i, s) {
  return U(), oe("div", {
    class: X([t.ns.b("dropdown"), t.ns.is("multiple", t.isMultiple), t.popperClass]),
    style: it({ [t.isFitInputWidth ? "width" : "minWidth"]: t.minWidth })
  }, [
    Me(t.$slots, "default")
  ], 6);
}
var IR = /* @__PURE__ */ Ge(TR, [["render", OR], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select-dropdown.vue"]]);
function NR(t) {
  const { t: e } = lr();
  return Mn({
    options: /* @__PURE__ */ new Map(),
    cachedOptions: /* @__PURE__ */ new Map(),
    disabledOptions: /* @__PURE__ */ new Map(),
    createdLabel: null,
    createdSelected: !1,
    selected: t.multiple ? [] : {},
    inputLength: 20,
    inputWidth: 0,
    optionsCount: 0,
    filteredOptionsCount: 0,
    visible: !1,
    selectedLabel: "",
    hoverIndex: -1,
    query: "",
    previousQuery: null,
    inputHovering: !1,
    cachedPlaceHolder: "",
    currentPlaceholder: e("el.select.placeholder"),
    menuVisibleOnFocus: !1,
    isOnComposition: !1,
    prefixWidth: 11,
    mouseEnter: !1,
    focused: !1
  });
}
const RR = (t, e, n) => {
  const { t: r } = lr(), i = ze("select");
  Kg({
    from: "suffixTransition",
    replacement: "override style scheme",
    version: "2.3.0",
    scope: "props",
    ref: "https://element-plus.org/en-US/component/select.html#select-attributes"
  }, j(() => t.suffixTransition === !1));
  const s = K(null), o = K(null), a = K(null), l = K(null), u = K(null), c = K(null), d = K(null), h = K(null), v = K(), m = Fn({ query: "" }), b = Fn(""), p = K([]);
  let f = 0;
  const { form: g, formItem: y } = fi(), w = j(() => !t.filterable || t.multiple || !e.visible), _ = j(() => t.disabled || (g == null ? void 0 : g.disabled)), S = j(() => {
    const z = t.multiple ? Array.isArray(t.modelValue) && t.modelValue.length > 0 : t.modelValue !== void 0 && t.modelValue !== null && t.modelValue !== "";
    return t.clearable && !_.value && e.inputHovering && z;
  }), A = j(() => t.remote && t.filterable && !t.remoteShowSuffix ? "" : t.suffixIcon), C = j(() => i.is("reverse", A.value && e.visible && t.suffixTransition)), k = j(() => (g == null ? void 0 : g.statusIcon) && (y == null ? void 0 : y.validateState) && Vg[y == null ? void 0 : y.validateState]), O = j(() => t.remote ? 300 : 0), N = j(() => t.loading ? t.loadingText || r("el.select.loading") : t.remote && e.query === "" && e.options.size === 0 ? !1 : t.filterable && e.query && e.options.size > 0 && e.filteredOptionsCount === 0 ? t.noMatchText || r("el.select.noMatch") : e.options.size === 0 ? t.noDataText || r("el.select.noData") : null), B = j(() => {
    const z = Array.from(e.options.values()), ae = [];
    return p.value.forEach((E) => {
      const J = z.findIndex((se) => se.currentLabel === E);
      J > -1 && ae.push(z[J]);
    }), ae.length >= z.length ? ae : z;
  }), D = j(() => Array.from(e.cachedOptions.values())), F = j(() => {
    const z = B.value.filter((ae) => !ae.created).some((ae) => ae.currentLabel === e.query);
    return t.filterable && t.allowCreate && e.query !== "" && !z;
  }), Z = jr(), te = j(() => ["small"].includes(Z.value) ? "small" : "default"), L = j({
    get() {
      return e.visible && N.value !== !1;
    },
    set(z) {
      e.visible = z;
    }
  });
  Ae([() => _.value, () => Z.value, () => g == null ? void 0 : g.size], () => {
    rt(() => {
      V();
    });
  }), Ae(() => t.placeholder, (z) => {
    e.cachedPlaceHolder = e.currentPlaceholder = z, t.multiple && Array.isArray(t.modelValue) && t.modelValue.length > 0 && (e.currentPlaceholder = "");
  }), Ae(() => t.modelValue, (z, ae) => {
    t.multiple && (V(), z && z.length > 0 || o.value && e.query !== "" ? e.currentPlaceholder = "" : e.currentPlaceholder = e.cachedPlaceHolder, t.filterable && !t.reserveKeyword && (e.query = "", H(e.query))), Y(), t.filterable && !t.multiple && (e.inputLength = 20), !Sl(z, ae) && t.validateEvent && (y == null || y.validate("change").catch((E) => Vt(E)));
  }, {
    flush: "post",
    deep: !0
  }), Ae(() => e.visible, (z) => {
    var ae, E, J, se, I;
    z ? ((E = (ae = l.value) == null ? void 0 : ae.updatePopper) == null || E.call(ae), t.filterable && (e.filteredOptionsCount = e.optionsCount, e.query = t.remote ? "" : e.selectedLabel, (se = (J = a.value) == null ? void 0 : J.focus) == null || se.call(J), t.multiple ? (I = o.value) == null || I.focus() : e.selectedLabel && (e.currentPlaceholder = `${e.selectedLabel}`, e.selectedLabel = ""), H(e.query), !t.multiple && !t.remote && (m.value.query = "", ro(m), ro(b)))) : (t.filterable && (mn(t.filterMethod) && t.filterMethod(""), mn(t.remoteMethod) && t.remoteMethod("")), e.query = "", e.previousQuery = null, e.selectedLabel = "", e.inputLength = 20, e.menuVisibleOnFocus = !1, ue(), rt(() => {
      o.value && o.value.value === "" && e.selected.length === 0 && (e.currentPlaceholder = e.cachedPlaceHolder);
    }), t.multiple || (e.selected && (t.filterable && t.allowCreate && e.createdSelected && e.createdLabel ? e.selectedLabel = e.createdLabel : e.selectedLabel = e.selected.currentLabel, t.filterable && (e.query = e.selectedLabel)), t.filterable && (e.currentPlaceholder = e.cachedPlaceHolder))), n.emit("visible-change", z);
  }), Ae(() => e.options.entries(), () => {
    var z, ae, E;
    if (!St)
      return;
    (ae = (z = l.value) == null ? void 0 : z.updatePopper) == null || ae.call(z), t.multiple && V();
    const J = ((E = d.value) == null ? void 0 : E.querySelectorAll("input")) || [];
    (!t.filterable && !t.defaultFirstOption && !Cr(t.modelValue) || !Array.from(J).includes(document.activeElement)) && Y(), t.defaultFirstOption && (t.filterable || t.remote) && e.filteredOptionsCount && ne();
  }, {
    flush: "post"
  }), Ae(() => e.hoverIndex, (z) => {
    mt(z) && z > -1 ? v.value = B.value[z] || {} : v.value = {}, B.value.forEach((ae) => {
      ae.hover = v.value === ae;
    });
  });
  const V = () => {
    rt(() => {
      var z, ae;
      if (!s.value)
        return;
      const E = s.value.$el.querySelector("input");
      f = f || (E.clientHeight > 0 ? E.clientHeight + 2 : 0);
      const J = c.value, se = getComputedStyle(E).getPropertyValue(i.cssVarName("input-height")), I = Number.parseFloat(se) || eT(Z.value || (g == null ? void 0 : g.size)), W = Z.value || I === f || f <= 0 ? I : f;
      !(E.offsetParent === null) && (E.style.height = `${(e.selected.length === 0 ? W : Math.max(J ? J.clientHeight + (J.clientHeight > W ? 6 : 0) : 0, W)) - 2}px`), e.visible && N.value !== !1 && ((ae = (z = l.value) == null ? void 0 : z.updatePopper) == null || ae.call(z));
    });
  }, H = async (z) => {
    if (!(e.previousQuery === z || e.isOnComposition)) {
      if (e.previousQuery === null && (mn(t.filterMethod) || mn(t.remoteMethod))) {
        e.previousQuery = z;
        return;
      }
      e.previousQuery = z, rt(() => {
        var ae, E;
        e.visible && ((E = (ae = l.value) == null ? void 0 : ae.updatePopper) == null || E.call(ae));
      }), e.hoverIndex = -1, t.multiple && t.filterable && rt(() => {
        if (!_.value) {
          const ae = o.value.value.length * 15 + 20;
          e.inputLength = t.collapseTags ? Math.min(50, ae) : ae, ie();
        }
        V();
      }), t.remote && mn(t.remoteMethod) ? (e.hoverIndex = -1, t.remoteMethod(z)) : mn(t.filterMethod) ? (t.filterMethod(z), ro(b)) : (e.filteredOptionsCount = e.optionsCount, m.value.query = z, ro(m), ro(b)), t.defaultFirstOption && (t.filterable || t.remote) && e.filteredOptionsCount && (await rt(), ne());
    }
  }, ie = () => {
    e.currentPlaceholder !== "" && (e.currentPlaceholder = o.value.value ? "" : e.cachedPlaceHolder);
  }, ne = () => {
    const z = B.value.filter((J) => J.visible && !J.disabled && !J.states.groupDisabled), ae = z.find((J) => J.created), E = z[0];
    e.hoverIndex = Nt(B.value, ae || E);
  }, Y = () => {
    var z;
    if (t.multiple)
      e.selectedLabel = "";
    else {
      const E = de(t.modelValue);
      (z = E.props) != null && z.created ? (e.createdLabel = E.props.value, e.createdSelected = !0) : e.createdSelected = !1, e.selectedLabel = E.currentLabel, e.selected = E, t.filterable && (e.query = e.selectedLabel);
      return;
    }
    const ae = [];
    Array.isArray(t.modelValue) && t.modelValue.forEach((E) => {
      ae.push(de(E));
    }), e.selected = ae, rt(() => {
      V();
    });
  }, de = (z) => {
    let ae;
    const E = Cu(z).toLowerCase() === "object", J = Cu(z).toLowerCase() === "null", se = Cu(z).toLowerCase() === "undefined";
    for (let re = e.cachedOptions.size - 1; re >= 0; re--) {
      const Pe = D.value[re];
      if (E ? Cn(Pe.value, t.valueKey) === Cn(z, t.valueKey) : Pe.value === z) {
        ae = {
          value: z,
          currentLabel: Pe.currentLabel,
          isDisabled: Pe.isDisabled
        };
        break;
      }
    }
    if (ae)
      return ae;
    const I = E ? z.label : !J && !se ? z : "", W = {
      value: z,
      currentLabel: I
    };
    return t.multiple && (W.hitState = !1), W;
  }, ue = () => {
    setTimeout(() => {
      const z = t.valueKey;
      t.multiple ? e.selected.length > 0 ? e.hoverIndex = Math.min.apply(null, e.selected.map((ae) => B.value.findIndex((E) => Cn(E, z) === Cn(ae, z)))) : e.hoverIndex = -1 : e.hoverIndex = B.value.findIndex((ae) => Qe(ae) === Qe(e.selected));
    }, 300);
  }, Te = () => {
    var z, ae;
    _e(), (ae = (z = l.value) == null ? void 0 : z.updatePopper) == null || ae.call(z), t.multiple && V();
  }, _e = () => {
    var z;
    e.inputWidth = (z = s.value) == null ? void 0 : z.$el.offsetWidth;
  }, Fe = () => {
    t.filterable && e.query !== e.selectedLabel && (e.query = e.selectedLabel, H(e.query));
  }, Ce = ni(() => {
    Fe();
  }, O.value), tt = ni((z) => {
    H(z.target.value);
  }, O.value), je = (z) => {
    Sl(t.modelValue, z) || n.emit(ns, z);
  }, $e = (z) => bA(z, (ae) => !e.disabledOptions.has(ae)), ht = (z) => {
    if (z.code !== sn.delete) {
      if (z.target.value.length <= 0 && !lt()) {
        const ae = t.modelValue.slice(), E = $e(ae);
        if (E < 0)
          return;
        ae.splice(E, 1), n.emit(Dt, ae), je(ae);
      }
      z.target.value.length === 1 && t.modelValue.length === 0 && (e.currentPlaceholder = e.cachedPlaceHolder);
    }
  }, nt = (z, ae) => {
    const E = e.selected.indexOf(ae);
    if (E > -1 && !_.value) {
      const J = t.modelValue.slice();
      J.splice(E, 1), n.emit(Dt, J), je(J), n.emit("remove-tag", ae.value);
    }
    z.stopPropagation(), Ue();
  }, Et = (z) => {
    z.stopPropagation();
    const ae = t.multiple ? [] : "";
    if (!Gt(ae))
      for (const E of e.selected)
        E.isDisabled && ae.push(E.value);
    n.emit(Dt, ae), je(ae), e.hoverIndex = -1, e.visible = !1, n.emit("clear"), Ue();
  }, yt = (z) => {
    var ae;
    if (t.multiple) {
      const E = (t.modelValue || []).slice(), J = Nt(E, z.value);
      J > -1 ? E.splice(J, 1) : (t.multipleLimit <= 0 || E.length < t.multipleLimit) && E.push(z.value), n.emit(Dt, E), je(E), z.created && (e.query = "", H(""), e.inputLength = 20), t.filterable && ((ae = o.value) == null || ae.focus());
    } else
      n.emit(Dt, z.value), je(z.value), e.visible = !1;
    ot(), !e.visible && rt(() => {
      bt(z);
    });
  }, Nt = (z = [], ae) => {
    if (!_n(ae))
      return z.indexOf(ae);
    const E = t.valueKey;
    let J = -1;
    return z.some((se, I) => _r(Cn(se, E)) === Cn(ae, E) ? (J = I, !0) : !1), J;
  }, ot = () => {
    const z = o.value || s.value;
    z && (z == null || z.focus());
  }, bt = (z) => {
    var ae, E, J, se, I;
    const W = Array.isArray(z) ? z[0] : z;
    let re = null;
    if (W != null && W.value) {
      const Pe = B.value.filter((Oe) => Oe.value === W.value);
      Pe.length > 0 && (re = Pe[0].$el);
    }
    if (l.value && re) {
      const Pe = (se = (J = (E = (ae = l.value) == null ? void 0 : ae.popperRef) == null ? void 0 : E.contentRef) == null ? void 0 : J.querySelector) == null ? void 0 : se.call(J, `.${i.be("dropdown", "wrap")}`);
      Pe && zA(Pe, re);
    }
    (I = h.value) == null || I.handleScroll();
  }, Kt = (z) => {
    e.optionsCount++, e.filteredOptionsCount++, e.options.set(z.value, z), e.cachedOptions.set(z.value, z), z.disabled && e.disabledOptions.set(z.value, z);
  }, wt = (z, ae) => {
    e.options.get(z) === ae && (e.optionsCount--, e.filteredOptionsCount--, e.options.delete(z));
  }, xt = (z) => {
    z.code !== sn.backspace && lt(!1), e.inputLength = o.value.value.length * 15 + 20, V();
  }, lt = (z) => {
    if (!Array.isArray(e.selected))
      return;
    const ae = $e(e.selected.map((J) => J.value)), E = e.selected[ae];
    if (E)
      return z === !0 || z === !1 ? (E.hitState = z, z) : (E.hitState = !E.hitState, E.hitState);
  }, qe = (z) => {
    const ae = z.target.value;
    if (z.type === "compositionend")
      e.isOnComposition = !1, rt(() => H(ae));
    else {
      const E = ae[ae.length - 1] || "";
      e.isOnComposition = !Wg(E);
    }
  }, Rt = () => {
    rt(() => bt(e.selected));
  }, be = (z) => {
    e.focused || ((t.automaticDropdown || t.filterable) && (t.filterable && !e.visible && (e.menuVisibleOnFocus = !0), e.visible = !0), e.focused = !0, n.emit("focus", z));
  }, Ue = () => {
    var z, ae;
    e.visible ? (z = o.value || s.value) == null || z.focus() : (ae = s.value) == null || ae.focus();
  }, at = () => {
    var z, ae, E;
    e.visible = !1, (z = s.value) == null || z.blur(), (E = (ae = a.value) == null ? void 0 : ae.blur) == null || E.call(ae);
  }, Pt = (z) => {
    var ae, E, J;
    (ae = l.value) != null && ae.isFocusInsideContent(z) || (E = u.value) != null && E.isFocusInsideContent(z) || (J = d.value) != null && J.contains(z.relatedTarget) || (e.visible && Ie(), e.focused = !1, n.emit("blur", z));
  }, Qt = (z) => {
    Et(z);
  }, Ie = () => {
    e.visible = !1;
  }, Ve = (z) => {
    e.visible && (z.preventDefault(), z.stopPropagation(), e.visible = !1);
  }, Je = (z) => {
    z && !e.mouseEnter || _.value || (e.menuVisibleOnFocus ? e.menuVisibleOnFocus = !1 : (!l.value || !l.value.isFocusInsideContent()) && (e.visible = !e.visible), Ue());
  }, He = () => {
    e.visible ? B.value[e.hoverIndex] && yt(B.value[e.hoverIndex]) : Je();
  }, Qe = (z) => _n(z.value) ? Cn(z.value, t.valueKey) : z.value, At = j(() => B.value.filter((z) => z.visible).every((z) => z.disabled)), P = j(() => t.multiple ? e.selected.slice(0, t.maxCollapseTags) : []), he = j(() => t.multiple ? e.selected.slice(t.maxCollapseTags) : []), ge = (z) => {
    if (!e.visible) {
      e.visible = !0;
      return;
    }
    if (!(e.options.size === 0 || e.filteredOptionsCount === 0) && !e.isOnComposition && !At.value) {
      z === "next" ? (e.hoverIndex++, e.hoverIndex === e.options.size && (e.hoverIndex = 0)) : z === "prev" && (e.hoverIndex--, e.hoverIndex < 0 && (e.hoverIndex = e.options.size - 1));
      const ae = B.value[e.hoverIndex];
      (ae.disabled === !0 || ae.states.groupDisabled === !0 || !ae.visible) && ge(z), rt(() => bt(v.value));
    }
  }, Ne = () => {
    e.mouseEnter = !0;
  }, G = () => {
    e.mouseEnter = !1;
  }, ce = (z, ae) => {
    var E, J;
    nt(z, ae), (J = (E = u.value) == null ? void 0 : E.updatePopper) == null || J.call(E);
  }, T = j(() => ({
    maxWidth: `${x(e.inputWidth) - 32 - (k.value ? 22 : 0)}px`,
    width: "100%"
  }));
  return {
    optionList: p,
    optionsArray: B,
    hoverOption: v,
    selectSize: Z,
    handleResize: Te,
    debouncedOnInputChange: Ce,
    debouncedQueryChange: tt,
    deletePrevTag: ht,
    deleteTag: nt,
    deleteSelected: Et,
    handleOptionSelect: yt,
    scrollToOption: bt,
    readonly: w,
    resetInputHeight: V,
    showClose: S,
    iconComponent: A,
    iconReverse: C,
    showNewOption: F,
    collapseTagSize: te,
    setSelected: Y,
    managePlaceholder: ie,
    selectDisabled: _,
    emptyText: N,
    toggleLastOptionHitState: lt,
    resetInputState: xt,
    handleComposition: qe,
    onOptionCreate: Kt,
    onOptionDestroy: wt,
    handleMenuEnter: Rt,
    handleFocus: be,
    focus: Ue,
    blur: at,
    handleBlur: Pt,
    handleClearClick: Qt,
    handleClose: Ie,
    handleKeydownEscape: Ve,
    toggleMenu: Je,
    selectOption: He,
    getValueKey: Qe,
    navigateOptions: ge,
    handleDeleteTooltipTag: ce,
    dropMenuVisible: L,
    queryChange: m,
    groupQueryChange: b,
    showTagList: P,
    collapseTagList: he,
    selectTagsStyle: T,
    reference: s,
    input: o,
    iOSInput: a,
    tooltipRef: l,
    tagTooltipRef: u,
    tags: c,
    selectWrapper: d,
    scrollbar: h,
    handleMouseEnter: Ne,
    handleMouseLeave: G
  };
};
var PR = ye({
  name: "ElOptions",
  emits: ["update-options"],
  setup(t, { slots: e, emit: n }) {
    let r = [];
    function i(s, o) {
      if (s.length !== o.length)
        return !1;
      for (const [a] of s.entries())
        if (s[a] != o[a])
          return !1;
      return !0;
    }
    return () => {
      var s, o;
      const a = (s = e.default) == null ? void 0 : s.call(e), l = [];
      function u(c) {
        Array.isArray(c) && c.forEach((d) => {
          var h, v, m, b;
          const p = (h = (d == null ? void 0 : d.type) || {}) == null ? void 0 : h.name;
          p === "ElOptionGroup" ? u(!Gt(d.children) && !Array.isArray(d.children) && mn((v = d.children) == null ? void 0 : v.default) ? (m = d.children) == null ? void 0 : m.default() : d.children) : p === "ElOption" ? l.push((b = d.props) == null ? void 0 : b.label) : Array.isArray(d.children) && u(d.children);
        });
      }
      return a.length && u((o = a[0]) == null ? void 0 : o.children), i(l, r) || (r = l, n("update-options", l)), a;
    };
  }
});
const kp = "ElSelect", DR = ye({
  name: kp,
  componentName: kp,
  components: {
    ElInput: uu,
    ElSelectMenu: IR,
    ElOption: pf,
    ElOptions: PR,
    ElTag: k4,
    ElScrollbar: uf,
    ElTooltip: du,
    ElIcon: _t
  },
  directives: { ClickOutside: Om },
  props: {
    name: String,
    id: String,
    modelValue: {
      type: [Array, String, Number, Boolean, Object],
      default: void 0
    },
    autocomplete: {
      type: String,
      default: "off"
    },
    automaticDropdown: Boolean,
    size: {
      type: String,
      validator: tT
    },
    effect: {
      type: String,
      default: "light"
    },
    disabled: Boolean,
    clearable: Boolean,
    filterable: Boolean,
    allowCreate: Boolean,
    loading: Boolean,
    popperClass: {
      type: String,
      default: ""
    },
    popperOptions: {
      type: Object,
      default: () => ({})
    },
    remote: Boolean,
    loadingText: String,
    noMatchText: String,
    noDataText: String,
    remoteMethod: Function,
    filterMethod: Function,
    multiple: Boolean,
    multipleLimit: {
      type: Number,
      default: 0
    },
    placeholder: {
      type: String
    },
    defaultFirstOption: Boolean,
    reserveKeyword: {
      type: Boolean,
      default: !0
    },
    valueKey: {
      type: String,
      default: "value"
    },
    collapseTags: Boolean,
    collapseTagsTooltip: Boolean,
    maxCollapseTags: {
      type: Number,
      default: 1
    },
    teleported: qn.teleported,
    persistent: {
      type: Boolean,
      default: !0
    },
    clearIcon: {
      type: xi,
      default: iu
    },
    fitInputWidth: Boolean,
    suffixIcon: {
      type: xi,
      default: Gd
    },
    tagType: { ...qm.type, default: "info" },
    validateEvent: {
      type: Boolean,
      default: !0
    },
    remoteShowSuffix: Boolean,
    suffixTransition: {
      type: Boolean,
      default: !0
    },
    placement: {
      type: String,
      values: Js,
      default: "bottom-start"
    },
    ariaLabel: {
      type: String,
      default: void 0
    }
  },
  emits: [
    Dt,
    ns,
    "remove-tag",
    "clear",
    "visible-change",
    "focus",
    "blur"
  ],
  setup(t, e) {
    const n = ze("select"), r = ze("input"), { t: i } = lr(), s = ua(), o = NR(t), {
      optionList: a,
      optionsArray: l,
      hoverOption: u,
      selectSize: c,
      readonly: d,
      handleResize: h,
      collapseTagSize: v,
      debouncedOnInputChange: m,
      debouncedQueryChange: b,
      deletePrevTag: p,
      deleteTag: f,
      deleteSelected: g,
      handleOptionSelect: y,
      scrollToOption: w,
      setSelected: _,
      resetInputHeight: S,
      managePlaceholder: A,
      showClose: C,
      selectDisabled: k,
      iconComponent: O,
      iconReverse: N,
      showNewOption: B,
      emptyText: D,
      toggleLastOptionHitState: F,
      resetInputState: Z,
      handleComposition: te,
      onOptionCreate: L,
      onOptionDestroy: V,
      handleMenuEnter: H,
      handleFocus: ie,
      focus: ne,
      blur: Y,
      handleBlur: de,
      handleClearClick: ue,
      handleClose: Te,
      handleKeydownEscape: _e,
      toggleMenu: Fe,
      selectOption: Ce,
      getValueKey: tt,
      navigateOptions: je,
      handleDeleteTooltipTag: $e,
      dropMenuVisible: ht,
      reference: nt,
      input: Et,
      iOSInput: yt,
      tooltipRef: Nt,
      tagTooltipRef: ot,
      tags: bt,
      selectWrapper: Kt,
      scrollbar: wt,
      queryChange: xt,
      groupQueryChange: lt,
      handleMouseEnter: qe,
      handleMouseLeave: Rt,
      showTagList: be,
      collapseTagList: Ue,
      selectTagsStyle: at
    } = RR(t, o, e), {
      inputWidth: Pt,
      selected: Qt,
      inputLength: Ie,
      filteredOptionsCount: Ve,
      visible: Je,
      selectedLabel: He,
      hoverIndex: Qe,
      query: At,
      inputHovering: P,
      currentPlaceholder: he,
      menuVisibleOnFocus: ge,
      isOnComposition: Ne,
      options: G,
      cachedOptions: ce,
      optionsCount: T,
      prefixWidth: z
    } = pn(o), ae = j(() => {
      const Ye = [n.b()], ln = x(c);
      return ln && Ye.push(n.m(ln)), t.disabled && Ye.push(n.m("disabled")), Ye;
    }), E = j(() => [
      n.e("tags"),
      n.is("disabled", x(k))
    ]), J = j(() => [
      n.b("tags-wrapper"),
      { "has-prefix": x(z) && x(Qt).length }
    ]), se = j(() => [
      n.e("input"),
      n.is(x(c)),
      n.is("disabled", x(k))
    ]), I = j(() => [
      n.e("input"),
      n.is(x(c)),
      n.em("input", "iOS")
    ]), W = j(() => [
      n.is("empty", !t.allowCreate && !!x(At) && x(Ve) === 0)
    ]), re = j(() => ({ maxWidth: `${x(Pt) > 123 ? x(Pt) - 123 : x(Pt) - 75}px` })), Pe = j(() => ({
      marginLeft: `${x(z)}px`,
      flexGrow: 1,
      width: `${x(Ie) / (x(Pt) - 32)}%`,
      maxWidth: `${x(Pt) - 42}px`
    }));
    qt(fu, Mn({
      props: t,
      options: G,
      optionsArray: l,
      cachedOptions: ce,
      optionsCount: T,
      filteredOptionsCount: Ve,
      hoverIndex: Qe,
      handleOptionSelect: y,
      onOptionCreate: L,
      onOptionDestroy: V,
      selectWrapper: Kt,
      selected: Qt,
      setSelected: _,
      queryChange: xt,
      groupQueryChange: lt
    })), Ct(() => {
      o.cachedPlaceHolder = he.value = t.placeholder || (() => i("el.select.placeholder")), t.multiple && Array.isArray(t.modelValue) && t.modelValue.length > 0 && (he.value = ""), Ds(Kt, h), t.remote && t.multiple && S(), rt(() => {
        const Ye = nt.value && nt.value.$el;
        if (Ye && (Pt.value = Ye.getBoundingClientRect().width, e.slots.prefix)) {
          const ln = Ye.querySelector(`.${r.e("prefix")}`);
          z.value = Math.max(ln.getBoundingClientRect().width + 11, 30);
        }
      }), _();
    }), t.multiple && !Array.isArray(t.modelValue) && e.emit(Dt, []), !t.multiple && Array.isArray(t.modelValue) && e.emit(Dt, "");
    const Oe = j(() => {
      var Ye, ln;
      return (ln = (Ye = Nt.value) == null ? void 0 : Ye.popperRef) == null ? void 0 : ln.contentRef;
    });
    return {
      isIOS: Xv,
      onOptionsRendered: (Ye) => {
        a.value = Ye;
      },
      prefixWidth: z,
      selectSize: c,
      readonly: d,
      handleResize: h,
      collapseTagSize: v,
      debouncedOnInputChange: m,
      debouncedQueryChange: b,
      deletePrevTag: p,
      deleteTag: f,
      handleDeleteTooltipTag: $e,
      deleteSelected: g,
      handleOptionSelect: y,
      scrollToOption: w,
      inputWidth: Pt,
      selected: Qt,
      inputLength: Ie,
      filteredOptionsCount: Ve,
      visible: Je,
      selectedLabel: He,
      hoverIndex: Qe,
      query: At,
      inputHovering: P,
      currentPlaceholder: he,
      menuVisibleOnFocus: ge,
      isOnComposition: Ne,
      options: G,
      resetInputHeight: S,
      managePlaceholder: A,
      showClose: C,
      selectDisabled: k,
      iconComponent: O,
      iconReverse: N,
      showNewOption: B,
      emptyText: D,
      toggleLastOptionHitState: F,
      resetInputState: Z,
      handleComposition: te,
      handleMenuEnter: H,
      handleFocus: ie,
      focus: ne,
      blur: Y,
      handleBlur: de,
      handleClearClick: ue,
      handleClose: Te,
      handleKeydownEscape: _e,
      toggleMenu: Fe,
      selectOption: Ce,
      getValueKey: tt,
      navigateOptions: je,
      dropMenuVisible: ht,
      reference: nt,
      input: Et,
      iOSInput: yt,
      tooltipRef: Nt,
      popperPaneRef: Oe,
      tags: bt,
      selectWrapper: Kt,
      scrollbar: wt,
      wrapperKls: ae,
      tagsKls: E,
      tagWrapperKls: J,
      inputKls: se,
      iOSInputKls: I,
      scrollbarKls: W,
      selectTagsStyle: at,
      nsSelect: n,
      tagTextStyle: re,
      inputStyle: Pe,
      handleMouseEnter: qe,
      handleMouseLeave: Rt,
      showTagList: be,
      collapseTagList: Ue,
      tagTooltipRef: ot,
      contentId: s,
      hoverOption: u
    };
  }
}), BR = ["disabled", "autocomplete", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label"], MR = ["disabled"], LR = { style: { height: "100%", display: "flex", "justify-content": "center", "align-items": "center" } };
function zR(t, e, n, r, i, s) {
  const o = Mt("el-tag"), a = Mt("el-tooltip"), l = Mt("el-icon"), u = Mt("el-input"), c = Mt("el-option"), d = Mt("el-options"), h = Mt("el-scrollbar"), v = Mt("el-select-menu"), m = Ad("click-outside");
  return Bt((U(), oe("div", {
    ref: "selectWrapper",
    class: X(t.wrapperKls),
    onMouseenter: e[22] || (e[22] = (...b) => t.handleMouseEnter && t.handleMouseEnter(...b)),
    onMouseleave: e[23] || (e[23] = (...b) => t.handleMouseLeave && t.handleMouseLeave(...b)),
    onClick: e[24] || (e[24] = dt((...b) => t.toggleMenu && t.toggleMenu(...b), ["stop"]))
  }, [
    ve(a, {
      ref: "tooltipRef",
      visible: t.dropMenuVisible,
      placement: t.placement,
      teleported: t.teleported,
      "popper-class": [t.nsSelect.e("popper"), t.popperClass],
      "popper-options": t.popperOptions,
      "fallback-placements": ["bottom-start", "top-start", "right", "left"],
      effect: t.effect,
      pure: "",
      trigger: "click",
      transition: `${t.nsSelect.namespace.value}-zoom-in-top`,
      "stop-popper-mouse-event": !1,
      "gpu-acceleration": !1,
      persistent: t.persistent,
      onShow: t.handleMenuEnter
    }, {
      default: fe(() => {
        var b, p;
        return [
          le("div", {
            class: "select-trigger",
            onMouseenter: e[20] || (e[20] = (f) => t.inputHovering = !0),
            onMouseleave: e[21] || (e[21] = (f) => t.inputHovering = !1)
          }, [
            t.multiple ? (U(), oe("div", {
              key: 0,
              ref: "tags",
              tabindex: "-1",
              class: X(t.tagsKls),
              style: it(t.selectTagsStyle),
              onClick: e[15] || (e[15] = (...f) => t.focus && t.focus(...f))
            }, [
              t.collapseTags && t.selected.length ? (U(), xe(Sr, {
                key: 0,
                onAfterLeave: t.resetInputHeight
              }, {
                default: fe(() => [
                  le("span", {
                    class: X(t.tagWrapperKls)
                  }, [
                    (U(!0), oe(Ft, null, Yn(t.showTagList, (f) => (U(), xe(o, {
                      key: t.getValueKey(f),
                      closable: !t.selectDisabled && !f.isDisabled,
                      size: t.collapseTagSize,
                      hit: f.hitState,
                      type: t.tagType,
                      "disable-transitions": "",
                      onClose: (g) => t.deleteTag(g, f)
                    }, {
                      default: fe(() => [
                        le("span", {
                          class: X(t.nsSelect.e("tags-text")),
                          style: it(t.tagTextStyle)
                        }, st(f.currentLabel), 7)
                      ]),
                      _: 2
                    }, 1032, ["closable", "size", "hit", "type", "onClose"]))), 128)),
                    t.selected.length > t.maxCollapseTags ? (U(), xe(o, {
                      key: 0,
                      closable: !1,
                      size: t.collapseTagSize,
                      type: t.tagType,
                      "disable-transitions": ""
                    }, {
                      default: fe(() => [
                        t.collapseTagsTooltip ? (U(), xe(a, {
                          key: 0,
                          ref: "tagTooltipRef",
                          disabled: t.dropMenuVisible,
                          "fallback-placements": ["bottom", "top", "right", "left"],
                          effect: t.effect,
                          placement: "bottom",
                          teleported: t.teleported
                        }, {
                          default: fe(() => [
                            le("span", {
                              class: X(t.nsSelect.e("tags-text"))
                            }, "+ " + st(t.selected.length - t.maxCollapseTags), 3)
                          ]),
                          content: fe(() => [
                            le("div", {
                              class: X(t.nsSelect.e("collapse-tags"))
                            }, [
                              (U(!0), oe(Ft, null, Yn(t.collapseTagList, (f) => (U(), oe("div", {
                                key: t.getValueKey(f),
                                class: X(t.nsSelect.e("collapse-tag"))
                              }, [
                                ve(o, {
                                  class: "in-tooltip",
                                  closable: !t.selectDisabled && !f.isDisabled,
                                  size: t.collapseTagSize,
                                  hit: f.hitState,
                                  type: t.tagType,
                                  "disable-transitions": "",
                                  style: { margin: "2px" },
                                  onClose: (g) => t.handleDeleteTooltipTag(g, f)
                                }, {
                                  default: fe(() => [
                                    le("span", {
                                      class: X(t.nsSelect.e("tags-text")),
                                      style: it({
                                        maxWidth: t.inputWidth - 75 + "px"
                                      })
                                    }, st(f.currentLabel), 7)
                                  ]),
                                  _: 2
                                }, 1032, ["closable", "size", "hit", "type", "onClose"])
                              ], 2))), 128))
                            ], 2)
                          ]),
                          _: 1
                        }, 8, ["disabled", "effect", "teleported"])) : (U(), oe("span", {
                          key: 1,
                          class: X(t.nsSelect.e("tags-text"))
                        }, "+ " + st(t.selected.length - t.maxCollapseTags), 3))
                      ]),
                      _: 1
                    }, 8, ["size", "type"])) : me("v-if", !0)
                  ], 2)
                ]),
                _: 1
              }, 8, ["onAfterLeave"])) : me("v-if", !0),
              t.collapseTags ? me("v-if", !0) : (U(), xe(Sr, {
                key: 1,
                onAfterLeave: t.resetInputHeight
              }, {
                default: fe(() => [
                  le("span", {
                    class: X(t.tagWrapperKls),
                    style: it(t.prefixWidth && t.selected.length ? { marginLeft: `${t.prefixWidth}px` } : "")
                  }, [
                    (U(!0), oe(Ft, null, Yn(t.selected, (f) => (U(), xe(o, {
                      key: t.getValueKey(f),
                      closable: !t.selectDisabled && !f.isDisabled,
                      size: t.collapseTagSize,
                      hit: f.hitState,
                      type: t.tagType,
                      "disable-transitions": "",
                      onClose: (g) => t.deleteTag(g, f)
                    }, {
                      default: fe(() => [
                        le("span", {
                          class: X(t.nsSelect.e("tags-text")),
                          style: it({ maxWidth: t.inputWidth - 75 + "px" })
                        }, st(f.currentLabel), 7)
                      ]),
                      _: 2
                    }, 1032, ["closable", "size", "hit", "type", "onClose"]))), 128))
                  ], 6)
                ]),
                _: 1
              }, 8, ["onAfterLeave"])),
              t.filterable && !t.selectDisabled ? Bt((U(), oe("input", {
                key: 2,
                ref: "input",
                "onUpdate:modelValue": e[0] || (e[0] = (f) => t.query = f),
                type: "text",
                class: X(t.inputKls),
                disabled: t.selectDisabled,
                autocomplete: t.autocomplete,
                style: it(t.inputStyle),
                role: "combobox",
                "aria-activedescendant": ((b = t.hoverOption) == null ? void 0 : b.id) || "",
                "aria-controls": t.contentId,
                "aria-expanded": t.dropMenuVisible,
                "aria-label": t.ariaLabel,
                "aria-autocomplete": "none",
                "aria-haspopup": "listbox",
                onFocus: e[1] || (e[1] = (...f) => t.handleFocus && t.handleFocus(...f)),
                onBlur: e[2] || (e[2] = (...f) => t.handleBlur && t.handleBlur(...f)),
                onKeyup: e[3] || (e[3] = (...f) => t.managePlaceholder && t.managePlaceholder(...f)),
                onKeydown: [
                  e[4] || (e[4] = (...f) => t.resetInputState && t.resetInputState(...f)),
                  e[5] || (e[5] = gn(dt((f) => t.navigateOptions("next"), ["prevent"]), ["down"])),
                  e[6] || (e[6] = gn(dt((f) => t.navigateOptions("prev"), ["prevent"]), ["up"])),
                  e[7] || (e[7] = gn((...f) => t.handleKeydownEscape && t.handleKeydownEscape(...f), ["esc"])),
                  e[8] || (e[8] = gn(dt((...f) => t.selectOption && t.selectOption(...f), ["stop", "prevent"]), ["enter"])),
                  e[9] || (e[9] = gn((...f) => t.deletePrevTag && t.deletePrevTag(...f), ["delete"])),
                  e[10] || (e[10] = gn((f) => t.visible = !1, ["tab"]))
                ],
                onCompositionstart: e[11] || (e[11] = (...f) => t.handleComposition && t.handleComposition(...f)),
                onCompositionupdate: e[12] || (e[12] = (...f) => t.handleComposition && t.handleComposition(...f)),
                onCompositionend: e[13] || (e[13] = (...f) => t.handleComposition && t.handleComposition(...f)),
                onInput: e[14] || (e[14] = (...f) => t.debouncedQueryChange && t.debouncedQueryChange(...f))
              }, null, 46, BR)), [
                [Cb, t.query]
              ]) : me("v-if", !0)
            ], 6)) : me("v-if", !0),
            t.isIOS && !t.multiple && t.filterable && t.readonly ? (U(), oe("input", {
              key: 1,
              ref: "iOSInput",
              class: X(t.iOSInputKls),
              disabled: t.selectDisabled,
              type: "text"
            }, null, 10, MR)) : me("v-if", !0),
            ve(u, {
              id: t.id,
              ref: "reference",
              modelValue: t.selectedLabel,
              "onUpdate:modelValue": e[16] || (e[16] = (f) => t.selectedLabel = f),
              type: "text",
              placeholder: typeof t.currentPlaceholder == "function" ? t.currentPlaceholder() : t.currentPlaceholder,
              name: t.name,
              autocomplete: t.autocomplete,
              size: t.selectSize,
              disabled: t.selectDisabled,
              readonly: t.readonly,
              "validate-event": !1,
              class: X([t.nsSelect.is("focus", t.visible)]),
              tabindex: t.multiple && t.filterable ? -1 : void 0,
              role: "combobox",
              "aria-activedescendant": ((p = t.hoverOption) == null ? void 0 : p.id) || "",
              "aria-controls": t.contentId,
              "aria-expanded": t.dropMenuVisible,
              label: t.ariaLabel,
              "aria-autocomplete": "none",
              "aria-haspopup": "listbox",
              onFocus: t.handleFocus,
              onBlur: t.handleBlur,
              onInput: t.debouncedOnInputChange,
              onPaste: t.debouncedOnInputChange,
              onCompositionstart: t.handleComposition,
              onCompositionupdate: t.handleComposition,
              onCompositionend: t.handleComposition,
              onKeydown: [
                e[17] || (e[17] = gn(dt((f) => t.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
                e[18] || (e[18] = gn(dt((f) => t.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
                gn(dt(t.selectOption, ["stop", "prevent"]), ["enter"]),
                gn(t.handleKeydownEscape, ["esc"]),
                e[19] || (e[19] = gn((f) => t.visible = !1, ["tab"]))
              ]
            }, ac({
              suffix: fe(() => [
                t.iconComponent && !t.showClose ? (U(), xe(l, {
                  key: 0,
                  class: X([t.nsSelect.e("caret"), t.nsSelect.e("icon"), t.iconReverse])
                }, {
                  default: fe(() => [
                    (U(), xe(Pn(t.iconComponent)))
                  ]),
                  _: 1
                }, 8, ["class"])) : me("v-if", !0),
                t.showClose && t.clearIcon ? (U(), xe(l, {
                  key: 1,
                  class: X([t.nsSelect.e("caret"), t.nsSelect.e("icon")]),
                  onClick: t.handleClearClick
                }, {
                  default: fe(() => [
                    (U(), xe(Pn(t.clearIcon)))
                  ]),
                  _: 1
                }, 8, ["class", "onClick"])) : me("v-if", !0)
              ]),
              _: 2
            }, [
              t.$slots.prefix ? {
                name: "prefix",
                fn: fe(() => [
                  le("div", LR, [
                    Me(t.$slots, "prefix")
                  ])
                ])
              } : void 0
            ]), 1032, ["id", "modelValue", "placeholder", "name", "autocomplete", "size", "disabled", "readonly", "class", "tabindex", "aria-activedescendant", "aria-controls", "aria-expanded", "label", "onFocus", "onBlur", "onInput", "onPaste", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onKeydown"])
          ], 32)
        ];
      }),
      content: fe(() => [
        ve(v, null, {
          default: fe(() => [
            Bt(ve(h, {
              id: t.contentId,
              ref: "scrollbar",
              tag: "ul",
              "wrap-class": t.nsSelect.be("dropdown", "wrap"),
              "view-class": t.nsSelect.be("dropdown", "list"),
              class: X(t.scrollbarKls),
              role: "listbox",
              "aria-label": t.ariaLabel,
              "aria-orientation": "vertical"
            }, {
              default: fe(() => [
                t.showNewOption ? (U(), xe(c, {
                  key: 0,
                  value: t.query,
                  created: !0
                }, null, 8, ["value"])) : me("v-if", !0),
                ve(d, { onUpdateOptions: t.onOptionsRendered }, {
                  default: fe(() => [
                    Me(t.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["onUpdateOptions"])
              ]),
              _: 3
            }, 8, ["id", "wrap-class", "view-class", "class", "aria-label"]), [
              [Qn, t.options.size > 0 && !t.loading]
            ]),
            t.emptyText && (!t.allowCreate || t.loading || t.allowCreate && t.options.size === 0) ? (U(), oe(Ft, { key: 0 }, [
              t.$slots.empty ? Me(t.$slots, "empty", { key: 0 }) : (U(), oe("p", {
                key: 1,
                class: X(t.nsSelect.be("dropdown", "empty"))
              }, st(t.emptyText), 3))
            ], 64)) : me("v-if", !0)
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "effect", "transition", "persistent", "onShow"])
  ], 34)), [
    [m, t.handleClose, t.popperPaneRef]
  ]);
}
var jR = /* @__PURE__ */ Ge(DR, [["render", zR], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select.vue"]]);
const FR = ye({
  name: "ElOptionGroup",
  componentName: "ElOptionGroup",
  props: {
    label: String,
    disabled: Boolean
  },
  setup(t) {
    const e = ze("select"), n = K(!0), r = ft(), i = K([]);
    qt(ny, Mn({
      ...pn(t)
    }));
    const s = et(fu);
    Ct(() => {
      i.value = o(r.subTree);
    });
    const o = (l) => {
      const u = [];
      return Array.isArray(l.children) && l.children.forEach((c) => {
        var d;
        c.type && c.type.name === "ElOption" && c.component && c.component.proxy ? u.push(c.component.proxy) : (d = c.children) != null && d.length && u.push(...o(c));
      }), u;
    }, { groupQueryChange: a } = _r(s);
    return Ae(a, () => {
      n.value = i.value.some((l) => l.visible === !0);
    }, { flush: "post" }), {
      visible: n,
      ns: e
    };
  }
});
function HR(t, e, n, r, i, s) {
  return Bt((U(), oe("ul", {
    class: X(t.ns.be("group", "wrap"))
  }, [
    le("li", {
      class: X(t.ns.be("group", "title"))
    }, st(t.label), 3),
    le("li", null, [
      le("ul", {
        class: X(t.ns.b("group"))
      }, [
        Me(t.$slots, "default")
      ], 2)
    ])
  ], 2)), [
    [Qn, t.visible]
  ]);
}
var ry = /* @__PURE__ */ Ge(FR, [["render", HR], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option-group.vue"]]);
const UR = nn(jR, {
  Option: pf,
  OptionGroup: ry
}), VR = ar(pf);
ar(ry);
const WR = ut({
  trigger: Fo.trigger,
  placement: ju.placement,
  disabled: Fo.disabled,
  visible: qn.visible,
  transition: qn.transition,
  popperOptions: ju.popperOptions,
  tabindex: ju.tabindex,
  content: qn.content,
  popperStyle: qn.popperStyle,
  popperClass: qn.popperClass,
  enterable: {
    ...qn.enterable,
    default: !0
  },
  effect: {
    ...qn.effect,
    default: "light"
  },
  teleported: qn.teleported,
  title: String,
  width: {
    type: [String, Number],
    default: 150
  },
  offset: {
    type: Number,
    default: void 0
  },
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  autoClose: {
    type: Number,
    default: 0
  },
  showArrow: {
    type: Boolean,
    default: !0
  },
  persistent: {
    type: Boolean,
    default: !0
  },
  "onUpdate:visible": {
    type: Function
  }
}), $R = {
  "update:visible": (t) => ri(t),
  "before-enter": () => !0,
  "before-leave": () => !0,
  "after-enter": () => !0,
  "after-leave": () => !0
}, KR = "onUpdate:visible", GR = ye({
  name: "ElPopover"
}), qR = /* @__PURE__ */ ye({
  ...GR,
  props: WR,
  emits: $R,
  setup(t, { expose: e, emit: n }) {
    const r = t, i = j(() => r[KR]), s = ze("popover"), o = K(), a = j(() => {
      var p;
      return (p = x(o)) == null ? void 0 : p.popperRef;
    }), l = j(() => [
      {
        width: El(r.width)
      },
      r.popperStyle
    ]), u = j(() => [s.b(), r.popperClass, { [s.m("plain")]: !!r.content }]), c = j(() => r.transition === `${s.namespace.value}-fade-in-linear`), d = () => {
      var p;
      (p = o.value) == null || p.hide();
    }, h = () => {
      n("before-enter");
    }, v = () => {
      n("before-leave");
    }, m = () => {
      n("after-enter");
    }, b = () => {
      n("update:visible", !1), n("after-leave");
    };
    return e({
      popperRef: a,
      hide: d
    }), (p, f) => (U(), xe(x(du), Jn({
      ref_key: "tooltipRef",
      ref: o
    }, p.$attrs, {
      trigger: p.trigger,
      placement: p.placement,
      disabled: p.disabled,
      visible: p.visible,
      transition: p.transition,
      "popper-options": p.popperOptions,
      tabindex: p.tabindex,
      content: p.content,
      offset: p.offset,
      "show-after": p.showAfter,
      "hide-after": p.hideAfter,
      "auto-close": p.autoClose,
      "show-arrow": p.showArrow,
      "aria-label": p.title,
      effect: p.effect,
      enterable: p.enterable,
      "popper-class": x(u),
      "popper-style": x(l),
      teleported: p.teleported,
      persistent: p.persistent,
      "gpu-acceleration": x(c),
      "onUpdate:visible": x(i),
      onBeforeShow: h,
      onBeforeHide: v,
      onShow: m,
      onHide: b
    }), {
      content: fe(() => [
        p.title ? (U(), oe("div", {
          key: 0,
          class: X(x(s).e("title")),
          role: "title"
        }, st(p.title), 3)) : me("v-if", !0),
        Me(p.$slots, "default", {}, () => [
          cn(st(p.content), 1)
        ])
      ]),
      default: fe(() => [
        p.$slots.reference ? Me(p.$slots, "reference", { key: 0 }) : me("v-if", !0)
      ]),
      _: 3
    }, 16, ["trigger", "placement", "disabled", "visible", "transition", "popper-options", "tabindex", "content", "offset", "show-after", "hide-after", "auto-close", "show-arrow", "aria-label", "effect", "enterable", "popper-class", "popper-style", "teleported", "persistent", "gpu-acceleration", "onUpdate:visible"]));
  }
});
var JR = /* @__PURE__ */ Ge(qR, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popover/src/popover.vue"]]);
const Cp = (t, e) => {
  const n = e.arg || e.value, r = n == null ? void 0 : n.popperRef;
  r && (r.triggerRef = t);
};
var YR = {
  mounted(t, e) {
    Cp(t, e);
  },
  updated(t, e) {
    Cp(t, e);
  }
};
const QR = "popover", iy = Z2(YR, QR), da = nn(JR, {
  directive: iy
}), ZR = ut({
  type: {
    type: String,
    default: "line",
    values: ["line", "circle", "dashboard"]
  },
  percentage: {
    type: Number,
    default: 0,
    validator: (t) => t >= 0 && t <= 100
  },
  status: {
    type: String,
    default: "",
    values: ["", "success", "exception", "warning"]
  },
  indeterminate: {
    type: Boolean,
    default: !1
  },
  duration: {
    type: Number,
    default: 3
  },
  strokeWidth: {
    type: Number,
    default: 6
  },
  strokeLinecap: {
    type: De(String),
    default: "round"
  },
  textInside: {
    type: Boolean,
    default: !1
  },
  width: {
    type: Number,
    default: 126
  },
  showText: {
    type: Boolean,
    default: !0
  },
  color: {
    type: De([
      String,
      Array,
      Function
    ]),
    default: ""
  },
  striped: Boolean,
  stripedFlow: Boolean,
  format: {
    type: De(Function),
    default: (t) => `${t}%`
  }
}), XR = ["aria-valuenow"], eP = { viewBox: "0 0 100 100" }, tP = ["d", "stroke", "stroke-linecap", "stroke-width"], nP = ["d", "stroke", "opacity", "stroke-linecap", "stroke-width"], rP = { key: 0 }, iP = ye({
  name: "ElProgress"
}), sP = /* @__PURE__ */ ye({
  ...iP,
  props: ZR,
  setup(t) {
    const e = t, n = {
      success: "#13ce66",
      exception: "#ff4949",
      warning: "#e6a23c",
      default: "#20a0ff"
    }, r = ze("progress"), i = j(() => ({
      width: `${e.percentage}%`,
      animationDuration: `${e.duration}s`,
      backgroundColor: g(e.percentage)
    })), s = j(() => (e.strokeWidth / e.width * 100).toFixed(1)), o = j(() => ["circle", "dashboard"].includes(e.type) ? Number.parseInt(`${50 - Number.parseFloat(s.value) / 2}`, 10) : 0), a = j(() => {
      const y = o.value, w = e.type === "dashboard";
      return `
          M 50 50
          m 0 ${w ? "" : "-"}${y}
          a ${y} ${y} 0 1 1 0 ${w ? "-" : ""}${y * 2}
          a ${y} ${y} 0 1 1 0 ${w ? "" : "-"}${y * 2}
          `;
    }), l = j(() => 2 * Math.PI * o.value), u = j(() => e.type === "dashboard" ? 0.75 : 1), c = j(() => `${-1 * l.value * (1 - u.value) / 2}px`), d = j(() => ({
      strokeDasharray: `${l.value * u.value}px, ${l.value}px`,
      strokeDashoffset: c.value
    })), h = j(() => ({
      strokeDasharray: `${l.value * u.value * (e.percentage / 100)}px, ${l.value}px`,
      strokeDashoffset: c.value,
      transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s"
    })), v = j(() => {
      let y;
      return e.color ? y = g(e.percentage) : y = n[e.status] || n.default, y;
    }), m = j(() => e.status === "warning" ? j2 : e.type === "line" ? e.status === "success" ? Jd : iu : e.status === "success" ? Lg : Mo), b = j(() => e.type === "line" ? 12 + e.strokeWidth * 0.4 : e.width * 0.111111 + 2), p = j(() => e.format(e.percentage));
    function f(y) {
      const w = 100 / y.length;
      return y.map((S, A) => Gt(S) ? {
        color: S,
        percentage: (A + 1) * w
      } : S).sort((S, A) => S.percentage - A.percentage);
    }
    const g = (y) => {
      var w;
      const { color: _ } = e;
      if (mn(_))
        return _(y);
      if (Gt(_))
        return _;
      {
        const S = f(_);
        for (const A of S)
          if (A.percentage > y)
            return A.color;
        return (w = S[S.length - 1]) == null ? void 0 : w.color;
      }
    };
    return (y, w) => (U(), oe("div", {
      class: X([
        x(r).b(),
        x(r).m(y.type),
        x(r).is(y.status),
        {
          [x(r).m("without-text")]: !y.showText,
          [x(r).m("text-inside")]: y.textInside
        }
      ]),
      role: "progressbar",
      "aria-valuenow": y.percentage,
      "aria-valuemin": "0",
      "aria-valuemax": "100"
    }, [
      y.type === "line" ? (U(), oe("div", {
        key: 0,
        class: X(x(r).b("bar"))
      }, [
        le("div", {
          class: X(x(r).be("bar", "outer")),
          style: it({ height: `${y.strokeWidth}px` })
        }, [
          le("div", {
            class: X([
              x(r).be("bar", "inner"),
              { [x(r).bem("bar", "inner", "indeterminate")]: y.indeterminate },
              { [x(r).bem("bar", "inner", "striped")]: y.striped },
              { [x(r).bem("bar", "inner", "striped-flow")]: y.stripedFlow }
            ]),
            style: it(x(i))
          }, [
            (y.showText || y.$slots.default) && y.textInside ? (U(), oe("div", {
              key: 0,
              class: X(x(r).be("bar", "innerText"))
            }, [
              Me(y.$slots, "default", { percentage: y.percentage }, () => [
                le("span", null, st(x(p)), 1)
              ])
            ], 2)) : me("v-if", !0)
          ], 6)
        ], 6)
      ], 2)) : (U(), oe("div", {
        key: 1,
        class: X(x(r).b("circle")),
        style: it({ height: `${y.width}px`, width: `${y.width}px` })
      }, [
        (U(), oe("svg", eP, [
          le("path", {
            class: X(x(r).be("circle", "track")),
            d: x(a),
            stroke: `var(${x(r).cssVarName("fill-color-light")}, #e5e9f2)`,
            "stroke-linecap": y.strokeLinecap,
            "stroke-width": x(s),
            fill: "none",
            style: it(x(d))
          }, null, 14, tP),
          le("path", {
            class: X(x(r).be("circle", "path")),
            d: x(a),
            stroke: x(v),
            fill: "none",
            opacity: y.percentage ? 1 : 0,
            "stroke-linecap": y.strokeLinecap,
            "stroke-width": x(s),
            style: it(x(h))
          }, null, 14, nP)
        ]))
      ], 6)),
      (y.showText || y.$slots.default) && !y.textInside ? (U(), oe("div", {
        key: 2,
        class: X(x(r).e("text")),
        style: it({ fontSize: `${x(b)}px` })
      }, [
        Me(y.$slots, "default", { percentage: y.percentage }, () => [
          y.status ? (U(), xe(x(_t), { key: 1 }, {
            default: fe(() => [
              (U(), xe(Pn(x(m))))
            ]),
            _: 1
          })) : (U(), oe("span", rP, st(x(p)), 1))
        ])
      ], 6)) : me("v-if", !0)
    ], 10, XR));
  }
});
var oP = /* @__PURE__ */ Ge(sP, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/progress/src/progress.vue"]]);
const sy = nn(oP), oy = Symbol("sliderContextKey"), aP = ut({
  modelValue: {
    type: De([Number, Array]),
    default: 0
  },
  id: {
    type: String,
    default: void 0
  },
  min: {
    type: Number,
    default: 0
  },
  max: {
    type: Number,
    default: 100
  },
  step: {
    type: Number,
    default: 1
  },
  showInput: Boolean,
  showInputControls: {
    type: Boolean,
    default: !0
  },
  size: zr,
  inputSize: zr,
  showStops: Boolean,
  showTooltip: {
    type: Boolean,
    default: !0
  },
  formatTooltip: {
    type: De(Function),
    default: void 0
  },
  disabled: Boolean,
  range: Boolean,
  vertical: Boolean,
  height: String,
  debounce: {
    type: Number,
    default: 300
  },
  label: {
    type: String,
    default: void 0
  },
  rangeStartLabel: {
    type: String,
    default: void 0
  },
  rangeEndLabel: {
    type: String,
    default: void 0
  },
  formatValueText: {
    type: De(Function),
    default: void 0
  },
  tooltipClass: {
    type: String,
    default: void 0
  },
  placement: {
    type: String,
    values: Js,
    default: "top"
  },
  marks: {
    type: De(Object)
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), Fu = (t) => mt(t) || Br(t) && t.every(mt), lP = {
  [Dt]: Fu,
  [Fi]: Fu,
  [ns]: Fu
}, uP = (t, e, n) => {
  const r = K();
  return Ct(async () => {
    t.range ? (Array.isArray(t.modelValue) ? (e.firstValue = Math.max(t.min, t.modelValue[0]), e.secondValue = Math.min(t.max, t.modelValue[1])) : (e.firstValue = t.min, e.secondValue = t.max), e.oldValue = [e.firstValue, e.secondValue]) : (typeof t.modelValue != "number" || Number.isNaN(t.modelValue) ? e.firstValue = t.min : e.firstValue = Math.min(t.max, Math.max(t.min, t.modelValue)), e.oldValue = e.firstValue), wn(window, "resize", n), await rt(), n();
  }), {
    sliderWrapper: r
  };
}, cP = (t) => j(() => t.marks ? Object.keys(t.marks).map(Number.parseFloat).sort((n, r) => n - r).filter((n) => n <= t.max && n >= t.min).map((n) => ({
  point: n,
  position: (n - t.min) * 100 / (t.max - t.min),
  mark: t.marks[n]
})) : []), dP = (t, e, n) => {
  const { form: r, formItem: i } = fi(), s = Fn(), o = K(), a = K(), l = {
    firstButton: o,
    secondButton: a
  }, u = j(() => t.disabled || (r == null ? void 0 : r.disabled) || !1), c = j(() => Math.min(e.firstValue, e.secondValue)), d = j(() => Math.max(e.firstValue, e.secondValue)), h = j(() => t.range ? `${100 * (d.value - c.value) / (t.max - t.min)}%` : `${100 * (e.firstValue - t.min) / (t.max - t.min)}%`), v = j(() => t.range ? `${100 * (c.value - t.min) / (t.max - t.min)}%` : "0%"), m = j(() => t.vertical ? { height: t.height } : {}), b = j(() => t.vertical ? {
    height: h.value,
    bottom: v.value
  } : {
    width: h.value,
    left: v.value
  }), p = () => {
    s.value && (e.sliderSize = s.value[`client${t.vertical ? "Height" : "Width"}`]);
  }, f = (N) => {
    const B = t.min + N * (t.max - t.min) / 100;
    if (!t.range)
      return o;
    let D;
    return Math.abs(c.value - B) < Math.abs(d.value - B) ? D = e.firstValue < e.secondValue ? "firstButton" : "secondButton" : D = e.firstValue > e.secondValue ? "firstButton" : "secondButton", l[D];
  }, g = (N) => {
    const B = f(N);
    return B.value.setPosition(N), B;
  }, y = (N) => {
    e.firstValue = N, _(t.range ? [c.value, d.value] : N);
  }, w = (N) => {
    e.secondValue = N, t.range && _([c.value, d.value]);
  }, _ = (N) => {
    n(Dt, N), n(Fi, N);
  }, S = async () => {
    await rt(), n(ns, t.range ? [c.value, d.value] : t.modelValue);
  }, A = (N) => {
    var B, D, F, Z, te, L;
    if (u.value || e.dragging)
      return;
    p();
    let V = 0;
    if (t.vertical) {
      const H = (F = (D = (B = N.touches) == null ? void 0 : B.item(0)) == null ? void 0 : D.clientY) != null ? F : N.clientY;
      V = (s.value.getBoundingClientRect().bottom - H) / e.sliderSize * 100;
    } else {
      const H = (L = (te = (Z = N.touches) == null ? void 0 : Z.item(0)) == null ? void 0 : te.clientX) != null ? L : N.clientX, ie = s.value.getBoundingClientRect().left;
      V = (H - ie) / e.sliderSize * 100;
    }
    if (!(V < 0 || V > 100))
      return g(V);
  };
  return {
    elFormItem: i,
    slider: s,
    firstButton: o,
    secondButton: a,
    sliderDisabled: u,
    minValue: c,
    maxValue: d,
    runwayStyle: m,
    barStyle: b,
    resetSize: p,
    setPosition: g,
    emitChange: S,
    onSliderWrapperPrevent: (N) => {
      var B, D;
      ((B = l.firstButton.value) != null && B.dragging || (D = l.secondButton.value) != null && D.dragging) && N.preventDefault();
    },
    onSliderClick: (N) => {
      A(N) && S();
    },
    onSliderDown: async (N) => {
      const B = A(N);
      B && (await rt(), B.value.onButtonDown(N));
    },
    setFirstValue: y,
    setSecondValue: w
  };
}, { left: fP, down: hP, right: pP, up: vP, home: gP, end: mP, pageUp: yP, pageDown: bP } = sn, wP = (t, e, n) => {
  const r = K(), i = K(!1), s = j(() => e.value instanceof Function), o = j(() => s.value && e.value(t.modelValue) || t.modelValue), a = ni(() => {
    n.value && (i.value = !0);
  }, 50), l = ni(() => {
    n.value && (i.value = !1);
  }, 50);
  return {
    tooltip: r,
    tooltipVisible: i,
    formatValue: o,
    displayTooltip: a,
    hideTooltip: l
  };
}, _P = (t, e, n) => {
  const {
    disabled: r,
    min: i,
    max: s,
    step: o,
    showTooltip: a,
    precision: l,
    sliderSize: u,
    formatTooltip: c,
    emitChange: d,
    resetSize: h,
    updateDragging: v
  } = et(oy), { tooltip: m, tooltipVisible: b, formatValue: p, displayTooltip: f, hideTooltip: g } = wP(t, c, a), y = K(), w = j(() => `${(t.modelValue - i.value) / (s.value - i.value) * 100}%`), _ = j(() => t.vertical ? { bottom: w.value } : { left: w.value }), S = () => {
    e.hovering = !0, f();
  }, A = () => {
    e.hovering = !1, e.dragging || g();
  }, C = (Y) => {
    r.value || (Y.preventDefault(), V(Y), window.addEventListener("mousemove", H), window.addEventListener("touchmove", H), window.addEventListener("mouseup", ie), window.addEventListener("touchend", ie), window.addEventListener("contextmenu", ie), y.value.focus());
  }, k = (Y) => {
    r.value || (e.newPosition = Number.parseFloat(w.value) + Y / (s.value - i.value) * 100, ne(e.newPosition), d());
  }, O = () => {
    k(-o.value);
  }, N = () => {
    k(o.value);
  }, B = () => {
    k(-o.value * 4);
  }, D = () => {
    k(o.value * 4);
  }, F = () => {
    r.value || (ne(0), d());
  }, Z = () => {
    r.value || (ne(100), d());
  }, te = (Y) => {
    let de = !0;
    [fP, hP].includes(Y.key) ? O() : [pP, vP].includes(Y.key) ? N() : Y.key === gP ? F() : Y.key === mP ? Z() : Y.key === bP ? B() : Y.key === yP ? D() : de = !1, de && Y.preventDefault();
  }, L = (Y) => {
    let de, ue;
    return Y.type.startsWith("touch") ? (ue = Y.touches[0].clientY, de = Y.touches[0].clientX) : (ue = Y.clientY, de = Y.clientX), {
      clientX: de,
      clientY: ue
    };
  }, V = (Y) => {
    e.dragging = !0, e.isClick = !0;
    const { clientX: de, clientY: ue } = L(Y);
    t.vertical ? e.startY = ue : e.startX = de, e.startPosition = Number.parseFloat(w.value), e.newPosition = e.startPosition;
  }, H = (Y) => {
    if (e.dragging) {
      e.isClick = !1, f(), h();
      let de;
      const { clientX: ue, clientY: Te } = L(Y);
      t.vertical ? (e.currentY = Te, de = (e.startY - e.currentY) / u.value * 100) : (e.currentX = ue, de = (e.currentX - e.startX) / u.value * 100), e.newPosition = e.startPosition + de, ne(e.newPosition);
    }
  }, ie = () => {
    e.dragging && (setTimeout(() => {
      e.dragging = !1, e.hovering || g(), e.isClick || ne(e.newPosition), d();
    }, 0), window.removeEventListener("mousemove", H), window.removeEventListener("touchmove", H), window.removeEventListener("mouseup", ie), window.removeEventListener("touchend", ie), window.removeEventListener("contextmenu", ie));
  }, ne = async (Y) => {
    if (Y === null || Number.isNaN(+Y))
      return;
    Y < 0 ? Y = 0 : Y > 100 && (Y = 100);
    const de = 100 / ((s.value - i.value) / o.value);
    let Te = Math.round(Y / de) * de * (s.value - i.value) * 0.01 + i.value;
    Te = Number.parseFloat(Te.toFixed(l.value)), Te !== t.modelValue && n(Dt, Te), !e.dragging && t.modelValue !== e.oldValue && (e.oldValue = t.modelValue), await rt(), e.dragging && f(), m.value.updatePopper();
  };
  return Ae(() => e.dragging, (Y) => {
    v(Y);
  }), {
    disabled: r,
    button: y,
    tooltip: m,
    tooltipVisible: b,
    showTooltip: a,
    wrapperStyle: _,
    formatValue: p,
    handleMouseEnter: S,
    handleMouseLeave: A,
    onButtonDown: C,
    onKeyDown: te,
    setPosition: ne
  };
}, SP = (t, e, n, r) => ({
  stops: j(() => {
    if (!t.showStops || t.min > t.max)
      return [];
    if (t.step === 0)
      return Vt("ElSlider", "step should not be 0."), [];
    const o = (t.max - t.min) / t.step, a = 100 * t.step / (t.max - t.min), l = Array.from({ length: o - 1 }).map((u, c) => (c + 1) * a);
    return t.range ? l.filter((u) => u < 100 * (n.value - t.min) / (t.max - t.min) || u > 100 * (r.value - t.min) / (t.max - t.min)) : l.filter((u) => u > 100 * (e.firstValue - t.min) / (t.max - t.min));
  }),
  getStopStyle: (o) => t.vertical ? { bottom: `${o}%` } : { left: `${o}%` }
}), EP = (t, e, n, r, i, s) => {
  const o = (u) => {
    i(Dt, u), i(Fi, u);
  }, a = () => t.range ? ![n.value, r.value].every((u, c) => u === e.oldValue[c]) : t.modelValue !== e.oldValue, l = () => {
    var u, c;
    t.min > t.max && ts("Slider", "min should not be greater than max.");
    const d = t.modelValue;
    t.range && Array.isArray(d) ? d[1] < t.min ? o([t.min, t.min]) : d[0] > t.max ? o([t.max, t.max]) : d[0] < t.min ? o([t.min, d[1]]) : d[1] > t.max ? o([d[0], t.max]) : (e.firstValue = d[0], e.secondValue = d[1], a() && (t.validateEvent && ((u = s == null ? void 0 : s.validate) == null || u.call(s, "change").catch((h) => Vt(h))), e.oldValue = d.slice())) : !t.range && typeof d == "number" && !Number.isNaN(d) && (d < t.min ? o(t.min) : d > t.max ? o(t.max) : (e.firstValue = d, a() && (t.validateEvent && ((c = s == null ? void 0 : s.validate) == null || c.call(s, "change").catch((h) => Vt(h))), e.oldValue = d)));
  };
  l(), Ae(() => e.dragging, (u) => {
    u || l();
  }), Ae(() => t.modelValue, (u, c) => {
    e.dragging || Array.isArray(u) && Array.isArray(c) && u.every((d, h) => d === c[h]) && e.firstValue === u[0] && e.secondValue === u[1] || l();
  }, {
    deep: !0
  }), Ae(() => [t.min, t.max], () => {
    l();
  });
}, xP = ut({
  modelValue: {
    type: Number,
    default: 0
  },
  vertical: Boolean,
  tooltipClass: String,
  placement: {
    type: String,
    values: Js,
    default: "top"
  }
}), AP = {
  [Dt]: (t) => mt(t)
}, kP = ["tabindex"], CP = ye({
  name: "ElSliderButton"
}), TP = /* @__PURE__ */ ye({
  ...CP,
  props: xP,
  emits: AP,
  setup(t, { expose: e, emit: n }) {
    const r = t, i = ze("slider"), s = Mn({
      hovering: !1,
      dragging: !1,
      isClick: !1,
      startX: 0,
      currentX: 0,
      startY: 0,
      currentY: 0,
      startPosition: 0,
      newPosition: 0,
      oldValue: r.modelValue
    }), {
      disabled: o,
      button: a,
      tooltip: l,
      showTooltip: u,
      tooltipVisible: c,
      wrapperStyle: d,
      formatValue: h,
      handleMouseEnter: v,
      handleMouseLeave: m,
      onButtonDown: b,
      onKeyDown: p,
      setPosition: f
    } = _P(r, s, n), { hovering: g, dragging: y } = pn(s);
    return e({
      onButtonDown: b,
      onKeyDown: p,
      setPosition: f,
      hovering: g,
      dragging: y
    }), (w, _) => (U(), oe("div", {
      ref_key: "button",
      ref: a,
      class: X([x(i).e("button-wrapper"), { hover: x(g), dragging: x(y) }]),
      style: it(x(d)),
      tabindex: x(o) ? -1 : 0,
      onMouseenter: _[0] || (_[0] = (...S) => x(v) && x(v)(...S)),
      onMouseleave: _[1] || (_[1] = (...S) => x(m) && x(m)(...S)),
      onMousedown: _[2] || (_[2] = (...S) => x(b) && x(b)(...S)),
      onTouchstart: _[3] || (_[3] = (...S) => x(b) && x(b)(...S)),
      onFocus: _[4] || (_[4] = (...S) => x(v) && x(v)(...S)),
      onBlur: _[5] || (_[5] = (...S) => x(m) && x(m)(...S)),
      onKeydown: _[6] || (_[6] = (...S) => x(p) && x(p)(...S))
    }, [
      ve(x(du), {
        ref_key: "tooltip",
        ref: l,
        visible: x(c),
        placement: w.placement,
        "fallback-placements": ["top", "bottom", "right", "left"],
        "stop-popper-mouse-event": !1,
        "popper-class": w.tooltipClass,
        disabled: !x(u),
        persistent: ""
      }, {
        content: fe(() => [
          le("span", null, st(x(h)), 1)
        ]),
        default: fe(() => [
          le("div", {
            class: X([x(i).e("button"), { hover: x(g), dragging: x(y) }])
          }, null, 2)
        ]),
        _: 1
      }, 8, ["visible", "placement", "popper-class", "disabled"])
    ], 46, kP));
  }
});
var Tp = /* @__PURE__ */ Ge(TP, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/button.vue"]]);
const OP = ut({
  mark: {
    type: De([String, Object]),
    default: void 0
  }
});
var IP = ye({
  name: "ElSliderMarker",
  props: OP,
  setup(t) {
    const e = ze("slider"), n = j(() => Gt(t.mark) ? t.mark : t.mark.label), r = j(() => Gt(t.mark) ? void 0 : t.mark.style);
    return () => Xe("div", {
      class: e.e("marks-text"),
      style: r.value
    }, n.value);
  }
});
const NP = ["id", "role", "aria-label", "aria-labelledby"], RP = { key: 1 }, PP = ye({
  name: "ElSlider"
}), DP = /* @__PURE__ */ ye({
  ...PP,
  props: aP,
  emits: lP,
  setup(t, { expose: e, emit: n }) {
    const r = t, i = ze("slider"), { t: s } = lr(), o = Mn({
      firstValue: 0,
      secondValue: 0,
      oldValue: 0,
      dragging: !1,
      sliderSize: 1
    }), {
      elFormItem: a,
      slider: l,
      firstButton: u,
      secondButton: c,
      sliderDisabled: d,
      minValue: h,
      maxValue: v,
      runwayStyle: m,
      barStyle: b,
      resetSize: p,
      emitChange: f,
      onSliderWrapperPrevent: g,
      onSliderClick: y,
      onSliderDown: w,
      setFirstValue: _,
      setSecondValue: S
    } = dP(r, o, n), { stops: A, getStopStyle: C } = SP(r, o, h, v), { inputId: k, isLabeledByFormItem: O } = ca(r, {
      formItemContext: a
    }), N = jr(), B = j(() => r.inputSize || N.value), D = j(() => r.label || s("el.slider.defaultLabel", {
      min: r.min,
      max: r.max
    })), F = j(() => r.range ? r.rangeStartLabel || s("el.slider.defaultRangeStartLabel") : D.value), Z = j(() => r.formatValueText ? r.formatValueText(Y.value) : `${Y.value}`), te = j(() => r.rangeEndLabel || s("el.slider.defaultRangeEndLabel")), L = j(() => r.formatValueText ? r.formatValueText(de.value) : `${de.value}`), V = j(() => [
      i.b(),
      i.m(N.value),
      i.is("vertical", r.vertical),
      { [i.m("with-input")]: r.showInput }
    ]), H = cP(r);
    EP(r, o, h, v, n, a);
    const ie = j(() => {
      const _e = [r.min, r.max, r.step].map((Fe) => {
        const Ce = `${Fe}`.split(".")[1];
        return Ce ? Ce.length : 0;
      });
      return Math.max.apply(null, _e);
    }), { sliderWrapper: ne } = uP(r, o, p), { firstValue: Y, secondValue: de, sliderSize: ue } = pn(o), Te = (_e) => {
      o.dragging = _e;
    };
    return qt(oy, {
      ...pn(r),
      sliderSize: ue,
      disabled: d,
      precision: ie,
      emitChange: f,
      resetSize: p,
      updateDragging: Te
    }), e({
      onSliderClick: y
    }), (_e, Fe) => {
      var Ce, tt;
      return U(), oe("div", {
        id: _e.range ? x(k) : void 0,
        ref_key: "sliderWrapper",
        ref: ne,
        class: X(x(V)),
        role: _e.range ? "group" : void 0,
        "aria-label": _e.range && !x(O) ? x(D) : void 0,
        "aria-labelledby": _e.range && x(O) ? (Ce = x(a)) == null ? void 0 : Ce.labelId : void 0,
        onTouchstart: Fe[2] || (Fe[2] = (...je) => x(g) && x(g)(...je)),
        onTouchmove: Fe[3] || (Fe[3] = (...je) => x(g) && x(g)(...je))
      }, [
        le("div", {
          ref_key: "slider",
          ref: l,
          class: X([
            x(i).e("runway"),
            { "show-input": _e.showInput && !_e.range },
            x(i).is("disabled", x(d))
          ]),
          style: it(x(m)),
          onMousedown: Fe[0] || (Fe[0] = (...je) => x(w) && x(w)(...je)),
          onTouchstart: Fe[1] || (Fe[1] = (...je) => x(w) && x(w)(...je))
        }, [
          le("div", {
            class: X(x(i).e("bar")),
            style: it(x(b))
          }, null, 6),
          ve(Tp, {
            id: _e.range ? void 0 : x(k),
            ref_key: "firstButton",
            ref: u,
            "model-value": x(Y),
            vertical: _e.vertical,
            "tooltip-class": _e.tooltipClass,
            placement: _e.placement,
            role: "slider",
            "aria-label": _e.range || !x(O) ? x(F) : void 0,
            "aria-labelledby": !_e.range && x(O) ? (tt = x(a)) == null ? void 0 : tt.labelId : void 0,
            "aria-valuemin": _e.min,
            "aria-valuemax": _e.range ? x(de) : _e.max,
            "aria-valuenow": x(Y),
            "aria-valuetext": x(Z),
            "aria-orientation": _e.vertical ? "vertical" : "horizontal",
            "aria-disabled": x(d),
            "onUpdate:modelValue": x(_)
          }, null, 8, ["id", "model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-labelledby", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"]),
          _e.range ? (U(), xe(Tp, {
            key: 0,
            ref_key: "secondButton",
            ref: c,
            "model-value": x(de),
            vertical: _e.vertical,
            "tooltip-class": _e.tooltipClass,
            placement: _e.placement,
            role: "slider",
            "aria-label": x(te),
            "aria-valuemin": x(Y),
            "aria-valuemax": _e.max,
            "aria-valuenow": x(de),
            "aria-valuetext": x(L),
            "aria-orientation": _e.vertical ? "vertical" : "horizontal",
            "aria-disabled": x(d),
            "onUpdate:modelValue": x(S)
          }, null, 8, ["model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"])) : me("v-if", !0),
          _e.showStops ? (U(), oe("div", RP, [
            (U(!0), oe(Ft, null, Yn(x(A), (je, $e) => (U(), oe("div", {
              key: $e,
              class: X(x(i).e("stop")),
              style: it(x(C)(je))
            }, null, 6))), 128))
          ])) : me("v-if", !0),
          x(H).length > 0 ? (U(), oe(Ft, { key: 2 }, [
            le("div", null, [
              (U(!0), oe(Ft, null, Yn(x(H), (je, $e) => (U(), oe("div", {
                key: $e,
                style: it(x(C)(je.position)),
                class: X([x(i).e("stop"), x(i).e("marks-stop")])
              }, null, 6))), 128))
            ]),
            le("div", {
              class: X(x(i).e("marks"))
            }, [
              (U(!0), oe(Ft, null, Yn(x(H), (je, $e) => (U(), xe(x(IP), {
                key: $e,
                mark: je.mark,
                style: it(x(C)(je.position))
              }, null, 8, ["mark", "style"]))), 128))
            ], 2)
          ], 64)) : me("v-if", !0)
        ], 38),
        _e.showInput && !_e.range ? (U(), xe(x(ty), {
          key: 0,
          ref: "input",
          "model-value": x(Y),
          class: X(x(i).e("input")),
          step: _e.step,
          disabled: x(d),
          controls: _e.showInputControls,
          min: _e.min,
          max: _e.max,
          debounce: _e.debounce,
          size: x(B),
          "onUpdate:modelValue": x(_),
          onChange: x(f)
        }, null, 8, ["model-value", "class", "step", "disabled", "controls", "min", "max", "debounce", "size", "onUpdate:modelValue", "onChange"])) : me("v-if", !0)
      ], 42, NP);
    };
  }
});
var BP = /* @__PURE__ */ Ge(DP, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/slider.vue"]]);
const MP = nn(BP);
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
var LP = /["'&<>]/, zP = jP;
function jP(t) {
  var e = "" + t, n = LP.exec(e);
  if (!n)
    return e;
  var r, i = "", s = 0, o = 0;
  for (s = n.index; s < e.length; s++) {
    switch (e.charCodeAt(s)) {
      case 34:
        r = "&quot;";
        break;
      case 38:
        r = "&amp;";
        break;
      case 39:
        r = "&#39;";
        break;
      case 60:
        r = "&lt;";
        break;
      case 62:
        r = "&gt;";
        break;
      default:
        continue;
    }
    o !== s && (i += e.substring(o, s)), o = s + 1, i += r;
  }
  return o !== s ? i + e.substring(o, s) : i;
}
const Hu = function(t) {
  var e;
  return (e = t.target) == null ? void 0 : e.closest("td");
}, FP = function(t, e, n, r, i) {
  if (!e && !r && (!i || Array.isArray(i) && !i.length))
    return t;
  typeof n == "string" ? n = n === "descending" ? -1 : 1 : n = n && n < 0 ? -1 : 1;
  const s = r ? null : function(a, l) {
    return i ? (Array.isArray(i) || (i = [i]), i.map((u) => typeof u == "string" ? Cn(a, u) : u(a, l, t))) : (e !== "$key" && _n(a) && "$value" in a && (a = a.$value), [_n(a) ? Cn(a, e) : a]);
  }, o = function(a, l) {
    if (r)
      return r(a.value, l.value);
    for (let u = 0, c = a.key.length; u < c; u++) {
      if (a.key[u] < l.key[u])
        return -1;
      if (a.key[u] > l.key[u])
        return 1;
    }
    return 0;
  };
  return t.map((a, l) => ({
    value: a,
    index: l,
    key: s ? s(a, l) : null
  })).sort((a, l) => {
    let u = o(a, l);
    return u || (u = a.index - l.index), u * +n;
  }).map((a) => a.value);
}, ay = function(t, e) {
  let n = null;
  return t.columns.forEach((r) => {
    r.id === e && (n = r);
  }), n;
}, HP = function(t, e) {
  let n = null;
  for (let r = 0; r < t.columns.length; r++) {
    const i = t.columns[r];
    if (i.columnKey === e) {
      n = i;
      break;
    }
  }
  return n || ts("ElTable", `No column matching with column-key: ${e}`), n;
}, Op = function(t, e, n) {
  const r = (e.className || "").match(new RegExp(`${n}-table_[^\\s]+`, "gm"));
  return r ? ay(t, r[0]) : null;
}, bn = (t, e) => {
  if (!t)
    throw new Error("Row is required when get row identity");
  if (typeof e == "string") {
    if (!e.includes("."))
      return `${t[e]}`;
    const n = e.split(".");
    let r = t;
    for (const i of n)
      r = r[i];
    return `${r}`;
  } else if (typeof e == "function")
    return e.call(null, t);
}, zi = function(t, e) {
  const n = {};
  return (t || []).forEach((r, i) => {
    n[bn(r, e)] = { row: r, index: i };
  }), n;
};
function UP(t, e) {
  const n = {};
  let r;
  for (r in t)
    n[r] = t[r];
  for (r in e)
    if (Dr(e, r)) {
      const i = e[r];
      typeof i < "u" && (n[r] = i);
    }
  return n;
}
function vf(t) {
  return t === "" || t !== void 0 && (t = Number.parseInt(t, 10), Number.isNaN(t) && (t = "")), t;
}
function ly(t) {
  return t === "" || t !== void 0 && (t = vf(t), Number.isNaN(t) && (t = 80)), t;
}
function VP(t) {
  return typeof t == "number" ? t : typeof t == "string" ? /^\d+(?:px)?$/.test(t) ? Number.parseInt(t, 10) : t : null;
}
function WP(...t) {
  return t.length === 0 ? (e) => e : t.length === 1 ? t[0] : t.reduce((e, n) => (...r) => e(n(...r)));
}
function _o(t, e, n) {
  let r = !1;
  const i = t.indexOf(e), s = i !== -1, o = (a) => {
    a === "add" ? t.push(e) : t.splice(i, 1), r = !0, Br(e.children) && e.children.forEach((l) => {
      _o(t, l, n ?? !s);
    });
  };
  return ri(n) ? n && !s ? o("add") : !n && s && o("remove") : o(s ? "remove" : "add"), r;
}
function $P(t, e, n = "children", r = "hasChildren") {
  const i = (o) => !(Array.isArray(o) && o.length);
  function s(o, a, l) {
    e(o, a, l), a.forEach((u) => {
      if (u[r]) {
        e(u, null, l + 1);
        return;
      }
      const c = u[n];
      i(c) || s(u, c, l + 1);
    });
  }
  t.forEach((o) => {
    if (o[r]) {
      e(o, null, 0);
      return;
    }
    const a = o[n];
    i(a) || s(o, a, 0);
  });
}
let Gr;
function KP(t, e, n, r, i) {
  i = Rg({
    enterable: !0,
    showArrow: !0
  }, i);
  const s = t == null ? void 0 : t.dataset.prefix, o = t == null ? void 0 : t.querySelector(`.${s}-scrollbar__wrap`);
  function a() {
    const p = i.effect === "light", f = document.createElement("div");
    return f.className = [
      `${s}-popper`,
      p ? "is-light" : "is-dark",
      i.popperClass || ""
    ].join(" "), n = zP(n), f.innerHTML = n, f.style.zIndex = String(r()), t == null || t.appendChild(f), f;
  }
  function l() {
    const p = document.createElement("div");
    return p.className = `${s}-popper__arrow`, p;
  }
  function u() {
    c && c.update();
  }
  Gr == null || Gr(), Gr = () => {
    try {
      c && c.destroy(), v && (t == null || t.removeChild(v)), e.removeEventListener("mouseenter", d), e.removeEventListener("mouseleave", h), o == null || o.removeEventListener("scroll", Gr), Gr = void 0;
    } catch {
    }
  };
  let c = null, d = u, h = Gr;
  i.enterable && ({ onOpen: d, onClose: h } = dm({
    showAfter: i.showAfter,
    hideAfter: i.hideAfter,
    open: u,
    close: Gr
  }));
  const v = a();
  v.onmouseenter = d, v.onmouseleave = h;
  const m = [];
  if (i.offset && m.push({
    name: "offset",
    options: {
      offset: [0, i.offset]
    }
  }), i.showArrow) {
    const p = v.appendChild(l());
    m.push({
      name: "arrow",
      options: {
        element: p,
        padding: 10
      }
    });
  }
  const b = i.popperOptions || {};
  return c = lm(e, v, {
    placement: i.placement || "top",
    strategy: "fixed",
    ...b,
    modifiers: b.modifiers ? m.concat(b.modifiers) : m
  }), e.addEventListener("mouseenter", d), e.addEventListener("mouseleave", h), o == null || o.addEventListener("scroll", Gr), c;
}
function uy(t) {
  return t.children ? SA(t.children, uy) : [t];
}
function Ip(t, e) {
  return t + e.colSpan;
}
const cy = (t, e, n, r) => {
  let i = 0, s = t;
  const o = n.states.columns.value;
  if (r) {
    const l = uy(r[t]);
    i = o.slice(0, o.indexOf(l[0])).reduce(Ip, 0), s = i + l.reduce(Ip, 0) - 1;
  } else
    i = t;
  let a;
  switch (e) {
    case "left":
      s < n.states.fixedLeafColumnsLength.value && (a = "left");
      break;
    case "right":
      i >= o.length - n.states.rightFixedLeafColumnsLength.value && (a = "right");
      break;
    default:
      s < n.states.fixedLeafColumnsLength.value ? a = "left" : i >= o.length - n.states.rightFixedLeafColumnsLength.value && (a = "right");
  }
  return a ? {
    direction: a,
    start: i,
    after: s
  } : {};
}, gf = (t, e, n, r, i, s = 0) => {
  const o = [], { direction: a, start: l, after: u } = cy(e, n, r, i);
  if (a) {
    const c = a === "left";
    o.push(`${t}-fixed-column--${a}`), c && u + s === r.states.fixedLeafColumnsLength.value - 1 ? o.push("is-last-column") : !c && l - s === r.states.columns.value.length - r.states.rightFixedLeafColumnsLength.value && o.push("is-first-column");
  }
  return o;
};
function Np(t, e) {
  return t + (e.realWidth === null || Number.isNaN(e.realWidth) ? Number(e.width) : e.realWidth);
}
const mf = (t, e, n, r) => {
  const {
    direction: i,
    start: s = 0,
    after: o = 0
  } = cy(t, e, n, r);
  if (!i)
    return;
  const a = {}, l = i === "left", u = n.states.columns.value;
  return l ? a.left = u.slice(0, s).reduce(Np, 0) : a.right = u.slice(o + 1).reverse().reduce(Np, 0), a;
}, Us = (t, e) => {
  t && (Number.isNaN(t[e]) || (t[e] = `${t[e]}px`));
};
function GP(t) {
  const e = ft(), n = K(!1), r = K([]);
  return {
    updateExpandRows: () => {
      const l = t.data.value || [], u = t.rowKey.value;
      if (n.value)
        r.value = l.slice();
      else if (u) {
        const c = zi(r.value, u);
        r.value = l.reduce((d, h) => {
          const v = bn(h, u);
          return c[v] && d.push(h), d;
        }, []);
      } else
        r.value = [];
    },
    toggleRowExpansion: (l, u) => {
      _o(r.value, l, u) && e.emit("expand-change", l, r.value.slice());
    },
    setExpandRowKeys: (l) => {
      e.store.assertRowKey();
      const u = t.data.value || [], c = t.rowKey.value, d = zi(u, c);
      r.value = l.reduce((h, v) => {
        const m = d[v];
        return m && h.push(m.row), h;
      }, []);
    },
    isRowExpanded: (l) => {
      const u = t.rowKey.value;
      return u ? !!zi(r.value, u)[bn(l, u)] : r.value.includes(l);
    },
    states: {
      expandRows: r,
      defaultExpandAll: n
    }
  };
}
function qP(t) {
  const e = ft(), n = K(null), r = K(null), i = (u) => {
    e.store.assertRowKey(), n.value = u, o(u);
  }, s = () => {
    n.value = null;
  }, o = (u) => {
    const { data: c, rowKey: d } = t;
    let h = null;
    d.value && (h = (x(c) || []).find((v) => bn(v, d.value) === u)), r.value = h, e.emit("current-change", r.value, null);
  };
  return {
    setCurrentRowKey: i,
    restoreCurrentRowKey: s,
    setCurrentRowByKey: o,
    updateCurrentRow: (u) => {
      const c = r.value;
      if (u && u !== c) {
        r.value = u, e.emit("current-change", r.value, c);
        return;
      }
      !u && c && (r.value = null, e.emit("current-change", null, c));
    },
    updateCurrentRowData: () => {
      const u = t.rowKey.value, c = t.data.value || [], d = r.value;
      if (!c.includes(d) && d) {
        if (u) {
          const h = bn(d, u);
          o(h);
        } else
          r.value = null;
        r.value === null && e.emit("current-change", null, d);
      } else
        n.value && (o(n.value), s());
    },
    states: {
      _currentRowKey: n,
      currentRow: r
    }
  };
}
function JP(t) {
  const e = K([]), n = K({}), r = K(16), i = K(!1), s = K({}), o = K("hasChildren"), a = K("children"), l = ft(), u = j(() => {
    if (!t.rowKey.value)
      return {};
    const f = t.data.value || [];
    return d(f);
  }), c = j(() => {
    const f = t.rowKey.value, g = Object.keys(s.value), y = {};
    return g.length && g.forEach((w) => {
      if (s.value[w].length) {
        const _ = { children: [] };
        s.value[w].forEach((S) => {
          const A = bn(S, f);
          _.children.push(A), S[o.value] && !y[A] && (y[A] = { children: [] });
        }), y[w] = _;
      }
    }), y;
  }), d = (f) => {
    const g = t.rowKey.value, y = {};
    return $P(f, (w, _, S) => {
      const A = bn(w, g);
      Array.isArray(_) ? y[A] = {
        children: _.map((C) => bn(C, g)),
        level: S
      } : i.value && (y[A] = {
        children: [],
        lazy: !0,
        level: S
      });
    }, a.value, o.value), y;
  }, h = (f = !1, g = ((y) => (y = l.store) == null ? void 0 : y.states.defaultExpandAll.value)()) => {
    var y;
    const w = u.value, _ = c.value, S = Object.keys(w), A = {};
    if (S.length) {
      const C = x(n), k = [], O = (B, D) => {
        if (f)
          return e.value ? g || e.value.includes(D) : !!(g || B != null && B.expanded);
        {
          const F = g || e.value && e.value.includes(D);
          return !!(B != null && B.expanded || F);
        }
      };
      S.forEach((B) => {
        const D = C[B], F = { ...w[B] };
        if (F.expanded = O(D, B), F.lazy) {
          const { loaded: Z = !1, loading: te = !1 } = D || {};
          F.loaded = !!Z, F.loading = !!te, k.push(B);
        }
        A[B] = F;
      });
      const N = Object.keys(_);
      i.value && N.length && k.length && N.forEach((B) => {
        const D = C[B], F = _[B].children;
        if (k.includes(B)) {
          if (A[B].children.length !== 0)
            throw new Error("[ElTable]children must be an empty array.");
          A[B].children = F;
        } else {
          const { loaded: Z = !1, loading: te = !1 } = D || {};
          A[B] = {
            lazy: !0,
            loaded: !!Z,
            loading: !!te,
            expanded: O(D, B),
            children: F,
            level: ""
          };
        }
      });
    }
    n.value = A, (y = l.store) == null || y.updateTableScrollY();
  };
  Ae(() => e.value, () => {
    h(!0);
  }), Ae(() => u.value, () => {
    h();
  }), Ae(() => c.value, () => {
    h();
  });
  const v = (f) => {
    e.value = f, h();
  }, m = (f, g) => {
    l.store.assertRowKey();
    const y = t.rowKey.value, w = bn(f, y), _ = w && n.value[w];
    if (w && _ && "expanded" in _) {
      const S = _.expanded;
      g = typeof g > "u" ? !_.expanded : g, n.value[w].expanded = g, S !== g && l.emit("expand-change", f, g), l.store.updateTableScrollY();
    }
  }, b = (f) => {
    l.store.assertRowKey();
    const g = t.rowKey.value, y = bn(f, g), w = n.value[y];
    i.value && w && "loaded" in w && !w.loaded ? p(f, y, w) : m(f, void 0);
  }, p = (f, g, y) => {
    const { load: w } = l.props;
    w && !n.value[g].loaded && (n.value[g].loading = !0, w(f, y, (_) => {
      if (!Array.isArray(_))
        throw new TypeError("[ElTable] data must be an array");
      n.value[g].loading = !1, n.value[g].loaded = !0, n.value[g].expanded = !0, _.length && (s.value[g] = _), l.emit("expand-change", f, !0);
    }));
  };
  return {
    loadData: p,
    loadOrToggle: b,
    toggleTreeExpansion: m,
    updateTreeExpandKeys: v,
    updateTreeData: h,
    normalize: d,
    states: {
      expandRowKeys: e,
      treeData: n,
      indent: r,
      lazy: i,
      lazyTreeNodeMap: s,
      lazyColumnIdentifier: o,
      childrenColumnName: a
    }
  };
}
const YP = (t, e) => {
  const n = e.sortingColumn;
  return !n || typeof n.sortable == "string" ? t : FP(t, e.sortProp, e.sortOrder, n.sortMethod, n.sortBy);
}, el = (t) => {
  const e = [];
  return t.forEach((n) => {
    n.children && n.children.length > 0 ? e.push.apply(e, el(n.children)) : e.push(n);
  }), e;
};
function QP() {
  var t;
  const e = ft(), { size: n } = pn((t = e.proxy) == null ? void 0 : t.$props), r = K(null), i = K([]), s = K([]), o = K(!1), a = K([]), l = K([]), u = K([]), c = K([]), d = K([]), h = K([]), v = K([]), m = K([]), b = [], p = K(0), f = K(0), g = K(0), y = K(!1), w = K([]), _ = K(!1), S = K(!1), A = K(null), C = K({}), k = K(null), O = K(null), N = K(null), B = K(null), D = K(null);
  Ae(i, () => e.state && L(!1), {
    deep: !0
  });
  const F = () => {
    if (!r.value)
      throw new Error("[ElTable] prop row-key is required");
  }, Z = (Ie) => {
    var Ve;
    (Ve = Ie.children) == null || Ve.forEach((Je) => {
      Je.fixed = Ie.fixed, Z(Je);
    });
  }, te = () => {
    a.value.forEach((Qe) => {
      Z(Qe);
    }), c.value = a.value.filter((Qe) => Qe.fixed === !0 || Qe.fixed === "left"), d.value = a.value.filter((Qe) => Qe.fixed === "right"), c.value.length > 0 && a.value[0] && a.value[0].type === "selection" && !a.value[0].fixed && (a.value[0].fixed = !0, c.value.unshift(a.value[0]));
    const Ie = a.value.filter((Qe) => !Qe.fixed);
    l.value = [].concat(c.value).concat(Ie).concat(d.value);
    const Ve = el(Ie), Je = el(c.value), He = el(d.value);
    p.value = Ve.length, f.value = Je.length, g.value = He.length, u.value = [].concat(Je).concat(Ve).concat(He), o.value = c.value.length > 0 || d.value.length > 0;
  }, L = (Ie, Ve = !1) => {
    Ie && te(), Ve ? e.state.doLayout() : e.state.debouncedUpdateLayout();
  }, V = (Ie) => w.value.includes(Ie), H = () => {
    y.value = !1, w.value.length && (w.value = [], e.emit("selection-change", []));
  }, ie = () => {
    let Ie;
    if (r.value) {
      Ie = [];
      const Ve = zi(w.value, r.value), Je = zi(i.value, r.value);
      for (const He in Ve)
        Dr(Ve, He) && !Je[He] && Ie.push(Ve[He].row);
    } else
      Ie = w.value.filter((Ve) => !i.value.includes(Ve));
    if (Ie.length) {
      const Ve = w.value.filter((Je) => !Ie.includes(Je));
      w.value = Ve, e.emit("selection-change", Ve.slice());
    }
  }, ne = () => (w.value || []).slice(), Y = (Ie, Ve = void 0, Je = !0) => {
    if (_o(w.value, Ie, Ve)) {
      const Qe = (w.value || []).slice();
      Je && e.emit("select", Qe, Ie), e.emit("selection-change", Qe);
    }
  }, de = () => {
    var Ie, Ve;
    const Je = S.value ? !y.value : !(y.value || w.value.length);
    y.value = Je;
    let He = !1, Qe = 0;
    const At = (Ve = (Ie = e == null ? void 0 : e.store) == null ? void 0 : Ie.states) == null ? void 0 : Ve.rowKey.value;
    i.value.forEach((P, he) => {
      const ge = he + Qe;
      A.value ? A.value.call(null, P, ge) && _o(w.value, P, Je) && (He = !0) : _o(w.value, P, Je) && (He = !0), Qe += _e(bn(P, At));
    }), He && e.emit("selection-change", w.value ? w.value.slice() : []), e.emit("select-all", w.value);
  }, ue = () => {
    const Ie = zi(w.value, r.value);
    i.value.forEach((Ve) => {
      const Je = bn(Ve, r.value), He = Ie[Je];
      He && (w.value[He.index] = Ve);
    });
  }, Te = () => {
    var Ie, Ve, Je;
    if (((Ie = i.value) == null ? void 0 : Ie.length) === 0) {
      y.value = !1;
      return;
    }
    let He;
    r.value && (He = zi(w.value, r.value));
    const Qe = function(ge) {
      return He ? !!He[bn(ge, r.value)] : w.value.includes(ge);
    };
    let At = !0, P = 0, he = 0;
    for (let ge = 0, Ne = (i.value || []).length; ge < Ne; ge++) {
      const G = (Je = (Ve = e == null ? void 0 : e.store) == null ? void 0 : Ve.states) == null ? void 0 : Je.rowKey.value, ce = ge + he, T = i.value[ge], z = A.value && A.value.call(null, T, ce);
      if (Qe(T))
        P++;
      else if (!A.value || z) {
        At = !1;
        break;
      }
      he += _e(bn(T, G));
    }
    P === 0 && (At = !1), y.value = At;
  }, _e = (Ie) => {
    var Ve;
    if (!e || !e.store)
      return 0;
    const { treeData: Je } = e.store.states;
    let He = 0;
    const Qe = (Ve = Je.value[Ie]) == null ? void 0 : Ve.children;
    return Qe && (He += Qe.length, Qe.forEach((At) => {
      He += _e(At);
    })), He;
  }, Fe = (Ie, Ve) => {
    Array.isArray(Ie) || (Ie = [Ie]);
    const Je = {};
    return Ie.forEach((He) => {
      C.value[He.id] = Ve, Je[He.columnKey || He.id] = Ve;
    }), Je;
  }, Ce = (Ie, Ve, Je) => {
    O.value && O.value !== Ie && (O.value.order = null), O.value = Ie, N.value = Ve, B.value = Je;
  }, tt = () => {
    let Ie = x(s);
    Object.keys(C.value).forEach((Ve) => {
      const Je = C.value[Ve];
      if (!Je || Je.length === 0)
        return;
      const He = ay({
        columns: u.value
      }, Ve);
      He && He.filterMethod && (Ie = Ie.filter((Qe) => Je.some((At) => He.filterMethod.call(null, At, Qe, He))));
    }), k.value = Ie;
  }, je = () => {
    i.value = YP(k.value, {
      sortingColumn: O.value,
      sortProp: N.value,
      sortOrder: B.value
    });
  }, $e = (Ie = void 0) => {
    Ie && Ie.filter || tt(), je();
  }, ht = (Ie) => {
    const { tableHeaderRef: Ve } = e.refs;
    if (!Ve)
      return;
    const Je = Object.assign({}, Ve.filterPanels), He = Object.keys(Je);
    if (He.length)
      if (typeof Ie == "string" && (Ie = [Ie]), Array.isArray(Ie)) {
        const Qe = Ie.map((At) => HP({
          columns: u.value
        }, At));
        He.forEach((At) => {
          const P = Qe.find((he) => he.id === At);
          P && (P.filteredValue = []);
        }), e.store.commit("filterChange", {
          column: Qe,
          values: [],
          silent: !0,
          multi: !0
        });
      } else
        He.forEach((Qe) => {
          const At = u.value.find((P) => P.id === Qe);
          At && (At.filteredValue = []);
        }), C.value = {}, e.store.commit("filterChange", {
          column: {},
          values: [],
          silent: !0
        });
  }, nt = () => {
    O.value && (Ce(null, null, null), e.store.commit("changeSortCondition", {
      silent: !0
    }));
  }, {
    setExpandRowKeys: Et,
    toggleRowExpansion: yt,
    updateExpandRows: Nt,
    states: ot,
    isRowExpanded: bt
  } = GP({
    data: i,
    rowKey: r
  }), {
    updateTreeExpandKeys: Kt,
    toggleTreeExpansion: wt,
    updateTreeData: xt,
    loadOrToggle: lt,
    states: qe
  } = JP({
    data: i,
    rowKey: r
  }), {
    updateCurrentRowData: Rt,
    updateCurrentRow: be,
    setCurrentRowKey: Ue,
    states: at
  } = qP({
    data: i,
    rowKey: r
  });
  return {
    assertRowKey: F,
    updateColumns: te,
    scheduleLayout: L,
    isSelected: V,
    clearSelection: H,
    cleanSelection: ie,
    getSelectionRows: ne,
    toggleRowSelection: Y,
    _toggleAllSelection: de,
    toggleAllSelection: null,
    updateSelectionByRowKey: ue,
    updateAllSelected: Te,
    updateFilters: Fe,
    updateCurrentRow: be,
    updateSort: Ce,
    execFilter: tt,
    execSort: je,
    execQuery: $e,
    clearFilter: ht,
    clearSort: nt,
    toggleRowExpansion: yt,
    setExpandRowKeysAdapter: (Ie) => {
      Et(Ie), Kt(Ie);
    },
    setCurrentRowKey: Ue,
    toggleRowExpansionAdapter: (Ie, Ve) => {
      u.value.some(({ type: He }) => He === "expand") ? yt(Ie, Ve) : wt(Ie, Ve);
    },
    isRowExpanded: bt,
    updateExpandRows: Nt,
    updateCurrentRowData: Rt,
    loadOrToggle: lt,
    updateTreeData: xt,
    states: {
      tableSize: n,
      rowKey: r,
      data: i,
      _data: s,
      isComplex: o,
      _columns: a,
      originColumns: l,
      columns: u,
      fixedColumns: c,
      rightFixedColumns: d,
      leafColumns: h,
      fixedLeafColumns: v,
      rightFixedLeafColumns: m,
      updateOrderFns: b,
      leafColumnsLength: p,
      fixedLeafColumnsLength: f,
      rightFixedLeafColumnsLength: g,
      isAllSelected: y,
      selection: w,
      reserveSelection: _,
      selectOnIndeterminate: S,
      selectable: A,
      filters: C,
      filteredData: k,
      sortingColumn: O,
      sortProp: N,
      sortOrder: B,
      hoverRow: D,
      ...ot,
      ...qe,
      ...at
    }
  };
}
function Dc(t, e) {
  return t.map((n) => {
    var r;
    return n.id === e.id ? e : ((r = n.children) != null && r.length && (n.children = Dc(n.children, e)), n);
  });
}
function Bc(t) {
  t.forEach((e) => {
    var n, r;
    e.no = (n = e.getColumnIndex) == null ? void 0 : n.call(e), (r = e.children) != null && r.length && Bc(e.children);
  }), t.sort((e, n) => e.no - n.no);
}
function ZP() {
  const t = ft(), e = QP();
  return {
    ns: ze("table"),
    ...e,
    mutations: {
      setData(o, a) {
        const l = x(o._data) !== a;
        o.data.value = a, o._data.value = a, t.store.execQuery(), t.store.updateCurrentRowData(), t.store.updateExpandRows(), t.store.updateTreeData(t.store.states.defaultExpandAll.value), x(o.reserveSelection) ? (t.store.assertRowKey(), t.store.updateSelectionByRowKey()) : l ? t.store.clearSelection() : t.store.cleanSelection(), t.store.updateAllSelected(), t.$ready && t.store.scheduleLayout();
      },
      insertColumn(o, a, l, u) {
        const c = x(o._columns);
        let d = [];
        l ? (l && !l.children && (l.children = []), l.children.push(a), d = Dc(c, l)) : (c.push(a), d = c), Bc(d), o._columns.value = d, o.updateOrderFns.push(u), a.type === "selection" && (o.selectable.value = a.selectable, o.reserveSelection.value = a.reserveSelection), t.$ready && (t.store.updateColumns(), t.store.scheduleLayout());
      },
      updateColumnOrder(o, a) {
        var l;
        ((l = a.getColumnIndex) == null ? void 0 : l.call(a)) !== a.no && (Bc(o._columns.value), t.$ready && t.store.updateColumns());
      },
      removeColumn(o, a, l, u) {
        const c = x(o._columns) || [];
        if (l)
          l.children.splice(l.children.findIndex((h) => h.id === a.id), 1), rt(() => {
            var h;
            ((h = l.children) == null ? void 0 : h.length) === 0 && delete l.children;
          }), o._columns.value = Dc(c, l);
        else {
          const h = c.indexOf(a);
          h > -1 && (c.splice(h, 1), o._columns.value = c);
        }
        const d = o.updateOrderFns.indexOf(u);
        d > -1 && o.updateOrderFns.splice(d, 1), t.$ready && (t.store.updateColumns(), t.store.scheduleLayout());
      },
      sort(o, a) {
        const { prop: l, order: u, init: c } = a;
        if (l) {
          const d = x(o.columns).find((h) => h.property === l);
          d && (d.order = u, t.store.updateSort(d, l, u), t.store.commit("changeSortCondition", { init: c }));
        }
      },
      changeSortCondition(o, a) {
        const { sortingColumn: l, sortProp: u, sortOrder: c } = o, d = x(l), h = x(u), v = x(c);
        v === null && (o.sortingColumn.value = null, o.sortProp.value = null);
        const m = { filter: !0 };
        t.store.execQuery(m), (!a || !(a.silent || a.init)) && t.emit("sort-change", {
          column: d,
          prop: h,
          order: v
        }), t.store.updateTableScrollY();
      },
      filterChange(o, a) {
        const { column: l, values: u, silent: c } = a, d = t.store.updateFilters(l, u);
        t.store.execQuery(), c || t.emit("filter-change", d), t.store.updateTableScrollY();
      },
      toggleAllSelection() {
        t.store.toggleAllSelection();
      },
      rowSelectedChanged(o, a) {
        t.store.toggleRowSelection(a), t.store.updateAllSelected();
      },
      setHoverRow(o, a) {
        o.hoverRow.value = a;
      },
      setCurrentRow(o, a) {
        t.store.updateCurrentRow(a);
      }
    },
    commit: function(o, ...a) {
      const l = t.store.mutations;
      if (l[o])
        l[o].apply(t, [t.store.states].concat(a));
      else
        throw new Error(`Action not found: ${o}`);
    },
    updateTableScrollY: function() {
      rt(() => t.layout.updateScrollY.apply(t.layout));
    }
  };
}
const So = {
  rowKey: "rowKey",
  defaultExpandAll: "defaultExpandAll",
  selectOnIndeterminate: "selectOnIndeterminate",
  indent: "indent",
  lazy: "lazy",
  data: "data",
  ["treeProps.hasChildren"]: {
    key: "lazyColumnIdentifier",
    default: "hasChildren"
  },
  ["treeProps.children"]: {
    key: "childrenColumnName",
    default: "children"
  }
};
function XP(t, e) {
  if (!t)
    throw new Error("Table is required.");
  const n = ZP();
  return n.toggleAllSelection = ni(n._toggleAllSelection, 10), Object.keys(So).forEach((r) => {
    dy(fy(e, r), r, n);
  }), e3(n, e), n;
}
function e3(t, e) {
  Object.keys(So).forEach((n) => {
    Ae(() => fy(e, n), (r) => {
      dy(r, n, t);
    });
  });
}
function dy(t, e, n) {
  let r = t, i = So[e];
  typeof So[e] == "object" && (i = i.key, r = r || So[e].default), n.states[i].value = r;
}
function fy(t, e) {
  if (e.includes(".")) {
    const n = e.split(".");
    let r = t;
    return n.forEach((i) => {
      r = r[i];
    }), r;
  } else
    return t[e];
}
class t3 {
  constructor(e) {
    this.observers = [], this.table = null, this.store = null, this.columns = [], this.fit = !0, this.showHeader = !0, this.height = K(null), this.scrollX = K(!1), this.scrollY = K(!1), this.bodyWidth = K(null), this.fixedWidth = K(null), this.rightFixedWidth = K(null), this.gutterWidth = 0;
    for (const n in e)
      Dr(e, n) && (on(this[n]) ? this[n].value = e[n] : this[n] = e[n]);
    if (!this.table)
      throw new Error("Table is required for Table Layout");
    if (!this.store)
      throw new Error("Store is required for Table Layout");
  }
  updateScrollY() {
    if (this.height.value === null)
      return !1;
    const n = this.table.refs.scrollBarRef;
    if (this.table.vnode.el && (n != null && n.wrapRef)) {
      let r = !0;
      const i = this.scrollY.value;
      return r = n.wrapRef.scrollHeight > n.wrapRef.clientHeight, this.scrollY.value = r, i !== r;
    }
    return !1;
  }
  setHeight(e, n = "height") {
    if (!St)
      return;
    const r = this.table.vnode.el;
    if (e = VP(e), this.height.value = Number(e), !r && (e || e === 0))
      return rt(() => this.setHeight(e, n));
    typeof e == "number" ? (r.style[n] = `${e}px`, this.updateElsHeight()) : typeof e == "string" && (r.style[n] = e, this.updateElsHeight());
  }
  setMaxHeight(e) {
    this.setHeight(e, "max-height");
  }
  getFlattenColumns() {
    const e = [];
    return this.table.store.states.columns.value.forEach((r) => {
      r.isColumnGroup ? e.push.apply(e, r.columns) : e.push(r);
    }), e;
  }
  updateElsHeight() {
    this.updateScrollY(), this.notifyObservers("scrollable");
  }
  headerDisplayNone(e) {
    if (!e)
      return !0;
    let n = e;
    for (; n.tagName !== "DIV"; ) {
      if (getComputedStyle(n).display === "none")
        return !0;
      n = n.parentElement;
    }
    return !1;
  }
  updateColumnsWidth() {
    if (!St)
      return;
    const e = this.fit, n = this.table.vnode.el.clientWidth;
    let r = 0;
    const i = this.getFlattenColumns(), s = i.filter((l) => typeof l.width != "number");
    if (i.forEach((l) => {
      typeof l.width == "number" && l.realWidth && (l.realWidth = null);
    }), s.length > 0 && e) {
      if (i.forEach((l) => {
        r += Number(l.width || l.minWidth || 80);
      }), r <= n) {
        this.scrollX.value = !1;
        const l = n - r;
        if (s.length === 1)
          s[0].realWidth = Number(s[0].minWidth || 80) + l;
        else {
          const u = s.reduce((h, v) => h + Number(v.minWidth || 80), 0), c = l / u;
          let d = 0;
          s.forEach((h, v) => {
            if (v === 0)
              return;
            const m = Math.floor(Number(h.minWidth || 80) * c);
            d += m, h.realWidth = Number(h.minWidth || 80) + m;
          }), s[0].realWidth = Number(s[0].minWidth || 80) + l - d;
        }
      } else
        this.scrollX.value = !0, s.forEach((l) => {
          l.realWidth = Number(l.minWidth);
        });
      this.bodyWidth.value = Math.max(r, n), this.table.state.resizeState.value.width = this.bodyWidth.value;
    } else
      i.forEach((l) => {
        !l.width && !l.minWidth ? l.realWidth = 80 : l.realWidth = Number(l.width || l.minWidth), r += l.realWidth;
      }), this.scrollX.value = r > n, this.bodyWidth.value = r;
    const o = this.store.states.fixedColumns.value;
    if (o.length > 0) {
      let l = 0;
      o.forEach((u) => {
        l += Number(u.realWidth || u.width);
      }), this.fixedWidth.value = l;
    }
    const a = this.store.states.rightFixedColumns.value;
    if (a.length > 0) {
      let l = 0;
      a.forEach((u) => {
        l += Number(u.realWidth || u.width);
      }), this.rightFixedWidth.value = l;
    }
    this.notifyObservers("columns");
  }
  addObserver(e) {
    this.observers.push(e);
  }
  removeObserver(e) {
    const n = this.observers.indexOf(e);
    n !== -1 && this.observers.splice(n, 1);
  }
  notifyObservers(e) {
    this.observers.forEach((r) => {
      var i, s;
      switch (e) {
        case "columns":
          (i = r.state) == null || i.onColumnsChange(this);
          break;
        case "scrollable":
          (s = r.state) == null || s.onScrollableChange(this);
          break;
        default:
          throw new Error(`Table Layout don't have event ${e}.`);
      }
    });
  }
}
const { CheckboxGroup: n3 } = qi, r3 = ye({
  name: "ElTableFilterPanel",
  components: {
    ElCheckbox: qi,
    ElCheckboxGroup: n3,
    ElScrollbar: uf,
    ElTooltip: du,
    ElIcon: _t,
    ArrowDown: Gd,
    ArrowUp: Mg
  },
  directives: { ClickOutside: Om },
  props: {
    placement: {
      type: String,
      default: "bottom-start"
    },
    store: {
      type: Object
    },
    column: {
      type: Object
    },
    upDataColumn: {
      type: Function
    }
  },
  setup(t) {
    const e = ft(), { t: n } = lr(), r = ze("table-filter"), i = e == null ? void 0 : e.parent;
    i.filterPanels.value[t.column.id] || (i.filterPanels.value[t.column.id] = e);
    const s = K(!1), o = K(null), a = j(() => t.column && t.column.filters), l = j({
      get: () => {
        var w;
        return (((w = t.column) == null ? void 0 : w.filteredValue) || [])[0];
      },
      set: (w) => {
        u.value && (typeof w < "u" && w !== null ? u.value.splice(0, 1, w) : u.value.splice(0, 1));
      }
    }), u = j({
      get() {
        return t.column ? t.column.filteredValue || [] : [];
      },
      set(w) {
        t.column && t.upDataColumn("filteredValue", w);
      }
    }), c = j(() => t.column ? t.column.filterMultiple : !0), d = (w) => w.value === l.value, h = () => {
      s.value = !1;
    }, v = (w) => {
      w.stopPropagation(), s.value = !s.value;
    }, m = () => {
      s.value = !1;
    }, b = () => {
      g(u.value), h();
    }, p = () => {
      u.value = [], g(u.value), h();
    }, f = (w) => {
      l.value = w, g(typeof w < "u" && w !== null ? u.value : []), h();
    }, g = (w) => {
      t.store.commit("filterChange", {
        column: t.column,
        values: w
      }), t.store.updateAllSelected();
    };
    Ae(s, (w) => {
      t.column && t.upDataColumn("filterOpened", w);
    }, {
      immediate: !0
    });
    const y = j(() => {
      var w, _;
      return (_ = (w = o.value) == null ? void 0 : w.popperRef) == null ? void 0 : _.contentRef;
    });
    return {
      tooltipVisible: s,
      multiple: c,
      filteredValue: u,
      filterValue: l,
      filters: a,
      handleConfirm: b,
      handleReset: p,
      handleSelect: f,
      isActive: d,
      t: n,
      ns: r,
      showFilterPanel: v,
      hideFilterPanel: m,
      popperPaneRef: y,
      tooltip: o
    };
  }
}), i3 = { key: 0 }, s3 = ["disabled"], o3 = ["label", "onClick"];
function a3(t, e, n, r, i, s) {
  const o = Mt("el-checkbox"), a = Mt("el-checkbox-group"), l = Mt("el-scrollbar"), u = Mt("arrow-up"), c = Mt("arrow-down"), d = Mt("el-icon"), h = Mt("el-tooltip"), v = Ad("click-outside");
  return U(), xe(h, {
    ref: "tooltip",
    visible: t.tooltipVisible,
    offset: 0,
    placement: t.placement,
    "show-arrow": !1,
    "stop-popper-mouse-event": !1,
    teleported: "",
    effect: "light",
    pure: "",
    "popper-class": t.ns.b(),
    persistent: ""
  }, {
    content: fe(() => [
      t.multiple ? (U(), oe("div", i3, [
        le("div", {
          class: X(t.ns.e("content"))
        }, [
          ve(l, {
            "wrap-class": t.ns.e("wrap")
          }, {
            default: fe(() => [
              ve(a, {
                modelValue: t.filteredValue,
                "onUpdate:modelValue": e[0] || (e[0] = (m) => t.filteredValue = m),
                class: X(t.ns.e("checkbox-group"))
              }, {
                default: fe(() => [
                  (U(!0), oe(Ft, null, Yn(t.filters, (m) => (U(), xe(o, {
                    key: m.value,
                    label: m.value
                  }, {
                    default: fe(() => [
                      cn(st(m.text), 1)
                    ]),
                    _: 2
                  }, 1032, ["label"]))), 128))
                ]),
                _: 1
              }, 8, ["modelValue", "class"])
            ]),
            _: 1
          }, 8, ["wrap-class"])
        ], 2),
        le("div", {
          class: X(t.ns.e("bottom"))
        }, [
          le("button", {
            class: X({ [t.ns.is("disabled")]: t.filteredValue.length === 0 }),
            disabled: t.filteredValue.length === 0,
            type: "button",
            onClick: e[1] || (e[1] = (...m) => t.handleConfirm && t.handleConfirm(...m))
          }, st(t.t("el.table.confirmFilter")), 11, s3),
          le("button", {
            type: "button",
            onClick: e[2] || (e[2] = (...m) => t.handleReset && t.handleReset(...m))
          }, st(t.t("el.table.resetFilter")), 1)
        ], 2)
      ])) : (U(), oe("ul", {
        key: 1,
        class: X(t.ns.e("list"))
      }, [
        le("li", {
          class: X([
            t.ns.e("list-item"),
            {
              [t.ns.is("active")]: t.filterValue === void 0 || t.filterValue === null
            }
          ]),
          onClick: e[3] || (e[3] = (m) => t.handleSelect(null))
        }, st(t.t("el.table.clearFilter")), 3),
        (U(!0), oe(Ft, null, Yn(t.filters, (m) => (U(), oe("li", {
          key: m.value,
          class: X([t.ns.e("list-item"), t.ns.is("active", t.isActive(m))]),
          label: m.value,
          onClick: (b) => t.handleSelect(m.value)
        }, st(m.text), 11, o3))), 128))
      ], 2))
    ]),
    default: fe(() => [
      Bt((U(), oe("span", {
        class: X([
          `${t.ns.namespace.value}-table__column-filter-trigger`,
          `${t.ns.namespace.value}-none-outline`
        ]),
        onClick: e[4] || (e[4] = (...m) => t.showFilterPanel && t.showFilterPanel(...m))
      }, [
        ve(d, null, {
          default: fe(() => [
            t.column.filterOpened ? (U(), xe(u, { key: 0 })) : (U(), xe(c, { key: 1 }))
          ]),
          _: 1
        })
      ], 2)), [
        [v, t.hideFilterPanel, t.popperPaneRef]
      ])
    ]),
    _: 1
  }, 8, ["visible", "placement", "popper-class"]);
}
var l3 = /* @__PURE__ */ Ge(r3, [["render", a3], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/table/src/filter-panel.vue"]]);
function hy(t) {
  const e = ft();
  xd(() => {
    n.value.addObserver(e);
  }), Ct(() => {
    r(n.value), i(n.value);
  }), Yl(() => {
    r(n.value), i(n.value);
  }), ea(() => {
    n.value.removeObserver(e);
  });
  const n = j(() => {
    const s = t.layout;
    if (!s)
      throw new Error("Can not find table layout.");
    return s;
  }), r = (s) => {
    var o;
    const a = ((o = t.vnode.el) == null ? void 0 : o.querySelectorAll("colgroup > col")) || [];
    if (!a.length)
      return;
    const l = s.getFlattenColumns(), u = {};
    l.forEach((c) => {
      u[c.id] = c;
    });
    for (let c = 0, d = a.length; c < d; c++) {
      const h = a[c], v = h.getAttribute("name"), m = u[v];
      m && h.setAttribute("width", m.realWidth || m.width);
    }
  }, i = (s) => {
    var o, a;
    const l = ((o = t.vnode.el) == null ? void 0 : o.querySelectorAll("colgroup > col[name=gutter]")) || [];
    for (let c = 0, d = l.length; c < d; c++)
      l[c].setAttribute("width", s.scrollY.value ? s.gutterWidth : "0");
    const u = ((a = t.vnode.el) == null ? void 0 : a.querySelectorAll("th.gutter")) || [];
    for (let c = 0, d = u.length; c < d; c++) {
      const h = u[c];
      h.style.width = s.scrollY.value ? `${s.gutterWidth}px` : "0", h.style.display = s.scrollY.value ? "" : "none";
    }
  };
  return {
    tableLayout: n.value,
    onColumnsChange: r,
    onScrollableChange: i
  };
}
const Hr = Symbol("ElTable");
function u3(t, e) {
  const n = ft(), r = et(Hr), i = (b) => {
    b.stopPropagation();
  }, s = (b, p) => {
    !p.filters && p.sortable ? m(b, p, !1) : p.filterable && !p.sortable && i(b), r == null || r.emit("header-click", p, b);
  }, o = (b, p) => {
    r == null || r.emit("header-contextmenu", p, b);
  }, a = K(null), l = K(!1), u = K({}), c = (b, p) => {
    if (St && !(p.children && p.children.length > 0) && a.value && t.border) {
      l.value = !0;
      const f = r;
      e("set-drag-visible", !0);
      const y = (f == null ? void 0 : f.vnode.el).getBoundingClientRect().left, w = n.vnode.el.querySelector(`th.${p.id}`), _ = w.getBoundingClientRect(), S = _.left - y + 30;
      Bo(w, "noclick"), u.value = {
        startMouseLeft: b.clientX,
        startLeft: _.right - y,
        startColumnLeft: _.left - y,
        tableLeft: y
      };
      const A = f == null ? void 0 : f.refs.resizeProxy;
      A.style.left = `${u.value.startLeft}px`, document.onselectstart = function() {
        return !1;
      }, document.ondragstart = function() {
        return !1;
      };
      const C = (O) => {
        const N = O.clientX - u.value.startMouseLeft, B = u.value.startLeft + N;
        A.style.left = `${Math.max(S, B)}px`;
      }, k = () => {
        if (l.value) {
          const { startColumnLeft: O, startLeft: N } = u.value, D = Number.parseInt(A.style.left, 10) - O;
          p.width = p.realWidth = D, f == null || f.emit("header-dragend", p.width, N - O, p, b), requestAnimationFrame(() => {
            t.store.scheduleLayout(!1, !0);
          }), document.body.style.cursor = "", l.value = !1, a.value = null, u.value = {}, e("set-drag-visible", !1);
        }
        document.removeEventListener("mousemove", C), document.removeEventListener("mouseup", k), document.onselectstart = null, document.ondragstart = null, setTimeout(() => {
          Or(w, "noclick");
        }, 0);
      };
      document.addEventListener("mousemove", C), document.addEventListener("mouseup", k);
    }
  }, d = (b, p) => {
    if (p.children && p.children.length > 0)
      return;
    const f = b.target;
    if (!Gi(f))
      return;
    const g = f == null ? void 0 : f.closest("th");
    if (!(!p || !p.resizable) && !l.value && t.border) {
      const y = g.getBoundingClientRect(), w = document.body.style;
      y.width > 12 && y.right - b.pageX < 8 ? (w.cursor = "col-resize", Ga(g, "is-sortable") && (g.style.cursor = "col-resize"), a.value = p) : l.value || (w.cursor = "", Ga(g, "is-sortable") && (g.style.cursor = "pointer"), a.value = null);
    }
  }, h = () => {
    St && (document.body.style.cursor = "");
  }, v = ({ order: b, sortOrders: p }) => {
    if (b === "")
      return p[0];
    const f = p.indexOf(b || null);
    return p[f > p.length - 2 ? 0 : f + 1];
  }, m = (b, p, f) => {
    var g;
    b.stopPropagation();
    const y = p.order === f ? null : f || v(p), w = (g = b.target) == null ? void 0 : g.closest("th");
    if (w && Ga(w, "noclick")) {
      Or(w, "noclick");
      return;
    }
    if (!p.sortable)
      return;
    const _ = t.store.states;
    let S = _.sortProp.value, A;
    const C = _.sortingColumn.value;
    (C !== p || C === p && C.order === null) && (C && (C.order = null), _.sortingColumn.value = p, S = p.property), y ? A = p.order = y : A = p.order = null, _.sortProp.value = S, _.sortOrder.value = A, r == null || r.store.commit("changeSortCondition");
  };
  return {
    handleHeaderClick: s,
    handleHeaderContextMenu: o,
    handleMouseDown: c,
    handleMouseMove: d,
    handleMouseOut: h,
    handleSortClick: m,
    handleFilterClick: i
  };
}
function c3(t) {
  const e = et(Hr), n = ze("table");
  return {
    getHeaderRowStyle: (a) => {
      const l = e == null ? void 0 : e.props.headerRowStyle;
      return typeof l == "function" ? l.call(null, { rowIndex: a }) : l;
    },
    getHeaderRowClass: (a) => {
      const l = [], u = e == null ? void 0 : e.props.headerRowClassName;
      return typeof u == "string" ? l.push(u) : typeof u == "function" && l.push(u.call(null, { rowIndex: a })), l.join(" ");
    },
    getHeaderCellStyle: (a, l, u, c) => {
      var d;
      let h = (d = e == null ? void 0 : e.props.headerCellStyle) != null ? d : {};
      typeof h == "function" && (h = h.call(null, {
        rowIndex: a,
        columnIndex: l,
        row: u,
        column: c
      }));
      const v = mf(l, c.fixed, t.store, u);
      return Us(v, "left"), Us(v, "right"), Object.assign({}, h, v);
    },
    getHeaderCellClass: (a, l, u, c) => {
      const d = gf(n.b(), l, c.fixed, t.store, u), h = [
        c.id,
        c.order,
        c.headerAlign,
        c.className,
        c.labelClassName,
        ...d
      ];
      c.children || h.push("is-leaf"), c.sortable && h.push("is-sortable");
      const v = e == null ? void 0 : e.props.headerCellClassName;
      return typeof v == "string" ? h.push(v) : typeof v == "function" && h.push(v.call(null, {
        rowIndex: a,
        columnIndex: l,
        row: u,
        column: c
      })), h.push(n.e("cell")), h.filter((m) => !!m).join(" ");
    }
  };
}
const py = (t) => {
  const e = [];
  return t.forEach((n) => {
    n.children ? (e.push(n), e.push.apply(e, py(n.children))) : e.push(n);
  }), e;
}, d3 = (t) => {
  let e = 1;
  const n = (s, o) => {
    if (o && (s.level = o.level + 1, e < s.level && (e = s.level)), s.children) {
      let a = 0;
      s.children.forEach((l) => {
        n(l, s), a += l.colSpan;
      }), s.colSpan = a;
    } else
      s.colSpan = 1;
  };
  t.forEach((s) => {
    s.level = 1, n(s, void 0);
  });
  const r = [];
  for (let s = 0; s < e; s++)
    r.push([]);
  return py(t).forEach((s) => {
    s.children ? (s.rowSpan = 1, s.children.forEach((o) => o.isSubColumn = !0)) : s.rowSpan = e - s.level + 1, r[s.level - 1].push(s);
  }), r;
};
function f3(t) {
  const e = et(Hr), n = j(() => d3(t.store.states.originColumns.value));
  return {
    isGroup: j(() => {
      const s = n.value.length > 1;
      return s && e && (e.state.isGroup.value = !0), s;
    }),
    toggleAllSelection: (s) => {
      s.stopPropagation(), e == null || e.store.commit("toggleAllSelection");
    },
    columnRows: n
  };
}
var h3 = ye({
  name: "ElTableHeader",
  components: {
    ElCheckbox: qi
  },
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: !0,
      type: Object
    },
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => ({
        prop: "",
        order: ""
      })
    }
  },
  setup(t, { emit: e }) {
    const n = ft(), r = et(Hr), i = ze("table"), s = K({}), { onColumnsChange: o, onScrollableChange: a } = hy(r);
    Ct(async () => {
      await rt(), await rt();
      const { prop: S, order: A } = t.defaultSort;
      r == null || r.store.commit("sort", { prop: S, order: A, init: !0 });
    });
    const {
      handleHeaderClick: l,
      handleHeaderContextMenu: u,
      handleMouseDown: c,
      handleMouseMove: d,
      handleMouseOut: h,
      handleSortClick: v,
      handleFilterClick: m
    } = u3(t, e), {
      getHeaderRowStyle: b,
      getHeaderRowClass: p,
      getHeaderCellStyle: f,
      getHeaderCellClass: g
    } = c3(t), { isGroup: y, toggleAllSelection: w, columnRows: _ } = f3(t);
    return n.state = {
      onColumnsChange: o,
      onScrollableChange: a
    }, n.filterPanels = s, {
      ns: i,
      filterPanels: s,
      onColumnsChange: o,
      onScrollableChange: a,
      columnRows: _,
      getHeaderRowClass: p,
      getHeaderRowStyle: b,
      getHeaderCellClass: g,
      getHeaderCellStyle: f,
      handleHeaderClick: l,
      handleHeaderContextMenu: u,
      handleMouseDown: c,
      handleMouseMove: d,
      handleMouseOut: h,
      handleSortClick: v,
      handleFilterClick: m,
      isGroup: y,
      toggleAllSelection: w
    };
  },
  render() {
    const {
      ns: t,
      isGroup: e,
      columnRows: n,
      getHeaderCellStyle: r,
      getHeaderCellClass: i,
      getHeaderRowClass: s,
      getHeaderRowStyle: o,
      handleHeaderClick: a,
      handleHeaderContextMenu: l,
      handleMouseDown: u,
      handleMouseMove: c,
      handleSortClick: d,
      handleMouseOut: h,
      store: v,
      $parent: m
    } = this;
    let b = 1;
    return Xe("thead", {
      class: { [t.is("group")]: e }
    }, n.map((p, f) => Xe("tr", {
      class: s(f),
      key: f,
      style: o(f)
    }, p.map((g, y) => (g.rowSpan > b && (b = g.rowSpan), Xe("th", {
      class: i(f, y, p, g),
      colspan: g.colSpan,
      key: `${g.id}-thead`,
      rowspan: g.rowSpan,
      style: r(f, y, p, g),
      onClick: (w) => a(w, g),
      onContextmenu: (w) => l(w, g),
      onMousedown: (w) => u(w, g),
      onMousemove: (w) => c(w, g),
      onMouseout: h
    }, [
      Xe("div", {
        class: [
          "cell",
          g.filteredValue && g.filteredValue.length > 0 ? "highlight" : ""
        ]
      }, [
        g.renderHeader ? g.renderHeader({
          column: g,
          $index: y,
          store: v,
          _self: m
        }) : g.label,
        g.sortable && Xe("span", {
          onClick: (w) => d(w, g),
          class: "caret-wrapper"
        }, [
          Xe("i", {
            onClick: (w) => d(w, g, "ascending"),
            class: "sort-caret ascending"
          }),
          Xe("i", {
            onClick: (w) => d(w, g, "descending"),
            class: "sort-caret descending"
          })
        ]),
        g.filterable && Xe(l3, {
          store: v,
          placement: g.filterPlacement || "bottom-start",
          column: g,
          upDataColumn: (w, _) => {
            g[w] = _;
          }
        })
      ])
    ]))))));
  }
});
function p3(t) {
  const e = et(Hr), n = K(""), r = K(Xe("div")), { nextZIndex: i } = lu(), s = (m, b, p) => {
    var f;
    const g = e, y = Hu(m);
    let w;
    const _ = (f = g == null ? void 0 : g.vnode.el) == null ? void 0 : f.dataset.prefix;
    y && (w = Op({
      columns: t.store.states.columns.value
    }, y, _), w && (g == null || g.emit(`cell-${p}`, b, w, y, m))), g == null || g.emit(`row-${p}`, b, w, m);
  }, o = (m, b) => {
    s(m, b, "dblclick");
  }, a = (m, b) => {
    t.store.commit("setCurrentRow", b), s(m, b, "click");
  }, l = (m, b) => {
    s(m, b, "contextmenu");
  }, u = ni((m) => {
    t.store.commit("setHoverRow", m);
  }, 30), c = ni(() => {
    t.store.commit("setHoverRow", null);
  }, 30), d = (m) => {
    const b = window.getComputedStyle(m, null), p = Number.parseInt(b.paddingLeft, 10) || 0, f = Number.parseInt(b.paddingRight, 10) || 0, g = Number.parseInt(b.paddingTop, 10) || 0, y = Number.parseInt(b.paddingBottom, 10) || 0;
    return {
      left: p,
      right: f,
      top: g,
      bottom: y
    };
  };
  return {
    handleDoubleClick: o,
    handleClick: a,
    handleContextMenu: l,
    handleMouseEnter: u,
    handleMouseLeave: c,
    handleCellMouseEnter: (m, b, p) => {
      var f;
      const g = e, y = Hu(m), w = (f = g == null ? void 0 : g.vnode.el) == null ? void 0 : f.dataset.prefix;
      if (y) {
        const L = Op({
          columns: t.store.states.columns.value
        }, y, w), V = g.hoverState = { cell: y, column: L, row: b };
        g == null || g.emit("cell-mouse-enter", V.row, V.column, V.cell, m);
      }
      if (!p)
        return;
      const _ = m.target.querySelector(".cell");
      if (!(Ga(_, `${w}-tooltip`) && _.childNodes.length))
        return;
      const S = document.createRange();
      S.setStart(_, 0), S.setEnd(_, _.childNodes.length);
      let A = S.getBoundingClientRect().width, C = S.getBoundingClientRect().height;
      A - Math.floor(A) < 1e-3 && (A = Math.floor(A)), C - Math.floor(C) < 1e-3 && (C = Math.floor(C));
      const { top: N, left: B, right: D, bottom: F } = d(_), Z = B + D, te = N + F;
      (A + Z > _.offsetWidth || C + te > _.offsetHeight || _.scrollWidth > _.offsetWidth) && KP(e == null ? void 0 : e.refs.tableWrapper, y, y.innerText || y.textContent, i, p);
    },
    handleCellMouseLeave: (m) => {
      if (!Hu(m))
        return;
      const p = e == null ? void 0 : e.hoverState;
      e == null || e.emit("cell-mouse-leave", p == null ? void 0 : p.row, p == null ? void 0 : p.column, p == null ? void 0 : p.cell, m);
    },
    tooltipContent: n,
    tooltipTrigger: r
  };
}
function v3(t) {
  const e = et(Hr), n = ze("table");
  return {
    getRowStyle: (u, c) => {
      const d = e == null ? void 0 : e.props.rowStyle;
      return typeof d == "function" ? d.call(null, {
        row: u,
        rowIndex: c
      }) : d || null;
    },
    getRowClass: (u, c) => {
      const d = [n.e("row")];
      e != null && e.props.highlightCurrentRow && u === t.store.states.currentRow.value && d.push("current-row"), t.stripe && c % 2 === 1 && d.push(n.em("row", "striped"));
      const h = e == null ? void 0 : e.props.rowClassName;
      return typeof h == "string" ? d.push(h) : typeof h == "function" && d.push(h.call(null, {
        row: u,
        rowIndex: c
      })), d;
    },
    getCellStyle: (u, c, d, h) => {
      const v = e == null ? void 0 : e.props.cellStyle;
      let m = v ?? {};
      typeof v == "function" && (m = v.call(null, {
        rowIndex: u,
        columnIndex: c,
        row: d,
        column: h
      }));
      const b = mf(c, t == null ? void 0 : t.fixed, t.store);
      return Us(b, "left"), Us(b, "right"), Object.assign({}, m, b);
    },
    getCellClass: (u, c, d, h, v) => {
      const m = gf(n.b(), c, t == null ? void 0 : t.fixed, t.store, void 0, v), b = [h.id, h.align, h.className, ...m], p = e == null ? void 0 : e.props.cellClassName;
      return typeof p == "string" ? b.push(p) : typeof p == "function" && b.push(p.call(null, {
        rowIndex: u,
        columnIndex: c,
        row: d,
        column: h
      })), b.push(n.e("cell")), b.filter((f) => !!f).join(" ");
    },
    getSpan: (u, c, d, h) => {
      let v = 1, m = 1;
      const b = e == null ? void 0 : e.props.spanMethod;
      if (typeof b == "function") {
        const p = b({
          row: u,
          column: c,
          rowIndex: d,
          columnIndex: h
        });
        Array.isArray(p) ? (v = p[0], m = p[1]) : typeof p == "object" && (v = p.rowspan, m = p.colspan);
      }
      return { rowspan: v, colspan: m };
    },
    getColspanRealWidth: (u, c, d) => {
      if (c < 1)
        return u[d].realWidth;
      const h = u.map(({ realWidth: v, width: m }) => v || m).slice(d, d + c);
      return Number(h.reduce((v, m) => Number(v) + Number(m), -1));
    }
  };
}
function g3(t) {
  const e = et(Hr), n = ze("table"), {
    handleDoubleClick: r,
    handleClick: i,
    handleContextMenu: s,
    handleMouseEnter: o,
    handleMouseLeave: a,
    handleCellMouseEnter: l,
    handleCellMouseLeave: u,
    tooltipContent: c,
    tooltipTrigger: d
  } = p3(t), {
    getRowStyle: h,
    getRowClass: v,
    getCellStyle: m,
    getCellClass: b,
    getSpan: p,
    getColspanRealWidth: f
  } = v3(t), g = j(() => t.store.states.columns.value.findIndex(({ type: A }) => A === "default")), y = (A, C) => {
    const k = e.props.rowKey;
    return k ? bn(A, k) : C;
  }, w = (A, C, k, O = !1) => {
    const { tooltipEffect: N, tooltipOptions: B, store: D } = t, { indent: F, columns: Z } = D.states, te = v(A, C);
    let L = !0;
    return k && (te.push(n.em("row", `level-${k.level}`)), L = k.display), Xe("tr", {
      style: [L ? null : {
        display: "none"
      }, h(A, C)],
      class: te,
      key: y(A, C),
      onDblclick: (H) => r(H, A),
      onClick: (H) => i(H, A),
      onContextmenu: (H) => s(H, A),
      onMouseenter: () => o(C),
      onMouseleave: a
    }, Z.value.map((H, ie) => {
      const { rowspan: ne, colspan: Y } = p(A, H, C, ie);
      if (!ne || !Y)
        return null;
      const de = Object.assign({}, H);
      de.realWidth = f(Z.value, Y, ie);
      const ue = {
        store: t.store,
        _self: t.context || e,
        column: de,
        row: A,
        $index: C,
        cellIndex: ie,
        expanded: O
      };
      ie === g.value && k && (ue.treeNode = {
        indent: k.level * F.value,
        level: k.level
      }, typeof k.expanded == "boolean" && (ue.treeNode.expanded = k.expanded, "loading" in k && (ue.treeNode.loading = k.loading), "noLazyChildren" in k && (ue.treeNode.noLazyChildren = k.noLazyChildren)));
      const Te = `${C},${ie}`, _e = de.columnKey || de.rawColumnKey || "", Fe = _(ie, H, ue), Ce = H.showOverflowTooltip && Rg({
        effect: N
      }, B, H.showOverflowTooltip);
      return Xe("td", {
        style: m(C, ie, A, H),
        class: b(C, ie, A, H, Y - 1),
        key: `${_e}${Te}`,
        rowspan: ne,
        colspan: Y,
        onMouseenter: (tt) => l(tt, A, Ce),
        onMouseleave: u
      }, [Fe]);
    }));
  }, _ = (A, C, k) => C.renderCell(k);
  return {
    wrappedRowRender: (A, C) => {
      const k = t.store, { isRowExpanded: O, assertRowKey: N } = k, { treeData: B, lazyTreeNodeMap: D, childrenColumnName: F, rowKey: Z } = k.states, te = k.states.columns.value;
      if (te.some(({ type: V }) => V === "expand")) {
        const V = O(A), H = w(A, C, void 0, V), ie = e.renderExpanded;
        return V ? ie ? [
          [
            H,
            Xe("tr", {
              key: `expanded-row__${H.key}`
            }, [
              Xe("td", {
                colspan: te.length,
                class: `${n.e("cell")} ${n.e("expanded-cell")}`
              }, [ie({ row: A, $index: C, store: k, expanded: V })])
            ])
          ]
        ] : (console.error("[Element Error]renderExpanded is required."), H) : [[H]];
      } else if (Object.keys(B.value).length) {
        N();
        const V = bn(A, Z.value);
        let H = B.value[V], ie = null;
        H && (ie = {
          expanded: H.expanded,
          level: H.level,
          display: !0
        }, typeof H.lazy == "boolean" && (typeof H.loaded == "boolean" && H.loaded && (ie.noLazyChildren = !(H.children && H.children.length)), ie.loading = H.loading));
        const ne = [w(A, C, ie)];
        if (H) {
          let Y = 0;
          const de = (Te, _e) => {
            Te && Te.length && _e && Te.forEach((Fe) => {
              const Ce = {
                display: _e.display && _e.expanded,
                level: _e.level + 1,
                expanded: !1,
                noLazyChildren: !1,
                loading: !1
              }, tt = bn(Fe, Z.value);
              if (tt == null)
                throw new Error("For nested data item, row-key is required.");
              if (H = { ...B.value[tt] }, H && (Ce.expanded = H.expanded, H.level = H.level || Ce.level, H.display = !!(H.expanded && Ce.display), typeof H.lazy == "boolean" && (typeof H.loaded == "boolean" && H.loaded && (Ce.noLazyChildren = !(H.children && H.children.length)), Ce.loading = H.loading)), Y++, ne.push(w(Fe, C + Y, Ce)), H) {
                const je = D.value[tt] || Fe[F.value];
                de(je, H);
              }
            });
          };
          H.display = !0;
          const ue = D.value[V] || A[F.value];
          de(ue, H);
        }
        return ne;
      } else
        return w(A, C, void 0);
    },
    tooltipContent: c,
    tooltipTrigger: d
  };
}
const m3 = {
  store: {
    required: !0,
    type: Object
  },
  stripe: Boolean,
  tooltipEffect: String,
  tooltipOptions: {
    type: Object
  },
  context: {
    default: () => ({}),
    type: Object
  },
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  fixed: {
    type: String,
    default: ""
  },
  highlight: Boolean
};
var y3 = ye({
  name: "ElTableBody",
  props: m3,
  setup(t) {
    const e = ft(), n = et(Hr), r = ze("table"), { wrappedRowRender: i, tooltipContent: s, tooltipTrigger: o } = g3(t), { onColumnsChange: a, onScrollableChange: l } = hy(n);
    return Ae(t.store.states.hoverRow, (u, c) => {
      !t.store.states.isComplex.value || !St || nT(() => {
        const d = e == null ? void 0 : e.vnode.el, h = Array.from((d == null ? void 0 : d.children) || []).filter((b) => b == null ? void 0 : b.classList.contains(`${r.e("row")}`)), v = h[c], m = h[u];
        v && Or(v, "hover-row"), m && Bo(m, "hover-row");
      });
    }), ea(() => {
      var u;
      (u = Gr) == null || u();
    }), {
      ns: r,
      onColumnsChange: a,
      onScrollableChange: l,
      wrappedRowRender: i,
      tooltipContent: s,
      tooltipTrigger: o
    };
  },
  render() {
    const { wrappedRowRender: t, store: e } = this, n = e.states.data.value || [];
    return Xe("tbody", { tabIndex: -1 }, [
      n.reduce((r, i) => r.concat(t(i, r.length)), [])
    ]);
  }
});
function b3() {
  const t = et(Hr), e = t == null ? void 0 : t.store, n = j(() => e.states.fixedLeafColumnsLength.value), r = j(() => e.states.rightFixedColumns.value.length), i = j(() => e.states.columns.value.length), s = j(() => e.states.fixedColumns.value.length), o = j(() => e.states.rightFixedColumns.value.length);
  return {
    leftFixedLeafCount: n,
    rightFixedLeafCount: r,
    columnsCount: i,
    leftFixedCount: s,
    rightFixedCount: o,
    columns: e.states.columns
  };
}
function w3(t) {
  const { columns: e } = b3(), n = ze("table");
  return {
    getCellClasses: (s, o) => {
      const a = s[o], l = [
        n.e("cell"),
        a.id,
        a.align,
        a.labelClassName,
        ...gf(n.b(), o, a.fixed, t.store)
      ];
      return a.className && l.push(a.className), a.children || l.push(n.is("leaf")), l;
    },
    getCellStyles: (s, o) => {
      const a = mf(o, s.fixed, t.store);
      return Us(a, "left"), Us(a, "right"), a;
    },
    columns: e
  };
}
var _3 = ye({
  name: "ElTableFooter",
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: !0,
      type: Object
    },
    summaryMethod: Function,
    sumText: String,
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => ({
        prop: "",
        order: ""
      })
    }
  },
  setup(t) {
    const { getCellClasses: e, getCellStyles: n, columns: r } = w3(t);
    return {
      ns: ze("table"),
      getCellClasses: e,
      getCellStyles: n,
      columns: r
    };
  },
  render() {
    const { columns: t, getCellStyles: e, getCellClasses: n, summaryMethod: r, sumText: i } = this, s = this.store.states.data.value;
    let o = [];
    return r ? o = r({
      columns: t,
      data: s
    }) : t.forEach((a, l) => {
      if (l === 0) {
        o[l] = i;
        return;
      }
      const u = s.map((v) => Number(v[a.property])), c = [];
      let d = !0;
      u.forEach((v) => {
        if (!Number.isNaN(+v)) {
          d = !1;
          const m = `${v}`.split(".")[1];
          c.push(m ? m.length : 0);
        }
      });
      const h = Math.max.apply(null, c);
      d ? o[l] = "" : o[l] = u.reduce((v, m) => {
        const b = Number(m);
        return Number.isNaN(+b) ? v : Number.parseFloat((v + m).toFixed(Math.min(h, 20)));
      }, 0);
    }), Xe(Xe("tfoot", [
      Xe("tr", {}, [
        ...t.map((a, l) => Xe("td", {
          key: l,
          colspan: a.colSpan,
          rowspan: a.rowSpan,
          class: n(t, l),
          style: e(a, l)
        }, [
          Xe("div", {
            class: ["cell", a.labelClassName]
          }, [o[l]])
        ]))
      ])
    ]));
  }
});
function S3(t) {
  return {
    setCurrentRow: (c) => {
      t.commit("setCurrentRow", c);
    },
    getSelectionRows: () => t.getSelectionRows(),
    toggleRowSelection: (c, d) => {
      t.toggleRowSelection(c, d, !1), t.updateAllSelected();
    },
    clearSelection: () => {
      t.clearSelection();
    },
    clearFilter: (c) => {
      t.clearFilter(c);
    },
    toggleAllSelection: () => {
      t.commit("toggleAllSelection");
    },
    toggleRowExpansion: (c, d) => {
      t.toggleRowExpansionAdapter(c, d);
    },
    clearSort: () => {
      t.clearSort();
    },
    sort: (c, d) => {
      t.commit("sort", { prop: c, order: d });
    }
  };
}
function E3(t, e, n, r) {
  const i = K(!1), s = K(null), o = K(!1), a = (H) => {
    o.value = H;
  }, l = K({
    width: null,
    height: null,
    headerHeight: null
  }), u = K(!1), c = {
    display: "inline-block",
    verticalAlign: "middle"
  }, d = K(), h = K(0), v = K(0), m = K(0), b = K(0), p = K(0);
  go(() => {
    e.setHeight(t.height);
  }), go(() => {
    e.setMaxHeight(t.maxHeight);
  }), Ae(() => [t.currentRowKey, n.states.rowKey], ([H, ie]) => {
    !x(ie) || !x(H) || n.setCurrentRowKey(`${H}`);
  }, {
    immediate: !0
  }), Ae(() => t.data, (H) => {
    r.store.commit("setData", H);
  }, {
    immediate: !0,
    deep: !0
  }), go(() => {
    t.expandRowKeys && n.setExpandRowKeysAdapter(t.expandRowKeys);
  });
  const f = () => {
    r.store.commit("setHoverRow", null), r.hoverState && (r.hoverState = null);
  }, g = (H, ie) => {
    const { pixelX: ne, pixelY: Y } = ie;
    Math.abs(ne) >= Math.abs(Y) && (r.refs.bodyWrapper.scrollLeft += ie.pixelX / 5);
  }, y = j(() => t.height || t.maxHeight || n.states.fixedColumns.value.length > 0 || n.states.rightFixedColumns.value.length > 0), w = j(() => ({
    width: e.bodyWidth.value ? `${e.bodyWidth.value}px` : ""
  })), _ = () => {
    y.value && e.updateElsHeight(), e.updateColumnsWidth(), requestAnimationFrame(k);
  };
  Ct(async () => {
    await rt(), n.updateColumns(), O(), requestAnimationFrame(_);
    const H = r.vnode.el, ie = r.refs.headerWrapper;
    t.flexible && H && H.parentElement && (H.parentElement.style.minWidth = "0"), l.value = {
      width: d.value = H.offsetWidth,
      height: H.offsetHeight,
      headerHeight: t.showHeader && ie ? ie.offsetHeight : null
    }, n.states.columns.value.forEach((ne) => {
      ne.filteredValue && ne.filteredValue.length && r.store.commit("filterChange", {
        column: ne,
        values: ne.filteredValue,
        silent: !0
      });
    }), r.$ready = !0;
  });
  const S = (H, ie) => {
    if (!H)
      return;
    const ne = Array.from(H.classList).filter((Y) => !Y.startsWith("is-scrolling-"));
    ne.push(e.scrollX.value ? ie : "is-scrolling-none"), H.className = ne.join(" ");
  }, A = (H) => {
    const { tableWrapper: ie } = r.refs;
    S(ie, H);
  }, C = (H) => {
    const { tableWrapper: ie } = r.refs;
    return !!(ie && ie.classList.contains(H));
  }, k = function() {
    if (!r.refs.scrollBarRef)
      return;
    if (!e.scrollX.value) {
      const _e = "is-scrolling-none";
      C(_e) || A(_e);
      return;
    }
    const H = r.refs.scrollBarRef.wrapRef;
    if (!H)
      return;
    const { scrollLeft: ie, offsetWidth: ne, scrollWidth: Y } = H, { headerWrapper: de, footerWrapper: ue } = r.refs;
    de && (de.scrollLeft = ie), ue && (ue.scrollLeft = ie);
    const Te = Y - ne - 1;
    ie >= Te ? A("is-scrolling-right") : A(ie === 0 ? "is-scrolling-left" : "is-scrolling-middle");
  }, O = () => {
    r.refs.scrollBarRef && (r.refs.scrollBarRef.wrapRef && wn(r.refs.scrollBarRef.wrapRef, "scroll", k, {
      passive: !0
    }), t.fit ? Ds(r.vnode.el, N) : wn(window, "resize", N), Ds(r.refs.bodyWrapper, () => {
      var H, ie;
      N(), (ie = (H = r.refs) == null ? void 0 : H.scrollBarRef) == null || ie.update();
    }));
  }, N = () => {
    var H, ie, ne, Y;
    const de = r.vnode.el;
    if (!r.$ready || !de)
      return;
    let ue = !1;
    const {
      width: Te,
      height: _e,
      headerHeight: Fe
    } = l.value, Ce = d.value = de.offsetWidth;
    Te !== Ce && (ue = !0);
    const tt = de.offsetHeight;
    (t.height || y.value) && _e !== tt && (ue = !0);
    const je = t.tableLayout === "fixed" ? r.refs.headerWrapper : (H = r.refs.tableHeaderRef) == null ? void 0 : H.$el;
    t.showHeader && (je == null ? void 0 : je.offsetHeight) !== Fe && (ue = !0), h.value = ((ie = r.refs.tableWrapper) == null ? void 0 : ie.scrollHeight) || 0, m.value = (je == null ? void 0 : je.scrollHeight) || 0, b.value = ((ne = r.refs.footerWrapper) == null ? void 0 : ne.offsetHeight) || 0, p.value = ((Y = r.refs.appendWrapper) == null ? void 0 : Y.offsetHeight) || 0, v.value = h.value - m.value - b.value - p.value, ue && (l.value = {
      width: Ce,
      height: tt,
      headerHeight: t.showHeader && (je == null ? void 0 : je.offsetHeight) || 0
    }, _());
  }, B = jr(), D = j(() => {
    const { bodyWidth: H, scrollY: ie, gutterWidth: ne } = e;
    return H.value ? `${H.value - (ie.value ? ne : 0)}px` : "";
  }), F = j(() => t.maxHeight ? "fixed" : t.tableLayout), Z = j(() => {
    if (t.data && t.data.length)
      return null;
    let H = "100%";
    t.height && v.value && (H = `${v.value}px`);
    const ie = d.value;
    return {
      width: ie ? `${ie}px` : "",
      height: H
    };
  }), te = j(() => t.height ? {
    height: Number.isNaN(Number(t.height)) ? t.height : `${t.height}px`
  } : t.maxHeight ? {
    maxHeight: Number.isNaN(Number(t.maxHeight)) ? t.maxHeight : `${t.maxHeight}px`
  } : {}), L = j(() => t.height ? {
    height: "100%"
  } : t.maxHeight ? Number.isNaN(Number(t.maxHeight)) ? {
    maxHeight: `calc(${t.maxHeight} - ${m.value + b.value}px)`
  } : {
    maxHeight: `${t.maxHeight - m.value - b.value}px`
  } : {});
  return {
    isHidden: i,
    renderExpanded: s,
    setDragVisible: a,
    isGroup: u,
    handleMouseLeave: f,
    handleHeaderFooterMousewheel: g,
    tableSize: B,
    emptyBlockStyle: Z,
    handleFixedMousewheel: (H, ie) => {
      const ne = r.refs.bodyWrapper;
      if (Math.abs(ie.spinY) > 0) {
        const Y = ne.scrollTop;
        ie.pixelY < 0 && Y !== 0 && H.preventDefault(), ie.pixelY > 0 && ne.scrollHeight - ne.clientHeight > Y && H.preventDefault(), ne.scrollTop += Math.ceil(ie.pixelY / 5);
      } else
        ne.scrollLeft += Math.ceil(ie.pixelX / 5);
    },
    resizeProxyVisible: o,
    bodyWidth: D,
    resizeState: l,
    doLayout: _,
    tableBodyStyles: w,
    tableLayout: F,
    scrollbarViewStyle: c,
    tableInnerStyle: te,
    scrollbarStyle: L
  };
}
function x3(t) {
  const e = K(), n = () => {
    const i = t.vnode.el.querySelector(".hidden-columns"), s = { childList: !0, subtree: !0 }, o = t.store.states.updateOrderFns;
    e.value = new MutationObserver(() => {
      o.forEach((a) => a());
    }), e.value.observe(i, s);
  };
  Ct(() => {
    n();
  }), ea(() => {
    var r;
    (r = e.value) == null || r.disconnect();
  });
}
var A3 = {
  data: {
    type: Array,
    default: () => []
  },
  size: zr,
  width: [String, Number],
  height: [String, Number],
  maxHeight: [String, Number],
  fit: {
    type: Boolean,
    default: !0
  },
  stripe: Boolean,
  border: Boolean,
  rowKey: [String, Function],
  showHeader: {
    type: Boolean,
    default: !0
  },
  showSummary: Boolean,
  sumText: String,
  summaryMethod: Function,
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  cellClassName: [String, Function],
  cellStyle: [Object, Function],
  headerRowClassName: [String, Function],
  headerRowStyle: [Object, Function],
  headerCellClassName: [String, Function],
  headerCellStyle: [Object, Function],
  highlightCurrentRow: Boolean,
  currentRowKey: [String, Number],
  emptyText: String,
  expandRowKeys: Array,
  defaultExpandAll: Boolean,
  defaultSort: Object,
  tooltipEffect: String,
  tooltipOptions: Object,
  spanMethod: Function,
  selectOnIndeterminate: {
    type: Boolean,
    default: !0
  },
  indent: {
    type: Number,
    default: 16
  },
  treeProps: {
    type: Object,
    default: () => ({
      hasChildren: "hasChildren",
      children: "children"
    })
  },
  lazy: Boolean,
  load: Function,
  style: {
    type: Object,
    default: () => ({})
  },
  className: {
    type: String,
    default: ""
  },
  tableLayout: {
    type: String,
    default: "fixed"
  },
  scrollbarAlwaysOn: {
    type: Boolean,
    default: !1
  },
  flexible: Boolean,
  showOverflowTooltip: [Boolean, Object]
};
function vy(t) {
  const e = t.tableLayout === "auto";
  let n = t.columns || [];
  e && n.every((i) => i.width === void 0) && (n = []);
  const r = (i) => {
    const s = {
      key: `${t.tableLayout}_${i.id}`,
      style: {},
      name: void 0
    };
    return e ? s.style = {
      width: `${i.width}px`
    } : s.name = i.id, s;
  };
  return Xe("colgroup", {}, n.map((i) => Xe("col", r(i))));
}
vy.props = ["columns", "tableLayout"];
const k3 = () => {
  const t = K(), e = (s, o) => {
    const a = t.value;
    a && a.scrollTo(s, o);
  }, n = (s, o) => {
    const a = t.value;
    a && mt(o) && ["Top", "Left"].includes(s) && a[`setScroll${s}`](o);
  };
  return {
    scrollBarRef: t,
    scrollTo: e,
    setScrollTop: (s) => n("Top", s),
    setScrollLeft: (s) => n("Left", s)
  };
};
let C3 = 1;
const T3 = ye({
  name: "ElTable",
  directives: {
    Mousewheel: MN
  },
  components: {
    TableHeader: h3,
    TableBody: y3,
    TableFooter: _3,
    ElScrollbar: uf,
    hColgroup: vy
  },
  props: A3,
  emits: [
    "select",
    "select-all",
    "selection-change",
    "cell-mouse-enter",
    "cell-mouse-leave",
    "cell-contextmenu",
    "cell-click",
    "cell-dblclick",
    "row-click",
    "row-contextmenu",
    "row-dblclick",
    "header-click",
    "header-contextmenu",
    "sort-change",
    "filter-change",
    "current-change",
    "header-dragend",
    "expand-change"
  ],
  setup(t) {
    const { t: e } = lr(), n = ze("table"), r = ft();
    qt(Hr, r);
    const i = XP(r, t);
    r.store = i;
    const s = new t3({
      store: r.store,
      table: r,
      fit: t.fit,
      showHeader: t.showHeader
    });
    r.layout = s;
    const o = j(() => (i.states.data.value || []).length === 0), {
      setCurrentRow: a,
      getSelectionRows: l,
      toggleRowSelection: u,
      clearSelection: c,
      clearFilter: d,
      toggleAllSelection: h,
      toggleRowExpansion: v,
      clearSort: m,
      sort: b
    } = S3(i), {
      isHidden: p,
      renderExpanded: f,
      setDragVisible: g,
      isGroup: y,
      handleMouseLeave: w,
      handleHeaderFooterMousewheel: _,
      tableSize: S,
      emptyBlockStyle: A,
      handleFixedMousewheel: C,
      resizeProxyVisible: k,
      bodyWidth: O,
      resizeState: N,
      doLayout: B,
      tableBodyStyles: D,
      tableLayout: F,
      scrollbarViewStyle: Z,
      tableInnerStyle: te,
      scrollbarStyle: L
    } = E3(t, s, i, r), { scrollBarRef: V, scrollTo: H, setScrollLeft: ie, setScrollTop: ne } = k3(), Y = ni(B, 50), de = `${n.namespace.value}-table_${C3++}`;
    r.tableId = de, r.state = {
      isGroup: y,
      resizeState: N,
      doLayout: B,
      debouncedUpdateLayout: Y
    };
    const ue = j(() => t.sumText || e("el.table.sumText")), Te = j(() => t.emptyText || e("el.table.emptyText"));
    return x3(r), {
      ns: n,
      layout: s,
      store: i,
      handleHeaderFooterMousewheel: _,
      handleMouseLeave: w,
      tableId: de,
      tableSize: S,
      isHidden: p,
      isEmpty: o,
      renderExpanded: f,
      resizeProxyVisible: k,
      resizeState: N,
      isGroup: y,
      bodyWidth: O,
      tableBodyStyles: D,
      emptyBlockStyle: A,
      debouncedUpdateLayout: Y,
      handleFixedMousewheel: C,
      setCurrentRow: a,
      getSelectionRows: l,
      toggleRowSelection: u,
      clearSelection: c,
      clearFilter: d,
      toggleAllSelection: h,
      toggleRowExpansion: v,
      clearSort: m,
      doLayout: B,
      sort: b,
      t: e,
      setDragVisible: g,
      context: r,
      computedSumText: ue,
      computedEmptyText: Te,
      tableLayout: F,
      scrollbarViewStyle: Z,
      tableInnerStyle: te,
      scrollbarStyle: L,
      scrollBarRef: V,
      scrollTo: H,
      setScrollLeft: ie,
      setScrollTop: ne
    };
  }
}), O3 = ["data-prefix"], I3 = {
  ref: "hiddenColumns",
  class: "hidden-columns"
};
function N3(t, e, n, r, i, s) {
  const o = Mt("hColgroup"), a = Mt("table-header"), l = Mt("table-body"), u = Mt("table-footer"), c = Mt("el-scrollbar"), d = Ad("mousewheel");
  return U(), oe("div", {
    ref: "tableWrapper",
    class: X([
      {
        [t.ns.m("fit")]: t.fit,
        [t.ns.m("striped")]: t.stripe,
        [t.ns.m("border")]: t.border || t.isGroup,
        [t.ns.m("hidden")]: t.isHidden,
        [t.ns.m("group")]: t.isGroup,
        [t.ns.m("fluid-height")]: t.maxHeight,
        [t.ns.m("scrollable-x")]: t.layout.scrollX.value,
        [t.ns.m("scrollable-y")]: t.layout.scrollY.value,
        [t.ns.m("enable-row-hover")]: !t.store.states.isComplex.value,
        [t.ns.m("enable-row-transition")]: (t.store.states.data.value || []).length !== 0 && (t.store.states.data.value || []).length < 100,
        "has-footer": t.showSummary
      },
      t.ns.m(t.tableSize),
      t.className,
      t.ns.b(),
      t.ns.m(`layout-${t.tableLayout}`)
    ]),
    style: it(t.style),
    "data-prefix": t.ns.namespace.value,
    onMouseleave: e[0] || (e[0] = (...h) => t.handleMouseLeave && t.handleMouseLeave(...h))
  }, [
    le("div", {
      class: X(t.ns.e("inner-wrapper")),
      style: it(t.tableInnerStyle)
    }, [
      le("div", I3, [
        Me(t.$slots, "default")
      ], 512),
      t.showHeader && t.tableLayout === "fixed" ? Bt((U(), oe("div", {
        key: 0,
        ref: "headerWrapper",
        class: X(t.ns.e("header-wrapper"))
      }, [
        le("table", {
          ref: "tableHeader",
          class: X(t.ns.e("header")),
          style: it(t.tableBodyStyles),
          border: "0",
          cellpadding: "0",
          cellspacing: "0"
        }, [
          ve(o, {
            columns: t.store.states.columns.value,
            "table-layout": t.tableLayout
          }, null, 8, ["columns", "table-layout"]),
          ve(a, {
            ref: "tableHeaderRef",
            border: t.border,
            "default-sort": t.defaultSort,
            store: t.store,
            onSetDragVisible: t.setDragVisible
          }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"])
        ], 6)
      ], 2)), [
        [d, t.handleHeaderFooterMousewheel]
      ]) : me("v-if", !0),
      le("div", {
        ref: "bodyWrapper",
        class: X(t.ns.e("body-wrapper"))
      }, [
        ve(c, {
          ref: "scrollBarRef",
          "view-style": t.scrollbarViewStyle,
          "wrap-style": t.scrollbarStyle,
          always: t.scrollbarAlwaysOn
        }, {
          default: fe(() => [
            le("table", {
              ref: "tableBody",
              class: X(t.ns.e("body")),
              cellspacing: "0",
              cellpadding: "0",
              border: "0",
              style: it({
                width: t.bodyWidth,
                tableLayout: t.tableLayout
              })
            }, [
              ve(o, {
                columns: t.store.states.columns.value,
                "table-layout": t.tableLayout
              }, null, 8, ["columns", "table-layout"]),
              t.showHeader && t.tableLayout === "auto" ? (U(), xe(a, {
                key: 0,
                ref: "tableHeaderRef",
                class: X(t.ns.e("body-header")),
                border: t.border,
                "default-sort": t.defaultSort,
                store: t.store,
                onSetDragVisible: t.setDragVisible
              }, null, 8, ["class", "border", "default-sort", "store", "onSetDragVisible"])) : me("v-if", !0),
              ve(l, {
                context: t.context,
                highlight: t.highlightCurrentRow,
                "row-class-name": t.rowClassName,
                "tooltip-effect": t.tooltipEffect,
                "tooltip-options": t.tooltipOptions,
                "row-style": t.rowStyle,
                store: t.store,
                stripe: t.stripe
              }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "tooltip-options", "row-style", "store", "stripe"]),
              t.showSummary && t.tableLayout === "auto" ? (U(), xe(u, {
                key: 1,
                class: X(t.ns.e("body-footer")),
                border: t.border,
                "default-sort": t.defaultSort,
                store: t.store,
                "sum-text": t.computedSumText,
                "summary-method": t.summaryMethod
              }, null, 8, ["class", "border", "default-sort", "store", "sum-text", "summary-method"])) : me("v-if", !0)
            ], 6),
            t.isEmpty ? (U(), oe("div", {
              key: 0,
              ref: "emptyBlock",
              style: it(t.emptyBlockStyle),
              class: X(t.ns.e("empty-block"))
            }, [
              le("span", {
                class: X(t.ns.e("empty-text"))
              }, [
                Me(t.$slots, "empty", {}, () => [
                  cn(st(t.computedEmptyText), 1)
                ])
              ], 2)
            ], 6)) : me("v-if", !0),
            t.$slots.append ? (U(), oe("div", {
              key: 1,
              ref: "appendWrapper",
              class: X(t.ns.e("append-wrapper"))
            }, [
              Me(t.$slots, "append")
            ], 2)) : me("v-if", !0)
          ]),
          _: 3
        }, 8, ["view-style", "wrap-style", "always"])
      ], 2),
      t.showSummary && t.tableLayout === "fixed" ? Bt((U(), oe("div", {
        key: 1,
        ref: "footerWrapper",
        class: X(t.ns.e("footer-wrapper"))
      }, [
        le("table", {
          class: X(t.ns.e("footer")),
          cellspacing: "0",
          cellpadding: "0",
          border: "0",
          style: it(t.tableBodyStyles)
        }, [
          ve(o, {
            columns: t.store.states.columns.value,
            "table-layout": t.tableLayout
          }, null, 8, ["columns", "table-layout"]),
          ve(u, {
            border: t.border,
            "default-sort": t.defaultSort,
            store: t.store,
            "sum-text": t.computedSumText,
            "summary-method": t.summaryMethod
          }, null, 8, ["border", "default-sort", "store", "sum-text", "summary-method"])
        ], 6)
      ], 2)), [
        [Qn, !t.isEmpty],
        [d, t.handleHeaderFooterMousewheel]
      ]) : me("v-if", !0),
      t.border || t.isGroup ? (U(), oe("div", {
        key: 2,
        class: X(t.ns.e("border-left-patch"))
      }, null, 2)) : me("v-if", !0)
    ], 6),
    Bt(le("div", {
      ref: "resizeProxy",
      class: X(t.ns.e("column-resize-proxy"))
    }, null, 2), [
      [Qn, t.resizeProxyVisible]
    ])
  ], 46, O3);
}
var R3 = /* @__PURE__ */ Ge(T3, [["render", N3], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/table/src/table.vue"]]);
const P3 = {
  selection: "table-column--selection",
  expand: "table__expand-column"
}, D3 = {
  default: {
    order: ""
  },
  selection: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  expand: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  index: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  }
}, B3 = (t) => P3[t] || "", M3 = {
  selection: {
    renderHeader({ store: t, column: e }) {
      function n() {
        return t.states.data.value && t.states.data.value.length === 0;
      }
      return Xe(qi, {
        disabled: n(),
        size: t.states.tableSize.value,
        indeterminate: t.states.selection.value.length > 0 && !t.states.isAllSelected.value,
        "onUpdate:modelValue": t.toggleAllSelection,
        modelValue: t.states.isAllSelected.value,
        ariaLabel: e.label
      });
    },
    renderCell({
      row: t,
      column: e,
      store: n,
      $index: r
    }) {
      return Xe(qi, {
        disabled: e.selectable ? !e.selectable.call(null, t, r) : !1,
        size: n.states.tableSize.value,
        onChange: () => {
          n.commit("rowSelectedChanged", t);
        },
        onClick: (i) => i.stopPropagation(),
        modelValue: n.isSelected(t),
        ariaLabel: e.label
      });
    },
    sortable: !1,
    resizable: !1
  },
  index: {
    renderHeader({ column: t }) {
      return t.label || "#";
    },
    renderCell({
      column: t,
      $index: e
    }) {
      let n = e + 1;
      const r = t.index;
      return typeof r == "number" ? n = e + r : typeof r == "function" && (n = r(e)), Xe("div", {}, [n]);
    },
    sortable: !1
  },
  expand: {
    renderHeader({ column: t }) {
      return t.label || "";
    },
    renderCell({
      row: t,
      store: e,
      expanded: n
    }) {
      const { ns: r } = e, i = [r.e("expand-icon")];
      return n && i.push(r.em("expand-icon", "expanded")), Xe("div", {
        class: i,
        onClick: function(o) {
          o.stopPropagation(), e.toggleRowExpansion(t);
        }
      }, {
        default: () => [
          Xe(_t, null, {
            default: () => [Xe(qd)]
          })
        ]
      });
    },
    sortable: !1,
    resizable: !1
  }
};
function L3({
  row: t,
  column: e,
  $index: n
}) {
  var r;
  const i = e.property, s = i && DA(t, i).value;
  return e && e.formatter ? e.formatter(t, e, s, n) : ((r = s == null ? void 0 : s.toString) == null ? void 0 : r.call(s)) || "";
}
function z3({
  row: t,
  treeNode: e,
  store: n
}, r = !1) {
  const { ns: i } = n;
  if (!e)
    return r ? [
      Xe("span", {
        class: i.e("placeholder")
      })
    ] : null;
  const s = [], o = function(a) {
    a.stopPropagation(), !e.loading && n.loadOrToggle(t);
  };
  if (e.indent && s.push(Xe("span", {
    class: i.e("indent"),
    style: { "padding-left": `${e.indent}px` }
  })), typeof e.expanded == "boolean" && !e.noLazyChildren) {
    const a = [
      i.e("expand-icon"),
      e.expanded ? i.em("expand-icon", "expanded") : ""
    ];
    let l = qd;
    e.loading && (l = su), s.push(Xe("div", {
      class: a,
      onClick: o
    }, {
      default: () => [
        Xe(_t, { class: { [i.is("loading")]: e.loading } }, {
          default: () => [Xe(l)]
        })
      ]
    }));
  } else
    s.push(Xe("span", {
      class: i.e("placeholder")
    }));
  return s;
}
function Rp(t, e) {
  return t.reduce((n, r) => (n[r] = r, n), e);
}
function j3(t, e) {
  const n = ft();
  return {
    registerComplexWatchers: () => {
      const s = ["fixed"], o = {
        realWidth: "width",
        realMinWidth: "minWidth"
      }, a = Rp(s, o);
      Object.keys(a).forEach((l) => {
        const u = o[l];
        Dr(e, u) && Ae(() => e[u], (c) => {
          let d = c;
          u === "width" && l === "realWidth" && (d = vf(c)), u === "minWidth" && l === "realMinWidth" && (d = ly(c)), n.columnConfig.value[u] = d, n.columnConfig.value[l] = d;
          const h = u === "fixed";
          t.value.store.scheduleLayout(h);
        });
      });
    },
    registerNormalWatchers: () => {
      const s = [
        "label",
        "filters",
        "filterMultiple",
        "filteredValue",
        "sortable",
        "index",
        "formatter",
        "className",
        "labelClassName",
        "showOverflowTooltip"
      ], o = {
        property: "prop",
        align: "realAlign",
        headerAlign: "realHeaderAlign"
      }, a = Rp(s, o);
      Object.keys(a).forEach((l) => {
        const u = o[l];
        Dr(e, u) && Ae(() => e[u], (c) => {
          n.columnConfig.value[l] = c;
        });
      });
    }
  };
}
function F3(t, e, n) {
  const r = ft(), i = K(""), s = K(!1), o = K(), a = K(), l = ze("table");
  go(() => {
    o.value = t.align ? `is-${t.align}` : null, o.value;
  }), go(() => {
    a.value = t.headerAlign ? `is-${t.headerAlign}` : o.value, a.value;
  });
  const u = j(() => {
    let w = r.vnode.vParent || r.parent;
    for (; w && !w.tableId && !w.columnId; )
      w = w.vnode.vParent || w.parent;
    return w;
  }), c = j(() => {
    const { store: w } = r.parent;
    if (!w)
      return !1;
    const { treeData: _ } = w.states, S = _.value;
    return S && Object.keys(S).length > 0;
  }), d = K(vf(t.width)), h = K(ly(t.minWidth)), v = (w) => (d.value && (w.width = d.value), h.value && (w.minWidth = h.value), !d.value && h.value && (w.width = void 0), w.minWidth || (w.minWidth = 80), w.realWidth = Number(w.width === void 0 ? w.minWidth : w.width), w), m = (w) => {
    const _ = w.type, S = M3[_] || {};
    Object.keys(S).forEach((C) => {
      const k = S[C];
      C !== "className" && k !== void 0 && (w[C] = k);
    });
    const A = B3(_);
    if (A) {
      const C = `${x(l.namespace)}-${A}`;
      w.className = w.className ? `${w.className} ${C}` : C;
    }
    return w;
  }, b = (w) => {
    Array.isArray(w) ? w.forEach((S) => _(S)) : _(w);
    function _(S) {
      var A;
      ((A = S == null ? void 0 : S.type) == null ? void 0 : A.name) === "ElTableColumn" && (S.vParent = r);
    }
  };
  return {
    columnId: i,
    realAlign: o,
    isSubColumn: s,
    realHeaderAlign: a,
    columnOrTableParent: u,
    setColumnWidth: v,
    setColumnForcedProps: m,
    setColumnRenders: (w) => {
      t.renderHeader ? Vt("TableColumn", "Comparing to render-header, scoped-slot header is easier to use. We recommend users to use scoped-slot header.") : w.type !== "selection" && (w.renderHeader = (S) => {
        r.columnConfig.value.label;
        const A = e.header;
        return A ? A(S) : w.label;
      });
      let _ = w.renderCell;
      return w.type === "expand" ? (w.renderCell = (S) => Xe("div", {
        class: "cell"
      }, [_(S)]), n.value.renderExpanded = (S) => e.default ? e.default(S) : e.default) : (_ = _ || L3, w.renderCell = (S) => {
        let A = null;
        if (e.default) {
          const D = e.default(S);
          A = D.some((F) => F.type !== Dv) ? D : _(S);
        } else
          A = _(S);
        const { columns: C } = n.value.store.states, k = C.value.findIndex((D) => D.type === "default"), O = c.value && S.cellIndex === k, N = z3(S, O), B = {
          class: "cell",
          style: {}
        };
        return w.showOverflowTooltip && (B.class = `${B.class} ${x(l.namespace)}-tooltip`, B.style = {
          width: `${(S.column.realWidth || Number(S.column.width)) - 1}px`
        }), b(A), Xe("div", B, [N, A]);
      }), w;
    },
    getPropsData: (...w) => w.reduce((_, S) => (Array.isArray(S) && S.forEach((A) => {
      _[A] = t[A];
    }), _), {}),
    getColumnElIndex: (w, _) => Array.prototype.indexOf.call(w, _),
    updateColumnOrder: () => {
      n.value.store.commit("updateColumnOrder", r.columnConfig.value);
    }
  };
}
var H3 = {
  type: {
    type: String,
    default: "default"
  },
  label: String,
  className: String,
  labelClassName: String,
  property: String,
  prop: String,
  width: {
    type: [String, Number],
    default: ""
  },
  minWidth: {
    type: [String, Number],
    default: ""
  },
  renderHeader: Function,
  sortable: {
    type: [Boolean, String],
    default: !1
  },
  sortMethod: Function,
  sortBy: [String, Function, Array],
  resizable: {
    type: Boolean,
    default: !0
  },
  columnKey: String,
  align: String,
  headerAlign: String,
  showOverflowTooltip: {
    type: [Boolean, Object],
    default: void 0
  },
  fixed: [Boolean, String],
  formatter: Function,
  selectable: Function,
  reserveSelection: Boolean,
  filterMethod: Function,
  filteredValue: Array,
  filters: Array,
  filterPlacement: String,
  filterMultiple: {
    type: Boolean,
    default: !0
  },
  index: [Number, Function],
  sortOrders: {
    type: Array,
    default: () => ["ascending", "descending", null],
    validator: (t) => t.every((e) => ["ascending", "descending", null].includes(e))
  }
};
let U3 = 1;
var gy = ye({
  name: "ElTableColumn",
  components: {
    ElCheckbox: qi
  },
  props: H3,
  setup(t, { slots: e }) {
    const n = ft(), r = K({}), i = j(() => {
      let y = n.parent;
      for (; y && !y.tableId; )
        y = y.parent;
      return y;
    }), { registerNormalWatchers: s, registerComplexWatchers: o } = j3(i, t), {
      columnId: a,
      isSubColumn: l,
      realHeaderAlign: u,
      columnOrTableParent: c,
      setColumnWidth: d,
      setColumnForcedProps: h,
      setColumnRenders: v,
      getPropsData: m,
      getColumnElIndex: b,
      realAlign: p,
      updateColumnOrder: f
    } = F3(t, e, i), g = c.value;
    a.value = `${g.tableId || g.columnId}_column_${U3++}`, xd(() => {
      l.value = i.value !== g;
      const y = t.type || "default", w = t.sortable === "" ? !0 : t.sortable, _ = Cr(t.showOverflowTooltip) ? g.props.showOverflowTooltip : t.showOverflowTooltip, S = {
        ...D3[y],
        id: a.value,
        type: y,
        property: t.prop || t.property,
        align: p,
        headerAlign: u,
        showOverflowTooltip: _,
        filterable: t.filters || t.filterMethod,
        filteredValue: [],
        filterPlacement: "",
        isColumnGroup: !1,
        isSubColumn: !1,
        filterOpened: !1,
        sortable: w,
        index: t.index,
        rawColumnKey: n.vnode.key
      };
      let N = m([
        "columnKey",
        "label",
        "className",
        "labelClassName",
        "type",
        "renderHeader",
        "formatter",
        "fixed",
        "resizable"
      ], ["sortMethod", "sortBy", "sortOrders"], ["selectable", "reserveSelection"], [
        "filterMethod",
        "filters",
        "filterMultiple",
        "filterOpened",
        "filteredValue",
        "filterPlacement"
      ]);
      N = UP(S, N), N = WP(v, d, h)(N), r.value = N, s(), o();
    }), Ct(() => {
      var y;
      const w = c.value, _ = l.value ? w.vnode.el.children : (y = w.refs.hiddenColumns) == null ? void 0 : y.children, S = () => b(_ || [], n.vnode.el);
      r.value.getColumnIndex = S, S() > -1 && i.value.store.commit("insertColumn", r.value, l.value ? w.columnConfig.value : null, f);
    }), xn(() => {
      i.value.store.commit("removeColumn", r.value, l.value ? g.columnConfig.value : null, f);
    }), n.columnId = a.value, n.columnConfig = r;
  },
  render() {
    var t, e, n;
    try {
      const r = (e = (t = this.$slots).default) == null ? void 0 : e.call(t, {
        row: {},
        column: {},
        $index: -1
      }), i = [];
      if (Array.isArray(r))
        for (const o of r)
          ((n = o.type) == null ? void 0 : n.name) === "ElTableColumn" || o.shapeFlag & 2 ? i.push(o) : o.type === Ft && Array.isArray(o.children) && o.children.forEach((a) => {
            (a == null ? void 0 : a.patchFlag) !== 1024 && !Gt(a == null ? void 0 : a.children) && i.push(a);
          });
      return Xe("div", i);
    } catch {
      return Xe("div", []);
    }
  }
});
const V3 = nn(R3, {
  TableColumn: gy
}), W3 = ar(gy), Os = "$treeNodeId", Pp = function(t, e) {
  !e || e[Os] || Object.defineProperty(e, Os, {
    value: t.id,
    enumerable: !1,
    configurable: !1,
    writable: !1
  });
}, yf = function(t, e) {
  return t ? e[t] : e[Os];
}, Mc = (t, e, n) => {
  const r = t.value.currentNode;
  n();
  const i = t.value.currentNode;
  r !== i && e("current-change", i ? i.data : null, i);
}, Lc = (t) => {
  let e = !0, n = !0, r = !0;
  for (let i = 0, s = t.length; i < s; i++) {
    const o = t[i];
    (o.checked !== !0 || o.indeterminate) && (e = !1, o.disabled || (r = !1)), (o.checked !== !1 || o.indeterminate) && (n = !1);
  }
  return { all: e, none: n, allWithoutDisable: r, half: !e && !n };
}, tl = function(t) {
  if (t.childNodes.length === 0 || t.loading)
    return;
  const { all: e, none: n, half: r } = Lc(t.childNodes);
  e ? (t.checked = !0, t.indeterminate = !1) : r ? (t.checked = !1, t.indeterminate = !0) : n && (t.checked = !1, t.indeterminate = !1);
  const i = t.parent;
  !i || i.level === 0 || t.store.checkStrictly || tl(i);
}, Ra = function(t, e) {
  const n = t.store.props, r = t.data || {}, i = n[e];
  if (typeof i == "function")
    return i(r, t);
  if (typeof i == "string")
    return r[i];
  if (typeof i > "u") {
    const s = r[e];
    return s === void 0 ? "" : s;
  }
};
let $3 = 0, zc = class nl {
  constructor(e) {
    this.id = $3++, this.text = null, this.checked = !1, this.indeterminate = !1, this.data = null, this.expanded = !1, this.parent = null, this.visible = !0, this.isCurrent = !1, this.canFocus = !1;
    for (const n in e)
      Dr(e, n) && (this[n] = e[n]);
    this.level = 0, this.loaded = !1, this.childNodes = [], this.loading = !1, this.parent && (this.level = this.parent.level + 1);
  }
  initialize() {
    const e = this.store;
    if (!e)
      throw new Error("[Node]store is required!");
    e.registerNode(this);
    const n = e.props;
    if (n && typeof n.isLeaf < "u") {
      const s = Ra(this, "isLeaf");
      typeof s == "boolean" && (this.isLeafByUser = s);
    }
    if (e.lazy !== !0 && this.data ? (this.setData(this.data), e.defaultExpandAll && (this.expanded = !0, this.canFocus = !0)) : this.level > 0 && e.lazy && e.defaultExpandAll && this.expand(), Array.isArray(this.data) || Pp(this, this.data), !this.data)
      return;
    const r = e.defaultExpandedKeys, i = e.key;
    i && r && r.includes(this.key) && this.expand(null, e.autoExpandParent), i && e.currentNodeKey !== void 0 && this.key === e.currentNodeKey && (e.currentNode = this, e.currentNode.isCurrent = !0), e.lazy && e._initDefaultCheckedNode(this), this.updateLeafState(), this.parent && (this.level === 1 || this.parent.expanded === !0) && (this.canFocus = !0);
  }
  setData(e) {
    Array.isArray(e) || Pp(this, e), this.data = e, this.childNodes = [];
    let n;
    this.level === 0 && Array.isArray(this.data) ? n = this.data : n = Ra(this, "children") || [];
    for (let r = 0, i = n.length; r < i; r++)
      this.insertChild({ data: n[r] });
  }
  get label() {
    return Ra(this, "label");
  }
  get key() {
    const e = this.store.key;
    return this.data ? this.data[e] : null;
  }
  get disabled() {
    return Ra(this, "disabled");
  }
  get nextSibling() {
    const e = this.parent;
    if (e) {
      const n = e.childNodes.indexOf(this);
      if (n > -1)
        return e.childNodes[n + 1];
    }
    return null;
  }
  get previousSibling() {
    const e = this.parent;
    if (e) {
      const n = e.childNodes.indexOf(this);
      if (n > -1)
        return n > 0 ? e.childNodes[n - 1] : null;
    }
    return null;
  }
  contains(e, n = !0) {
    return (this.childNodes || []).some((r) => r === e || n && r.contains(e));
  }
  remove() {
    const e = this.parent;
    e && e.removeChild(this);
  }
  insertChild(e, n, r) {
    if (!e)
      throw new Error("InsertChild error: child is required.");
    if (!(e instanceof nl)) {
      if (!r) {
        const i = this.getChildren(!0);
        i.includes(e.data) || (typeof n > "u" || n < 0 ? i.push(e.data) : i.splice(n, 0, e.data));
      }
      Object.assign(e, {
        parent: this,
        store: this.store
      }), e = Mn(new nl(e)), e instanceof nl && e.initialize();
    }
    e.level = this.level + 1, typeof n > "u" || n < 0 ? this.childNodes.push(e) : this.childNodes.splice(n, 0, e), this.updateLeafState();
  }
  insertBefore(e, n) {
    let r;
    n && (r = this.childNodes.indexOf(n)), this.insertChild(e, r);
  }
  insertAfter(e, n) {
    let r;
    n && (r = this.childNodes.indexOf(n), r !== -1 && (r += 1)), this.insertChild(e, r);
  }
  removeChild(e) {
    const n = this.getChildren() || [], r = n.indexOf(e.data);
    r > -1 && n.splice(r, 1);
    const i = this.childNodes.indexOf(e);
    i > -1 && (this.store && this.store.deregisterNode(e), e.parent = null, this.childNodes.splice(i, 1)), this.updateLeafState();
  }
  removeChildByData(e) {
    let n = null;
    for (let r = 0; r < this.childNodes.length; r++)
      if (this.childNodes[r].data === e) {
        n = this.childNodes[r];
        break;
      }
    n && this.removeChild(n);
  }
  expand(e, n) {
    const r = () => {
      if (n) {
        let i = this.parent;
        for (; i.level > 0; )
          i.expanded = !0, i = i.parent;
      }
      this.expanded = !0, e && e(), this.childNodes.forEach((i) => {
        i.canFocus = !0;
      });
    };
    this.shouldLoadData() ? this.loadData((i) => {
      Array.isArray(i) && (this.checked ? this.setChecked(!0, !0) : this.store.checkStrictly || tl(this), r());
    }) : r();
  }
  doCreateChildren(e, n = {}) {
    e.forEach((r) => {
      this.insertChild(Object.assign({ data: r }, n), void 0, !0);
    });
  }
  collapse() {
    this.expanded = !1, this.childNodes.forEach((e) => {
      e.canFocus = !1;
    });
  }
  shouldLoadData() {
    return this.store.lazy === !0 && this.store.load && !this.loaded;
  }
  updateLeafState() {
    if (this.store.lazy === !0 && this.loaded !== !0 && typeof this.isLeafByUser < "u") {
      this.isLeaf = this.isLeafByUser;
      return;
    }
    const e = this.childNodes;
    if (!this.store.lazy || this.store.lazy === !0 && this.loaded === !0) {
      this.isLeaf = !e || e.length === 0;
      return;
    }
    this.isLeaf = !1;
  }
  setChecked(e, n, r, i) {
    if (this.indeterminate = e === "half", this.checked = e === !0, this.store.checkStrictly)
      return;
    if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
      const { all: o, allWithoutDisable: a } = Lc(this.childNodes);
      !this.isLeaf && !o && a && (this.checked = !1, e = !1);
      const l = () => {
        if (n) {
          const u = this.childNodes;
          for (let h = 0, v = u.length; h < v; h++) {
            const m = u[h];
            i = i || e !== !1;
            const b = m.disabled ? m.checked : i;
            m.setChecked(b, n, !0, i);
          }
          const { half: c, all: d } = Lc(u);
          d || (this.checked = d, this.indeterminate = c);
        }
      };
      if (this.shouldLoadData()) {
        this.loadData(() => {
          l(), tl(this);
        }, {
          checked: e !== !1
        });
        return;
      } else
        l();
    }
    const s = this.parent;
    !s || s.level === 0 || r || tl(s);
  }
  getChildren(e = !1) {
    if (this.level === 0)
      return this.data;
    const n = this.data;
    if (!n)
      return null;
    const r = this.store.props;
    let i = "children";
    return r && (i = r.children || "children"), n[i] === void 0 && (n[i] = null), e && !n[i] && (n[i] = []), n[i];
  }
  updateChildren() {
    const e = this.getChildren() || [], n = this.childNodes.map((s) => s.data), r = {}, i = [];
    e.forEach((s, o) => {
      const a = s[Os];
      !!a && n.findIndex((u) => u[Os] === a) >= 0 ? r[a] = { index: o, data: s } : i.push({ index: o, data: s });
    }), this.store.lazy || n.forEach((s) => {
      r[s[Os]] || this.removeChildByData(s);
    }), i.forEach(({ index: s, data: o }) => {
      this.insertChild({ data: o }, s);
    }), this.updateLeafState();
  }
  loadData(e, n = {}) {
    if (this.store.lazy === !0 && this.store.load && !this.loaded && (!this.loading || Object.keys(n).length)) {
      this.loading = !0;
      const r = (i) => {
        this.childNodes = [], this.doCreateChildren(i, n), this.loaded = !0, this.loading = !1, this.updateLeafState(), e && e.call(this, i);
      };
      this.store.load(this, r);
    } else
      e && e.call(this);
  }
};
class K3 {
  constructor(e) {
    this.currentNode = null, this.currentNodeKey = null;
    for (const n in e)
      Dr(e, n) && (this[n] = e[n]);
    this.nodesMap = {};
  }
  initialize() {
    if (this.root = new zc({
      data: this.data,
      store: this
    }), this.root.initialize(), this.lazy && this.load) {
      const e = this.load;
      e(this.root, (n) => {
        this.root.doCreateChildren(n), this._initDefaultCheckedNodes();
      });
    } else
      this._initDefaultCheckedNodes();
  }
  filter(e) {
    const n = this.filterNodeMethod, r = this.lazy, i = function(s) {
      const o = s.root ? s.root.childNodes : s.childNodes;
      if (o.forEach((a) => {
        a.visible = n.call(a, e, a.data, a), i(a);
      }), !s.visible && o.length) {
        let a = !0;
        a = !o.some((l) => l.visible), s.root ? s.root.visible = a === !1 : s.visible = a === !1;
      }
      e && s.visible && !s.isLeaf && !r && s.expand();
    };
    i(this);
  }
  setData(e) {
    e !== this.root.data ? (this.root.setData(e), this._initDefaultCheckedNodes()) : this.root.updateChildren();
  }
  getNode(e) {
    if (e instanceof zc)
      return e;
    const n = _n(e) ? yf(this.key, e) : e;
    return this.nodesMap[n] || null;
  }
  insertBefore(e, n) {
    const r = this.getNode(n);
    r.parent.insertBefore({ data: e }, r);
  }
  insertAfter(e, n) {
    const r = this.getNode(n);
    r.parent.insertAfter({ data: e }, r);
  }
  remove(e) {
    const n = this.getNode(e);
    n && n.parent && (n === this.currentNode && (this.currentNode = null), n.parent.removeChild(n));
  }
  append(e, n) {
    const r = n ? this.getNode(n) : this.root;
    r && r.insertChild({ data: e });
  }
  _initDefaultCheckedNodes() {
    const e = this.defaultCheckedKeys || [], n = this.nodesMap;
    e.forEach((r) => {
      const i = n[r];
      i && i.setChecked(!0, !this.checkStrictly);
    });
  }
  _initDefaultCheckedNode(e) {
    (this.defaultCheckedKeys || []).includes(e.key) && e.setChecked(!0, !this.checkStrictly);
  }
  setDefaultCheckedKey(e) {
    e !== this.defaultCheckedKeys && (this.defaultCheckedKeys = e, this._initDefaultCheckedNodes());
  }
  registerNode(e) {
    const n = this.key;
    !e || !e.data || (n ? e.key !== void 0 && (this.nodesMap[e.key] = e) : this.nodesMap[e.id] = e);
  }
  deregisterNode(e) {
    !this.key || !e || !e.data || (e.childNodes.forEach((r) => {
      this.deregisterNode(r);
    }), delete this.nodesMap[e.key]);
  }
  getCheckedNodes(e = !1, n = !1) {
    const r = [], i = function(s) {
      (s.root ? s.root.childNodes : s.childNodes).forEach((a) => {
        (a.checked || n && a.indeterminate) && (!e || e && a.isLeaf) && r.push(a.data), i(a);
      });
    };
    return i(this), r;
  }
  getCheckedKeys(e = !1) {
    return this.getCheckedNodes(e).map((n) => (n || {})[this.key]);
  }
  getHalfCheckedNodes() {
    const e = [], n = function(r) {
      (r.root ? r.root.childNodes : r.childNodes).forEach((s) => {
        s.indeterminate && e.push(s.data), n(s);
      });
    };
    return n(this), e;
  }
  getHalfCheckedKeys() {
    return this.getHalfCheckedNodes().map((e) => (e || {})[this.key]);
  }
  _getAllNodes() {
    const e = [], n = this.nodesMap;
    for (const r in n)
      Dr(n, r) && e.push(n[r]);
    return e;
  }
  updateChildren(e, n) {
    const r = this.nodesMap[e];
    if (!r)
      return;
    const i = r.childNodes;
    for (let s = i.length - 1; s >= 0; s--) {
      const o = i[s];
      this.remove(o.data);
    }
    for (let s = 0, o = n.length; s < o; s++) {
      const a = n[s];
      this.append(a, r.data);
    }
  }
  _setCheckedKeys(e, n = !1, r) {
    const i = this._getAllNodes().sort((a, l) => l.level - a.level), s = /* @__PURE__ */ Object.create(null), o = Object.keys(r);
    i.forEach((a) => a.setChecked(!1, !1));
    for (let a = 0, l = i.length; a < l; a++) {
      const u = i[a], c = u.data[e].toString();
      if (!o.includes(c)) {
        u.checked && !s[c] && u.setChecked(!1, !1);
        continue;
      }
      let h = u.parent;
      for (; h && h.level > 0; )
        s[h.data[e]] = !0, h = h.parent;
      if (u.isLeaf || this.checkStrictly) {
        u.setChecked(!0, !1);
        continue;
      }
      if (u.setChecked(!0, !0), n) {
        u.setChecked(!1, !1);
        const v = function(m) {
          m.childNodes.forEach((p) => {
            p.isLeaf || p.setChecked(!1, !1), v(p);
          });
        };
        v(u);
      }
    }
  }
  setCheckedNodes(e, n = !1) {
    const r = this.key, i = {};
    e.forEach((s) => {
      i[(s || {})[r]] = !0;
    }), this._setCheckedKeys(r, n, i);
  }
  setCheckedKeys(e, n = !1) {
    this.defaultCheckedKeys = e;
    const r = this.key, i = {};
    e.forEach((s) => {
      i[s] = !0;
    }), this._setCheckedKeys(r, n, i);
  }
  setDefaultExpandedKeys(e) {
    e = e || [], this.defaultExpandedKeys = e, e.forEach((n) => {
      const r = this.getNode(n);
      r && r.expand(null, this.autoExpandParent);
    });
  }
  setChecked(e, n, r) {
    const i = this.getNode(e);
    i && i.setChecked(!!n, r);
  }
  getCurrentNode() {
    return this.currentNode;
  }
  setCurrentNode(e) {
    const n = this.currentNode;
    n && (n.isCurrent = !1), this.currentNode = e, this.currentNode.isCurrent = !0;
  }
  setUserCurrentNode(e, n = !0) {
    const r = e[this.key], i = this.nodesMap[r];
    this.setCurrentNode(i), n && this.currentNode.level > 1 && this.currentNode.parent.expand(null, !0);
  }
  setCurrentNodeKey(e, n = !0) {
    if (e == null) {
      this.currentNode && (this.currentNode.isCurrent = !1), this.currentNode = null;
      return;
    }
    const r = this.getNode(e);
    r && (this.setCurrentNode(r), n && this.currentNode.level > 1 && this.currentNode.parent.expand(null, !0));
  }
}
const G3 = ye({
  name: "ElTreeNodeContent",
  props: {
    node: {
      type: Object,
      required: !0
    },
    renderContent: Function
  },
  setup(t) {
    const e = ze("tree"), n = et("NodeInstance"), r = et("RootTree");
    return () => {
      const i = t.node, { data: s, store: o } = i;
      return t.renderContent ? t.renderContent(Xe, { _self: n, node: i, data: s, store: o }) : r.ctx.slots.default ? r.ctx.slots.default({ node: i, data: s }) : Xe("span", { class: e.be("node", "label") }, [i.label]);
    };
  }
});
var q3 = /* @__PURE__ */ Ge(G3, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node-content.vue"]]);
function my(t) {
  const e = et("TreeNodeMap", null), n = {
    treeNodeExpand: (r) => {
      t.node !== r && t.node.collapse();
    },
    children: []
  };
  return e && e.children.push(n), qt("TreeNodeMap", n), {
    broadcastExpanded: (r) => {
      if (t.accordion)
        for (const i of n.children)
          i.treeNodeExpand(r);
    }
  };
}
const yy = Symbol("dragEvents");
function J3({ props: t, ctx: e, el$: n, dropIndicator$: r, store: i }) {
  const s = ze("tree"), o = K({
    showDropIndicator: !1,
    draggingNode: null,
    dropNode: null,
    allowDrop: !0,
    dropType: null
  });
  return qt(yy, {
    treeNodeDragStart: ({ event: c, treeNode: d }) => {
      if (typeof t.allowDrag == "function" && !t.allowDrag(d.node))
        return c.preventDefault(), !1;
      c.dataTransfer.effectAllowed = "move";
      try {
        c.dataTransfer.setData("text/plain", "");
      } catch {
      }
      o.value.draggingNode = d, e.emit("node-drag-start", d.node, c);
    },
    treeNodeDragOver: ({ event: c, treeNode: d }) => {
      const h = d, v = o.value.dropNode;
      v && v.node.id !== h.node.id && Or(v.$el, s.is("drop-inner"));
      const m = o.value.draggingNode;
      if (!m || !h)
        return;
      let b = !0, p = !0, f = !0, g = !0;
      typeof t.allowDrop == "function" && (b = t.allowDrop(m.node, h.node, "prev"), g = p = t.allowDrop(m.node, h.node, "inner"), f = t.allowDrop(m.node, h.node, "next")), c.dataTransfer.dropEffect = p || b || f ? "move" : "none", (b || p || f) && (v == null ? void 0 : v.node.id) !== h.node.id && (v && e.emit("node-drag-leave", m.node, v.node, c), e.emit("node-drag-enter", m.node, h.node, c)), (b || p || f) && (o.value.dropNode = h), h.node.nextSibling === m.node && (f = !1), h.node.previousSibling === m.node && (b = !1), h.node.contains(m.node, !1) && (p = !1), (m.node === h.node || m.node.contains(h.node)) && (b = !1, p = !1, f = !1);
      const y = h.$el.querySelector(`.${s.be("node", "content")}`).getBoundingClientRect(), w = n.value.getBoundingClientRect();
      let _;
      const S = b ? p ? 0.25 : f ? 0.45 : 1 : -1, A = f ? p ? 0.75 : b ? 0.55 : 0 : 1;
      let C = -9999;
      const k = c.clientY - y.top;
      k < y.height * S ? _ = "before" : k > y.height * A ? _ = "after" : p ? _ = "inner" : _ = "none";
      const O = h.$el.querySelector(`.${s.be("node", "expand-icon")}`).getBoundingClientRect(), N = r.value;
      _ === "before" ? C = O.top - w.top : _ === "after" && (C = O.bottom - w.top), N.style.top = `${C}px`, N.style.left = `${O.right - w.left}px`, _ === "inner" ? Bo(h.$el, s.is("drop-inner")) : Or(h.$el, s.is("drop-inner")), o.value.showDropIndicator = _ === "before" || _ === "after", o.value.allowDrop = o.value.showDropIndicator || g, o.value.dropType = _, e.emit("node-drag-over", m.node, h.node, c);
    },
    treeNodeDragEnd: (c) => {
      const { draggingNode: d, dropType: h, dropNode: v } = o.value;
      if (c.preventDefault(), c.dataTransfer.dropEffect = "move", d && v) {
        const m = { data: d.node.data };
        h !== "none" && d.node.remove(), h === "before" ? v.node.parent.insertBefore(m, v.node) : h === "after" ? v.node.parent.insertAfter(m, v.node) : h === "inner" && v.node.insertChild(m), h !== "none" && i.value.registerNode(m), Or(v.$el, s.is("drop-inner")), e.emit("node-drag-end", d.node, v.node, h, c), h !== "none" && e.emit("node-drop", d.node, v.node, h, c);
      }
      d && !v && e.emit("node-drag-end", d.node, null, h, c), o.value.showDropIndicator = !1, o.value.draggingNode = null, o.value.dropNode = null, o.value.allowDrop = !0;
    }
  }), {
    dragState: o
  };
}
const Y3 = ye({
  name: "ElTreeNode",
  components: {
    ElCollapseTransition: O4,
    ElCheckbox: qi,
    NodeContent: q3,
    ElIcon: _t,
    Loading: su
  },
  props: {
    node: {
      type: zc,
      default: () => ({})
    },
    props: {
      type: Object,
      default: () => ({})
    },
    accordion: Boolean,
    renderContent: Function,
    renderAfterExpand: Boolean,
    showCheckbox: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["node-expand"],
  setup(t, e) {
    const n = ze("tree"), { broadcastExpanded: r } = my(t), i = et("RootTree"), s = K(!1), o = K(!1), a = K(null), l = K(null), u = K(null), c = et(yy), d = ft();
    qt("NodeInstance", d), i || Vt("Tree", "Can not find node's tree."), t.node.expanded && (s.value = !0, o.value = !0);
    const h = i.props.props.children || "children";
    Ae(() => {
      const k = t.node.data[h];
      return k && [...k];
    }, () => {
      t.node.updateChildren();
    }), Ae(() => t.node.indeterminate, (k) => {
      b(t.node.checked, k);
    }), Ae(() => t.node.checked, (k) => {
      b(k, t.node.indeterminate);
    }), Ae(() => t.node.expanded, (k) => {
      rt(() => s.value = k), k && (o.value = !0);
    });
    const v = (k) => yf(i.props.nodeKey, k.data), m = (k) => {
      const O = t.props.class;
      if (!O)
        return {};
      let N;
      if (mn(O)) {
        const { data: B } = k;
        N = O(B, k);
      } else
        N = O;
      return Gt(N) ? { [N]: !0 } : N;
    }, b = (k, O) => {
      (a.value !== k || l.value !== O) && i.ctx.emit("check-change", t.node.data, k, O), a.value = k, l.value = O;
    }, p = (k) => {
      Mc(i.store, i.ctx.emit, () => i.store.value.setCurrentNode(t.node)), i.currentNode.value = t.node, i.props.expandOnClickNode && g(), i.props.checkOnClickNode && !t.node.disabled && y(null, {
        target: { checked: !t.node.checked }
      }), i.ctx.emit("node-click", t.node.data, t.node, d, k);
    }, f = (k) => {
      i.instance.vnode.props.onNodeContextmenu && (k.stopPropagation(), k.preventDefault()), i.ctx.emit("node-contextmenu", k, t.node.data, t.node, d);
    }, g = () => {
      t.node.isLeaf || (s.value ? (i.ctx.emit("node-collapse", t.node.data, t.node, d), t.node.collapse()) : (t.node.expand(), e.emit("node-expand", t.node.data, t.node, d)));
    }, y = (k, O) => {
      t.node.setChecked(O.target.checked, !i.props.checkStrictly), rt(() => {
        const N = i.store.value;
        i.ctx.emit("check", t.node.data, {
          checkedNodes: N.getCheckedNodes(),
          checkedKeys: N.getCheckedKeys(),
          halfCheckedNodes: N.getHalfCheckedNodes(),
          halfCheckedKeys: N.getHalfCheckedKeys()
        });
      });
    };
    return {
      ns: n,
      node$: u,
      tree: i,
      expanded: s,
      childNodeRendered: o,
      oldChecked: a,
      oldIndeterminate: l,
      getNodeKey: v,
      getNodeClass: m,
      handleSelectChange: b,
      handleClick: p,
      handleContextMenu: f,
      handleExpandIconClick: g,
      handleCheckChange: y,
      handleChildNodeExpand: (k, O, N) => {
        r(O), i.ctx.emit("node-expand", k, O, N);
      },
      handleDragStart: (k) => {
        i.props.draggable && c.treeNodeDragStart({ event: k, treeNode: t });
      },
      handleDragOver: (k) => {
        k.preventDefault(), i.props.draggable && c.treeNodeDragOver({
          event: k,
          treeNode: { $el: u.value, node: t.node }
        });
      },
      handleDrop: (k) => {
        k.preventDefault();
      },
      handleDragEnd: (k) => {
        i.props.draggable && c.treeNodeDragEnd(k);
      },
      CaretRight: yk
    };
  }
}), Q3 = ["aria-expanded", "aria-disabled", "aria-checked", "draggable", "data-key"], Z3 = ["aria-expanded"];
function X3(t, e, n, r, i, s) {
  const o = Mt("el-icon"), a = Mt("el-checkbox"), l = Mt("loading"), u = Mt("node-content"), c = Mt("el-tree-node"), d = Mt("el-collapse-transition");
  return Bt((U(), oe("div", {
    ref: "node$",
    class: X([
      t.ns.b("node"),
      t.ns.is("expanded", t.expanded),
      t.ns.is("current", t.node.isCurrent),
      t.ns.is("hidden", !t.node.visible),
      t.ns.is("focusable", !t.node.disabled),
      t.ns.is("checked", !t.node.disabled && t.node.checked),
      t.getNodeClass(t.node)
    ]),
    role: "treeitem",
    tabindex: "-1",
    "aria-expanded": t.expanded,
    "aria-disabled": t.node.disabled,
    "aria-checked": t.node.checked,
    draggable: t.tree.props.draggable,
    "data-key": t.getNodeKey(t.node),
    onClick: e[1] || (e[1] = dt((...h) => t.handleClick && t.handleClick(...h), ["stop"])),
    onContextmenu: e[2] || (e[2] = (...h) => t.handleContextMenu && t.handleContextMenu(...h)),
    onDragstart: e[3] || (e[3] = dt((...h) => t.handleDragStart && t.handleDragStart(...h), ["stop"])),
    onDragover: e[4] || (e[4] = dt((...h) => t.handleDragOver && t.handleDragOver(...h), ["stop"])),
    onDragend: e[5] || (e[5] = dt((...h) => t.handleDragEnd && t.handleDragEnd(...h), ["stop"])),
    onDrop: e[6] || (e[6] = dt((...h) => t.handleDrop && t.handleDrop(...h), ["stop"]))
  }, [
    le("div", {
      class: X(t.ns.be("node", "content")),
      style: it({ paddingLeft: (t.node.level - 1) * t.tree.props.indent + "px" })
    }, [
      t.tree.props.icon || t.CaretRight ? (U(), xe(o, {
        key: 0,
        class: X([
          t.ns.be("node", "expand-icon"),
          t.ns.is("leaf", t.node.isLeaf),
          {
            expanded: !t.node.isLeaf && t.expanded
          }
        ]),
        onClick: dt(t.handleExpandIconClick, ["stop"])
      }, {
        default: fe(() => [
          (U(), xe(Pn(t.tree.props.icon || t.CaretRight)))
        ]),
        _: 1
      }, 8, ["class", "onClick"])) : me("v-if", !0),
      t.showCheckbox ? (U(), xe(a, {
        key: 1,
        "model-value": t.node.checked,
        indeterminate: t.node.indeterminate,
        disabled: !!t.node.disabled,
        onClick: e[0] || (e[0] = dt(() => {
        }, ["stop"])),
        onChange: t.handleCheckChange
      }, null, 8, ["model-value", "indeterminate", "disabled", "onChange"])) : me("v-if", !0),
      t.node.loading ? (U(), xe(o, {
        key: 2,
        class: X([t.ns.be("node", "loading-icon"), t.ns.is("loading")])
      }, {
        default: fe(() => [
          ve(l)
        ]),
        _: 1
      }, 8, ["class"])) : me("v-if", !0),
      ve(u, {
        node: t.node,
        "render-content": t.renderContent
      }, null, 8, ["node", "render-content"])
    ], 6),
    ve(d, null, {
      default: fe(() => [
        !t.renderAfterExpand || t.childNodeRendered ? Bt((U(), oe("div", {
          key: 0,
          class: X(t.ns.be("node", "children")),
          role: "group",
          "aria-expanded": t.expanded
        }, [
          (U(!0), oe(Ft, null, Yn(t.node.childNodes, (h) => (U(), xe(c, {
            key: t.getNodeKey(h),
            "render-content": t.renderContent,
            "render-after-expand": t.renderAfterExpand,
            "show-checkbox": t.showCheckbox,
            node: h,
            accordion: t.accordion,
            props: t.props,
            onNodeExpand: t.handleChildNodeExpand
          }, null, 8, ["render-content", "render-after-expand", "show-checkbox", "node", "accordion", "props", "onNodeExpand"]))), 128))
        ], 10, Z3)), [
          [Qn, t.expanded]
        ]) : me("v-if", !0)
      ]),
      _: 1
    })
  ], 42, Q3)), [
    [Qn, t.node.visible]
  ]);
}
var eD = /* @__PURE__ */ Ge(Y3, [["render", X3], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node.vue"]]);
function tD({ el$: t }, e) {
  const n = ze("tree"), r = Fn([]), i = Fn([]);
  Ct(() => {
    o();
  }), Yl(() => {
    r.value = Array.from(t.value.querySelectorAll("[role=treeitem]")), i.value = Array.from(t.value.querySelectorAll("input[type=checkbox]"));
  }), Ae(i, (a) => {
    a.forEach((l) => {
      l.setAttribute("tabindex", "-1");
    });
  }), wn(t, "keydown", (a) => {
    const l = a.target;
    if (!l.className.includes(n.b("node")))
      return;
    const u = a.code;
    r.value = Array.from(t.value.querySelectorAll(`.${n.is("focusable")}[role=treeitem]`));
    const c = r.value.indexOf(l);
    let d;
    if ([sn.up, sn.down].includes(u)) {
      if (a.preventDefault(), u === sn.up) {
        d = c === -1 ? 0 : c !== 0 ? c - 1 : r.value.length - 1;
        const v = d;
        for (; !e.value.getNode(r.value[d].dataset.key).canFocus; ) {
          if (d--, d === v) {
            d = -1;
            break;
          }
          d < 0 && (d = r.value.length - 1);
        }
      } else {
        d = c === -1 ? 0 : c < r.value.length - 1 ? c + 1 : 0;
        const v = d;
        for (; !e.value.getNode(r.value[d].dataset.key).canFocus; ) {
          if (d++, d === v) {
            d = -1;
            break;
          }
          d >= r.value.length && (d = 0);
        }
      }
      d !== -1 && r.value[d].focus();
    }
    [sn.left, sn.right].includes(u) && (a.preventDefault(), l.click());
    const h = l.querySelector('[type="checkbox"]');
    [sn.enter, sn.space].includes(u) && h && (a.preventDefault(), h.click());
  });
  const o = () => {
    var a;
    r.value = Array.from(t.value.querySelectorAll(`.${n.is("focusable")}[role=treeitem]`)), i.value = Array.from(t.value.querySelectorAll("input[type=checkbox]"));
    const l = t.value.querySelectorAll(`.${n.is("checked")}[role=treeitem]`);
    if (l.length) {
      l[0].setAttribute("tabindex", "0");
      return;
    }
    (a = r.value[0]) == null || a.setAttribute("tabindex", "0");
  };
}
const nD = ye({
  name: "ElTree",
  components: { ElTreeNode: eD },
  props: {
    data: {
      type: Array,
      default: () => []
    },
    emptyText: {
      type: String
    },
    renderAfterExpand: {
      type: Boolean,
      default: !0
    },
    nodeKey: String,
    checkStrictly: Boolean,
    defaultExpandAll: Boolean,
    expandOnClickNode: {
      type: Boolean,
      default: !0
    },
    checkOnClickNode: Boolean,
    checkDescendants: {
      type: Boolean,
      default: !1
    },
    autoExpandParent: {
      type: Boolean,
      default: !0
    },
    defaultCheckedKeys: Array,
    defaultExpandedKeys: Array,
    currentNodeKey: [String, Number],
    renderContent: Function,
    showCheckbox: {
      type: Boolean,
      default: !1
    },
    draggable: {
      type: Boolean,
      default: !1
    },
    allowDrag: Function,
    allowDrop: Function,
    props: {
      type: Object,
      default: () => ({
        children: "children",
        label: "label",
        disabled: "disabled"
      })
    },
    lazy: {
      type: Boolean,
      default: !1
    },
    highlightCurrent: Boolean,
    load: Function,
    filterNodeMethod: Function,
    accordion: Boolean,
    indent: {
      type: Number,
      default: 18
    },
    icon: {
      type: xi
    }
  },
  emits: [
    "check-change",
    "current-change",
    "node-click",
    "node-contextmenu",
    "node-collapse",
    "node-expand",
    "check",
    "node-drag-start",
    "node-drag-end",
    "node-drop",
    "node-drag-leave",
    "node-drag-enter",
    "node-drag-over"
  ],
  setup(t, e) {
    const { t: n } = lr(), r = ze("tree"), i = K(new K3({
      key: t.nodeKey,
      data: t.data,
      lazy: t.lazy,
      props: t.props,
      load: t.load,
      currentNodeKey: t.currentNodeKey,
      checkStrictly: t.checkStrictly,
      checkDescendants: t.checkDescendants,
      defaultCheckedKeys: t.defaultCheckedKeys,
      defaultExpandedKeys: t.defaultExpandedKeys,
      autoExpandParent: t.autoExpandParent,
      defaultExpandAll: t.defaultExpandAll,
      filterNodeMethod: t.filterNodeMethod
    }));
    i.value.initialize();
    const s = K(i.value.root), o = K(null), a = K(null), l = K(null), { broadcastExpanded: u } = my(t), { dragState: c } = J3({
      props: t,
      ctx: e,
      el$: a,
      dropIndicator$: l,
      store: i
    });
    tD({ el$: a }, i);
    const d = j(() => {
      const { childNodes: L } = s.value;
      return !L || L.length === 0 || L.every(({ visible: V }) => !V);
    });
    Ae(() => t.currentNodeKey, (L) => {
      i.value.setCurrentNodeKey(L);
    }), Ae(() => t.defaultCheckedKeys, (L) => {
      i.value.setDefaultCheckedKey(L);
    }), Ae(() => t.defaultExpandedKeys, (L) => {
      i.value.setDefaultExpandedKeys(L);
    }), Ae(() => t.data, (L) => {
      i.value.setData(L);
    }, { deep: !0 }), Ae(() => t.checkStrictly, (L) => {
      i.value.checkStrictly = L;
    });
    const h = (L) => {
      if (!t.filterNodeMethod)
        throw new Error("[Tree] filterNodeMethod is required when filter");
      i.value.filter(L);
    }, v = (L) => yf(t.nodeKey, L.data), m = (L) => {
      if (!t.nodeKey)
        throw new Error("[Tree] nodeKey is required in getNodePath");
      const V = i.value.getNode(L);
      if (!V)
        return [];
      const H = [V.data];
      let ie = V.parent;
      for (; ie && ie !== s.value; )
        H.push(ie.data), ie = ie.parent;
      return H.reverse();
    }, b = (L, V) => i.value.getCheckedNodes(L, V), p = (L) => i.value.getCheckedKeys(L), f = () => {
      const L = i.value.getCurrentNode();
      return L ? L.data : null;
    }, g = () => {
      if (!t.nodeKey)
        throw new Error("[Tree] nodeKey is required in getCurrentKey");
      const L = f();
      return L ? L[t.nodeKey] : null;
    }, y = (L, V) => {
      if (!t.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCheckedNodes");
      i.value.setCheckedNodes(L, V);
    }, w = (L, V) => {
      if (!t.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCheckedKeys");
      i.value.setCheckedKeys(L, V);
    }, _ = (L, V, H) => {
      i.value.setChecked(L, V, H);
    }, S = () => i.value.getHalfCheckedNodes(), A = () => i.value.getHalfCheckedKeys(), C = (L, V = !0) => {
      if (!t.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCurrentNode");
      Mc(i, e.emit, () => i.value.setUserCurrentNode(L, V));
    }, k = (L, V = !0) => {
      if (!t.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCurrentKey");
      Mc(i, e.emit, () => i.value.setCurrentNodeKey(L, V));
    }, O = (L) => i.value.getNode(L), N = (L) => {
      i.value.remove(L);
    }, B = (L, V) => {
      i.value.append(L, V);
    }, D = (L, V) => {
      i.value.insertBefore(L, V);
    }, F = (L, V) => {
      i.value.insertAfter(L, V);
    }, Z = (L, V, H) => {
      u(V), e.emit("node-expand", L, V, H);
    }, te = (L, V) => {
      if (!t.nodeKey)
        throw new Error("[Tree] nodeKey is required in updateKeyChild");
      i.value.updateChildren(L, V);
    };
    return qt("RootTree", {
      ctx: e,
      props: t,
      store: i,
      root: s,
      currentNode: o,
      instance: ft()
    }), qt(jo, void 0), {
      ns: r,
      store: i,
      root: s,
      currentNode: o,
      dragState: c,
      el$: a,
      dropIndicator$: l,
      isEmpty: d,
      filter: h,
      getNodeKey: v,
      getNodePath: m,
      getCheckedNodes: b,
      getCheckedKeys: p,
      getCurrentNode: f,
      getCurrentKey: g,
      setCheckedNodes: y,
      setCheckedKeys: w,
      setChecked: _,
      getHalfCheckedNodes: S,
      getHalfCheckedKeys: A,
      setCurrentNode: C,
      setCurrentKey: k,
      t: n,
      getNode: O,
      remove: N,
      append: B,
      insertBefore: D,
      insertAfter: F,
      handleNodeExpand: Z,
      updateKeyChildren: te
    };
  }
});
function rD(t, e, n, r, i, s) {
  const o = Mt("el-tree-node");
  return U(), oe("div", {
    ref: "el$",
    class: X([
      t.ns.b(),
      t.ns.is("dragging", !!t.dragState.draggingNode),
      t.ns.is("drop-not-allow", !t.dragState.allowDrop),
      t.ns.is("drop-inner", t.dragState.dropType === "inner"),
      { [t.ns.m("highlight-current")]: t.highlightCurrent }
    ]),
    role: "tree"
  }, [
    (U(!0), oe(Ft, null, Yn(t.root.childNodes, (a) => (U(), xe(o, {
      key: t.getNodeKey(a),
      node: a,
      props: t.props,
      accordion: t.accordion,
      "render-after-expand": t.renderAfterExpand,
      "show-checkbox": t.showCheckbox,
      "render-content": t.renderContent,
      onNodeExpand: t.handleNodeExpand
    }, null, 8, ["node", "props", "accordion", "render-after-expand", "show-checkbox", "render-content", "onNodeExpand"]))), 128)),
    t.isEmpty ? (U(), oe("div", {
      key: 0,
      class: X(t.ns.e("empty-block"))
    }, [
      Me(t.$slots, "empty", {}, () => {
        var a;
        return [
          le("span", {
            class: X(t.ns.e("empty-text"))
          }, st((a = t.emptyText) != null ? a : t.t("el.tree.emptyText")), 3)
        ];
      })
    ], 2)) : me("v-if", !0),
    Bt(le("div", {
      ref: "dropIndicator$",
      class: X(t.ns.e("drop-indicator"))
    }, null, 2), [
      [Qn, t.dragState.showDropIndicator]
    ])
  ], 2);
}
var rl = /* @__PURE__ */ Ge(nD, [["render", rD], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree.vue"]]);
rl.install = (t) => {
  t.component(rl.name, rl);
};
const iD = rl, sD = iD, by = Symbol("uploadContextKey"), oD = "ElUpload";
class aD extends Error {
  constructor(e, n, r, i) {
    super(e), this.name = "UploadAjaxError", this.status = n, this.method = r, this.url = i;
  }
}
function Dp(t, e, n) {
  let r;
  return n.response ? r = `${n.response.error || n.response}` : n.responseText ? r = `${n.responseText}` : r = `fail to ${e.method} ${t} ${n.status}`, new aD(r, n.status, e.method, t);
}
function lD(t) {
  const e = t.responseText || t.response;
  if (!e)
    return e;
  try {
    return JSON.parse(e);
  } catch {
    return e;
  }
}
const uD = (t) => {
  typeof XMLHttpRequest > "u" && ts(oD, "XMLHttpRequest is undefined");
  const e = new XMLHttpRequest(), n = t.action;
  e.upload && e.upload.addEventListener("progress", (s) => {
    const o = s;
    o.percent = s.total > 0 ? s.loaded / s.total * 100 : 0, t.onProgress(o);
  });
  const r = new FormData();
  if (t.data)
    for (const [s, o] of Object.entries(t.data))
      Br(o) && o.length ? r.append(s, ...o) : r.append(s, o);
  r.append(t.filename, t.file, t.file.name), e.addEventListener("error", () => {
    t.onError(Dp(n, t, e));
  }), e.addEventListener("load", () => {
    if (e.status < 200 || e.status >= 300)
      return t.onError(Dp(n, t, e));
    t.onSuccess(lD(e));
  }), e.open(t.method, n, !0), t.withCredentials && "withCredentials" in e && (e.withCredentials = !0);
  const i = t.headers || {};
  if (i instanceof Headers)
    i.forEach((s, o) => e.setRequestHeader(o, s));
  else
    for (const [s, o] of Object.entries(i))
      nr(o) || e.setRequestHeader(s, String(o));
  return e.send(r), e;
}, wy = ["text", "picture", "picture-card"];
let cD = 1;
const jc = () => Date.now() + cD++, _y = ut({
  action: {
    type: String,
    default: "#"
  },
  headers: {
    type: De(Object)
  },
  method: {
    type: String,
    default: "post"
  },
  data: {
    type: De([Object, Function, Promise]),
    default: () => Ms({})
  },
  multiple: {
    type: Boolean,
    default: !1
  },
  name: {
    type: String,
    default: "file"
  },
  drag: {
    type: Boolean,
    default: !1
  },
  withCredentials: Boolean,
  showFileList: {
    type: Boolean,
    default: !0
  },
  accept: {
    type: String,
    default: ""
  },
  fileList: {
    type: De(Array),
    default: () => Ms([])
  },
  autoUpload: {
    type: Boolean,
    default: !0
  },
  listType: {
    type: String,
    values: wy,
    default: "text"
  },
  httpRequest: {
    type: De(Function),
    default: uD
  },
  disabled: Boolean,
  limit: Number
}), dD = ut({
  ..._y,
  beforeUpload: {
    type: De(Function),
    default: en
  },
  beforeRemove: {
    type: De(Function)
  },
  onRemove: {
    type: De(Function),
    default: en
  },
  onChange: {
    type: De(Function),
    default: en
  },
  onPreview: {
    type: De(Function),
    default: en
  },
  onSuccess: {
    type: De(Function),
    default: en
  },
  onProgress: {
    type: De(Function),
    default: en
  },
  onError: {
    type: De(Function),
    default: en
  },
  onExceed: {
    type: De(Function),
    default: en
  }
}), fD = ut({
  files: {
    type: De(Array),
    default: () => Ms([])
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  handlePreview: {
    type: De(Function),
    default: en
  },
  listType: {
    type: String,
    values: wy,
    default: "text"
  }
}), hD = {
  remove: (t) => !!t
}, pD = ["onKeydown"], vD = ["src"], gD = ["onClick"], mD = ["title"], yD = ["onClick"], bD = ["onClick"], wD = ye({
  name: "ElUploadList"
}), _D = /* @__PURE__ */ ye({
  ...wD,
  props: fD,
  emits: hD,
  setup(t, { emit: e }) {
    const n = t, { t: r } = lr(), i = ze("upload"), s = ze("icon"), o = ze("list"), a = Fr(), l = K(!1), u = j(() => [
      i.b("list"),
      i.bm("list", n.listType),
      i.is("disabled", n.disabled)
    ]), c = (d) => {
      e("remove", d);
    };
    return (d, h) => (U(), xe(Tb, {
      tag: "ul",
      class: X(x(u)),
      name: x(o).b()
    }, {
      default: fe(() => [
        (U(!0), oe(Ft, null, Yn(d.files, (v) => (U(), oe("li", {
          key: v.uid || v.name,
          class: X([
            x(i).be("list", "item"),
            x(i).is(v.status),
            { focusing: l.value }
          ]),
          tabindex: "0",
          onKeydown: gn((m) => !x(a) && c(v), ["delete"]),
          onFocus: h[0] || (h[0] = (m) => l.value = !0),
          onBlur: h[1] || (h[1] = (m) => l.value = !1),
          onClick: h[2] || (h[2] = (m) => l.value = !1)
        }, [
          Me(d.$slots, "default", { file: v }, () => [
            d.listType === "picture" || v.status !== "uploading" && d.listType === "picture-card" ? (U(), oe("img", {
              key: 0,
              class: X(x(i).be("list", "item-thumbnail")),
              src: v.url,
              alt: ""
            }, null, 10, vD)) : me("v-if", !0),
            v.status === "uploading" || d.listType !== "picture-card" ? (U(), oe("div", {
              key: 1,
              class: X(x(i).be("list", "item-info"))
            }, [
              le("a", {
                class: X(x(i).be("list", "item-name")),
                onClick: dt((m) => d.handlePreview(v), ["prevent"])
              }, [
                ve(x(_t), {
                  class: X(x(s).m("document"))
                }, {
                  default: fe(() => [
                    ve(x(Qk))
                  ]),
                  _: 1
                }, 8, ["class"]),
                le("span", {
                  class: X(x(i).be("list", "item-file-name")),
                  title: v.name
                }, st(v.name), 11, mD)
              ], 10, gD),
              v.status === "uploading" ? (U(), xe(x(sy), {
                key: 0,
                type: d.listType === "picture-card" ? "circle" : "line",
                "stroke-width": d.listType === "picture-card" ? 6 : 2,
                percentage: Number(v.percentage),
                style: it(d.listType === "picture-card" ? "" : "margin-top: 0.5rem")
              }, null, 8, ["type", "stroke-width", "percentage", "style"])) : me("v-if", !0)
            ], 2)) : me("v-if", !0),
            le("label", {
              class: X(x(i).be("list", "item-status-label"))
            }, [
              d.listType === "text" ? (U(), xe(x(_t), {
                key: 0,
                class: X([x(s).m("upload-success"), x(s).m("circle-check")])
              }, {
                default: fe(() => [
                  ve(x(Jd))
                ]),
                _: 1
              }, 8, ["class"])) : ["picture-card", "picture"].includes(d.listType) ? (U(), xe(x(_t), {
                key: 1,
                class: X([x(s).m("upload-success"), x(s).m("check")])
              }, {
                default: fe(() => [
                  ve(x(Lg))
                ]),
                _: 1
              }, 8, ["class"])) : me("v-if", !0)
            ], 2),
            x(a) ? me("v-if", !0) : (U(), xe(x(_t), {
              key: 2,
              class: X(x(s).m("close")),
              onClick: (m) => c(v)
            }, {
              default: fe(() => [
                ve(x(Mo))
              ]),
              _: 2
            }, 1032, ["class", "onClick"])),
            me(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"),
            me(" This is a bug which needs to be fixed "),
            me(" TODO: Fix the incorrect navigation interaction "),
            x(a) ? me("v-if", !0) : (U(), oe("i", {
              key: 3,
              class: X(x(s).m("close-tip"))
            }, st(x(r)("el.upload.deleteTip")), 3)),
            d.listType === "picture-card" ? (U(), oe("span", {
              key: 4,
              class: X(x(i).be("list", "item-actions"))
            }, [
              le("span", {
                class: X(x(i).be("list", "item-preview")),
                onClick: (m) => d.handlePreview(v)
              }, [
                ve(x(_t), {
                  class: X(x(s).m("zoom-in"))
                }, {
                  default: fe(() => [
                    ve(x(Hg))
                  ]),
                  _: 1
                }, 8, ["class"])
              ], 10, yD),
              x(a) ? me("v-if", !0) : (U(), oe("span", {
                key: 0,
                class: X(x(i).be("list", "item-delete")),
                onClick: (m) => c(v)
              }, [
                ve(x(_t), {
                  class: X(x(s).m("delete"))
                }, {
                  default: fe(() => [
                    ve(x(zg))
                  ]),
                  _: 1
                }, 8, ["class"])
              ], 10, bD))
            ], 2)) : me("v-if", !0)
          ])
        ], 42, pD))), 128)),
        Me(d.$slots, "append")
      ]),
      _: 3
    }, 8, ["class", "name"]));
  }
});
var Bp = /* @__PURE__ */ Ge(_D, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-list.vue"]]);
const SD = ut({
  disabled: {
    type: Boolean,
    default: !1
  }
}), ED = {
  file: (t) => Br(t)
}, xD = ["onDrop", "onDragover"], Sy = "ElUploadDrag", AD = ye({
  name: Sy
}), kD = /* @__PURE__ */ ye({
  ...AD,
  props: SD,
  emits: ED,
  setup(t, { emit: e }) {
    const n = et(by);
    n || ts(Sy, "usage: <el-upload><el-upload-dragger /></el-upload>");
    const r = ze("upload"), i = K(!1), s = Fr(), o = (l) => {
      if (s.value)
        return;
      i.value = !1, l.stopPropagation();
      const u = Array.from(l.dataTransfer.files), c = n.accept.value;
      if (!c) {
        e("file", u);
        return;
      }
      const d = u.filter((h) => {
        const { type: v, name: m } = h, b = m.includes(".") ? `.${m.split(".").pop()}` : "", p = v.replace(/\/.*$/, "");
        return c.split(",").map((f) => f.trim()).filter((f) => f).some((f) => f.startsWith(".") ? b === f : /\/\*$/.test(f) ? p === f.replace(/\/\*$/, "") : /^[^/]+\/[^/]+$/.test(f) ? v === f : !1);
      });
      e("file", d);
    }, a = () => {
      s.value || (i.value = !0);
    };
    return (l, u) => (U(), oe("div", {
      class: X([x(r).b("dragger"), x(r).is("dragover", i.value)]),
      onDrop: dt(o, ["prevent"]),
      onDragover: dt(a, ["prevent"]),
      onDragleave: u[0] || (u[0] = dt((c) => i.value = !1, ["prevent"]))
    }, [
      Me(l.$slots, "default")
    ], 42, xD));
  }
});
var CD = /* @__PURE__ */ Ge(kD, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-dragger.vue"]]);
const TD = ut({
  ..._y,
  beforeUpload: {
    type: De(Function),
    default: en
  },
  onRemove: {
    type: De(Function),
    default: en
  },
  onStart: {
    type: De(Function),
    default: en
  },
  onSuccess: {
    type: De(Function),
    default: en
  },
  onProgress: {
    type: De(Function),
    default: en
  },
  onError: {
    type: De(Function),
    default: en
  },
  onExceed: {
    type: De(Function),
    default: en
  }
}), OD = ["onKeydown"], ID = ["name", "multiple", "accept"], ND = ye({
  name: "ElUploadContent",
  inheritAttrs: !1
}), RD = /* @__PURE__ */ ye({
  ...ND,
  props: TD,
  setup(t, { expose: e }) {
    const n = t, r = ze("upload"), i = Fr(), s = Fn({}), o = Fn(), a = (b) => {
      if (b.length === 0)
        return;
      const { autoUpload: p, limit: f, fileList: g, multiple: y, onStart: w, onExceed: _ } = n;
      if (f && g.length + b.length > f) {
        _(b, g);
        return;
      }
      y || (b = b.slice(0, 1));
      for (const S of b) {
        const A = S;
        A.uid = jc(), w(A), p && l(A);
      }
    }, l = async (b) => {
      if (o.value.value = "", !n.beforeUpload)
        return c(b);
      let p, f = {};
      try {
        const y = n.data, w = n.beforeUpload(b);
        f = ph(n.data) ? Hh(n.data) : n.data, p = await w, ph(n.data) && Sl(y, f) && (f = Hh(n.data));
      } catch {
        p = !1;
      }
      if (p === !1) {
        n.onRemove(b);
        return;
      }
      let g = b;
      p instanceof Blob && (p instanceof File ? g = p : g = new File([p], b.name, {
        type: b.type
      })), c(Object.assign(g, {
        uid: b.uid
      }), f);
    }, u = async (b, p) => mn(b) ? b(p) : b, c = async (b, p) => {
      const {
        headers: f,
        data: g,
        method: y,
        withCredentials: w,
        name: _,
        action: S,
        onProgress: A,
        onSuccess: C,
        onError: k,
        httpRequest: O
      } = n;
      try {
        p = await u(p ?? g, b);
      } catch {
        n.onRemove(b);
        return;
      }
      const { uid: N } = b, B = {
        headers: f || {},
        withCredentials: w,
        file: b,
        data: p,
        method: y,
        filename: _,
        action: S,
        onProgress: (F) => {
          A(F, b);
        },
        onSuccess: (F) => {
          C(F, b), delete s.value[N];
        },
        onError: (F) => {
          k(F, b), delete s.value[N];
        }
      }, D = O(B);
      s.value[N] = D, D instanceof Promise && D.then(B.onSuccess, B.onError);
    }, d = (b) => {
      const p = b.target.files;
      p && a(Array.from(p));
    }, h = () => {
      i.value || (o.value.value = "", o.value.click());
    }, v = () => {
      h();
    };
    return e({
      abort: (b) => {
        PA(s.value).filter(b ? ([f]) => String(b.uid) === f : () => !0).forEach(([f, g]) => {
          g instanceof XMLHttpRequest && g.abort(), delete s.value[f];
        });
      },
      upload: l
    }), (b, p) => (U(), oe("div", {
      class: X([x(r).b(), x(r).m(b.listType), x(r).is("drag", b.drag)]),
      tabindex: "0",
      onClick: h,
      onKeydown: gn(dt(v, ["self"]), ["enter", "space"])
    }, [
      b.drag ? (U(), xe(CD, {
        key: 0,
        disabled: x(i),
        onFile: a
      }, {
        default: fe(() => [
          Me(b.$slots, "default")
        ]),
        _: 3
      }, 8, ["disabled"])) : Me(b.$slots, "default", { key: 1 }),
      le("input", {
        ref_key: "inputRef",
        ref: o,
        class: X(x(r).e("input")),
        name: b.name,
        multiple: b.multiple,
        accept: b.accept,
        type: "file",
        onChange: d,
        onClick: p[0] || (p[0] = dt(() => {
        }, ["stop"]))
      }, null, 42, ID)
    ], 42, OD));
  }
});
var Mp = /* @__PURE__ */ Ge(RD, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-content.vue"]]);
const Lp = "ElUpload", zp = (t) => {
  var e;
  (e = t.url) != null && e.startsWith("blob:") && URL.revokeObjectURL(t.url);
}, PD = (t, e) => {
  const n = Ew(t, "fileList", void 0, { passive: !0 }), r = (h) => n.value.find((v) => v.uid === h.uid);
  function i(h) {
    var v;
    (v = e.value) == null || v.abort(h);
  }
  function s(h = ["ready", "uploading", "success", "fail"]) {
    n.value = n.value.filter((v) => !h.includes(v.status));
  }
  const o = (h, v) => {
    const m = r(v);
    m && (console.error(h), m.status = "fail", n.value.splice(n.value.indexOf(m), 1), t.onError(h, m, n.value), t.onChange(m, n.value));
  }, a = (h, v) => {
    const m = r(v);
    m && (t.onProgress(h, m, n.value), m.status = "uploading", m.percentage = Math.round(h.percent));
  }, l = (h, v) => {
    const m = r(v);
    m && (m.status = "success", m.response = h, t.onSuccess(h, m, n.value), t.onChange(m, n.value));
  }, u = (h) => {
    nr(h.uid) && (h.uid = jc());
    const v = {
      name: h.name,
      percentage: 0,
      status: "ready",
      size: h.size,
      raw: h,
      uid: h.uid
    };
    if (t.listType === "picture-card" || t.listType === "picture")
      try {
        v.url = URL.createObjectURL(h);
      } catch (m) {
        Vt(Lp, m.message), t.onError(m, v, n.value);
      }
    n.value = [...n.value, v], t.onChange(v, n.value);
  }, c = async (h) => {
    const v = h instanceof File ? r(h) : h;
    v || ts(Lp, "file to be removed not found");
    const m = (b) => {
      i(b);
      const p = n.value;
      p.splice(p.indexOf(b), 1), t.onRemove(b, p), zp(b);
    };
    t.beforeRemove ? await t.beforeRemove(v, n.value) !== !1 && m(v) : m(v);
  };
  function d() {
    n.value.filter(({ status: h }) => h === "ready").forEach(({ raw: h }) => {
      var v;
      return h && ((v = e.value) == null ? void 0 : v.upload(h));
    });
  }
  return Ae(() => t.listType, (h) => {
    h !== "picture-card" && h !== "picture" || (n.value = n.value.map((v) => {
      const { raw: m, url: b } = v;
      if (!b && m)
        try {
          v.url = URL.createObjectURL(m);
        } catch (p) {
          t.onError(p, v, n.value);
        }
      return v;
    }));
  }), Ae(n, (h) => {
    for (const v of h)
      v.uid || (v.uid = jc()), v.status || (v.status = "success");
  }, { immediate: !0, deep: !0 }), {
    uploadFiles: n,
    abort: i,
    clearFiles: s,
    handleError: o,
    handleProgress: a,
    handleStart: u,
    handleSuccess: l,
    handleRemove: c,
    submit: d,
    revokeFileObjectURL: zp
  };
}, DD = ye({
  name: "ElUpload"
}), BD = /* @__PURE__ */ ye({
  ...DD,
  props: dD,
  setup(t, { expose: e }) {
    const n = t, r = Fr(), i = Fn(), {
      abort: s,
      submit: o,
      clearFiles: a,
      uploadFiles: l,
      handleStart: u,
      handleError: c,
      handleRemove: d,
      handleSuccess: h,
      handleProgress: v,
      revokeFileObjectURL: m
    } = PD(n, i), b = j(() => n.listType === "picture-card"), p = j(() => ({
      ...n,
      fileList: l.value,
      onStart: u,
      onProgress: v,
      onSuccess: h,
      onError: c,
      onRemove: d
    }));
    return xn(() => {
      l.value.forEach(m);
    }), qt(by, {
      accept: On(n, "accept")
    }), e({
      abort: s,
      submit: o,
      clearFiles: a,
      handleStart: u,
      handleRemove: d
    }), (f, g) => (U(), oe("div", null, [
      x(b) && f.showFileList ? (U(), xe(Bp, {
        key: 0,
        disabled: x(r),
        "list-type": f.listType,
        files: x(l),
        "handle-preview": f.onPreview,
        onRemove: x(d)
      }, ac({
        append: fe(() => [
          ve(Mp, Jn({
            ref_key: "uploadRef",
            ref: i
          }, x(p)), {
            default: fe(() => [
              f.$slots.trigger ? Me(f.$slots, "trigger", { key: 0 }) : me("v-if", !0),
              !f.$slots.trigger && f.$slots.default ? Me(f.$slots, "default", { key: 1 }) : me("v-if", !0)
            ]),
            _: 3
          }, 16)
        ]),
        _: 2
      }, [
        f.$slots.file ? {
          name: "default",
          fn: fe(({ file: y }) => [
            Me(f.$slots, "file", { file: y })
          ])
        } : void 0
      ]), 1032, ["disabled", "list-type", "files", "handle-preview", "onRemove"])) : me("v-if", !0),
      !x(b) || x(b) && !f.showFileList ? (U(), xe(Mp, Jn({
        key: 1,
        ref_key: "uploadRef",
        ref: i
      }, x(p)), {
        default: fe(() => [
          f.$slots.trigger ? Me(f.$slots, "trigger", { key: 0 }) : me("v-if", !0),
          !f.$slots.trigger && f.$slots.default ? Me(f.$slots, "default", { key: 1 }) : me("v-if", !0)
        ]),
        _: 3
      }, 16)) : me("v-if", !0),
      f.$slots.trigger ? Me(f.$slots, "default", { key: 2 }) : me("v-if", !0),
      Me(f.$slots, "tip"),
      !x(b) && f.showFileList ? (U(), xe(Bp, {
        key: 3,
        disabled: x(r),
        "list-type": f.listType,
        files: x(l),
        "handle-preview": f.onPreview,
        onRemove: x(d)
      }, ac({ _: 2 }, [
        f.$slots.file ? {
          name: "default",
          fn: fe(({ file: y }) => [
            Me(f.$slots, "file", { file: y })
          ])
        } : void 0
      ]), 1032, ["disabled", "list-type", "files", "handle-preview", "onRemove"])) : me("v-if", !0)
    ]));
  }
});
var MD = /* @__PURE__ */ Ge(BD, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload.vue"]]);
const LD = nn(MD);
function zD(t) {
  let e;
  const n = K(!1), r = Mn({
    ...t,
    originalPosition: "",
    originalOverflow: "",
    visible: !1
  });
  function i(h) {
    r.text = h;
  }
  function s() {
    const h = r.parent, v = d.ns;
    if (!h.vLoadingAddClassList) {
      let m = h.getAttribute("loading-number");
      m = Number.parseInt(m) - 1, m ? h.setAttribute("loading-number", m.toString()) : (Or(h, v.bm("parent", "relative")), h.removeAttribute("loading-number")), Or(h, v.bm("parent", "hidden"));
    }
    o(), c.unmount();
  }
  function o() {
    var h, v;
    (v = (h = d.$el) == null ? void 0 : h.parentNode) == null || v.removeChild(d.$el);
  }
  function a() {
    var h;
    t.beforeClose && !t.beforeClose() || (n.value = !0, clearTimeout(e), e = window.setTimeout(l, 400), r.visible = !1, (h = t.closed) == null || h.call(t));
  }
  function l() {
    if (!n.value)
      return;
    const h = r.parent;
    n.value = !1, h.vLoadingAddClassList = void 0, s();
  }
  const u = ye({
    name: "ElLoading",
    setup(h, { expose: v }) {
      const { ns: m, zIndex: b } = AO("loading");
      return v({
        ns: m,
        zIndex: b
      }), () => {
        const p = r.spinner || r.svg, f = Xe("svg", {
          class: "circular",
          viewBox: r.svgViewBox ? r.svgViewBox : "0 0 50 50",
          ...p ? { innerHTML: p } : {}
        }, [
          Xe("circle", {
            class: "path",
            cx: "25",
            cy: "25",
            r: "20",
            fill: "none"
          })
        ]), g = r.text ? Xe("p", { class: m.b("text") }, [r.text]) : void 0;
        return Xe(Sr, {
          name: m.b("fade"),
          onAfterLeave: l
        }, {
          default: fe(() => [
            Bt(ve("div", {
              style: {
                backgroundColor: r.background || ""
              },
              class: [
                m.b("mask"),
                r.customClass,
                r.fullscreen ? "is-fullscreen" : ""
              ]
            }, [
              Xe("div", {
                class: m.b("spinner")
              }, [f, g])
            ]), [[Qn, r.visible]])
          ])
        });
      };
    }
  }), c = Ob(u), d = c.mount(document.createElement("div"));
  return {
    ...pn(r),
    setText: i,
    removeElLoadingChild: o,
    close: a,
    handleAfterLeave: l,
    vm: d,
    get $el() {
      return d.$el;
    }
  };
}
let Pa;
const jD = function(t = {}) {
  if (!St)
    return;
  const e = FD(t);
  if (e.fullscreen && Pa)
    return Pa;
  const n = zD({
    ...e,
    closed: () => {
      var i;
      (i = e.closed) == null || i.call(e), e.fullscreen && (Pa = void 0);
    }
  });
  HD(e, e.parent, n), jp(e, e.parent, n), e.parent.vLoadingAddClassList = () => jp(e, e.parent, n);
  let r = e.parent.getAttribute("loading-number");
  return r ? r = `${Number.parseInt(r) + 1}` : r = "1", e.parent.setAttribute("loading-number", r), e.parent.appendChild(n.$el), rt(() => n.visible.value = e.visible), e.fullscreen && (Pa = n), n;
}, FD = (t) => {
  var e, n, r, i;
  let s;
  return Gt(t.target) ? s = (e = document.querySelector(t.target)) != null ? e : document.body : s = t.target || document.body, {
    parent: s === document.body || t.body ? document.body : s,
    background: t.background || "",
    svg: t.svg || "",
    svgViewBox: t.svgViewBox || "",
    spinner: t.spinner || !1,
    text: t.text || "",
    fullscreen: s === document.body && ((n = t.fullscreen) != null ? n : !0),
    lock: (r = t.lock) != null ? r : !1,
    customClass: t.customClass || "",
    visible: (i = t.visible) != null ? i : !0,
    target: s
  };
}, HD = async (t, e, n) => {
  const { nextZIndex: r } = n.vm.zIndex || n.vm._.exposed.zIndex, i = {};
  if (t.fullscreen)
    n.originalPosition.value = ws(document.body, "position"), n.originalOverflow.value = ws(document.body, "overflow"), i.zIndex = r();
  else if (t.parent === document.body) {
    n.originalPosition.value = ws(document.body, "position"), await rt();
    for (const s of ["top", "left"]) {
      const o = s === "top" ? "scrollTop" : "scrollLeft";
      i[s] = `${t.target.getBoundingClientRect()[s] + document.body[o] + document.documentElement[o] - Number.parseInt(ws(document.body, `margin-${s}`), 10)}px`;
    }
    for (const s of ["height", "width"])
      i[s] = `${t.target.getBoundingClientRect()[s]}px`;
  } else
    n.originalPosition.value = ws(e, "position");
  for (const [s, o] of Object.entries(i))
    n.$el.style[s] = o;
}, jp = (t, e, n) => {
  const r = n.vm.ns || n.vm._.exposed.ns;
  ["absolute", "fixed", "sticky"].includes(n.originalPosition.value) ? Or(e, r.bm("parent", "relative")) : Bo(e, r.bm("parent", "relative")), t.fullscreen && t.lock ? Bo(e, r.bm("parent", "hidden")) : Or(e, r.bm("parent", "hidden"));
}, Fc = Symbol("ElLoading"), Fp = (t, e) => {
  var n, r, i, s;
  const o = e.instance, a = (h) => _n(e.value) ? e.value[h] : void 0, l = (h) => {
    const v = Gt(h) && (o == null ? void 0 : o[h]) || h;
    return v && K(v);
  }, u = (h) => l(a(h) || t.getAttribute(`element-loading-${Nw(h)}`)), c = (n = a("fullscreen")) != null ? n : e.modifiers.fullscreen, d = {
    text: u("text"),
    svg: u("svg"),
    svgViewBox: u("svgViewBox"),
    spinner: u("spinner"),
    background: u("background"),
    customClass: u("customClass"),
    fullscreen: c,
    target: (r = a("target")) != null ? r : c ? void 0 : t,
    body: (i = a("body")) != null ? i : e.modifiers.body,
    lock: (s = a("lock")) != null ? s : e.modifiers.lock
  };
  t[Fc] = {
    options: d,
    instance: jD(d)
  };
}, UD = (t, e) => {
  for (const n of Object.keys(e))
    on(e[n]) && (e[n].value = t[n]);
}, VD = {
  mounted(t, e) {
    e.value && Fp(t, e);
  },
  updated(t, e) {
    const n = t[Fc];
    e.oldValue !== e.value && (e.value && !e.oldValue ? Fp(t, e) : e.value && e.oldValue ? _n(e.value) && UD(e.value, n.options) : n == null || n.instance.close());
  },
  unmounted(t) {
    var e;
    (e = t[Fc]) == null || e.instance.close();
  }
};
const is = (t, e) => {
  const n = t.__vccOpts || t;
  for (const [r, i] of e)
    n[r] = i;
  return n;
}, WD = { id: "left" }, $D = ["title"], KD = { id: "right" }, GD = {
  __name: "Titlebar",
  props: {
    backdrop: {
      default: !1,
      type: Boolean
    },
    title: {
      default: "Reader",
      type: String
    }
  },
  setup(t) {
    const e = t;
    let n = !1;
    const r = (s, o) => s.length > o ? `${s.substr(0, o - 3)}...` : s, i = () => {
      if (n)
        document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitCancelFullScreen ? document.webkitCancelFullScreen() : document.msExitFullscreen && document.msExitFullscreen(), n = !1;
      else {
        const s = document.documentElement, o = s.requestFullScreen || s.webkitRequestFullScreen || s.mozRequestFullScreen || s.msRequestFullscreen;
        typeof o < "u" && o && o.call(s), n = !0;
      }
    };
    return (s, o) => {
      const a = rs, l = U4;
      return U(), xe(l, {
        height: "40px",
        class: X({ backdrop: e.backdrop })
      }, {
        default: fe(() => [
          le("span", WD, [
            Me(s.$slots, "default", {}, void 0, !0)
          ]),
          le("span", {
            id: "center",
            title: e.title
          }, st(r(e.title, 15)), 9, $D),
          le("span", KD, [
            ve(a, {
              size: "small",
              icon: x(jg),
              circle: "",
              onClick: i
            }, null, 8, ["icon"])
          ])
        ]),
        _: 3
      }, 8, ["class"]);
    };
  }
}, Ey = /* @__PURE__ */ is(GD, [["__scopeId", "data-v-ea5e85e1"]]);
var Hc = {}, qD = {
  get exports() {
    return Hc;
  },
  set exports(t) {
    Hc = t;
  }
};
(function(t, e) {
  (function(n, r) {
    r();
  })(yn, function() {
    function n(u, c) {
      return typeof c > "u" ? c = { autoBom: !1 } : typeof c != "object" && (console.warn("Deprecated: Expected third argument to be a object"), c = { autoBom: !c }), c.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(u.type) ? new Blob(["\uFEFF", u], { type: u.type }) : u;
    }
    function r(u, c, d) {
      var h = new XMLHttpRequest();
      h.open("GET", u), h.responseType = "blob", h.onload = function() {
        l(h.response, c, d);
      }, h.onerror = function() {
        console.error("could not download file");
      }, h.send();
    }
    function i(u) {
      var c = new XMLHttpRequest();
      c.open("HEAD", u, !1);
      try {
        c.send();
      } catch {
      }
      return 200 <= c.status && 299 >= c.status;
    }
    function s(u) {
      try {
        u.dispatchEvent(new MouseEvent("click"));
      } catch {
        var c = document.createEvent("MouseEvents");
        c.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), u.dispatchEvent(c);
      }
    }
    var o = typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof yn == "object" && yn.global === yn ? yn : void 0, a = o.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), l = o.saveAs || (typeof window != "object" || window !== o ? function() {
    } : "download" in HTMLAnchorElement.prototype && !a ? function(u, c, d) {
      var h = o.URL || o.webkitURL, v = document.createElement("a");
      c = c || u.name || "download", v.download = c, v.rel = "noopener", typeof u == "string" ? (v.href = u, v.origin === location.origin ? s(v) : i(v.href) ? r(u, c, d) : s(v, v.target = "_blank")) : (v.href = h.createObjectURL(u), setTimeout(function() {
        h.revokeObjectURL(v.href);
      }, 4e4), setTimeout(function() {
        s(v);
      }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(u, c, d) {
      if (c = c || u.name || "download", typeof u != "string")
        navigator.msSaveOrOpenBlob(n(u, d), c);
      else if (i(u))
        r(u, c, d);
      else {
        var h = document.createElement("a");
        h.href = u, h.target = "_blank", setTimeout(function() {
          s(h);
        });
      }
    } : function(u, c, d, h) {
      if (h = h || open("", "_blank"), h && (h.document.title = h.document.body.innerText = "downloading..."), typeof u == "string")
        return r(u, c, d);
      var v = u.type === "application/octet-stream", m = /constructor/i.test(o.HTMLElement) || o.safari, b = /CriOS\/[\d]+/.test(navigator.userAgent);
      if ((b || v && m || a) && typeof FileReader < "u") {
        var p = new FileReader();
        p.onloadend = function() {
          var y = p.result;
          y = b ? y : y.replace(/^data:[^;]*;/, "data:attachment/file;"), h ? h.location.href = y : location = y, h = null;
        }, p.readAsDataURL(u);
      } else {
        var f = o.URL || o.webkitURL, g = f.createObjectURL(u);
        h ? h.location = g : location.href = g, h = null, setTimeout(function() {
          f.revokeObjectURL(g);
        }, 4e4);
      }
    });
    o.saveAs = l.saveAs = l, t.exports = l;
  });
})(qD);
const JD = Hc, Ut = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, an = Object.keys, In = Array.isArray;
function Bn(t, e) {
  return typeof e != "object" || an(e).forEach(function(n) {
    t[n] = e[n];
  }), t;
}
typeof Promise > "u" || Ut.Promise || (Ut.Promise = Promise);
const Ho = Object.getPrototypeOf, YD = {}.hasOwnProperty;
function Zn(t, e) {
  return YD.call(t, e);
}
function Vs(t, e) {
  typeof e == "function" && (e = e(Ho(t))), (typeof Reflect > "u" ? an : Reflect.ownKeys)(e).forEach((n) => {
    Xr(t, n, e[n]);
  });
}
const xy = Object.defineProperty;
function Xr(t, e, n, r) {
  xy(t, e, Bn(n && Zn(n, "get") && typeof n.get == "function" ? { get: n.get, set: n.set, configurable: !0 } : { value: n, configurable: !0, writable: !0 }, r));
}
function Is(t) {
  return { from: function(e) {
    return t.prototype = Object.create(e.prototype), Xr(t.prototype, "constructor", t), { extend: Vs.bind(null, t.prototype) };
  } };
}
const QD = Object.getOwnPropertyDescriptor;
function bf(t, e) {
  let n;
  return QD(t, e) || (n = Ho(t)) && bf(n, e);
}
const ZD = [].slice;
function kl(t, e, n) {
  return ZD.call(t, e, n);
}
function Ay(t, e) {
  return e(t);
}
function po(t) {
  if (!t)
    throw new Error("Assertion Failed");
}
function ky(t) {
  Ut.setImmediate ? setImmediate(t) : setTimeout(t, 0);
}
function Cy(t, e) {
  return t.reduce((n, r, i) => {
    var s = e(r, i);
    return s && (n[s[0]] = s[1]), n;
  }, {});
}
function ei(t, e) {
  if (Zn(t, e))
    return t[e];
  if (!e)
    return t;
  if (typeof e != "string") {
    for (var n = [], r = 0, i = e.length; r < i; ++r) {
      var s = ei(t, e[r]);
      n.push(s);
    }
    return n;
  }
  var o = e.indexOf(".");
  if (o !== -1) {
    var a = t[e.substr(0, o)];
    return a === void 0 ? void 0 : ei(a, e.substr(o + 1));
  }
}
function br(t, e, n) {
  if (t && e !== void 0 && (!("isFrozen" in Object) || !Object.isFrozen(t)))
    if (typeof e != "string" && "length" in e) {
      po(typeof n != "string" && "length" in n);
      for (var r = 0, i = e.length; r < i; ++r)
        br(t, e[r], n[r]);
    } else {
      var s = e.indexOf(".");
      if (s !== -1) {
        var o = e.substr(0, s), a = e.substr(s + 1);
        if (a === "")
          n === void 0 ? In(t) && !isNaN(parseInt(o)) ? t.splice(o, 1) : delete t[o] : t[o] = n;
        else {
          var l = t[o];
          l && Zn(t, o) || (l = t[o] = {}), br(l, a, n);
        }
      } else
        n === void 0 ? In(t) && !isNaN(parseInt(e)) ? t.splice(e, 1) : delete t[e] : t[e] = n;
    }
}
function Ty(t) {
  var e = {};
  for (var n in t)
    Zn(t, n) && (e[n] = t[n]);
  return e;
}
const XD = [].concat;
function Oy(t) {
  return XD.apply([], t);
}
const Iy = "Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(Oy([8, 16, 32, 64].map((t) => ["Int", "Uint", "Float"].map((e) => e + t + "Array")))).filter((t) => Ut[t]), eB = Iy.map((t) => Ut[t]);
Cy(Iy, (t) => [t, !0]);
let yi = null;
function fa(t) {
  yi = typeof WeakMap < "u" && /* @__PURE__ */ new WeakMap();
  const e = Uc(t);
  return yi = null, e;
}
function Uc(t) {
  if (!t || typeof t != "object")
    return t;
  let e = yi && yi.get(t);
  if (e)
    return e;
  if (In(t)) {
    e = [], yi && yi.set(t, e);
    for (var n = 0, r = t.length; n < r; ++n)
      e.push(Uc(t[n]));
  } else if (eB.indexOf(t.constructor) >= 0)
    e = t;
  else {
    const s = Ho(t);
    for (var i in e = s === Object.prototype ? {} : Object.create(s), yi && yi.set(t, e), t)
      Zn(t, i) && (e[i] = Uc(t[i]));
  }
  return e;
}
const { toString: tB } = {};
function Vc(t) {
  return tB.call(t).slice(8, -1);
}
const Wc = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", nB = typeof Wc == "symbol" ? function(t) {
  var e;
  return t != null && (e = t[Wc]) && e.apply(t);
} : function() {
  return null;
}, Ss = {};
function Yr(t) {
  var e, n, r, i;
  if (arguments.length === 1) {
    if (In(t))
      return t.slice();
    if (this === Ss && typeof t == "string")
      return [t];
    if (i = nB(t)) {
      for (n = []; !(r = i.next()).done; )
        n.push(r.value);
      return n;
    }
    if (t == null)
      return [t];
    if (typeof (e = t.length) == "number") {
      for (n = new Array(e); e--; )
        n[e] = t[e];
      return n;
    }
    return [t];
  }
  for (e = arguments.length, n = new Array(e); e--; )
    n[e] = arguments[e];
  return n;
}
const wf = typeof Symbol < "u" ? (t) => t[Symbol.toStringTag] === "AsyncFunction" : () => !1;
var Ur = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
function Ny(t, e) {
  Ur = t, Ry = e;
}
var Ry = () => !0;
const rB = !new Error("").stack;
function ss() {
  if (rB)
    try {
      throw ss.arguments, new Error();
    } catch (t) {
      return t;
    }
  return new Error();
}
function $c(t, e) {
  var n = t.stack;
  return n ? (e = e || 0, n.indexOf(t.name) === 0 && (e += (t.name + t.message).split(`
`).length), n.split(`
`).slice(e).filter(Ry).map((r) => `
` + r).join("")) : "";
}
var Py = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], _f = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Py), iB = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
function Ns(t, e) {
  this._e = ss(), this.name = t, this.message = e;
}
function Dy(t, e) {
  return t + ". Errors: " + Object.keys(e).map((n) => e[n].toString()).filter((n, r, i) => i.indexOf(n) === r).join(`
`);
}
function Cl(t, e, n, r) {
  this._e = ss(), this.failures = e, this.failedKeys = r, this.successCount = n, this.message = Dy(t, e);
}
function Eo(t, e) {
  this._e = ss(), this.name = "BulkError", this.failures = Object.keys(e).map((n) => e[n]), this.failuresByPos = e, this.message = Dy(t, e);
}
Is(Ns).from(Error).extend({ stack: { get: function() {
  return this._stack || (this._stack = this.name + ": " + this.message + $c(this._e, 2));
} }, toString: function() {
  return this.name + ": " + this.message;
} }), Is(Cl).from(Ns), Is(Eo).from(Ns);
var Sf = _f.reduce((t, e) => (t[e] = e + "Error", t), {});
const sB = Ns;
var Ze = _f.reduce((t, e) => {
  var n = e + "Error";
  function r(i, s) {
    this._e = ss(), this.name = n, i ? typeof i == "string" ? (this.message = `${i}${s ? `
 ` + s : ""}`, this.inner = s || null) : typeof i == "object" && (this.message = `${i.name} ${i.message}`, this.inner = i) : (this.message = iB[e] || n, this.inner = null);
  }
  return Is(r).from(sB), t[e] = r, t;
}, {});
Ze.Syntax = SyntaxError, Ze.Type = TypeError, Ze.Range = RangeError;
var Hp = Py.reduce((t, e) => (t[e + "Error"] = Ze[e], t), {}), il = _f.reduce((t, e) => (["Syntax", "Type", "Range"].indexOf(e) === -1 && (t[e + "Error"] = Ze[e]), t), {});
function Lt() {
}
function Uo(t) {
  return t;
}
function oB(t, e) {
  return t == null || t === Uo ? e : function(n) {
    return e(t(n));
  };
}
function Ji(t, e) {
  return function() {
    t.apply(this, arguments), e.apply(this, arguments);
  };
}
function aB(t, e) {
  return t === Lt ? e : function() {
    var n = t.apply(this, arguments);
    n !== void 0 && (arguments[0] = n);
    var r = this.onsuccess, i = this.onerror;
    this.onsuccess = null, this.onerror = null;
    var s = e.apply(this, arguments);
    return r && (this.onsuccess = this.onsuccess ? Ji(r, this.onsuccess) : r), i && (this.onerror = this.onerror ? Ji(i, this.onerror) : i), s !== void 0 ? s : n;
  };
}
function lB(t, e) {
  return t === Lt ? e : function() {
    t.apply(this, arguments);
    var n = this.onsuccess, r = this.onerror;
    this.onsuccess = this.onerror = null, e.apply(this, arguments), n && (this.onsuccess = this.onsuccess ? Ji(n, this.onsuccess) : n), r && (this.onerror = this.onerror ? Ji(r, this.onerror) : r);
  };
}
function uB(t, e) {
  return t === Lt ? e : function(n) {
    var r = t.apply(this, arguments);
    Bn(n, r);
    var i = this.onsuccess, s = this.onerror;
    this.onsuccess = null, this.onerror = null;
    var o = e.apply(this, arguments);
    return i && (this.onsuccess = this.onsuccess ? Ji(i, this.onsuccess) : i), s && (this.onerror = this.onerror ? Ji(s, this.onerror) : s), r === void 0 ? o === void 0 ? void 0 : o : Bn(r, o);
  };
}
function cB(t, e) {
  return t === Lt ? e : function() {
    return e.apply(this, arguments) !== !1 && t.apply(this, arguments);
  };
}
function Ef(t, e) {
  return t === Lt ? e : function() {
    var n = t.apply(this, arguments);
    if (n && typeof n.then == "function") {
      for (var r = this, i = arguments.length, s = new Array(i); i--; )
        s[i] = arguments[i];
      return n.then(function() {
        return e.apply(r, s);
      });
    }
    return e.apply(this, arguments);
  };
}
il.ModifyError = Cl, il.DexieError = Ns, il.BulkError = Eo;
var Vo = {};
const By = 100, [Kc, Tl, Gc] = typeof Promise > "u" ? [] : (() => {
  let t = Promise.resolve();
  if (typeof crypto > "u" || !crypto.subtle)
    return [t, Ho(t), t];
  const e = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
  return [e, Ho(e), t];
})(), My = Tl && Tl.then, sl = Kc && Kc.constructor, xf = !!Gc;
var qc = !1, dB = Gc ? () => {
  Gc.then(Da);
} : Ut.setImmediate ? setImmediate.bind(null, Da) : Ut.MutationObserver ? () => {
  var t = document.createElement("div");
  new MutationObserver(() => {
    Da(), t = null;
  }).observe(t, { attributes: !0 }), t.setAttribute("i", "1");
} : () => {
  setTimeout(Da, 0);
}, xo = function(t, e) {
  vo.push([t, e]), Ol && (dB(), Ol = !1);
}, Jc = !0, Ol = !0, Ui = [], ol = [], Yc = null, Qc = Uo, Rs = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: Wp, pgp: !1, env: {}, finalize: function() {
  this.unhandleds.forEach((t) => {
    try {
      Wp(t[0], t[1]);
    } catch {
    }
  });
} }, Ke = Rs, vo = [], Vi = 0, al = [];
function Le(t) {
  if (typeof this != "object")
    throw new TypeError("Promises must be constructed via new");
  this._listeners = [], this.onuncatched = Lt, this._lib = !1;
  var e = this._PSD = Ke;
  if (Ur && (this._stackHolder = ss(), this._prev = null, this._numPrev = 0), typeof t != "function") {
    if (t !== Vo)
      throw new TypeError("Not a function");
    return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && Xc(this, this._value));
  }
  this._state = null, this._value = null, ++e.ref, zy(this, t);
}
const Zc = { get: function() {
  var t = Ke, e = Il;
  function n(r, i) {
    var s = !t.global && (t !== Ke || e !== Il);
    const o = s && !si();
    var a = new Le((l, u) => {
      Af(this, new Ly(Nl(r, t, s, o), Nl(i, t, s, o), l, u, t));
    });
    return Ur && Hy(a, this), a;
  }
  return n.prototype = Vo, n;
}, set: function(t) {
  Xr(this, "then", t && t.prototype === Vo ? Zc : { get: function() {
    return t;
  }, set: Zc.set });
} };
function Ly(t, e, n, r, i) {
  this.onFulfilled = typeof t == "function" ? t : null, this.onRejected = typeof e == "function" ? e : null, this.resolve = n, this.reject = r, this.psd = i;
}
function zy(t, e) {
  try {
    e((n) => {
      if (t._state === null) {
        if (n === t)
          throw new TypeError("A promise cannot be resolved with itself.");
        var r = t._lib && ha();
        n && typeof n.then == "function" ? zy(t, (i, s) => {
          n instanceof Le ? n._then(i, s) : n.then(i, s);
        }) : (t._state = !0, t._value = n, jy(t)), r && pa();
      }
    }, Xc.bind(null, t));
  } catch (n) {
    Xc(t, n);
  }
}
function Xc(t, e) {
  if (ol.push(e), t._state === null) {
    var n = t._lib && ha();
    e = Qc(e), t._state = !1, t._value = e, Ur && e !== null && typeof e == "object" && !e._promise && function(r, i, s) {
      try {
        r.apply(null, s);
      } catch (o) {
        i && i(o);
      }
    }(() => {
      var r = bf(e, "stack");
      e._promise = t, Xr(e, "stack", { get: () => qc ? r && (r.get ? r.get.apply(e) : r.value) : t.stack });
    }), function(r) {
      Ui.some((i) => i._value === r._value) || Ui.push(r);
    }(t), jy(t), n && pa();
  }
}
function jy(t) {
  var e = t._listeners;
  t._listeners = [];
  for (var n = 0, r = e.length; n < r; ++n)
    Af(t, e[n]);
  var i = t._PSD;
  --i.ref || i.finalize(), Vi === 0 && (++Vi, xo(() => {
    --Vi == 0 && kf();
  }, []));
}
function Af(t, e) {
  if (t._state !== null) {
    var n = t._state ? e.onFulfilled : e.onRejected;
    if (n === null)
      return (t._state ? e.resolve : e.reject)(t._value);
    ++e.psd.ref, ++Vi, xo(fB, [n, t, e]);
  } else
    t._listeners.push(e);
}
function fB(t, e, n) {
  try {
    Yc = e;
    var r, i = e._value;
    e._state ? r = t(i) : (ol.length && (ol = []), r = t(i), ol.indexOf(i) === -1 && function(s) {
      for (var o = Ui.length; o; )
        if (Ui[--o]._value === s._value)
          return void Ui.splice(o, 1);
    }(e)), n.resolve(r);
  } catch (s) {
    n.reject(s);
  } finally {
    Yc = null, --Vi == 0 && kf(), --n.psd.ref || n.psd.finalize();
  }
}
function Fy(t, e, n) {
  if (e.length === n)
    return e;
  var r = "";
  if (t._state === !1) {
    var i, s, o = t._value;
    o != null ? (i = o.name || "Error", s = o.message || o, r = $c(o, 0)) : (i = o, s = ""), e.push(i + (s ? ": " + s : "") + r);
  }
  return Ur && ((r = $c(t._stackHolder, 2)) && e.indexOf(r) === -1 && e.push(r), t._prev && Fy(t._prev, e, n)), e;
}
function Hy(t, e) {
  var n = e ? e._numPrev + 1 : 0;
  n < 100 && (t._prev = e, t._numPrev = n);
}
function Da() {
  ha() && pa();
}
function ha() {
  var t = Jc;
  return Jc = !1, Ol = !1, t;
}
function pa() {
  var t, e, n;
  do
    for (; vo.length > 0; )
      for (t = vo, vo = [], n = t.length, e = 0; e < n; ++e) {
        var r = t[e];
        r[0].apply(null, r[1]);
      }
  while (vo.length > 0);
  Jc = !0, Ol = !0;
}
function kf() {
  var t = Ui;
  Ui = [], t.forEach((r) => {
    r._PSD.onunhandled.call(null, r._value, r);
  });
  for (var e = al.slice(0), n = e.length; n; )
    e[--n]();
}
function Ba(t) {
  return new Le(Vo, !1, t);
}
function $t(t, e) {
  var n = Ke;
  return function() {
    var r = ha(), i = Ke;
    try {
      return ki(n, !0), t.apply(this, arguments);
    } catch (s) {
      e && e(s);
    } finally {
      ki(i, !1), r && pa();
    }
  };
}
Vs(Le.prototype, { then: Zc, _then: function(t, e) {
  Af(this, new Ly(null, null, t, e, Ke));
}, catch: function(t) {
  if (arguments.length === 1)
    return this.then(null, t);
  var e = arguments[0], n = arguments[1];
  return typeof e == "function" ? this.then(null, (r) => r instanceof e ? n(r) : Ba(r)) : this.then(null, (r) => r && r.name === e ? n(r) : Ba(r));
}, finally: function(t) {
  return this.then((e) => (t(), e), (e) => (t(), Ba(e)));
}, stack: { get: function() {
  if (this._stack)
    return this._stack;
  try {
    qc = !0;
    var t = Fy(this, [], 20).join(`
From previous: `);
    return this._state !== null && (this._stack = t), t;
  } finally {
    qc = !1;
  }
} }, timeout: function(t, e) {
  return t < 1 / 0 ? new Le((n, r) => {
    var i = setTimeout(() => r(new Ze.Timeout(e)), t);
    this.then(n, r).finally(clearTimeout.bind(null, i));
  }) : this;
} }), typeof Symbol < "u" && Symbol.toStringTag && Xr(Le.prototype, Symbol.toStringTag, "Dexie.Promise"), Rs.env = Uy(), Vs(Le, { all: function() {
  var t = Yr.apply(null, arguments).map(Ma);
  return new Le(function(e, n) {
    t.length === 0 && e([]);
    var r = t.length;
    t.forEach((i, s) => Le.resolve(i).then((o) => {
      t[s] = o, --r || e(t);
    }, n));
  });
}, resolve: (t) => {
  if (t instanceof Le)
    return t;
  if (t && typeof t.then == "function")
    return new Le((n, r) => {
      t.then(n, r);
    });
  var e = new Le(Vo, !0, t);
  return Hy(e, Yc), e;
}, reject: Ba, race: function() {
  var t = Yr.apply(null, arguments).map(Ma);
  return new Le((e, n) => {
    t.map((r) => Le.resolve(r).then(e, n));
  });
}, PSD: { get: () => Ke, set: (t) => Ke = t }, totalEchoes: { get: () => Il }, newPSD: Ai, usePSD: Zs, scheduler: { get: () => xo, set: (t) => {
  xo = t;
} }, rejectionMapper: { get: () => Qc, set: (t) => {
  Qc = t;
} }, follow: (t, e) => new Le((n, r) => Ai((i, s) => {
  var o = Ke;
  o.unhandleds = [], o.onunhandled = s, o.finalize = Ji(function() {
    (function(a) {
      function l() {
        a(), al.splice(al.indexOf(l), 1);
      }
      al.push(l), ++Vi, xo(() => {
        --Vi == 0 && kf();
      }, []);
    })(() => {
      this.unhandleds.length === 0 ? i() : s(this.unhandleds[0]);
    });
  }, o.finalize), t();
}, e, n, r)) }), sl && (sl.allSettled && Xr(Le, "allSettled", function() {
  const t = Yr.apply(null, arguments).map(Ma);
  return new Le((e) => {
    t.length === 0 && e([]);
    let n = t.length;
    const r = new Array(n);
    t.forEach((i, s) => Le.resolve(i).then((o) => r[s] = { status: "fulfilled", value: o }, (o) => r[s] = { status: "rejected", reason: o }).then(() => --n || e(r)));
  });
}), sl.any && typeof AggregateError < "u" && Xr(Le, "any", function() {
  const t = Yr.apply(null, arguments).map(Ma);
  return new Le((e, n) => {
    t.length === 0 && n(new AggregateError([]));
    let r = t.length;
    const i = new Array(r);
    t.forEach((s, o) => Le.resolve(s).then((a) => e(a), (a) => {
      i[o] = a, --r || n(new AggregateError(i));
    }));
  });
}));
const Tn = { awaits: 0, echoes: 0, id: 0 };
var hB = 0, ll = [], Uu = 0, Il = 0, pB = 0;
function Ai(t, e, n, r) {
  var i = Ke, s = Object.create(i);
  s.parent = i, s.ref = 0, s.global = !1, s.id = ++pB;
  var o = Rs.env;
  s.env = xf ? { Promise: Le, PromiseProp: { value: Le, configurable: !0, writable: !0 }, all: Le.all, race: Le.race, allSettled: Le.allSettled, any: Le.any, resolve: Le.resolve, reject: Le.reject, nthen: Up(o.nthen, s), gthen: Up(o.gthen, s) } : {}, e && Bn(s, e), ++i.ref, s.finalize = function() {
    --this.parent.ref || this.parent.finalize();
  };
  var a = Zs(s, t, n, r);
  return s.ref === 0 && s.finalize(), a;
}
function Qs() {
  return Tn.id || (Tn.id = ++hB), ++Tn.awaits, Tn.echoes += By, Tn.id;
}
function si() {
  return !!Tn.awaits && (--Tn.awaits == 0 && (Tn.id = 0), Tn.echoes = Tn.awaits * By, !0);
}
function Ma(t) {
  return Tn.echoes && t && t.constructor === sl ? (Qs(), t.then((e) => (si(), e), (e) => (si(), dn(e)))) : t;
}
function vB(t) {
  ++Il, Tn.echoes && --Tn.echoes != 0 || (Tn.echoes = Tn.id = 0), ll.push(Ke), ki(t, !0);
}
function gB() {
  var t = ll[ll.length - 1];
  ll.pop(), ki(t, !1);
}
function ki(t, e) {
  var n = Ke;
  if ((e ? !Tn.echoes || Uu++ && t === Ke : !Uu || --Uu && t === Ke) || Vy(e ? vB.bind(null, t) : gB), t !== Ke && (Ke = t, n === Rs && (Rs.env = Uy()), xf)) {
    var r = Rs.env.Promise, i = t.env;
    Tl.then = i.nthen, r.prototype.then = i.gthen, (n.global || t.global) && (Object.defineProperty(Ut, "Promise", i.PromiseProp), r.all = i.all, r.race = i.race, r.resolve = i.resolve, r.reject = i.reject, i.allSettled && (r.allSettled = i.allSettled), i.any && (r.any = i.any));
  }
}
function Uy() {
  var t = Ut.Promise;
  return xf ? { Promise: t, PromiseProp: Object.getOwnPropertyDescriptor(Ut, "Promise"), all: t.all, race: t.race, allSettled: t.allSettled, any: t.any, resolve: t.resolve, reject: t.reject, nthen: Tl.then, gthen: t.prototype.then } : {};
}
function Zs(t, e, n, r, i) {
  var s = Ke;
  try {
    return ki(t, !0), e(n, r, i);
  } finally {
    ki(s, !1);
  }
}
function Vy(t) {
  My.call(Kc, t);
}
function Nl(t, e, n, r) {
  return typeof t != "function" ? t : function() {
    var i = Ke;
    n && Qs(), ki(e, !0);
    try {
      return t.apply(this, arguments);
    } finally {
      ki(i, !1), r && Vy(si);
    }
  };
}
function Up(t, e) {
  return function(n, r) {
    return t.call(this, Nl(n, e), Nl(r, e));
  };
}
("" + My).indexOf("[native code]") === -1 && (Qs = si = Lt);
const Vp = "unhandledrejection";
function Wp(t, e) {
  var n;
  try {
    n = e.onuncatched(t);
  } catch {
  }
  if (n !== !1)
    try {
      var r, i = { promise: e, reason: t };
      if (Ut.document && document.createEvent ? ((r = document.createEvent("Event")).initEvent(Vp, !0, !0), Bn(r, i)) : Ut.CustomEvent && Bn(r = new CustomEvent(Vp, { detail: i }), i), r && Ut.dispatchEvent && (dispatchEvent(r), !Ut.PromiseRejectionEvent && Ut.onunhandledrejection))
        try {
          Ut.onunhandledrejection(r);
        } catch {
        }
      Ur && r && !r.defaultPrevented && console.warn(`Unhandled rejection: ${t.stack || t}`);
    } catch {
    }
}
var dn = Le.reject;
function ed(t, e, n, r) {
  if (t.idbdb && (t._state.openComplete || Ke.letThrough || t._vip)) {
    var i = t._createTransaction(e, n, t._dbSchema);
    try {
      i.create(), t._state.PR1398_maxLoop = 3;
    } catch (s) {
      return s.name === Sf.InvalidState && t.isOpen() && --t._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), t._close(), t.open().then(() => ed(t, e, n, r))) : dn(s);
    }
    return i._promise(e, (s, o) => Ai(() => (Ke.trans = i, r(s, o, i)))).then((s) => i._completion.then(() => s));
  }
  if (t._state.openComplete)
    return dn(new Ze.DatabaseClosed(t._state.dbOpenError));
  if (!t._state.isBeingOpened) {
    if (!t._options.autoOpen)
      return dn(new Ze.DatabaseClosed());
    t.open().catch(Lt);
  }
  return t._state.dbReadyPromise.then(() => ed(t, e, n, r));
}
const $p = "3.2.4", ji = String.fromCharCode(65535), td = -1 / 0, Kr = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Wy = "String expected.", Ao = [], hu = typeof navigator < "u" && /(MSIE|Trident|Edge)/.test(navigator.userAgent), mB = hu, yB = hu, $y = (t) => !/(dexie\.js|dexie\.min\.js)/.test(t), pu = "__dbnames", Vu = "readonly", Wu = "readwrite";
function Yi(t, e) {
  return t ? e ? function() {
    return t.apply(this, arguments) && e.apply(this, arguments);
  } : t : e;
}
const Ky = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
function La(t) {
  return typeof t != "string" || /\./.test(t) ? (e) => e : (e) => (e[t] === void 0 && t in e && delete (e = fa(e))[t], e);
}
class bB {
  _trans(e, n, r) {
    const i = this._tx || Ke.trans, s = this.name;
    function o(l, u, c) {
      if (!c.schema[s])
        throw new Ze.NotFound("Table " + s + " not part of transaction");
      return n(c.idbtrans, c);
    }
    const a = ha();
    try {
      return i && i.db === this.db ? i === Ke.trans ? i._promise(e, o, r) : Ai(() => i._promise(e, o, r), { trans: i, transless: Ke.transless || Ke }) : ed(this.db, e, [this.name], o);
    } finally {
      a && pa();
    }
  }
  get(e, n) {
    return e && e.constructor === Object ? this.where(e).first(n) : this._trans("readonly", (r) => this.core.get({ trans: r, key: e }).then((i) => this.hook.reading.fire(i))).then(n);
  }
  where(e) {
    if (typeof e == "string")
      return new this.db.WhereClause(this, e);
    if (In(e))
      return new this.db.WhereClause(this, `[${e.join("+")}]`);
    const n = an(e);
    if (n.length === 1)
      return this.where(n[0]).equals(e[n[0]]);
    const r = this.schema.indexes.concat(this.schema.primKey).filter((u) => u.compound && n.every((c) => u.keyPath.indexOf(c) >= 0) && u.keyPath.every((c) => n.indexOf(c) >= 0))[0];
    if (r && this.db._maxKey !== ji)
      return this.where(r.name).equals(r.keyPath.map((u) => e[u]));
    !r && Ur && console.warn(`The query ${JSON.stringify(e)} on ${this.name} would benefit of a compound index [${n.join("+")}]`);
    const { idxByName: i } = this.schema, s = this.db._deps.indexedDB;
    function o(u, c) {
      try {
        return s.cmp(u, c) === 0;
      } catch {
        return !1;
      }
    }
    const [a, l] = n.reduce(([u, c], d) => {
      const h = i[d], v = e[d];
      return [u || h, u || !h ? Yi(c, h && h.multi ? (m) => {
        const b = ei(m, d);
        return In(b) && b.some((p) => o(v, p));
      } : (m) => o(v, ei(m, d))) : c];
    }, [null, null]);
    return a ? this.where(a.name).equals(e[a.keyPath]).filter(l) : r ? this.filter(l) : this.where(n).equals("");
  }
  filter(e) {
    return this.toCollection().and(e);
  }
  count(e) {
    return this.toCollection().count(e);
  }
  offset(e) {
    return this.toCollection().offset(e);
  }
  limit(e) {
    return this.toCollection().limit(e);
  }
  each(e) {
    return this.toCollection().each(e);
  }
  toArray(e) {
    return this.toCollection().toArray(e);
  }
  toCollection() {
    return new this.db.Collection(new this.db.WhereClause(this));
  }
  orderBy(e) {
    return new this.db.Collection(new this.db.WhereClause(this, In(e) ? `[${e.join("+")}]` : e));
  }
  reverse() {
    return this.toCollection().reverse();
  }
  mapToClass(e) {
    this.schema.mappedClass = e;
    const n = (r) => {
      if (!r)
        return r;
      const i = Object.create(e.prototype);
      for (var s in r)
        if (Zn(r, s))
          try {
            i[s] = r[s];
          } catch {
          }
      return i;
    };
    return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = n, this.hook("reading", n), e;
  }
  defineClass() {
    return this.mapToClass(function(e) {
      Bn(this, e);
    });
  }
  add(e, n) {
    const { auto: r, keyPath: i } = this.schema.primKey;
    let s = e;
    return i && r && (s = La(i)(e)), this._trans("readwrite", (o) => this.core.mutate({ trans: o, type: "add", keys: n != null ? [n] : null, values: [s] })).then((o) => o.numFailures ? Le.reject(o.failures[0]) : o.lastResult).then((o) => {
      if (i)
        try {
          br(e, i, o);
        } catch {
        }
      return o;
    });
  }
  update(e, n) {
    if (typeof e != "object" || In(e))
      return this.where(":id").equals(e).modify(n);
    {
      const r = ei(e, this.schema.primKey.keyPath);
      if (r === void 0)
        return dn(new Ze.InvalidArgument("Given object does not contain its primary key"));
      try {
        typeof n != "function" ? an(n).forEach((i) => {
          br(e, i, n[i]);
        }) : n(e, { value: e, primKey: r });
      } catch {
      }
      return this.where(":id").equals(r).modify(n);
    }
  }
  put(e, n) {
    const { auto: r, keyPath: i } = this.schema.primKey;
    let s = e;
    return i && r && (s = La(i)(e)), this._trans("readwrite", (o) => this.core.mutate({ trans: o, type: "put", values: [s], keys: n != null ? [n] : null })).then((o) => o.numFailures ? Le.reject(o.failures[0]) : o.lastResult).then((o) => {
      if (i)
        try {
          br(e, i, o);
        } catch {
        }
      return o;
    });
  }
  delete(e) {
    return this._trans("readwrite", (n) => this.core.mutate({ trans: n, type: "delete", keys: [e] })).then((n) => n.numFailures ? Le.reject(n.failures[0]) : void 0);
  }
  clear() {
    return this._trans("readwrite", (e) => this.core.mutate({ trans: e, type: "deleteRange", range: Ky })).then((e) => e.numFailures ? Le.reject(e.failures[0]) : void 0);
  }
  bulkGet(e) {
    return this._trans("readonly", (n) => this.core.getMany({ keys: e, trans: n }).then((r) => r.map((i) => this.hook.reading.fire(i))));
  }
  bulkAdd(e, n, r) {
    const i = Array.isArray(n) ? n : void 0, s = (r = r || (i ? void 0 : n)) ? r.allKeys : void 0;
    return this._trans("readwrite", (o) => {
      const { auto: a, keyPath: l } = this.schema.primKey;
      if (l && i)
        throw new Ze.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
      if (i && i.length !== e.length)
        throw new Ze.InvalidArgument("Arguments objects and keys must have the same length");
      const u = e.length;
      let c = l && a ? e.map(La(l)) : e;
      return this.core.mutate({ trans: o, type: "add", keys: i, values: c, wantResults: s }).then(({ numFailures: d, results: h, lastResult: v, failures: m }) => {
        if (d === 0)
          return s ? h : v;
        throw new Eo(`${this.name}.bulkAdd(): ${d} of ${u} operations failed`, m);
      });
    });
  }
  bulkPut(e, n, r) {
    const i = Array.isArray(n) ? n : void 0, s = (r = r || (i ? void 0 : n)) ? r.allKeys : void 0;
    return this._trans("readwrite", (o) => {
      const { auto: a, keyPath: l } = this.schema.primKey;
      if (l && i)
        throw new Ze.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
      if (i && i.length !== e.length)
        throw new Ze.InvalidArgument("Arguments objects and keys must have the same length");
      const u = e.length;
      let c = l && a ? e.map(La(l)) : e;
      return this.core.mutate({ trans: o, type: "put", keys: i, values: c, wantResults: s }).then(({ numFailures: d, results: h, lastResult: v, failures: m }) => {
        if (d === 0)
          return s ? h : v;
        throw new Eo(`${this.name}.bulkPut(): ${d} of ${u} operations failed`, m);
      });
    });
  }
  bulkDelete(e) {
    const n = e.length;
    return this._trans("readwrite", (r) => this.core.mutate({ trans: r, type: "delete", keys: e })).then(({ numFailures: r, lastResult: i, failures: s }) => {
      if (r === 0)
        return i;
      throw new Eo(`${this.name}.bulkDelete(): ${r} of ${n} operations failed`, s);
    });
  }
}
function ko(t) {
  var e = {}, n = function(o, a) {
    if (a) {
      for (var l = arguments.length, u = new Array(l - 1); --l; )
        u[l - 1] = arguments[l];
      return e[o].subscribe.apply(null, u), t;
    }
    if (typeof o == "string")
      return e[o];
  };
  n.addEventType = s;
  for (var r = 1, i = arguments.length; r < i; ++r)
    s(arguments[r]);
  return n;
  function s(o, a, l) {
    if (typeof o != "object") {
      var u;
      a || (a = cB), l || (l = Lt);
      var c = { subscribers: [], fire: l, subscribe: function(d) {
        c.subscribers.indexOf(d) === -1 && (c.subscribers.push(d), c.fire = a(c.fire, d));
      }, unsubscribe: function(d) {
        c.subscribers = c.subscribers.filter(function(h) {
          return h !== d;
        }), c.fire = c.subscribers.reduce(a, l);
      } };
      return e[o] = n[o] = c, c;
    }
    an(u = o).forEach(function(d) {
      var h = u[d];
      if (In(h))
        s(d, u[d][0], u[d][1]);
      else {
        if (h !== "asap")
          throw new Ze.InvalidArgument("Invalid event config");
        var v = s(d, Uo, function() {
          for (var m = arguments.length, b = new Array(m); m--; )
            b[m] = arguments[m];
          v.subscribers.forEach(function(p) {
            ky(function() {
              p.apply(null, b);
            });
          });
        });
      }
    });
  }
}
function oo(t, e) {
  return Is(e).from({ prototype: t }), e;
}
function hs(t, e) {
  return !(t.filter || t.algorithm || t.or) && (e ? t.justLimit : !t.replayFilter);
}
function $u(t, e) {
  t.filter = Yi(t.filter, e);
}
function Ku(t, e, n) {
  var r = t.replayFilter;
  t.replayFilter = r ? () => Yi(r(), e()) : e, t.justLimit = n && !r;
}
function ul(t, e) {
  if (t.isPrimKey)
    return e.primaryKey;
  const n = e.getIndexByKeyPath(t.index);
  if (!n)
    throw new Ze.Schema("KeyPath " + t.index + " on object store " + e.name + " is not indexed");
  return n;
}
function Kp(t, e, n) {
  const r = ul(t, e.schema);
  return e.openCursor({ trans: n, values: !t.keysOnly, reverse: t.dir === "prev", unique: !!t.unique, query: { index: r, range: t.range } });
}
function za(t, e, n, r) {
  const i = t.replayFilter ? Yi(t.filter, t.replayFilter()) : t.filter;
  if (t.or) {
    const s = {}, o = (a, l, u) => {
      if (!i || i(l, u, (h) => l.stop(h), (h) => l.fail(h))) {
        var c = l.primaryKey, d = "" + c;
        d === "[object ArrayBuffer]" && (d = "" + new Uint8Array(c)), Zn(s, d) || (s[d] = !0, e(a, l, u));
      }
    };
    return Promise.all([t.or._iterate(o, n), Gp(Kp(t, r, n), t.algorithm, o, !t.keysOnly && t.valueMapper)]);
  }
  return Gp(Kp(t, r, n), Yi(t.algorithm, i), e, !t.keysOnly && t.valueMapper);
}
function Gp(t, e, n, r) {
  var i = $t(r ? (s, o, a) => n(r(s), o, a) : n);
  return t.then((s) => {
    if (s)
      return s.start(() => {
        var o = () => s.continue();
        e && !e(s, (a) => o = a, (a) => {
          s.stop(a), o = Lt;
        }, (a) => {
          s.fail(a), o = Lt;
        }) || i(s.value, s, (a) => o = a), o();
      });
  });
}
function Rn(t, e) {
  try {
    const n = qp(t), r = qp(e);
    if (n !== r)
      return n === "Array" ? 1 : r === "Array" ? -1 : n === "binary" ? 1 : r === "binary" ? -1 : n === "string" ? 1 : r === "string" ? -1 : n === "Date" ? 1 : r !== "Date" ? NaN : -1;
    switch (n) {
      case "number":
      case "Date":
      case "string":
        return t > e ? 1 : t < e ? -1 : 0;
      case "binary":
        return function(i, s) {
          const o = i.length, a = s.length, l = o < a ? o : a;
          for (let u = 0; u < l; ++u)
            if (i[u] !== s[u])
              return i[u] < s[u] ? -1 : 1;
          return o === a ? 0 : o < a ? -1 : 1;
        }(Jp(t), Jp(e));
      case "Array":
        return function(i, s) {
          const o = i.length, a = s.length, l = o < a ? o : a;
          for (let u = 0; u < l; ++u) {
            const c = Rn(i[u], s[u]);
            if (c !== 0)
              return c;
          }
          return o === a ? 0 : o < a ? -1 : 1;
        }(t, e);
    }
  } catch {
  }
  return NaN;
}
function qp(t) {
  const e = typeof t;
  if (e !== "object")
    return e;
  if (ArrayBuffer.isView(t))
    return "binary";
  const n = Vc(t);
  return n === "ArrayBuffer" ? "binary" : n;
}
function Jp(t) {
  return t instanceof Uint8Array ? t : ArrayBuffer.isView(t) ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : new Uint8Array(t);
}
class wB {
  _read(e, n) {
    var r = this._ctx;
    return r.error ? r.table._trans(null, dn.bind(null, r.error)) : r.table._trans("readonly", e).then(n);
  }
  _write(e) {
    var n = this._ctx;
    return n.error ? n.table._trans(null, dn.bind(null, n.error)) : n.table._trans("readwrite", e, "locked");
  }
  _addAlgorithm(e) {
    var n = this._ctx;
    n.algorithm = Yi(n.algorithm, e);
  }
  _iterate(e, n) {
    return za(this._ctx, e, n, this._ctx.table.core);
  }
  clone(e) {
    var n = Object.create(this.constructor.prototype), r = Object.create(this._ctx);
    return e && Bn(r, e), n._ctx = r, n;
  }
  raw() {
    return this._ctx.valueMapper = null, this;
  }
  each(e) {
    var n = this._ctx;
    return this._read((r) => za(n, e, r, n.table.core));
  }
  count(e) {
    return this._read((n) => {
      const r = this._ctx, i = r.table.core;
      if (hs(r, !0))
        return i.count({ trans: n, query: { index: ul(r, i.schema), range: r.range } }).then((o) => Math.min(o, r.limit));
      var s = 0;
      return za(r, () => (++s, !1), n, i).then(() => s);
    }).then(e);
  }
  sortBy(e, n) {
    const r = e.split(".").reverse(), i = r[0], s = r.length - 1;
    function o(u, c) {
      return c ? o(u[r[c]], c - 1) : u[i];
    }
    var a = this._ctx.dir === "next" ? 1 : -1;
    function l(u, c) {
      var d = o(u, s), h = o(c, s);
      return d < h ? -a : d > h ? a : 0;
    }
    return this.toArray(function(u) {
      return u.sort(l);
    }).then(n);
  }
  toArray(e) {
    return this._read((n) => {
      var r = this._ctx;
      if (r.dir === "next" && hs(r, !0) && r.limit > 0) {
        const { valueMapper: i } = r, s = ul(r, r.table.core.schema);
        return r.table.core.query({ trans: n, limit: r.limit, values: !0, query: { index: s, range: r.range } }).then(({ result: o }) => i ? o.map(i) : o);
      }
      {
        const i = [];
        return za(r, (s) => i.push(s), n, r.table.core).then(() => i);
      }
    }, e);
  }
  offset(e) {
    var n = this._ctx;
    return e <= 0 || (n.offset += e, hs(n) ? Ku(n, () => {
      var r = e;
      return (i, s) => r === 0 || (r === 1 ? (--r, !1) : (s(() => {
        i.advance(r), r = 0;
      }), !1));
    }) : Ku(n, () => {
      var r = e;
      return () => --r < 0;
    })), this;
  }
  limit(e) {
    return this._ctx.limit = Math.min(this._ctx.limit, e), Ku(this._ctx, () => {
      var n = e;
      return function(r, i, s) {
        return --n <= 0 && i(s), n >= 0;
      };
    }, !0), this;
  }
  until(e, n) {
    return $u(this._ctx, function(r, i, s) {
      return !e(r.value) || (i(s), n);
    }), this;
  }
  first(e) {
    return this.limit(1).toArray(function(n) {
      return n[0];
    }).then(e);
  }
  last(e) {
    return this.reverse().first(e);
  }
  filter(e) {
    var n, r;
    return $u(this._ctx, function(i) {
      return e(i.value);
    }), n = this._ctx, r = e, n.isMatch = Yi(n.isMatch, r), this;
  }
  and(e) {
    return this.filter(e);
  }
  or(e) {
    return new this.db.WhereClause(this._ctx.table, e, this);
  }
  reverse() {
    return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
  }
  desc() {
    return this.reverse();
  }
  eachKey(e) {
    var n = this._ctx;
    return n.keysOnly = !n.isMatch, this.each(function(r, i) {
      e(i.key, i);
    });
  }
  eachUniqueKey(e) {
    return this._ctx.unique = "unique", this.eachKey(e);
  }
  eachPrimaryKey(e) {
    var n = this._ctx;
    return n.keysOnly = !n.isMatch, this.each(function(r, i) {
      e(i.primaryKey, i);
    });
  }
  keys(e) {
    var n = this._ctx;
    n.keysOnly = !n.isMatch;
    var r = [];
    return this.each(function(i, s) {
      r.push(s.key);
    }).then(function() {
      return r;
    }).then(e);
  }
  primaryKeys(e) {
    var n = this._ctx;
    if (n.dir === "next" && hs(n, !0) && n.limit > 0)
      return this._read((i) => {
        var s = ul(n, n.table.core.schema);
        return n.table.core.query({ trans: i, values: !1, limit: n.limit, query: { index: s, range: n.range } });
      }).then(({ result: i }) => i).then(e);
    n.keysOnly = !n.isMatch;
    var r = [];
    return this.each(function(i, s) {
      r.push(s.primaryKey);
    }).then(function() {
      return r;
    }).then(e);
  }
  uniqueKeys(e) {
    return this._ctx.unique = "unique", this.keys(e);
  }
  firstKey(e) {
    return this.limit(1).keys(function(n) {
      return n[0];
    }).then(e);
  }
  lastKey(e) {
    return this.reverse().firstKey(e);
  }
  distinct() {
    var e = this._ctx, n = e.index && e.table.schema.idxByName[e.index];
    if (!n || !n.multi)
      return this;
    var r = {};
    return $u(this._ctx, function(i) {
      var s = i.primaryKey.toString(), o = Zn(r, s);
      return r[s] = !0, !o;
    }), this;
  }
  modify(e) {
    var n = this._ctx;
    return this._write((r) => {
      var i;
      if (typeof e == "function")
        i = e;
      else {
        var s = an(e), o = s.length;
        i = function(b) {
          for (var p = !1, f = 0; f < o; ++f) {
            var g = s[f], y = e[g];
            ei(b, g) !== y && (br(b, g, y), p = !0);
          }
          return p;
        };
      }
      const a = n.table.core, { outbound: l, extractKey: u } = a.schema.primaryKey, c = this.db._options.modifyChunkSize || 200, d = [];
      let h = 0;
      const v = [], m = (b, p) => {
        const { failures: f, numFailures: g } = p;
        h += b - g;
        for (let y of an(f))
          d.push(f[y]);
      };
      return this.clone().primaryKeys().then((b) => {
        const p = (f) => {
          const g = Math.min(c, b.length - f);
          return a.getMany({ trans: r, keys: b.slice(f, f + g), cache: "immutable" }).then((y) => {
            const w = [], _ = [], S = l ? [] : null, A = [];
            for (let k = 0; k < g; ++k) {
              const O = y[k], N = { value: fa(O), primKey: b[f + k] };
              i.call(N, N.value, N) !== !1 && (N.value == null ? A.push(b[f + k]) : l || Rn(u(O), u(N.value)) === 0 ? (_.push(N.value), l && S.push(b[f + k])) : (A.push(b[f + k]), w.push(N.value)));
            }
            const C = hs(n) && n.limit === 1 / 0 && (typeof e != "function" || e === Gu) && { index: n.index, range: n.range };
            return Promise.resolve(w.length > 0 && a.mutate({ trans: r, type: "add", values: w }).then((k) => {
              for (let O in k.failures)
                A.splice(parseInt(O), 1);
              m(w.length, k);
            })).then(() => (_.length > 0 || C && typeof e == "object") && a.mutate({ trans: r, type: "put", keys: S, values: _, criteria: C, changeSpec: typeof e != "function" && e }).then((k) => m(_.length, k))).then(() => (A.length > 0 || C && e === Gu) && a.mutate({ trans: r, type: "delete", keys: A, criteria: C }).then((k) => m(A.length, k))).then(() => b.length > f + g && p(f + c));
          });
        };
        return p(0).then(() => {
          if (d.length > 0)
            throw new Cl("Error modifying one or more objects", d, h, v);
          return b.length;
        });
      });
    });
  }
  delete() {
    var e = this._ctx, n = e.range;
    return hs(e) && (e.isPrimKey && !yB || n.type === 3) ? this._write((r) => {
      const { primaryKey: i } = e.table.core.schema, s = n;
      return e.table.core.count({ trans: r, query: { index: i, range: s } }).then((o) => e.table.core.mutate({ trans: r, type: "deleteRange", range: s }).then(({ failures: a, lastResult: l, results: u, numFailures: c }) => {
        if (c)
          throw new Cl("Could not delete some values", Object.keys(a).map((d) => a[d]), o - c);
        return o - c;
      }));
    }) : this.modify(Gu);
  }
}
const Gu = (t, e) => e.value = null;
function _B(t, e) {
  return t < e ? -1 : t === e ? 0 : 1;
}
function SB(t, e) {
  return t > e ? -1 : t === e ? 0 : 1;
}
function Gn(t, e, n) {
  var r = t instanceof qy ? new t.Collection(t) : t;
  return r._ctx.error = n ? new n(e) : new TypeError(e), r;
}
function ps(t) {
  return new t.Collection(t, () => Gy("")).limit(0);
}
function EB(t, e, n, r, i, s) {
  for (var o = Math.min(t.length, r.length), a = -1, l = 0; l < o; ++l) {
    var u = e[l];
    if (u !== r[l])
      return i(t[l], n[l]) < 0 ? t.substr(0, l) + n[l] + n.substr(l + 1) : i(t[l], r[l]) < 0 ? t.substr(0, l) + r[l] + n.substr(l + 1) : a >= 0 ? t.substr(0, a) + e[a] + n.substr(a + 1) : null;
    i(t[l], u) < 0 && (a = l);
  }
  return o < r.length && s === "next" ? t + n.substr(t.length) : o < t.length && s === "prev" ? t.substr(0, n.length) : a < 0 ? null : t.substr(0, a) + r[a] + n.substr(a + 1);
}
function ja(t, e, n, r) {
  var i, s, o, a, l, u, c, d = n.length;
  if (!n.every((b) => typeof b == "string"))
    return Gn(t, Wy);
  function h(b) {
    i = function(f) {
      return f === "next" ? (g) => g.toUpperCase() : (g) => g.toLowerCase();
    }(b), s = function(f) {
      return f === "next" ? (g) => g.toLowerCase() : (g) => g.toUpperCase();
    }(b), o = b === "next" ? _B : SB;
    var p = n.map(function(f) {
      return { lower: s(f), upper: i(f) };
    }).sort(function(f, g) {
      return o(f.lower, g.lower);
    });
    a = p.map(function(f) {
      return f.upper;
    }), l = p.map(function(f) {
      return f.lower;
    }), u = b, c = b === "next" ? "" : r;
  }
  h("next");
  var v = new t.Collection(t, () => mi(a[0], l[d - 1] + r));
  v._ondirectionchange = function(b) {
    h(b);
  };
  var m = 0;
  return v._addAlgorithm(function(b, p, f) {
    var g = b.key;
    if (typeof g != "string")
      return !1;
    var y = s(g);
    if (e(y, l, m))
      return !0;
    for (var w = null, _ = m; _ < d; ++_) {
      var S = EB(g, y, a[_], l[_], o, u);
      S === null && w === null ? m = _ + 1 : (w === null || o(w, S) > 0) && (w = S);
    }
    return p(w !== null ? function() {
      b.continue(w + c);
    } : f), !1;
  }), v;
}
function mi(t, e, n, r) {
  return { type: 2, lower: t, upper: e, lowerOpen: n, upperOpen: r };
}
function Gy(t) {
  return { type: 1, lower: t, upper: t };
}
class qy {
  get Collection() {
    return this._ctx.table.db.Collection;
  }
  between(e, n, r, i) {
    r = r !== !1, i = i === !0;
    try {
      return this._cmp(e, n) > 0 || this._cmp(e, n) === 0 && (r || i) && (!r || !i) ? ps(this) : new this.Collection(this, () => mi(e, n, !r, !i));
    } catch {
      return Gn(this, Kr);
    }
  }
  equals(e) {
    return e == null ? Gn(this, Kr) : new this.Collection(this, () => Gy(e));
  }
  above(e) {
    return e == null ? Gn(this, Kr) : new this.Collection(this, () => mi(e, void 0, !0));
  }
  aboveOrEqual(e) {
    return e == null ? Gn(this, Kr) : new this.Collection(this, () => mi(e, void 0, !1));
  }
  below(e) {
    return e == null ? Gn(this, Kr) : new this.Collection(this, () => mi(void 0, e, !1, !0));
  }
  belowOrEqual(e) {
    return e == null ? Gn(this, Kr) : new this.Collection(this, () => mi(void 0, e));
  }
  startsWith(e) {
    return typeof e != "string" ? Gn(this, Wy) : this.between(e, e + ji, !0, !0);
  }
  startsWithIgnoreCase(e) {
    return e === "" ? this.startsWith(e) : ja(this, (n, r) => n.indexOf(r[0]) === 0, [e], ji);
  }
  equalsIgnoreCase(e) {
    return ja(this, (n, r) => n === r[0], [e], "");
  }
  anyOfIgnoreCase() {
    var e = Yr.apply(Ss, arguments);
    return e.length === 0 ? ps(this) : ja(this, (n, r) => r.indexOf(n) !== -1, e, "");
  }
  startsWithAnyOfIgnoreCase() {
    var e = Yr.apply(Ss, arguments);
    return e.length === 0 ? ps(this) : ja(this, (n, r) => r.some((i) => n.indexOf(i) === 0), e, ji);
  }
  anyOf() {
    const e = Yr.apply(Ss, arguments);
    let n = this._cmp;
    try {
      e.sort(n);
    } catch {
      return Gn(this, Kr);
    }
    if (e.length === 0)
      return ps(this);
    const r = new this.Collection(this, () => mi(e[0], e[e.length - 1]));
    r._ondirectionchange = (s) => {
      n = s === "next" ? this._ascending : this._descending, e.sort(n);
    };
    let i = 0;
    return r._addAlgorithm((s, o, a) => {
      const l = s.key;
      for (; n(l, e[i]) > 0; )
        if (++i, i === e.length)
          return o(a), !1;
      return n(l, e[i]) === 0 || (o(() => {
        s.continue(e[i]);
      }), !1);
    }), r;
  }
  notEqual(e) {
    return this.inAnyRange([[td, e], [e, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
  }
  noneOf() {
    const e = Yr.apply(Ss, arguments);
    if (e.length === 0)
      return new this.Collection(this);
    try {
      e.sort(this._ascending);
    } catch {
      return Gn(this, Kr);
    }
    const n = e.reduce((r, i) => r ? r.concat([[r[r.length - 1][1], i]]) : [[td, i]], null);
    return n.push([e[e.length - 1], this.db._maxKey]), this.inAnyRange(n, { includeLowers: !1, includeUppers: !1 });
  }
  inAnyRange(e, n) {
    const r = this._cmp, i = this._ascending, s = this._descending, o = this._min, a = this._max;
    if (e.length === 0)
      return ps(this);
    if (!e.every((g) => g[0] !== void 0 && g[1] !== void 0 && i(g[0], g[1]) <= 0))
      return Gn(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", Ze.InvalidArgument);
    const l = !n || n.includeLowers !== !1, u = n && n.includeUppers === !0;
    let c, d = i;
    function h(g, y) {
      return d(g[0], y[0]);
    }
    try {
      c = e.reduce(function(g, y) {
        let w = 0, _ = g.length;
        for (; w < _; ++w) {
          const S = g[w];
          if (r(y[0], S[1]) < 0 && r(y[1], S[0]) > 0) {
            S[0] = o(S[0], y[0]), S[1] = a(S[1], y[1]);
            break;
          }
        }
        return w === _ && g.push(y), g;
      }, []), c.sort(h);
    } catch {
      return Gn(this, Kr);
    }
    let v = 0;
    const m = u ? (g) => i(g, c[v][1]) > 0 : (g) => i(g, c[v][1]) >= 0, b = l ? (g) => s(g, c[v][0]) > 0 : (g) => s(g, c[v][0]) >= 0;
    let p = m;
    const f = new this.Collection(this, () => mi(c[0][0], c[c.length - 1][1], !l, !u));
    return f._ondirectionchange = (g) => {
      g === "next" ? (p = m, d = i) : (p = b, d = s), c.sort(h);
    }, f._addAlgorithm((g, y, w) => {
      for (var _ = g.key; p(_); )
        if (++v, v === c.length)
          return y(w), !1;
      return !!function(S) {
        return !m(S) && !b(S);
      }(_) || (this._cmp(_, c[v][1]) === 0 || this._cmp(_, c[v][0]) === 0 || y(() => {
        d === i ? g.continue(c[v][0]) : g.continue(c[v][1]);
      }), !1);
    }), f;
  }
  startsWithAnyOf() {
    const e = Yr.apply(Ss, arguments);
    return e.every((n) => typeof n == "string") ? e.length === 0 ? ps(this) : this.inAnyRange(e.map((n) => [n, n + ji])) : Gn(this, "startsWithAnyOf() only works with strings");
  }
}
function kr(t) {
  return $t(function(e) {
    return Wo(e), t(e.target.error), !1;
  });
}
function Wo(t) {
  t.stopPropagation && t.stopPropagation(), t.preventDefault && t.preventDefault();
}
const $o = "storagemutated", bi = "x-storagemutated-1", Ci = ko(null, $o);
class xB {
  _lock() {
    return po(!Ke.global), ++this._reculock, this._reculock !== 1 || Ke.global || (Ke.lockOwnerFor = this), this;
  }
  _unlock() {
    if (po(!Ke.global), --this._reculock == 0)
      for (Ke.global || (Ke.lockOwnerFor = null); this._blockedFuncs.length > 0 && !this._locked(); ) {
        var e = this._blockedFuncs.shift();
        try {
          Zs(e[1], e[0]);
        } catch {
        }
      }
    return this;
  }
  _locked() {
    return this._reculock && Ke.lockOwnerFor !== this;
  }
  create(e) {
    if (!this.mode)
      return this;
    const n = this.db.idbdb, r = this.db._state.dbOpenError;
    if (po(!this.idbtrans), !e && !n)
      switch (r && r.name) {
        case "DatabaseClosedError":
          throw new Ze.DatabaseClosed(r);
        case "MissingAPIError":
          throw new Ze.MissingAPI(r.message, r);
        default:
          throw new Ze.OpenFailed(r);
      }
    if (!this.active)
      throw new Ze.TransactionInactive();
    return po(this._completion._state === null), (e = this.idbtrans = e || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : n.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }))).onerror = $t((i) => {
      Wo(i), this._reject(e.error);
    }), e.onabort = $t((i) => {
      Wo(i), this.active && this._reject(new Ze.Abort(e.error)), this.active = !1, this.on("abort").fire(i);
    }), e.oncomplete = $t(() => {
      this.active = !1, this._resolve(), "mutatedParts" in e && Ci.storagemutated.fire(e.mutatedParts);
    }), this;
  }
  _promise(e, n, r) {
    if (e === "readwrite" && this.mode !== "readwrite")
      return dn(new Ze.ReadOnly("Transaction is readonly"));
    if (!this.active)
      return dn(new Ze.TransactionInactive());
    if (this._locked())
      return new Le((s, o) => {
        this._blockedFuncs.push([() => {
          this._promise(e, n, r).then(s, o);
        }, Ke]);
      });
    if (r)
      return Ai(() => {
        var s = new Le((o, a) => {
          this._lock();
          const l = n(o, a, this);
          l && l.then && l.then(o, a);
        });
        return s.finally(() => this._unlock()), s._lib = !0, s;
      });
    var i = new Le((s, o) => {
      var a = n(s, o, this);
      a && a.then && a.then(s, o);
    });
    return i._lib = !0, i;
  }
  _root() {
    return this.parent ? this.parent._root() : this;
  }
  waitFor(e) {
    var n = this._root();
    const r = Le.resolve(e);
    if (n._waitingFor)
      n._waitingFor = n._waitingFor.then(() => r);
    else {
      n._waitingFor = r, n._waitingQueue = [];
      var i = n.idbtrans.objectStore(n.storeNames[0]);
      (function o() {
        for (++n._spinCount; n._waitingQueue.length; )
          n._waitingQueue.shift()();
        n._waitingFor && (i.get(-1 / 0).onsuccess = o);
      })();
    }
    var s = n._waitingFor;
    return new Le((o, a) => {
      r.then((l) => n._waitingQueue.push($t(o.bind(null, l))), (l) => n._waitingQueue.push($t(a.bind(null, l)))).finally(() => {
        n._waitingFor === s && (n._waitingFor = null);
      });
    });
  }
  abort() {
    this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new Ze.Abort()));
  }
  table(e) {
    const n = this._memoizedTables || (this._memoizedTables = {});
    if (Zn(n, e))
      return n[e];
    const r = this.schema[e];
    if (!r)
      throw new Ze.NotFound("Table " + e + " not part of transaction");
    const i = new this.db.Table(e, r, this);
    return i.core = this.db.core.table(e), n[e] = i, i;
  }
}
function nd(t, e, n, r, i, s, o) {
  return { name: t, keyPath: e, unique: n, multi: r, auto: i, compound: s, src: (n && !o ? "&" : "") + (r ? "*" : "") + (i ? "++" : "") + Jy(e) };
}
function Jy(t) {
  return typeof t == "string" ? t : t ? "[" + [].join.call(t, "+") + "]" : "";
}
function Yy(t, e, n) {
  return { name: t, primKey: e, indexes: n, mappedClass: null, idxByName: Cy(n, (r) => [r.name, r]) };
}
let Ko = (t) => {
  try {
    return t.only([[]]), Ko = () => [[]], [[]];
  } catch {
    return Ko = () => ji, ji;
  }
};
function rd(t) {
  return t == null ? () => {
  } : typeof t == "string" ? function(e) {
    return e.split(".").length === 1 ? (r) => r[e] : (r) => ei(r, e);
  }(t) : (e) => ei(e, t);
}
function Yp(t) {
  return [].slice.call(t);
}
let AB = 0;
function Co(t) {
  return t == null ? ":id" : typeof t == "string" ? t : `[${t.join("+")}]`;
}
function kB(t, e, n) {
  function r(l) {
    if (l.type === 3)
      return null;
    if (l.type === 4)
      throw new Error("Cannot convert never type to IDBKeyRange");
    const { lower: u, upper: c, lowerOpen: d, upperOpen: h } = l;
    return u === void 0 ? c === void 0 ? null : e.upperBound(c, !!h) : c === void 0 ? e.lowerBound(u, !!d) : e.bound(u, c, !!d, !!h);
  }
  const { schema: i, hasGetAll: s } = function(l, u) {
    const c = Yp(l.objectStoreNames);
    return { schema: { name: l.name, tables: c.map((d) => u.objectStore(d)).map((d) => {
      const { keyPath: h, autoIncrement: v } = d, m = In(h), b = h == null, p = {}, f = { name: d.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: b, compound: m, keyPath: h, autoIncrement: v, unique: !0, extractKey: rd(h) }, indexes: Yp(d.indexNames).map((g) => d.index(g)).map((g) => {
        const { name: y, unique: w, multiEntry: _, keyPath: S } = g, A = { name: y, compound: In(S), keyPath: S, unique: w, multiEntry: _, extractKey: rd(S) };
        return p[Co(S)] = A, A;
      }), getIndexByKeyPath: (g) => p[Co(g)] };
      return p[":id"] = f.primaryKey, h != null && (p[Co(h)] = f.primaryKey), f;
    }) }, hasGetAll: c.length > 0 && "getAll" in u.objectStore(c[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) };
  }(t, n), o = i.tables.map((l) => function(u) {
    const c = u.name;
    return { name: c, schema: u, mutate: function({ trans: d, type: h, keys: v, values: m, range: b }) {
      return new Promise((p, f) => {
        p = $t(p);
        const g = d.objectStore(c), y = g.keyPath == null, w = h === "put" || h === "add";
        if (!w && h !== "delete" && h !== "deleteRange")
          throw new Error("Invalid operation type: " + h);
        const { length: _ } = v || m || { length: 1 };
        if (v && m && v.length !== m.length)
          throw new Error("Given keys array must have same length as given values array.");
        if (_ === 0)
          return p({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
        let S;
        const A = [], C = [];
        let k = 0;
        const O = (B) => {
          ++k, Wo(B);
        };
        if (h === "deleteRange") {
          if (b.type === 4)
            return p({ numFailures: k, failures: C, results: [], lastResult: void 0 });
          b.type === 3 ? A.push(S = g.clear()) : A.push(S = g.delete(r(b)));
        } else {
          const [B, D] = w ? y ? [m, v] : [m, null] : [v, null];
          if (w)
            for (let F = 0; F < _; ++F)
              A.push(S = D && D[F] !== void 0 ? g[h](B[F], D[F]) : g[h](B[F])), S.onerror = O;
          else
            for (let F = 0; F < _; ++F)
              A.push(S = g[h](B[F])), S.onerror = O;
        }
        const N = (B) => {
          const D = B.target.result;
          A.forEach((F, Z) => F.error != null && (C[Z] = F.error)), p({ numFailures: k, failures: C, results: h === "delete" ? v : A.map((F) => F.result), lastResult: D });
        };
        S.onerror = (B) => {
          O(B), N(B);
        }, S.onsuccess = N;
      });
    }, getMany: ({ trans: d, keys: h }) => new Promise((v, m) => {
      v = $t(v);
      const b = d.objectStore(c), p = h.length, f = new Array(p);
      let g, y = 0, w = 0;
      const _ = (A) => {
        const C = A.target;
        f[C._pos] = C.result, ++w === y && v(f);
      }, S = kr(m);
      for (let A = 0; A < p; ++A)
        h[A] != null && (g = b.get(h[A]), g._pos = A, g.onsuccess = _, g.onerror = S, ++y);
      y === 0 && v(f);
    }), get: ({ trans: d, key: h }) => new Promise((v, m) => {
      v = $t(v);
      const b = d.objectStore(c).get(h);
      b.onsuccess = (p) => v(p.target.result), b.onerror = kr(m);
    }), query: function(d) {
      return (h) => new Promise((v, m) => {
        v = $t(v);
        const { trans: b, values: p, limit: f, query: g } = h, y = f === 1 / 0 ? void 0 : f, { index: w, range: _ } = g, S = b.objectStore(c), A = w.isPrimaryKey ? S : S.index(w.name), C = r(_);
        if (f === 0)
          return v({ result: [] });
        if (d) {
          const k = p ? A.getAll(C, y) : A.getAllKeys(C, y);
          k.onsuccess = (O) => v({ result: O.target.result }), k.onerror = kr(m);
        } else {
          let k = 0;
          const O = p || !("openKeyCursor" in A) ? A.openCursor(C) : A.openKeyCursor(C), N = [];
          O.onsuccess = (B) => {
            const D = O.result;
            return D ? (N.push(p ? D.value : D.primaryKey), ++k === f ? v({ result: N }) : void D.continue()) : v({ result: N });
          }, O.onerror = kr(m);
        }
      });
    }(s), openCursor: function({ trans: d, values: h, query: v, reverse: m, unique: b }) {
      return new Promise((p, f) => {
        p = $t(p);
        const { index: g, range: y } = v, w = d.objectStore(c), _ = g.isPrimaryKey ? w : w.index(g.name), S = m ? b ? "prevunique" : "prev" : b ? "nextunique" : "next", A = h || !("openKeyCursor" in _) ? _.openCursor(r(y), S) : _.openKeyCursor(r(y), S);
        A.onerror = kr(f), A.onsuccess = $t((C) => {
          const k = A.result;
          if (!k)
            return void p(null);
          k.___id = ++AB, k.done = !1;
          const O = k.continue.bind(k);
          let N = k.continuePrimaryKey;
          N && (N = N.bind(k));
          const B = k.advance.bind(k), D = () => {
            throw new Error("Cursor not stopped");
          };
          k.trans = d, k.stop = k.continue = k.continuePrimaryKey = k.advance = () => {
            throw new Error("Cursor not started");
          }, k.fail = $t(f), k.next = function() {
            let F = 1;
            return this.start(() => F-- ? this.continue() : this.stop()).then(() => this);
          }, k.start = (F) => {
            const Z = new Promise((L, V) => {
              L = $t(L), A.onerror = kr(V), k.fail = V, k.stop = (H) => {
                k.stop = k.continue = k.continuePrimaryKey = k.advance = D, L(H);
              };
            }), te = () => {
              if (A.result)
                try {
                  F();
                } catch (L) {
                  k.fail(L);
                }
              else
                k.done = !0, k.start = () => {
                  throw new Error("Cursor behind last entry");
                }, k.stop();
            };
            return A.onsuccess = $t((L) => {
              A.onsuccess = te, te();
            }), k.continue = O, k.continuePrimaryKey = N, k.advance = B, te(), Z;
          }, p(k);
        }, f);
      });
    }, count({ query: d, trans: h }) {
      const { index: v, range: m } = d;
      return new Promise((b, p) => {
        const f = h.objectStore(c), g = v.isPrimaryKey ? f : f.index(v.name), y = r(m), w = y ? g.count(y) : g.count();
        w.onsuccess = $t((_) => b(_.target.result)), w.onerror = kr(p);
      });
    } };
  }(l)), a = {};
  return o.forEach((l) => a[l.name] = l), { stack: "dbcore", transaction: t.transaction.bind(t), table(l) {
    if (!a[l])
      throw new Error(`Table '${l}' not found`);
    return a[l];
  }, MIN_KEY: -1 / 0, MAX_KEY: Ko(e), schema: i };
}
function id({ _novip: t }, e) {
  const n = e.db, r = function(i, s, { IDBKeyRange: o, indexedDB: a }, l) {
    return { dbcore: function(c, d) {
      return d.reduce((h, { create: v }) => ({ ...h, ...v(h) }), c);
    }(kB(s, o, l), i.dbcore) };
  }(t._middlewares, n, t._deps, e);
  t.core = r.dbcore, t.tables.forEach((i) => {
    const s = i.name;
    t.core.schema.tables.some((o) => o.name === s) && (i.core = t.core.table(s), t[s] instanceof t.Table && (t[s].core = i.core));
  });
}
function Rl({ _novip: t }, e, n, r) {
  n.forEach((i) => {
    const s = r[i];
    e.forEach((o) => {
      const a = bf(o, i);
      (!a || "value" in a && a.value === void 0) && (o === t.Transaction.prototype || o instanceof t.Transaction ? Xr(o, i, { get() {
        return this.table(i);
      }, set(l) {
        xy(this, i, { value: l, writable: !0, configurable: !0, enumerable: !0 });
      } }) : o[i] = new t.Table(i, s));
    });
  });
}
function sd({ _novip: t }, e) {
  e.forEach((n) => {
    for (let r in n)
      n[r] instanceof t.Table && delete n[r];
  });
}
function CB(t, e) {
  return t._cfg.version - e._cfg.version;
}
function TB(t, e, n, r) {
  const i = t._dbSchema, s = t._createTransaction("readwrite", t._storeNames, i);
  s.create(n), s._completion.catch(r);
  const o = s._reject.bind(s), a = Ke.transless || Ke;
  Ai(() => {
    Ke.trans = s, Ke.transless = a, e === 0 ? (an(i).forEach((l) => {
      qu(n, l, i[l].primKey, i[l].indexes);
    }), id(t, n), Le.follow(() => t.on.populate.fire(s)).catch(o)) : function({ _novip: l }, u, c, d) {
      const h = [], v = l._versions;
      let m = l._dbSchema = ad(l, l.idbdb, d), b = !1;
      const p = v.filter((g) => g._cfg.version >= u);
      function f() {
        return h.length ? Le.resolve(h.shift()(c.idbtrans)).then(f) : Le.resolve();
      }
      return p.forEach((g) => {
        h.push(() => {
          const y = m, w = g._cfg.dbschema;
          ld(l, y, d), ld(l, w, d), m = l._dbSchema = w;
          const _ = Qy(y, w);
          _.add.forEach((A) => {
            qu(d, A[0], A[1].primKey, A[1].indexes);
          }), _.change.forEach((A) => {
            if (A.recreate)
              throw new Ze.Upgrade("Not yet support for changing primary key");
            {
              const C = d.objectStore(A.name);
              A.add.forEach((k) => od(C, k)), A.change.forEach((k) => {
                C.deleteIndex(k.name), od(C, k);
              }), A.del.forEach((k) => C.deleteIndex(k));
            }
          });
          const S = g._cfg.contentUpgrade;
          if (S && g._cfg.version > u) {
            id(l, d), c._memoizedTables = {}, b = !0;
            let A = Ty(w);
            _.del.forEach((N) => {
              A[N] = y[N];
            }), sd(l, [l.Transaction.prototype]), Rl(l, [l.Transaction.prototype], an(A), A), c.schema = A;
            const C = wf(S);
            let k;
            C && Qs();
            const O = Le.follow(() => {
              if (k = S(c), k && C) {
                var N = si.bind(null, null);
                k.then(N, N);
              }
            });
            return k && typeof k.then == "function" ? Le.resolve(k) : O.then(() => k);
          }
        }), h.push((y) => {
          (!b || !mB) && function(w, _) {
            [].slice.call(_.db.objectStoreNames).forEach((S) => w[S] == null && _.db.deleteObjectStore(S));
          }(g._cfg.dbschema, y), sd(l, [l.Transaction.prototype]), Rl(l, [l.Transaction.prototype], l._storeNames, l._dbSchema), c.schema = l._dbSchema;
        });
      }), f().then(() => {
        var g, y;
        y = d, an(g = m).forEach((w) => {
          y.db.objectStoreNames.contains(w) || qu(y, w, g[w].primKey, g[w].indexes);
        });
      });
    }(t, e, s, n).catch(o);
  });
}
function Qy(t, e) {
  const n = { del: [], add: [], change: [] };
  let r;
  for (r in t)
    e[r] || n.del.push(r);
  for (r in e) {
    const i = t[r], s = e[r];
    if (i) {
      const o = { name: r, def: s, recreate: !1, del: [], add: [], change: [] };
      if ("" + (i.primKey.keyPath || "") != "" + (s.primKey.keyPath || "") || i.primKey.auto !== s.primKey.auto && !hu)
        o.recreate = !0, n.change.push(o);
      else {
        const a = i.idxByName, l = s.idxByName;
        let u;
        for (u in a)
          l[u] || o.del.push(u);
        for (u in l) {
          const c = a[u], d = l[u];
          c ? c.src !== d.src && o.change.push(d) : o.add.push(d);
        }
        (o.del.length > 0 || o.add.length > 0 || o.change.length > 0) && n.change.push(o);
      }
    } else
      n.add.push([r, s]);
  }
  return n;
}
function qu(t, e, n, r) {
  const i = t.db.createObjectStore(e, n.keyPath ? { keyPath: n.keyPath, autoIncrement: n.auto } : { autoIncrement: n.auto });
  return r.forEach((s) => od(i, s)), i;
}
function od(t, e) {
  t.createIndex(e.name, e.keyPath, { unique: e.unique, multiEntry: e.multi });
}
function ad(t, e, n) {
  const r = {};
  return kl(e.objectStoreNames, 0).forEach((i) => {
    const s = n.objectStore(i);
    let o = s.keyPath;
    const a = nd(Jy(o), o || "", !1, !1, !!s.autoIncrement, o && typeof o != "string", !0), l = [];
    for (let c = 0; c < s.indexNames.length; ++c) {
      const d = s.index(s.indexNames[c]);
      o = d.keyPath;
      var u = nd(d.name, o, !!d.unique, !!d.multiEntry, !1, o && typeof o != "string", !1);
      l.push(u);
    }
    r[i] = Yy(i, a, l);
  }), r;
}
function ld({ _novip: t }, e, n) {
  const r = n.db.objectStoreNames;
  for (let i = 0; i < r.length; ++i) {
    const s = r[i], o = n.objectStore(s);
    t._hasGetAll = "getAll" in o;
    for (let a = 0; a < o.indexNames.length; ++a) {
      const l = o.indexNames[a], u = o.index(l).keyPath, c = typeof u == "string" ? u : "[" + kl(u).join("+") + "]";
      if (e[s]) {
        const d = e[s].idxByName[c];
        d && (d.name = l, delete e[s].idxByName[c], e[s].idxByName[l] = d);
      }
    }
  }
  typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && Ut.WorkerGlobalScope && Ut instanceof Ut.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (t._hasGetAll = !1);
}
class OB {
  _parseStoresSpec(e, n) {
    an(e).forEach((r) => {
      if (e[r] !== null) {
        var i = e[r].split(",").map((o, a) => {
          const l = (o = o.trim()).replace(/([&*]|\+\+)/g, ""), u = /^\[/.test(l) ? l.match(/^\[(.*)\]$/)[1].split("+") : l;
          return nd(l, u || null, /\&/.test(o), /\*/.test(o), /\+\+/.test(o), In(u), a === 0);
        }), s = i.shift();
        if (s.multi)
          throw new Ze.Schema("Primary key cannot be multi-valued");
        i.forEach((o) => {
          if (o.auto)
            throw new Ze.Schema("Only primary key can be marked as autoIncrement (++)");
          if (!o.keyPath)
            throw new Ze.Schema("Index must have a name and cannot be an empty string");
        }), n[r] = Yy(r, s, i);
      }
    });
  }
  stores(e) {
    const n = this.db;
    this._cfg.storesSource = this._cfg.storesSource ? Bn(this._cfg.storesSource, e) : e;
    const r = n._versions, i = {};
    let s = {};
    return r.forEach((o) => {
      Bn(i, o._cfg.storesSource), s = o._cfg.dbschema = {}, o._parseStoresSpec(i, s);
    }), n._dbSchema = s, sd(n, [n._allTables, n, n.Transaction.prototype]), Rl(n, [n._allTables, n, n.Transaction.prototype, this._cfg.tables], an(s), s), n._storeNames = an(s), this;
  }
  upgrade(e) {
    return this._cfg.contentUpgrade = Ef(this._cfg.contentUpgrade || Lt, e), this;
  }
}
function Cf(t, e) {
  let n = t._dbNamesDB;
  return n || (n = t._dbNamesDB = new Wi(pu, { addons: [], indexedDB: t, IDBKeyRange: e }), n.version(1).stores({ dbnames: "name" })), n.table("dbnames");
}
function Tf(t) {
  return t && typeof t.databases == "function";
}
function ud(t) {
  return Ai(function() {
    return Ke.letThrough = !0, t();
  });
}
function IB() {
  var t;
  return !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(e) {
    var n = function() {
      return indexedDB.databases().finally(e);
    };
    t = setInterval(n, 100), n();
  }).finally(function() {
    return clearInterval(t);
  }) : Promise.resolve();
}
function NB(t) {
  const e = t._state, { indexedDB: n } = t._deps;
  if (e.isBeingOpened || t.idbdb)
    return e.dbReadyPromise.then(() => e.dbOpenError ? dn(e.dbOpenError) : t);
  Ur && (e.openCanceller._stackHolder = ss()), e.isBeingOpened = !0, e.dbOpenError = null, e.openComplete = !1;
  const r = e.openCanceller;
  function i() {
    if (e.openCanceller !== r)
      throw new Ze.DatabaseClosed("db.open() was cancelled");
  }
  let s = e.dbReadyResolve, o = null, a = !1;
  return Le.race([r, (typeof navigator > "u" ? Le.resolve() : IB()).then(() => new Le((l, u) => {
    if (i(), !n)
      throw new Ze.MissingAPI();
    const c = t.name, d = e.autoSchema ? n.open(c) : n.open(c, Math.round(10 * t.verno));
    if (!d)
      throw new Ze.MissingAPI();
    d.onerror = kr(u), d.onblocked = $t(t._fireOnBlocked), d.onupgradeneeded = $t((h) => {
      if (o = d.transaction, e.autoSchema && !t._options.allowEmptyDB) {
        d.onerror = Wo, o.abort(), d.result.close();
        const m = n.deleteDatabase(c);
        m.onsuccess = m.onerror = $t(() => {
          u(new Ze.NoSuchDatabase(`Database ${c} doesnt exist`));
        });
      } else {
        o.onerror = kr(u);
        var v = h.oldVersion > Math.pow(2, 62) ? 0 : h.oldVersion;
        a = v < 1, t._novip.idbdb = d.result, TB(t, v / 10, o, u);
      }
    }, u), d.onsuccess = $t(() => {
      o = null;
      const h = t._novip.idbdb = d.result, v = kl(h.objectStoreNames);
      if (v.length > 0)
        try {
          const b = h.transaction((m = v).length === 1 ? m[0] : m, "readonly");
          e.autoSchema ? function({ _novip: p }, f, g) {
            p.verno = f.version / 10;
            const y = p._dbSchema = ad(0, f, g);
            p._storeNames = kl(f.objectStoreNames, 0), Rl(p, [p._allTables], an(y), y);
          }(t, h, b) : (ld(t, t._dbSchema, b), function(p, f) {
            const g = Qy(ad(0, p.idbdb, f), p._dbSchema);
            return !(g.add.length || g.change.some((y) => y.add.length || y.change.length));
          }(t, b) || console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.")), id(t, b);
        } catch {
        }
      var m;
      Ao.push(t), h.onversionchange = $t((b) => {
        e.vcFired = !0, t.on("versionchange").fire(b);
      }), h.onclose = $t((b) => {
        t.on("close").fire(b);
      }), a && function({ indexedDB: b, IDBKeyRange: p }, f) {
        !Tf(b) && f !== pu && Cf(b, p).put({ name: f }).catch(Lt);
      }(t._deps, c), l();
    }, u);
  }))]).then(() => (i(), e.onReadyBeingFired = [], Le.resolve(ud(() => t.on.ready.fire(t.vip))).then(function l() {
    if (e.onReadyBeingFired.length > 0) {
      let u = e.onReadyBeingFired.reduce(Ef, Lt);
      return e.onReadyBeingFired = [], Le.resolve(ud(() => u(t.vip))).then(l);
    }
  }))).finally(() => {
    e.onReadyBeingFired = null, e.isBeingOpened = !1;
  }).then(() => t).catch((l) => {
    e.dbOpenError = l;
    try {
      o && o.abort();
    } catch {
    }
    return r === e.openCanceller && t._close(), dn(l);
  }).finally(() => {
    e.openComplete = !0, s();
  });
}
function cd(t) {
  var e = (s) => t.next(s), n = i(e), r = i((s) => t.throw(s));
  function i(s) {
    return (o) => {
      var a = s(o), l = a.value;
      return a.done ? l : l && typeof l.then == "function" ? l.then(n, r) : In(l) ? Promise.all(l).then(n, r) : n(l);
    };
  }
  return i(e)();
}
function RB(t, e, n) {
  var r = arguments.length;
  if (r < 2)
    throw new Ze.InvalidArgument("Too few arguments");
  for (var i = new Array(r - 1); --r; )
    i[r - 1] = arguments[r];
  return n = i.pop(), [t, Oy(i), n];
}
function Zy(t, e, n, r, i) {
  return Le.resolve().then(() => {
    const s = Ke.transless || Ke, o = t._createTransaction(e, n, t._dbSchema, r), a = { trans: o, transless: s };
    if (r)
      o.idbtrans = r.idbtrans;
    else
      try {
        o.create(), t._state.PR1398_maxLoop = 3;
      } catch (d) {
        return d.name === Sf.InvalidState && t.isOpen() && --t._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), t._close(), t.open().then(() => Zy(t, e, n, null, i))) : dn(d);
      }
    const l = wf(i);
    let u;
    l && Qs();
    const c = Le.follow(() => {
      if (u = i.call(o, o), u)
        if (l) {
          var d = si.bind(null, null);
          u.then(d, d);
        } else
          typeof u.next == "function" && typeof u.throw == "function" && (u = cd(u));
    }, a);
    return (u && typeof u.then == "function" ? Le.resolve(u).then((d) => o.active ? d : dn(new Ze.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"))) : c.then(() => u)).then((d) => (r && o._resolve(), o._completion.then(() => d))).catch((d) => (o._reject(d), dn(d)));
  });
}
function Fa(t, e, n) {
  const r = In(t) ? t.slice() : [t];
  for (let i = 0; i < n; ++i)
    r.push(e);
  return r;
}
const PB = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(t) {
  return { ...t, table(e) {
    const n = t.table(e), { schema: r } = n, i = {}, s = [];
    function o(c, d, h) {
      const v = Co(c), m = i[v] = i[v] || [], b = c == null ? 0 : typeof c == "string" ? 1 : c.length, p = d > 0, f = { ...h, isVirtual: p, keyTail: d, keyLength: b, extractKey: rd(c), unique: !p && h.unique };
      return m.push(f), f.isPrimaryKey || s.push(f), b > 1 && o(b === 2 ? c[0] : c.slice(0, b - 1), d + 1, h), m.sort((g, y) => g.keyTail - y.keyTail), f;
    }
    const a = o(r.primaryKey.keyPath, 0, r.primaryKey);
    i[":id"] = [a];
    for (const c of r.indexes)
      o(c.keyPath, 0, c);
    function l(c) {
      const d = c.query.index;
      return d.isVirtual ? { ...c, query: { index: d, range: (h = c.query.range, v = d.keyTail, { type: h.type === 1 ? 2 : h.type, lower: Fa(h.lower, h.lowerOpen ? t.MAX_KEY : t.MIN_KEY, v), lowerOpen: !0, upper: Fa(h.upper, h.upperOpen ? t.MIN_KEY : t.MAX_KEY, v), upperOpen: !0 }) } } : c;
      var h, v;
    }
    return { ...n, schema: { ...r, primaryKey: a, indexes: s, getIndexByKeyPath: function(c) {
      const d = i[Co(c)];
      return d && d[0];
    } }, count: (c) => n.count(l(c)), query: (c) => n.query(l(c)), openCursor(c) {
      const { keyTail: d, isVirtual: h, keyLength: v } = c.query.index;
      return h ? n.openCursor(l(c)).then((m) => m && function(b) {
        return Object.create(b, { continue: { value: function(f) {
          f != null ? b.continue(Fa(f, c.reverse ? t.MAX_KEY : t.MIN_KEY, d)) : c.unique ? b.continue(b.key.slice(0, v).concat(c.reverse ? t.MIN_KEY : t.MAX_KEY, d)) : b.continue();
        } }, continuePrimaryKey: { value(f, g) {
          b.continuePrimaryKey(Fa(f, t.MAX_KEY, d), g);
        } }, primaryKey: { get: () => b.primaryKey }, key: { get() {
          const f = b.key;
          return v === 1 ? f[0] : f.slice(0, v);
        } }, value: { get: () => b.value } });
      }(m)) : n.openCursor(c);
    } };
  } };
} };
function Of(t, e, n, r) {
  return n = n || {}, r = r || "", an(t).forEach((i) => {
    if (Zn(e, i)) {
      var s = t[i], o = e[i];
      if (typeof s == "object" && typeof o == "object" && s && o) {
        const a = Vc(s);
        a !== Vc(o) ? n[r + i] = e[i] : a === "Object" ? Of(s, o, n, r + i + ".") : s !== o && (n[r + i] = e[i]);
      } else
        s !== o && (n[r + i] = e[i]);
    } else
      n[r + i] = void 0;
  }), an(e).forEach((i) => {
    Zn(t, i) || (n[r + i] = e[i]);
  }), n;
}
const DB = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: (t) => ({ ...t, table(e) {
  const n = t.table(e), { primaryKey: r } = n.schema;
  return { ...n, mutate(s) {
    const o = Ke.trans, { deleting: a, creating: l, updating: u } = o.table(e).hook;
    switch (s.type) {
      case "add":
        if (l.fire === Lt)
          break;
        return o._promise("readwrite", () => c(s), !0);
      case "put":
        if (l.fire === Lt && u.fire === Lt)
          break;
        return o._promise("readwrite", () => c(s), !0);
      case "delete":
        if (a.fire === Lt)
          break;
        return o._promise("readwrite", () => c(s), !0);
      case "deleteRange":
        if (a.fire === Lt)
          break;
        return o._promise("readwrite", () => function(h) {
          return d(h.trans, h.range, 1e4);
        }(s), !0);
    }
    return n.mutate(s);
    function c(h) {
      const v = Ke.trans, m = h.keys || function(b, p) {
        return p.type === "delete" ? p.keys : p.keys || p.values.map(b.extractKey);
      }(r, h);
      if (!m)
        throw new Error("Keys missing");
      return (h = h.type === "add" || h.type === "put" ? { ...h, keys: m } : { ...h }).type !== "delete" && (h.values = [...h.values]), h.keys && (h.keys = [...h.keys]), function(b, p, f) {
        return p.type === "add" ? Promise.resolve([]) : b.getMany({ trans: p.trans, keys: f, cache: "immutable" });
      }(n, h, m).then((b) => {
        const p = m.map((f, g) => {
          const y = b[g], w = { onerror: null, onsuccess: null };
          if (h.type === "delete")
            a.fire.call(w, f, y, v);
          else if (h.type === "add" || y === void 0) {
            const _ = l.fire.call(w, f, h.values[g], v);
            f == null && _ != null && (f = _, h.keys[g] = f, r.outbound || br(h.values[g], r.keyPath, f));
          } else {
            const _ = Of(y, h.values[g]), S = u.fire.call(w, _, f, y, v);
            if (S) {
              const A = h.values[g];
              Object.keys(S).forEach((C) => {
                Zn(A, C) ? A[C] = S[C] : br(A, C, S[C]);
              });
            }
          }
          return w;
        });
        return n.mutate(h).then(({ failures: f, results: g, numFailures: y, lastResult: w }) => {
          for (let _ = 0; _ < m.length; ++_) {
            const S = g ? g[_] : m[_], A = p[_];
            S == null ? A.onerror && A.onerror(f[_]) : A.onsuccess && A.onsuccess(h.type === "put" && b[_] ? h.values[_] : S);
          }
          return { failures: f, results: g, numFailures: y, lastResult: w };
        }).catch((f) => (p.forEach((g) => g.onerror && g.onerror(f)), Promise.reject(f)));
      });
    }
    function d(h, v, m) {
      return n.query({ trans: h, values: !1, query: { index: r, range: v }, limit: m }).then(({ result: b }) => c({ type: "delete", keys: b, trans: h }).then((p) => p.numFailures > 0 ? Promise.reject(p.failures[0]) : b.length < m ? { failures: [], numFailures: 0, lastResult: void 0 } : d(h, { ...v, lower: b[b.length - 1], lowerOpen: !0 }, m)));
    }
  } };
} }) };
function Xy(t, e, n) {
  try {
    if (!e || e.keys.length < t.length)
      return null;
    const r = [];
    for (let i = 0, s = 0; i < e.keys.length && s < t.length; ++i)
      Rn(e.keys[i], t[s]) === 0 && (r.push(n ? fa(e.values[i]) : e.values[i]), ++s);
    return r.length === t.length ? r : null;
  } catch {
    return null;
  }
}
const BB = { stack: "dbcore", level: -1, create: (t) => ({ table: (e) => {
  const n = t.table(e);
  return { ...n, getMany: (r) => {
    if (!r.cache)
      return n.getMany(r);
    const i = Xy(r.keys, r.trans._cache, r.cache === "clone");
    return i ? Le.resolve(i) : n.getMany(r).then((s) => (r.trans._cache = { keys: r.keys, values: r.cache === "clone" ? fa(s) : s }, s));
  }, mutate: (r) => (r.type !== "add" && (r.trans._cache = null), n.mutate(r)) };
} }) };
function If(t) {
  return !("from" in t);
}
const Jr = function(t, e) {
  if (!this) {
    const n = new Jr();
    return t && "d" in t && Bn(n, t), n;
  }
  Bn(this, arguments.length ? { d: 1, from: t, to: arguments.length > 1 ? e : t } : { d: 0 });
};
function Go(t, e, n) {
  const r = Rn(e, n);
  if (isNaN(r))
    return;
  if (r > 0)
    throw RangeError();
  if (If(t))
    return Bn(t, { from: e, to: n, d: 1 });
  const i = t.l, s = t.r;
  if (Rn(n, t.from) < 0)
    return i ? Go(i, e, n) : t.l = { from: e, to: n, d: 1, l: null, r: null }, Qp(t);
  if (Rn(e, t.to) > 0)
    return s ? Go(s, e, n) : t.r = { from: e, to: n, d: 1, l: null, r: null }, Qp(t);
  Rn(e, t.from) < 0 && (t.from = e, t.l = null, t.d = s ? s.d + 1 : 1), Rn(n, t.to) > 0 && (t.to = n, t.r = null, t.d = t.l ? t.l.d + 1 : 1);
  const o = !t.r;
  i && !t.l && Pl(t, i), s && o && Pl(t, s);
}
function Pl(t, e) {
  If(e) || function n(r, { from: i, to: s, l: o, r: a }) {
    Go(r, i, s), o && n(r, o), a && n(r, a);
  }(t, e);
}
function MB(t, e) {
  const n = dd(e);
  let r = n.next();
  if (r.done)
    return !1;
  let i = r.value;
  const s = dd(t);
  let o = s.next(i.from), a = o.value;
  for (; !r.done && !o.done; ) {
    if (Rn(a.from, i.to) <= 0 && Rn(a.to, i.from) >= 0)
      return !0;
    Rn(i.from, a.from) < 0 ? i = (r = n.next(a.from)).value : a = (o = s.next(i.from)).value;
  }
  return !1;
}
function dd(t) {
  let e = If(t) ? null : { s: 0, n: t };
  return { next(n) {
    const r = arguments.length > 0;
    for (; e; )
      switch (e.s) {
        case 0:
          if (e.s = 1, r)
            for (; e.n.l && Rn(n, e.n.from) < 0; )
              e = { up: e, n: e.n.l, s: 1 };
          else
            for (; e.n.l; )
              e = { up: e, n: e.n.l, s: 1 };
        case 1:
          if (e.s = 2, !r || Rn(n, e.n.to) <= 0)
            return { value: e.n, done: !1 };
        case 2:
          if (e.n.r) {
            e.s = 3, e = { up: e, n: e.n.r, s: 0 };
            continue;
          }
        case 3:
          e = e.up;
      }
    return { done: !0 };
  } };
}
function Qp(t) {
  var e, n;
  const r = (((e = t.r) === null || e === void 0 ? void 0 : e.d) || 0) - (((n = t.l) === null || n === void 0 ? void 0 : n.d) || 0), i = r > 1 ? "r" : r < -1 ? "l" : "";
  if (i) {
    const s = i === "r" ? "l" : "r", o = { ...t }, a = t[i];
    t.from = a.from, t.to = a.to, t[i] = a[i], o[i] = a[s], t[s] = o, o.d = Zp(o);
  }
  t.d = Zp(t);
}
function Zp({ r: t, l: e }) {
  return (t ? e ? Math.max(t.d, e.d) : t.d : e ? e.d : 0) + 1;
}
Vs(Jr.prototype, { add(t) {
  return Pl(this, t), this;
}, addKey(t) {
  return Go(this, t, t), this;
}, addKeys(t) {
  return t.forEach((e) => Go(this, e, e)), this;
}, [Wc]() {
  return dd(this);
} });
const LB = { stack: "dbcore", level: 0, create: (t) => {
  const e = t.schema.name, n = new Jr(t.MIN_KEY, t.MAX_KEY);
  return { ...t, table: (r) => {
    const i = t.table(r), { schema: s } = i, { primaryKey: o } = s, { extractKey: a, outbound: l } = o, u = { ...i, mutate: (h) => {
      const v = h.trans, m = v.mutatedParts || (v.mutatedParts = {}), b = (S) => {
        const A = `idb://${e}/${r}/${S}`;
        return m[A] || (m[A] = new Jr());
      }, p = b(""), f = b(":dels"), { type: g } = h;
      let [y, w] = h.type === "deleteRange" ? [h.range] : h.type === "delete" ? [h.keys] : h.values.length < 50 ? [[], h.values] : [];
      const _ = h.trans._cache;
      return i.mutate(h).then((S) => {
        if (In(y)) {
          g !== "delete" && (y = S.results), p.addKeys(y);
          const A = Xy(y, _);
          A || g === "add" || f.addKeys(y), (A || w) && function(C, k, O, N) {
            function B(D) {
              const F = C(D.name || "");
              function Z(L) {
                return L != null ? D.extractKey(L) : null;
              }
              const te = (L) => D.multiEntry && In(L) ? L.forEach((V) => F.addKey(V)) : F.addKey(L);
              (O || N).forEach((L, V) => {
                const H = O && Z(O[V]), ie = N && Z(N[V]);
                Rn(H, ie) !== 0 && (H != null && te(H), ie != null && te(ie));
              });
            }
            k.indexes.forEach(B);
          }(b, s, A, w);
        } else if (y) {
          const A = { from: y.lower, to: y.upper };
          f.add(A), p.add(A);
        } else
          p.add(n), f.add(n), s.indexes.forEach((A) => b(A.name).add(n));
        return S;
      });
    } }, c = ({ query: { index: h, range: v } }) => {
      var m, b;
      return [h, new Jr((m = v.lower) !== null && m !== void 0 ? m : t.MIN_KEY, (b = v.upper) !== null && b !== void 0 ? b : t.MAX_KEY)];
    }, d = { get: (h) => [o, new Jr(h.key)], getMany: (h) => [o, new Jr().addKeys(h.keys)], count: c, query: c, openCursor: c };
    return an(d).forEach((h) => {
      u[h] = function(v) {
        const { subscr: m } = Ke;
        if (m) {
          const b = (w) => {
            const _ = `idb://${e}/${r}/${w}`;
            return m[_] || (m[_] = new Jr());
          }, p = b(""), f = b(":dels"), [g, y] = d[h](v);
          if (b(g.name || "").add(y), !g.isPrimaryKey) {
            if (h !== "count") {
              const w = h === "query" && l && v.values && i.query({ ...v, values: !1 });
              return i[h].apply(this, arguments).then((_) => {
                if (h === "query") {
                  if (l && v.values)
                    return w.then(({ result: A }) => (p.addKeys(A), _));
                  const S = v.values ? _.result.map(a) : _.result;
                  v.values ? p.addKeys(S) : f.addKeys(S);
                } else if (h === "openCursor") {
                  const S = _, A = v.values;
                  return S && Object.create(S, { key: { get: () => (f.addKey(S.primaryKey), S.key) }, primaryKey: { get() {
                    const C = S.primaryKey;
                    return f.addKey(C), C;
                  } }, value: { get: () => (A && p.addKey(S.primaryKey), S.value) } });
                }
                return _;
              });
            }
            f.add(n);
          }
        }
        return i[h].apply(this, arguments);
      };
    }), u;
  } };
} };
class Wi {
  constructor(e, n) {
    this._middlewares = {}, this.verno = 0;
    const r = Wi.dependencies;
    this._options = n = { addons: Wi.addons, autoOpen: !0, indexedDB: r.indexedDB, IDBKeyRange: r.IDBKeyRange, ...n }, this._deps = { indexedDB: n.indexedDB, IDBKeyRange: n.IDBKeyRange };
    const { addons: i } = n;
    this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
    const s = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: Lt, dbReadyPromise: null, cancelOpen: Lt, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3 };
    var o;
    s.dbReadyPromise = new Le((a) => {
      s.dbReadyResolve = a;
    }), s.openCanceller = new Le((a, l) => {
      s.cancelOpen = l;
    }), this._state = s, this.name = e, this.on = ko(this, "populate", "blocked", "versionchange", "close", { ready: [Ef, Lt] }), this.on.ready.subscribe = Ay(this.on.ready.subscribe, (a) => (l, u) => {
      Wi.vip(() => {
        const c = this._state;
        if (c.openComplete)
          c.dbOpenError || Le.resolve().then(l), u && a(l);
        else if (c.onReadyBeingFired)
          c.onReadyBeingFired.push(l), u && a(l);
        else {
          a(l);
          const d = this;
          u || a(function h() {
            d.on.ready.unsubscribe(l), d.on.ready.unsubscribe(h);
          });
        }
      });
    }), this.Collection = (o = this, oo(wB.prototype, function(a, l) {
      this.db = o;
      let u = Ky, c = null;
      if (l)
        try {
          u = l();
        } catch (m) {
          c = m;
        }
      const d = a._ctx, h = d.table, v = h.hook.reading.fire;
      this._ctx = { table: h, index: d.index, isPrimKey: !d.index || h.schema.primKey.keyPath && d.index === h.schema.primKey.name, range: u, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: c, or: d.or, valueMapper: v !== Uo ? v : null };
    })), this.Table = function(a) {
      return oo(bB.prototype, function(l, u, c) {
        this.db = a, this._tx = c, this.name = l, this.schema = u, this.hook = a._allTables[l] ? a._allTables[l].hook : ko(null, { creating: [aB, Lt], reading: [oB, Uo], updating: [uB, Lt], deleting: [lB, Lt] });
      });
    }(this), this.Transaction = function(a) {
      return oo(xB.prototype, function(l, u, c, d, h) {
        this.db = a, this.mode = l, this.storeNames = u, this.schema = c, this.chromeTransactionDurability = d, this.idbtrans = null, this.on = ko(this, "complete", "error", "abort"), this.parent = h || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new Le((v, m) => {
          this._resolve = v, this._reject = m;
        }), this._completion.then(() => {
          this.active = !1, this.on.complete.fire();
        }, (v) => {
          var m = this.active;
          return this.active = !1, this.on.error.fire(v), this.parent ? this.parent._reject(v) : m && this.idbtrans && this.idbtrans.abort(), dn(v);
        });
      });
    }(this), this.Version = function(a) {
      return oo(OB.prototype, function(l) {
        this.db = a, this._cfg = { version: l, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
      });
    }(this), this.WhereClause = function(a) {
      return oo(qy.prototype, function(l, u, c) {
        this.db = a, this._ctx = { table: l, index: u === ":id" ? null : u, or: c };
        const d = a._deps.indexedDB;
        if (!d)
          throw new Ze.MissingAPI();
        this._cmp = this._ascending = d.cmp.bind(d), this._descending = (h, v) => d.cmp(v, h), this._max = (h, v) => d.cmp(h, v) > 0 ? h : v, this._min = (h, v) => d.cmp(h, v) < 0 ? h : v, this._IDBKeyRange = a._deps.IDBKeyRange;
      });
    }(this), this.on("versionchange", (a) => {
      a.newVersion > 0 ? console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`) : console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`), this.close();
    }), this.on("blocked", (a) => {
      !a.newVersion || a.newVersion < a.oldVersion ? console.warn(`Dexie.delete('${this.name}') was blocked`) : console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${a.oldVersion / 10}`);
    }), this._maxKey = Ko(n.IDBKeyRange), this._createTransaction = (a, l, u, c) => new this.Transaction(a, l, u, this._options.chromeTransactionDurability, c), this._fireOnBlocked = (a) => {
      this.on("blocked").fire(a), Ao.filter((l) => l.name === this.name && l !== this && !l._state.vcFired).map((l) => l.on("versionchange").fire(a));
    }, this.use(PB), this.use(DB), this.use(LB), this.use(BB), this.vip = Object.create(this, { _vip: { value: !0 } }), i.forEach((a) => a(this));
  }
  version(e) {
    if (isNaN(e) || e < 0.1)
      throw new Ze.Type("Given version is not a positive number");
    if (e = Math.round(10 * e) / 10, this.idbdb || this._state.isBeingOpened)
      throw new Ze.Schema("Cannot add version when database is open");
    this.verno = Math.max(this.verno, e);
    const n = this._versions;
    var r = n.filter((i) => i._cfg.version === e)[0];
    return r || (r = new this.Version(e), n.push(r), n.sort(CB), r.stores({}), this._state.autoSchema = !1, r);
  }
  _whenReady(e) {
    return this.idbdb && (this._state.openComplete || Ke.letThrough || this._vip) ? e() : new Le((n, r) => {
      if (this._state.openComplete)
        return r(new Ze.DatabaseClosed(this._state.dbOpenError));
      if (!this._state.isBeingOpened) {
        if (!this._options.autoOpen)
          return void r(new Ze.DatabaseClosed());
        this.open().catch(Lt);
      }
      this._state.dbReadyPromise.then(n, r);
    }).then(e);
  }
  use({ stack: e, create: n, level: r, name: i }) {
    i && this.unuse({ stack: e, name: i });
    const s = this._middlewares[e] || (this._middlewares[e] = []);
    return s.push({ stack: e, create: n, level: r ?? 10, name: i }), s.sort((o, a) => o.level - a.level), this;
  }
  unuse({ stack: e, name: n, create: r }) {
    return e && this._middlewares[e] && (this._middlewares[e] = this._middlewares[e].filter((i) => r ? i.create !== r : !!n && i.name !== n)), this;
  }
  open() {
    return NB(this);
  }
  _close() {
    const e = this._state, n = Ao.indexOf(this);
    if (n >= 0 && Ao.splice(n, 1), this.idbdb) {
      try {
        this.idbdb.close();
      } catch {
      }
      this._novip.idbdb = null;
    }
    e.dbReadyPromise = new Le((r) => {
      e.dbReadyResolve = r;
    }), e.openCanceller = new Le((r, i) => {
      e.cancelOpen = i;
    });
  }
  close() {
    this._close();
    const e = this._state;
    this._options.autoOpen = !1, e.dbOpenError = new Ze.DatabaseClosed(), e.isBeingOpened && e.cancelOpen(e.dbOpenError);
  }
  delete() {
    const e = arguments.length > 0, n = this._state;
    return new Le((r, i) => {
      const s = () => {
        this.close();
        var o = this._deps.indexedDB.deleteDatabase(this.name);
        o.onsuccess = $t(() => {
          (function({ indexedDB: a, IDBKeyRange: l }, u) {
            !Tf(a) && u !== pu && Cf(a, l).delete(u).catch(Lt);
          })(this._deps, this.name), r();
        }), o.onerror = kr(i), o.onblocked = this._fireOnBlocked;
      };
      if (e)
        throw new Ze.InvalidArgument("Arguments not allowed in db.delete()");
      n.isBeingOpened ? n.dbReadyPromise.then(s) : s();
    });
  }
  backendDB() {
    return this.idbdb;
  }
  isOpen() {
    return this.idbdb !== null;
  }
  hasBeenClosed() {
    const e = this._state.dbOpenError;
    return e && e.name === "DatabaseClosed";
  }
  hasFailed() {
    return this._state.dbOpenError !== null;
  }
  dynamicallyOpened() {
    return this._state.autoSchema;
  }
  get tables() {
    return an(this._allTables).map((e) => this._allTables[e]);
  }
  transaction() {
    const e = RB.apply(this, arguments);
    return this._transaction.apply(this, e);
  }
  _transaction(e, n, r) {
    let i = Ke.trans;
    i && i.db === this && e.indexOf("!") === -1 || (i = null);
    const s = e.indexOf("?") !== -1;
    let o, a;
    e = e.replace("!", "").replace("?", "");
    try {
      if (a = n.map((u) => {
        var c = u instanceof this.Table ? u.name : u;
        if (typeof c != "string")
          throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
        return c;
      }), e == "r" || e === Vu)
        o = Vu;
      else {
        if (e != "rw" && e != Wu)
          throw new Ze.InvalidArgument("Invalid transaction mode: " + e);
        o = Wu;
      }
      if (i) {
        if (i.mode === Vu && o === Wu) {
          if (!s)
            throw new Ze.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
          i = null;
        }
        i && a.forEach((u) => {
          if (i && i.storeNames.indexOf(u) === -1) {
            if (!s)
              throw new Ze.SubTransaction("Table " + u + " not included in parent transaction.");
            i = null;
          }
        }), s && i && !i.active && (i = null);
      }
    } catch (u) {
      return i ? i._promise(null, (c, d) => {
        d(u);
      }) : dn(u);
    }
    const l = Zy.bind(null, this, o, a, i, r);
    return i ? i._promise(o, l, "lock") : Ke.trans ? Zs(Ke.transless, () => this._whenReady(l)) : this._whenReady(l);
  }
  table(e) {
    if (!Zn(this._allTables, e))
      throw new Ze.InvalidTable(`Table ${e} does not exist`);
    return this._allTables[e];
  }
}
const zB = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable";
class jB {
  constructor(e) {
    this._subscribe = e;
  }
  subscribe(e, n, r) {
    return this._subscribe(e && typeof e != "function" ? e : { next: e, error: n, complete: r });
  }
  [zB]() {
    return this;
  }
}
function e0(t, e) {
  return an(e).forEach((n) => {
    Pl(t[n] || (t[n] = new Jr()), e[n]);
  }), t;
}
function FB(t) {
  let e, n = !1;
  const r = new jB((i) => {
    const s = wf(t);
    let o = !1, a = {}, l = {};
    const u = { get closed() {
      return o;
    }, unsubscribe: () => {
      o = !0, Ci.storagemutated.unsubscribe(v);
    } };
    i.start && i.start(u);
    let c = !1, d = !1;
    function h() {
      return an(l).some((b) => a[b] && MB(a[b], l[b]));
    }
    const v = (b) => {
      e0(a, b), h() && m();
    }, m = () => {
      if (c || o)
        return;
      a = {};
      const b = {}, p = function(f) {
        s && Qs();
        const g = () => Ai(t, { subscr: f, trans: null }), y = Ke.trans ? Zs(Ke.transless, g) : g();
        return s && y.then(si, si), y;
      }(b);
      d || (Ci($o, v), d = !0), c = !0, Promise.resolve(p).then((f) => {
        n = !0, e = f, c = !1, o || (h() ? m() : (a = {}, l = b, i.next && i.next(f)));
      }, (f) => {
        c = !1, n = !1, i.error && i.error(f), u.unsubscribe();
      });
    };
    return m(), u;
  });
  return r.hasValue = () => n, r.getValue = () => e, r;
}
let fd;
try {
  fd = { indexedDB: Ut.indexedDB || Ut.mozIndexedDB || Ut.webkitIndexedDB || Ut.msIndexedDB, IDBKeyRange: Ut.IDBKeyRange || Ut.webkitIDBKeyRange };
} catch {
  fd = { indexedDB: null, IDBKeyRange: null };
}
const Ri = Wi;
function cl(t) {
  let e = Qr;
  try {
    Qr = !0, Ci.storagemutated.fire(t);
  } finally {
    Qr = e;
  }
}
Vs(Ri, { ...il, delete: (t) => new Ri(t, { addons: [] }).delete(), exists: (t) => new Ri(t, { addons: [] }).open().then((e) => (e.close(), !0)).catch("NoSuchDatabaseError", () => !1), getDatabaseNames(t) {
  try {
    return function({ indexedDB: e, IDBKeyRange: n }) {
      return Tf(e) ? Promise.resolve(e.databases()).then((r) => r.map((i) => i.name).filter((i) => i !== pu)) : Cf(e, n).toCollection().primaryKeys();
    }(Ri.dependencies).then(t);
  } catch {
    return dn(new Ze.MissingAPI());
  }
}, defineClass: () => function(t) {
  Bn(this, t);
}, ignoreTransaction: (t) => Ke.trans ? Zs(Ke.transless, t) : t(), vip: ud, async: function(t) {
  return function() {
    try {
      var e = cd(t.apply(this, arguments));
      return e && typeof e.then == "function" ? e : Le.resolve(e);
    } catch (n) {
      return dn(n);
    }
  };
}, spawn: function(t, e, n) {
  try {
    var r = cd(t.apply(n, e || []));
    return r && typeof r.then == "function" ? r : Le.resolve(r);
  } catch (i) {
    return dn(i);
  }
}, currentTransaction: { get: () => Ke.trans || null }, waitFor: function(t, e) {
  const n = Le.resolve(typeof t == "function" ? Ri.ignoreTransaction(t) : t).timeout(e || 6e4);
  return Ke.trans ? Ke.trans.waitFor(n) : n;
}, Promise: Le, debug: { get: () => Ur, set: (t) => {
  Ny(t, t === "dexie" ? () => !0 : $y);
} }, derive: Is, extend: Bn, props: Vs, override: Ay, Events: ko, on: Ci, liveQuery: FB, extendObservabilitySet: e0, getByKeyPath: ei, setByKeyPath: br, delByKeyPath: function(t, e) {
  typeof e == "string" ? br(t, e, void 0) : "length" in e && [].map.call(e, function(n) {
    br(t, n, void 0);
  });
}, shallowClone: Ty, deepClone: fa, getObjectDiff: Of, cmp: Rn, asap: ky, minKey: td, addons: [], connections: Ao, errnames: Sf, dependencies: fd, semVer: $p, version: $p.split(".").map((t) => parseInt(t)).reduce((t, e, n) => t + e / Math.pow(10, 2 * n)) }), Ri.maxKey = Ko(Ri.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (Ci($o, (t) => {
  if (!Qr) {
    let e;
    hu ? (e = document.createEvent("CustomEvent"), e.initCustomEvent(bi, !0, !0, t)) : e = new CustomEvent(bi, { detail: t }), Qr = !0, dispatchEvent(e), Qr = !1;
  }
}), addEventListener(bi, ({ detail: t }) => {
  Qr || cl(t);
}));
let Qr = !1;
if (typeof BroadcastChannel < "u") {
  const t = new BroadcastChannel(bi);
  typeof t.unref == "function" && t.unref(), Ci($o, (e) => {
    Qr || t.postMessage(e);
  }), t.onmessage = (e) => {
    e.data && cl(e.data);
  };
} else if (typeof self < "u" && typeof navigator < "u") {
  Ci($o, (e) => {
    try {
      Qr || (typeof localStorage < "u" && localStorage.setItem(bi, JSON.stringify({ trig: Math.random(), changedParts: e })), typeof self.clients == "object" && [...self.clients.matchAll({ includeUncontrolled: !0 })].forEach((n) => n.postMessage({ type: bi, changedParts: e })));
    } catch {
    }
  }), typeof addEventListener < "u" && addEventListener("storage", (e) => {
    if (e.key === bi) {
      const n = JSON.parse(e.newValue);
      n && cl(n.changedParts);
    }
  });
  const t = self.document && navigator.serviceWorker;
  t && t.addEventListener("message", function({ data: e }) {
    e && e.type === bi && cl(e.changedParts);
  });
}
Le.rejectionMapper = function(t, e) {
  if (!t || t instanceof Ns || t instanceof TypeError || t instanceof SyntaxError || !t.name || !Hp[t.name])
    return t;
  var n = new Hp[t.name](e || t.message, t);
  return "stack" in t && Xr(n, "stack", { get: function() {
    return this.inner.stack;
  } }), n;
}, Ny(Ur, $y);
const HB = new Wi("library");
HB.version(1).stores({
  books: "++id, name, buffer, md5 ,size"
});
var Xp = {}, UB = {
  get exports() {
    return Xp;
  },
  set exports(t) {
    Xp = t;
  }
};
(function(t, e) {
  (function(n) {
    t.exports = n();
  })(function(n) {
    var r = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    function i(f, g) {
      var y = f[0], w = f[1], _ = f[2], S = f[3];
      y += (w & _ | ~w & S) + g[0] - 680876936 | 0, y = (y << 7 | y >>> 25) + w | 0, S += (y & w | ~y & _) + g[1] - 389564586 | 0, S = (S << 12 | S >>> 20) + y | 0, _ += (S & y | ~S & w) + g[2] + 606105819 | 0, _ = (_ << 17 | _ >>> 15) + S | 0, w += (_ & S | ~_ & y) + g[3] - 1044525330 | 0, w = (w << 22 | w >>> 10) + _ | 0, y += (w & _ | ~w & S) + g[4] - 176418897 | 0, y = (y << 7 | y >>> 25) + w | 0, S += (y & w | ~y & _) + g[5] + 1200080426 | 0, S = (S << 12 | S >>> 20) + y | 0, _ += (S & y | ~S & w) + g[6] - 1473231341 | 0, _ = (_ << 17 | _ >>> 15) + S | 0, w += (_ & S | ~_ & y) + g[7] - 45705983 | 0, w = (w << 22 | w >>> 10) + _ | 0, y += (w & _ | ~w & S) + g[8] + 1770035416 | 0, y = (y << 7 | y >>> 25) + w | 0, S += (y & w | ~y & _) + g[9] - 1958414417 | 0, S = (S << 12 | S >>> 20) + y | 0, _ += (S & y | ~S & w) + g[10] - 42063 | 0, _ = (_ << 17 | _ >>> 15) + S | 0, w += (_ & S | ~_ & y) + g[11] - 1990404162 | 0, w = (w << 22 | w >>> 10) + _ | 0, y += (w & _ | ~w & S) + g[12] + 1804603682 | 0, y = (y << 7 | y >>> 25) + w | 0, S += (y & w | ~y & _) + g[13] - 40341101 | 0, S = (S << 12 | S >>> 20) + y | 0, _ += (S & y | ~S & w) + g[14] - 1502002290 | 0, _ = (_ << 17 | _ >>> 15) + S | 0, w += (_ & S | ~_ & y) + g[15] + 1236535329 | 0, w = (w << 22 | w >>> 10) + _ | 0, y += (w & S | _ & ~S) + g[1] - 165796510 | 0, y = (y << 5 | y >>> 27) + w | 0, S += (y & _ | w & ~_) + g[6] - 1069501632 | 0, S = (S << 9 | S >>> 23) + y | 0, _ += (S & w | y & ~w) + g[11] + 643717713 | 0, _ = (_ << 14 | _ >>> 18) + S | 0, w += (_ & y | S & ~y) + g[0] - 373897302 | 0, w = (w << 20 | w >>> 12) + _ | 0, y += (w & S | _ & ~S) + g[5] - 701558691 | 0, y = (y << 5 | y >>> 27) + w | 0, S += (y & _ | w & ~_) + g[10] + 38016083 | 0, S = (S << 9 | S >>> 23) + y | 0, _ += (S & w | y & ~w) + g[15] - 660478335 | 0, _ = (_ << 14 | _ >>> 18) + S | 0, w += (_ & y | S & ~y) + g[4] - 405537848 | 0, w = (w << 20 | w >>> 12) + _ | 0, y += (w & S | _ & ~S) + g[9] + 568446438 | 0, y = (y << 5 | y >>> 27) + w | 0, S += (y & _ | w & ~_) + g[14] - 1019803690 | 0, S = (S << 9 | S >>> 23) + y | 0, _ += (S & w | y & ~w) + g[3] - 187363961 | 0, _ = (_ << 14 | _ >>> 18) + S | 0, w += (_ & y | S & ~y) + g[8] + 1163531501 | 0, w = (w << 20 | w >>> 12) + _ | 0, y += (w & S | _ & ~S) + g[13] - 1444681467 | 0, y = (y << 5 | y >>> 27) + w | 0, S += (y & _ | w & ~_) + g[2] - 51403784 | 0, S = (S << 9 | S >>> 23) + y | 0, _ += (S & w | y & ~w) + g[7] + 1735328473 | 0, _ = (_ << 14 | _ >>> 18) + S | 0, w += (_ & y | S & ~y) + g[12] - 1926607734 | 0, w = (w << 20 | w >>> 12) + _ | 0, y += (w ^ _ ^ S) + g[5] - 378558 | 0, y = (y << 4 | y >>> 28) + w | 0, S += (y ^ w ^ _) + g[8] - 2022574463 | 0, S = (S << 11 | S >>> 21) + y | 0, _ += (S ^ y ^ w) + g[11] + 1839030562 | 0, _ = (_ << 16 | _ >>> 16) + S | 0, w += (_ ^ S ^ y) + g[14] - 35309556 | 0, w = (w << 23 | w >>> 9) + _ | 0, y += (w ^ _ ^ S) + g[1] - 1530992060 | 0, y = (y << 4 | y >>> 28) + w | 0, S += (y ^ w ^ _) + g[4] + 1272893353 | 0, S = (S << 11 | S >>> 21) + y | 0, _ += (S ^ y ^ w) + g[7] - 155497632 | 0, _ = (_ << 16 | _ >>> 16) + S | 0, w += (_ ^ S ^ y) + g[10] - 1094730640 | 0, w = (w << 23 | w >>> 9) + _ | 0, y += (w ^ _ ^ S) + g[13] + 681279174 | 0, y = (y << 4 | y >>> 28) + w | 0, S += (y ^ w ^ _) + g[0] - 358537222 | 0, S = (S << 11 | S >>> 21) + y | 0, _ += (S ^ y ^ w) + g[3] - 722521979 | 0, _ = (_ << 16 | _ >>> 16) + S | 0, w += (_ ^ S ^ y) + g[6] + 76029189 | 0, w = (w << 23 | w >>> 9) + _ | 0, y += (w ^ _ ^ S) + g[9] - 640364487 | 0, y = (y << 4 | y >>> 28) + w | 0, S += (y ^ w ^ _) + g[12] - 421815835 | 0, S = (S << 11 | S >>> 21) + y | 0, _ += (S ^ y ^ w) + g[15] + 530742520 | 0, _ = (_ << 16 | _ >>> 16) + S | 0, w += (_ ^ S ^ y) + g[2] - 995338651 | 0, w = (w << 23 | w >>> 9) + _ | 0, y += (_ ^ (w | ~S)) + g[0] - 198630844 | 0, y = (y << 6 | y >>> 26) + w | 0, S += (w ^ (y | ~_)) + g[7] + 1126891415 | 0, S = (S << 10 | S >>> 22) + y | 0, _ += (y ^ (S | ~w)) + g[14] - 1416354905 | 0, _ = (_ << 15 | _ >>> 17) + S | 0, w += (S ^ (_ | ~y)) + g[5] - 57434055 | 0, w = (w << 21 | w >>> 11) + _ | 0, y += (_ ^ (w | ~S)) + g[12] + 1700485571 | 0, y = (y << 6 | y >>> 26) + w | 0, S += (w ^ (y | ~_)) + g[3] - 1894986606 | 0, S = (S << 10 | S >>> 22) + y | 0, _ += (y ^ (S | ~w)) + g[10] - 1051523 | 0, _ = (_ << 15 | _ >>> 17) + S | 0, w += (S ^ (_ | ~y)) + g[1] - 2054922799 | 0, w = (w << 21 | w >>> 11) + _ | 0, y += (_ ^ (w | ~S)) + g[8] + 1873313359 | 0, y = (y << 6 | y >>> 26) + w | 0, S += (w ^ (y | ~_)) + g[15] - 30611744 | 0, S = (S << 10 | S >>> 22) + y | 0, _ += (y ^ (S | ~w)) + g[6] - 1560198380 | 0, _ = (_ << 15 | _ >>> 17) + S | 0, w += (S ^ (_ | ~y)) + g[13] + 1309151649 | 0, w = (w << 21 | w >>> 11) + _ | 0, y += (_ ^ (w | ~S)) + g[4] - 145523070 | 0, y = (y << 6 | y >>> 26) + w | 0, S += (w ^ (y | ~_)) + g[11] - 1120210379 | 0, S = (S << 10 | S >>> 22) + y | 0, _ += (y ^ (S | ~w)) + g[2] + 718787259 | 0, _ = (_ << 15 | _ >>> 17) + S | 0, w += (S ^ (_ | ~y)) + g[9] - 343485551 | 0, w = (w << 21 | w >>> 11) + _ | 0, f[0] = y + f[0] | 0, f[1] = w + f[1] | 0, f[2] = _ + f[2] | 0, f[3] = S + f[3] | 0;
    }
    function s(f) {
      var g = [], y;
      for (y = 0; y < 64; y += 4)
        g[y >> 2] = f.charCodeAt(y) + (f.charCodeAt(y + 1) << 8) + (f.charCodeAt(y + 2) << 16) + (f.charCodeAt(y + 3) << 24);
      return g;
    }
    function o(f) {
      var g = [], y;
      for (y = 0; y < 64; y += 4)
        g[y >> 2] = f[y] + (f[y + 1] << 8) + (f[y + 2] << 16) + (f[y + 3] << 24);
      return g;
    }
    function a(f) {
      var g = f.length, y = [1732584193, -271733879, -1732584194, 271733878], w, _, S, A, C, k;
      for (w = 64; w <= g; w += 64)
        i(y, s(f.substring(w - 64, w)));
      for (f = f.substring(w - 64), _ = f.length, S = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], w = 0; w < _; w += 1)
        S[w >> 2] |= f.charCodeAt(w) << (w % 4 << 3);
      if (S[w >> 2] |= 128 << (w % 4 << 3), w > 55)
        for (i(y, S), w = 0; w < 16; w += 1)
          S[w] = 0;
      return A = g * 8, A = A.toString(16).match(/(.*?)(.{0,8})$/), C = parseInt(A[2], 16), k = parseInt(A[1], 16) || 0, S[14] = C, S[15] = k, i(y, S), y;
    }
    function l(f) {
      var g = f.length, y = [1732584193, -271733879, -1732584194, 271733878], w, _, S, A, C, k;
      for (w = 64; w <= g; w += 64)
        i(y, o(f.subarray(w - 64, w)));
      for (f = w - 64 < g ? f.subarray(w - 64) : new Uint8Array(0), _ = f.length, S = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], w = 0; w < _; w += 1)
        S[w >> 2] |= f[w] << (w % 4 << 3);
      if (S[w >> 2] |= 128 << (w % 4 << 3), w > 55)
        for (i(y, S), w = 0; w < 16; w += 1)
          S[w] = 0;
      return A = g * 8, A = A.toString(16).match(/(.*?)(.{0,8})$/), C = parseInt(A[2], 16), k = parseInt(A[1], 16) || 0, S[14] = C, S[15] = k, i(y, S), y;
    }
    function u(f) {
      var g = "", y;
      for (y = 0; y < 4; y += 1)
        g += r[f >> y * 8 + 4 & 15] + r[f >> y * 8 & 15];
      return g;
    }
    function c(f) {
      var g;
      for (g = 0; g < f.length; g += 1)
        f[g] = u(f[g]);
      return f.join("");
    }
    c(a("hello")), typeof ArrayBuffer < "u" && !ArrayBuffer.prototype.slice && function() {
      function f(g, y) {
        return g = g | 0 || 0, g < 0 ? Math.max(g + y, 0) : Math.min(g, y);
      }
      ArrayBuffer.prototype.slice = function(g, y) {
        var w = this.byteLength, _ = f(g, w), S = w, A, C, k, O;
        return y !== n && (S = f(y, w)), _ > S ? new ArrayBuffer(0) : (A = S - _, C = new ArrayBuffer(A), k = new Uint8Array(C), O = new Uint8Array(this, _, A), k.set(O), C);
      };
    }();
    function d(f) {
      return /[\u0080-\uFFFF]/.test(f) && (f = unescape(encodeURIComponent(f))), f;
    }
    function h(f, g) {
      var y = f.length, w = new ArrayBuffer(y), _ = new Uint8Array(w), S;
      for (S = 0; S < y; S += 1)
        _[S] = f.charCodeAt(S);
      return g ? _ : w;
    }
    function v(f) {
      return String.fromCharCode.apply(null, new Uint8Array(f));
    }
    function m(f, g, y) {
      var w = new Uint8Array(f.byteLength + g.byteLength);
      return w.set(new Uint8Array(f)), w.set(new Uint8Array(g), f.byteLength), y ? w : w.buffer;
    }
    function b(f) {
      var g = [], y = f.length, w;
      for (w = 0; w < y - 1; w += 2)
        g.push(parseInt(f.substr(w, 2), 16));
      return String.fromCharCode.apply(String, g);
    }
    function p() {
      this.reset();
    }
    return p.prototype.append = function(f) {
      return this.appendBinary(d(f)), this;
    }, p.prototype.appendBinary = function(f) {
      this._buff += f, this._length += f.length;
      var g = this._buff.length, y;
      for (y = 64; y <= g; y += 64)
        i(this._hash, s(this._buff.substring(y - 64, y)));
      return this._buff = this._buff.substring(y - 64), this;
    }, p.prototype.end = function(f) {
      var g = this._buff, y = g.length, w, _ = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], S;
      for (w = 0; w < y; w += 1)
        _[w >> 2] |= g.charCodeAt(w) << (w % 4 << 3);
      return this._finish(_, y), S = c(this._hash), f && (S = b(S)), this.reset(), S;
    }, p.prototype.reset = function() {
      return this._buff = "", this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this;
    }, p.prototype.getState = function() {
      return {
        buff: this._buff,
        length: this._length,
        hash: this._hash.slice()
      };
    }, p.prototype.setState = function(f) {
      return this._buff = f.buff, this._length = f.length, this._hash = f.hash, this;
    }, p.prototype.destroy = function() {
      delete this._hash, delete this._buff, delete this._length;
    }, p.prototype._finish = function(f, g) {
      var y = g, w, _, S;
      if (f[y >> 2] |= 128 << (y % 4 << 3), y > 55)
        for (i(this._hash, f), y = 0; y < 16; y += 1)
          f[y] = 0;
      w = this._length * 8, w = w.toString(16).match(/(.*?)(.{0,8})$/), _ = parseInt(w[2], 16), S = parseInt(w[1], 16) || 0, f[14] = _, f[15] = S, i(this._hash, f);
    }, p.hash = function(f, g) {
      return p.hashBinary(d(f), g);
    }, p.hashBinary = function(f, g) {
      var y = a(f), w = c(y);
      return g ? b(w) : w;
    }, p.ArrayBuffer = function() {
      this.reset();
    }, p.ArrayBuffer.prototype.append = function(f) {
      var g = m(this._buff.buffer, f, !0), y = g.length, w;
      for (this._length += f.byteLength, w = 64; w <= y; w += 64)
        i(this._hash, o(g.subarray(w - 64, w)));
      return this._buff = w - 64 < y ? new Uint8Array(g.buffer.slice(w - 64)) : new Uint8Array(0), this;
    }, p.ArrayBuffer.prototype.end = function(f) {
      var g = this._buff, y = g.length, w = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], _, S;
      for (_ = 0; _ < y; _ += 1)
        w[_ >> 2] |= g[_] << (_ % 4 << 3);
      return this._finish(w, y), S = c(this._hash), f && (S = b(S)), this.reset(), S;
    }, p.ArrayBuffer.prototype.reset = function() {
      return this._buff = new Uint8Array(0), this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this;
    }, p.ArrayBuffer.prototype.getState = function() {
      var f = p.prototype.getState.call(this);
      return f.buff = v(f.buff), f;
    }, p.ArrayBuffer.prototype.setState = function(f) {
      return f.buff = h(f.buff, !0), p.prototype.setState.call(this, f);
    }, p.ArrayBuffer.prototype.destroy = p.prototype.destroy, p.ArrayBuffer.prototype._finish = p.prototype._finish, p.ArrayBuffer.hash = function(f, g) {
      var y = l(new Uint8Array(f)), w = c(y);
      return g ? b(w) : w;
    }, p;
  });
})(UB);
const VB = [
  {
    date: "2018-10-20T16:00:00+00:00",
    creator: "陈浩基",
    creatorFileAs: "陈浩基",
    UUID: "DB108833-1D43-4711-A2D0-240E07B37352",
    language: "zh",
    title: "13.67",
    "calibre:timestamp": "2019-09-20T03:57:38.859000+00:00",
    "calibre:title_sort": "13.67",
    cover: "cover",
    id: "54a785173f1a484c02e53418730b24b5",
    coverPath: "/books/cover/13.67.jpg",
    url: "13.67.epub",
    bgColorFromCover: "#076184",
    size: 435507,
    from: "url",
    coverBase64: "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"
  }
], Xs = nw("reader", {
  state: () => ({
    theme: "default",
    flow: "paginated",
    font: "",
    lineSpacing: 1.5,
    fontSize: 100,
    bookList: VB
  }),
  actions: {
    setTheme(t) {
      this.theme = t;
    },
    reset() {
      this.theme = "default", this.flow = "paginated", this.font = "", this.lineSpacing = 1.5, this.fontSize = 100;
    },
    setBook(t, e) {
      const n = this.bookList.findIndex((r) => r.id === t);
      n > -1 && (this.bookList[n] = e);
    },
    addBook() {
    },
    delBook(t) {
      const e = this.bookList.findIndex((n) => t === n.id);
      e > -1 && this.bookList.splice(e, 1);
    }
  },
  persist: !0
});
const WB = { class: "image-slot" }, $B = { key: 0 }, KB = { key: 1 }, GB = { key: 2 }, qB = ["title"], JB = { key: 3 }, YB = { key: 4 }, QB = { key: 5 }, ZB = { key: 6 }, XB = {
  __name: "Home",
  props: {
    useMin: {
      type: Boolean,
      default: !1
    },
    maxCols: {
      type: Number,
      // Maximum number of colums. Default: Infinite
      default: 1 / 0
    }
  },
  emits: ["update:currentBook"],
  setup(t, { emit: e }) {
    const n = t, r = Xs();
    console.log("Imported Books: ", r.bookList.length);
    const i = r.bookList.sort((D, F) => D.lastOpen && F.lastOpen ? F.lastOpen - D.lastOpen : 1);
    console.log("Books: ", i);
    const { saveAs: s } = JD, o = K(null), a = K(null), l = Mn({
      maxColWidth: 280,
      gap: 32
    });
    let u = [];
    const { maxColWidth: c, gap: d } = pn(l), { useMin: h, maxCols: v } = n;
    Ct(async () => {
      i.length && (p(), f(), window.addEventListener("resize", A));
    }), xn(() => {
      window.removeEventListener("resize", A);
    });
    const m = (D, F) => D.length > F ? `${D.substr(0, F - 3)}...` : D, b = (D) => {
      const F = new Date(D), Z = F.getFullYear(), te = F.getMonth() + 1, L = F.getDay();
      return `${Z}-${te}-${L}`;
    }, p = () => {
      u = o.value.children, u.length !== 0 && (a.value.$el.style.position = "relative", Array.prototype.forEach.call(u, (D) => {
        D.style.position = "absolute", D.style.maxWidth = `${c.value}px`, D.style.transition = "top 0.2s ease, left 0.2s ease, right 0.2s ease, buttom 0.2s ease";
      }));
    }, f = () => {
      if (u.length === 0)
        return;
      let { cols: D, wSpace: F } = S();
      F = Math.floor(F / 2), Array.prototype.forEach.call(u, (Z, te) => {
        const L = g(D, te), V = L.index * y() + F;
        Z.style.left = `${V}px`, Z.style.top = `${L.height + L.top}px`, L.height += L.top + Z.getBoundingClientRect().height, L.top = d.value;
      }), a.value.$el.style.height = `${_(D).height}px`;
    }, g = (D, F) => h ? w(D) : D[F % D.length], y = () => u[0].getBoundingClientRect().width + d.value, w = (D) => {
      let F = D[0];
      return D.forEach((Z) => {
        Z.height < F.height && (F = Z);
      }), F;
    }, _ = (D) => {
      let F = D[0];
      return D.forEach((Z) => {
        Z.height > F.height && (F = Z);
      }), F;
    }, S = () => {
      const { width: D } = a.value.$el.getBoundingClientRect();
      let F = Math.floor(D / y()) || 1;
      const Z = [];
      v && F > v && (F = v);
      for (let L = 0; L < F; L += 1)
        Z[L] = {
          height: 0,
          top: 0,
          index: L
        };
      const te = D - F * y() + d.value;
      return {
        cols: Z,
        wSpace: te
      };
    }, A = () => {
      setTimeout(f(), 200);
    }, C = (D) => D / 1024 / 1024 > 1 ? parseFloat(D / 1024 / 1024 + "").toFixed(2) + "Mb" : parseInt(D / 1024 + "") + "Kb", k = (D) => {
      s("/books/" + D, D);
    }, O = (D) => {
      e("update:currentBook", D);
    }, N = async (D) => {
      const { raw: F, name: Z, size: te } = D, L = new FileReader();
      L.onerror = (V) => {
        console.log(V);
      }, L.onloadend = (V) => {
        console.log(L), e("update:currentBook", L.result);
      }, L.readAsArrayBuffer(F);
    }, B = (D) => {
      r.delBook(D);
    };
    return (D, F) => {
      const Z = rs, te = LD, L = _t, V = gR, H = G4, ie = da, ne = HN, Y = ey, de = Xm;
      return U(), xe(de, { direction: "vertical" }, {
        default: fe(() => [
          ve(Ey, {
            backdrop: "",
            shadow: ""
          }, {
            default: fe(() => [
              ve(te, {
                "auto-upload": !1,
                accept: ".epub",
                "on-change": N,
                multiple: !1,
                "show-file-list": !1
              }, {
                default: fe(() => [
                  ve(Z, {
                    size: "small",
                    icon: x(Fg),
                    circle: "",
                    title: "Add To Library"
                  }, null, 8, ["icon"])
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          ve(Y, {
            class: "main",
            ref_key: "main",
            ref: a
          }, {
            default: fe(() => [
              le("div", {
                class: "grid",
                ref_key: "grid",
                ref: o
              }, [
                (U(!0), oe(Ft, null, Yn(x(i), (ue, Te) => (U(), oe("div", { key: Te }, [
                  ve(ne, {
                    onClick: (_e) => O(ue),
                    ref_for: !0,
                    ref: "card",
                    shadow: "hover",
                    class: "box-card",
                    "body-style": { padding: "0px" }
                  }, {
                    default: fe(() => [
                      ve(V, {
                        lazy: !0,
                        src: "data:image/png;base64," + ue.coverBase64,
                        fit: "fill",
                        class: "el-image"
                      }, {
                        error: fe(() => [
                          le("div", WB, [
                            ve(L, null, {
                              default: fe(() => [
                                ve(x($C))
                              ]),
                              _: 1
                            })
                          ])
                        ]),
                        _: 2
                      }, 1032, ["src"]),
                      ve(ie, {
                        trigger: "hover",
                        placement: "right"
                      }, {
                        reference: fe(() => [
                          le("div", {
                            class: "title",
                            style: it({
                              background: ue.bgColorFromCover ? ue.bgColorFromCover : "#6d6d6d"
                            })
                          }, st(m(ue.title, 12)), 5)
                        ]),
                        default: fe(() => [
                          le("div", null, [
                            le("p", null, [
                              ve(Z, {
                                type: "primary",
                                round: "",
                                icon: x(rC),
                                onClick: (_e) => k(ue.url)
                              }, {
                                default: fe(() => [
                                  cn("Download")
                                ]),
                                _: 2
                              }, 1032, ["icon", "onClick"])
                            ]),
                            le("p", null, [
                              ve(Z, {
                                type: "primary",
                                round: "",
                                icon: x(zg),
                                onClick: (_e) => B(ue.id)
                              }, {
                                default: fe(() => [
                                  cn("Delete")
                                ]),
                                _: 2
                              }, 1032, ["icon", "onClick"])
                            ]),
                            ve(H),
                            ue.title ? (U(), oe("p", $B, "Title: " + st(ue.title), 1)) : me("", !0),
                            ue.creator ? (U(), oe("p", KB, "Creator: " + st(ue.creator), 1)) : me("", !0),
                            ue.description ? (U(), oe("p", GB, [
                              cn(" Description: "),
                              le("span", {
                                title: ue.description
                              }, st(m(ue.description, 30)), 9, qB)
                            ])) : me("", !0),
                            ue.publisher ? (U(), oe("p", JB, "Publisher: " + st(ue.publisher), 1)) : me("", !0),
                            ue.date ? (U(), oe("p", YB, " Pub Date: " + st(b(ue.date) || b(ue.publishDate)), 1)) : me("", !0),
                            ue.language ? (U(), oe("p", QB, "Language: " + st(ue.language), 1)) : me("", !0),
                            ue.size ? (U(), oe("p", ZB, "File Size: " + st(C(ue.size)), 1)) : me("", !0)
                          ])
                        ]),
                        _: 2
                      }, 1024)
                    ]),
                    _: 2
                  }, 1032, ["onClick"])
                ]))), 128))
              ], 512)
            ]),
            _: 1
          }, 512)
        ]),
        _: 1
      });
    };
  }
}, e8 = /* @__PURE__ */ is(XB, [["__scopeId", "data-v-e5f46eca"]]);
var Dl = {}, t8 = {
  get exports() {
    return Dl;
  },
  set exports(t) {
    Dl = t;
  }
}, hd = {}, n8 = {
  get exports() {
    return hd;
  },
  set exports(t) {
    hd = t;
  }
}, r8 = void 0, t0 = function(t) {
  return t !== r8 && t !== null;
}, i8 = t0, s8 = {
  object: !0,
  function: !0,
  undefined: !0
  /* document.all */
}, o8 = function(t) {
  return i8(t) ? hasOwnProperty.call(s8, typeof t) : !1;
}, a8 = o8, l8 = function(t) {
  if (!a8(t))
    return !1;
  try {
    return t.constructor ? t.constructor.prototype === t : !1;
  } catch {
    return !1;
  }
}, u8 = l8, c8 = function(t) {
  if (typeof t != "function" || !hasOwnProperty.call(t, "length"))
    return !1;
  try {
    if (typeof t.length != "number" || typeof t.call != "function" || typeof t.apply != "function")
      return !1;
  } catch {
    return !1;
  }
  return !u8(t);
}, d8 = c8, f8 = /^\s*class[\s{/}]/, h8 = Function.prototype.toString, p8 = function(t) {
  return !(!d8(t) || f8.test(h8.call(t)));
}, v8 = function() {
  var t = Object.assign, e;
  return typeof t != "function" ? !1 : (e = { foo: "raz" }, t(e, { bar: "dwa" }, { trzy: "trzy" }), e.foo + e.bar + e.trzy === "razdwatrzy");
}, Ju, ev;
function g8() {
  return ev || (ev = 1, Ju = function() {
    try {
      return Object.keys("primitive"), !0;
    } catch {
      return !1;
    }
  }), Ju;
}
var m8 = function() {
}, y8 = m8(), Nf = function(t) {
  return t !== y8 && t !== null;
}, Yu, tv;
function b8() {
  if (tv)
    return Yu;
  tv = 1;
  var t = Nf, e = Object.keys;
  return Yu = function(n) {
    return e(t(n) ? Object(n) : n);
  }, Yu;
}
var Qu, nv;
function w8() {
  return nv || (nv = 1, Qu = g8()() ? Object.keys : b8()), Qu;
}
var Zu, rv;
function _8() {
  if (rv)
    return Zu;
  rv = 1;
  var t = Nf;
  return Zu = function(e) {
    if (!t(e))
      throw new TypeError("Cannot use null or undefined");
    return e;
  }, Zu;
}
var Xu, iv;
function S8() {
  if (iv)
    return Xu;
  iv = 1;
  var t = w8(), e = _8(), n = Math.max;
  return Xu = function(r, i) {
    var s, o, a = n(arguments.length, 2), l;
    for (r = Object(e(r)), l = function(u) {
      try {
        r[u] = i[u];
      } catch (c) {
        s || (s = c);
      }
    }, o = 1; o < a; ++o)
      i = arguments[o], t(i).forEach(l);
    if (s !== void 0)
      throw s;
    return r;
  }, Xu;
}
var E8 = v8() ? Object.assign : S8(), x8 = Nf, A8 = Array.prototype.forEach, k8 = Object.create, C8 = function(t, e) {
  var n;
  for (n in t)
    e[n] = t[n];
}, T8 = function(t) {
  var e = k8(null);
  return A8.call(arguments, function(n) {
    x8(n) && C8(Object(n), e);
  }), e;
}, ec = "razdwatrzy", O8 = function() {
  return typeof ec.contains != "function" ? !1 : ec.contains("dwa") === !0 && ec.contains("foo") === !1;
}, tc, sv;
function I8() {
  if (sv)
    return tc;
  sv = 1;
  var t = String.prototype.indexOf;
  return tc = function(e) {
    return t.call(this, e, arguments[1]) > -1;
  }, tc;
}
var N8 = O8() ? String.prototype.contains : I8(), dl = t0, ov = p8, n0 = E8, r0 = T8, To = N8, R8 = n8.exports = function(t, e) {
  var n, r, i, s, o;
  return arguments.length < 2 || typeof t != "string" ? (s = e, e = t, t = null) : s = arguments[2], dl(t) ? (n = To.call(t, "c"), r = To.call(t, "e"), i = To.call(t, "w")) : (n = i = !0, r = !1), o = { value: e, configurable: n, enumerable: r, writable: i }, s ? n0(r0(s), o) : o;
};
R8.gs = function(t, e, n) {
  var r, i, s, o;
  return typeof t != "string" ? (s = n, n = e, e = t, t = null) : s = arguments[3], dl(e) ? ov(e) ? dl(n) ? ov(n) || (s = n, n = void 0) : n = void 0 : (s = e, e = n = void 0) : e = void 0, dl(t) ? (r = To.call(t, "c"), i = To.call(t, "e")) : (r = !0, i = !1), o = { get: e, set: n, configurable: r, enumerable: i }, s ? n0(r0(s), o) : o;
};
var P8 = function(t) {
  if (typeof t != "function")
    throw new TypeError(t + " is not a function");
  return t;
};
(function(t, e) {
  var n = hd, r = P8, i = Function.prototype.apply, s = Function.prototype.call, o = Object.create, a = Object.defineProperty, l = Object.defineProperties, u = Object.prototype.hasOwnProperty, c = { configurable: !0, enumerable: !1, writable: !0 }, d, h, v, m, b, p, f;
  d = function(g, y) {
    var w;
    return r(y), u.call(this, "__ee__") ? w = this.__ee__ : (w = c.value = o(null), a(this, "__ee__", c), c.value = null), w[g] ? typeof w[g] == "object" ? w[g].push(y) : w[g] = [w[g], y] : w[g] = y, this;
  }, h = function(g, y) {
    var w, _;
    return r(y), _ = this, d.call(this, g, w = function() {
      v.call(_, g, w), i.call(y, this, arguments);
    }), w.__eeOnceListener__ = y, this;
  }, v = function(g, y) {
    var w, _, S, A;
    if (r(y), !u.call(this, "__ee__"))
      return this;
    if (w = this.__ee__, !w[g])
      return this;
    if (_ = w[g], typeof _ == "object")
      for (A = 0; S = _[A]; ++A)
        (S === y || S.__eeOnceListener__ === y) && (_.length === 2 ? w[g] = _[A ? 0 : 1] : _.splice(A, 1));
    else
      (_ === y || _.__eeOnceListener__ === y) && delete w[g];
    return this;
  }, m = function(g) {
    var y, w, _, S, A;
    if (u.call(this, "__ee__") && (S = this.__ee__[g], !!S))
      if (typeof S == "object") {
        for (w = arguments.length, A = new Array(w - 1), y = 1; y < w; ++y)
          A[y - 1] = arguments[y];
        for (S = S.slice(), y = 0; _ = S[y]; ++y)
          i.call(_, this, A);
      } else
        switch (arguments.length) {
          case 1:
            s.call(S, this);
            break;
          case 2:
            s.call(S, this, arguments[1]);
            break;
          case 3:
            s.call(S, this, arguments[1], arguments[2]);
            break;
          default:
            for (w = arguments.length, A = new Array(w - 1), y = 1; y < w; ++y)
              A[y - 1] = arguments[y];
            i.call(S, this, A);
        }
  }, b = {
    on: d,
    once: h,
    off: v,
    emit: m
  }, p = {
    on: n(d),
    once: n(h),
    off: n(v),
    emit: n(m)
  }, f = l({}, p), t.exports = e = function(g) {
    return g == null ? o(f) : l(Object(g), p);
  }, e.methods = b;
})(t8, Dl);
const Vr = Dl;
var Oi = {}, Ii = {};
function D8(t, e, n) {
  if (n === void 0 && (n = Array.prototype), t && typeof n.find == "function")
    return n.find.call(t, e);
  for (var r = 0; r < t.length; r++)
    if (Object.prototype.hasOwnProperty.call(t, r)) {
      var i = t[r];
      if (e.call(void 0, i, r, t))
        return i;
    }
}
function Rf(t, e) {
  return e === void 0 && (e = Object), e && typeof e.freeze == "function" ? e.freeze(t) : t;
}
var i0 = Rf({
  /**
   * `text/html`, the only mime type that triggers treating an XML document as HTML.
   *
   * @see DOMParser.SupportedType.isHTML
   * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/HTML Wikipedia
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
   * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
   */
  HTML: "text/html",
  /**
   * Helper method to check a mime type if it indicates an HTML document
   *
   * @param {string} [value]
   * @returns {boolean}
   *
   * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/HTML Wikipedia
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
   * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
  isHTML: function(t) {
    return t === i0.HTML;
  },
  /**
   * `application/xml`, the standard mime type for XML documents.
   *
   * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
   * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
   * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
   */
  XML_APPLICATION: "application/xml",
  /**
   * `text/html`, an alias for `application/xml`.
   *
   * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
   * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
   */
  XML_TEXT: "text/xml",
  /**
   * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
   * but is parsed as an XML document.
   *
   * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
   * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
   */
  XML_XHTML_APPLICATION: "application/xhtml+xml",
  /**
   * `image/svg+xml`,
   *
   * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
   * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
   * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
   */
  XML_SVG_IMAGE: "image/svg+xml"
}), s0 = Rf({
  /**
   * The XHTML namespace.
   *
   * @see http://www.w3.org/1999/xhtml
   */
  HTML: "http://www.w3.org/1999/xhtml",
  /**
   * Checks if `uri` equals `NAMESPACE.HTML`.
   *
   * @param {string} [uri]
   *
   * @see NAMESPACE.HTML
   */
  isHTML: function(t) {
    return t === s0.HTML;
  },
  /**
   * The SVG namespace.
   *
   * @see http://www.w3.org/2000/svg
   */
  SVG: "http://www.w3.org/2000/svg",
  /**
   * The `xml:` namespace.
   *
   * @see http://www.w3.org/XML/1998/namespace
   */
  XML: "http://www.w3.org/XML/1998/namespace",
  /**
   * The `xmlns:` namespace
   *
   * @see https://www.w3.org/2000/xmlns/
   */
  XMLNS: "http://www.w3.org/2000/xmlns/"
});
Ii.find = D8;
Ii.freeze = Rf;
Ii.MIME_TYPE = i0;
Ii.NAMESPACE = s0;
var o0 = Ii, Nr = o0.find, qo = o0.NAMESPACE;
function B8(t) {
  return t !== "";
}
function M8(t) {
  return t ? t.split(/[\t\n\f\r ]+/).filter(B8) : [];
}
function L8(t, e) {
  return t.hasOwnProperty(e) || (t[e] = !0), t;
}
function av(t) {
  if (!t)
    return [];
  var e = M8(t);
  return Object.keys(e.reduce(L8, {}));
}
function z8(t) {
  return function(e) {
    return t && t.indexOf(e) !== -1;
  };
}
function va(t, e) {
  for (var n in t)
    Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
}
function Wn(t, e) {
  var n = t.prototype;
  if (!(n instanceof e)) {
    let r = function() {
    };
    r.prototype = e.prototype, r = new r(), va(n, r), t.prototype = n = r;
  }
  n.constructor != t && (typeof t != "function" && console.error("unknown Class:" + t), n.constructor = t);
}
var $n = {}, wr = $n.ELEMENT_NODE = 1, Ws = $n.ATTRIBUTE_NODE = 2, Bl = $n.TEXT_NODE = 3, a0 = $n.CDATA_SECTION_NODE = 4, l0 = $n.ENTITY_REFERENCE_NODE = 5, j8 = $n.ENTITY_NODE = 6, u0 = $n.PROCESSING_INSTRUCTION_NODE = 7, c0 = $n.COMMENT_NODE = 8, d0 = $n.DOCUMENT_NODE = 9, f0 = $n.DOCUMENT_TYPE_NODE = 10, oi = $n.DOCUMENT_FRAGMENT_NODE = 11, F8 = $n.NOTATION_NODE = 12, Nn = {}, vn = {};
Nn.INDEX_SIZE_ERR = (vn[1] = "Index size error", 1);
Nn.DOMSTRING_SIZE_ERR = (vn[2] = "DOMString size error", 2);
var jn = Nn.HIERARCHY_REQUEST_ERR = (vn[3] = "Hierarchy request error", 3);
Nn.WRONG_DOCUMENT_ERR = (vn[4] = "Wrong document", 4);
Nn.INVALID_CHARACTER_ERR = (vn[5] = "Invalid character", 5);
Nn.NO_DATA_ALLOWED_ERR = (vn[6] = "No data allowed", 6);
Nn.NO_MODIFICATION_ALLOWED_ERR = (vn[7] = "No modification allowed", 7);
var h0 = Nn.NOT_FOUND_ERR = (vn[8] = "Not found", 8);
Nn.NOT_SUPPORTED_ERR = (vn[9] = "Not supported", 9);
var lv = Nn.INUSE_ATTRIBUTE_ERR = (vn[10] = "Attribute in use", 10);
Nn.INVALID_STATE_ERR = (vn[11] = "Invalid state", 11);
Nn.SYNTAX_ERR = (vn[12] = "Syntax error", 12);
Nn.INVALID_MODIFICATION_ERR = (vn[13] = "Invalid modification", 13);
Nn.NAMESPACE_ERR = (vn[14] = "Invalid namespace", 14);
Nn.INVALID_ACCESS_ERR = (vn[15] = "Invalid access", 15);
function tn(t, e) {
  if (e instanceof Error)
    var n = e;
  else
    n = this, Error.call(this, vn[t]), this.message = vn[t], Error.captureStackTrace && Error.captureStackTrace(this, tn);
  return n.code = t, e && (this.message = this.message + ": " + e), n;
}
tn.prototype = Error.prototype;
va(Nn, tn);
function ti() {
}
ti.prototype = {
  /**
   * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
   * @standard level1
   */
  length: 0,
  /**
   * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
   * @standard level1
   * @param index  unsigned long
   *   Index into the collection.
   * @return Node
   * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
   */
  item: function(t) {
    return this[t] || null;
  },
  toString: function(t, e) {
    for (var n = [], r = 0; r < this.length; r++)
      Ts(this[r], n, t, e);
    return n.join("");
  },
  /**
   * @private
   * @param {function (Node):boolean} predicate
   * @returns {Node[]}
   */
  filter: function(t) {
    return Array.prototype.filter.call(this, t);
  },
  /**
   * @private
   * @param {Node} item
   * @returns {number}
   */
  indexOf: function(t) {
    return Array.prototype.indexOf.call(this, t);
  }
};
function $s(t, e) {
  this._node = t, this._refresh = e, Pf(this);
}
function Pf(t) {
  var e = t._node._inc || t._node.ownerDocument._inc;
  if (t._inc != e) {
    var n = t._refresh(t._node);
    A0(t, "length", n.length), va(n, t), t._inc = e;
  }
}
$s.prototype.item = function(t) {
  return Pf(this), this[t];
};
Wn($s, ti);
function Ml() {
}
function p0(t, e) {
  for (var n = t.length; n--; )
    if (t[n] === e)
      return n;
}
function uv(t, e, n, r) {
  if (r ? e[p0(e, r)] = n : e[e.length++] = n, t) {
    n.ownerElement = t;
    var i = t.ownerDocument;
    i && (r && m0(i, t, r), H8(i, t, n));
  }
}
function cv(t, e, n) {
  var r = p0(e, n);
  if (r >= 0) {
    for (var i = e.length - 1; r < i; )
      e[r] = e[++r];
    if (e.length = i, t) {
      var s = t.ownerDocument;
      s && (m0(s, t, n), n.ownerElement = null);
    }
  } else
    throw new tn(h0, new Error(t.tagName + "@" + n));
}
Ml.prototype = {
  length: 0,
  item: ti.prototype.item,
  getNamedItem: function(t) {
    for (var e = this.length; e--; ) {
      var n = this[e];
      if (n.nodeName == t)
        return n;
    }
  },
  setNamedItem: function(t) {
    var e = t.ownerElement;
    if (e && e != this._ownerElement)
      throw new tn(lv);
    var n = this.getNamedItem(t.nodeName);
    return uv(this._ownerElement, this, t, n), n;
  },
  /* returns Node */
  setNamedItemNS: function(t) {
    var e = t.ownerElement, n;
    if (e && e != this._ownerElement)
      throw new tn(lv);
    return n = this.getNamedItemNS(t.namespaceURI, t.localName), uv(this._ownerElement, this, t, n), n;
  },
  /* returns Node */
  removeNamedItem: function(t) {
    var e = this.getNamedItem(t);
    return cv(this._ownerElement, this, e), e;
  },
  // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
  //for level2
  removeNamedItemNS: function(t, e) {
    var n = this.getNamedItemNS(t, e);
    return cv(this._ownerElement, this, n), n;
  },
  getNamedItemNS: function(t, e) {
    for (var n = this.length; n--; ) {
      var r = this[n];
      if (r.localName == e && r.namespaceURI == t)
        return r;
    }
    return null;
  }
};
function v0() {
}
v0.prototype = {
  /**
   * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
   * The different implementations fairly diverged in what kind of features were reported.
   * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
   *
   * @deprecated It is deprecated and modern browsers return true in all cases.
   *
   * @param {string} feature
   * @param {string} [version]
   * @returns {boolean} always true
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
   * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
   */
  hasFeature: function(t, e) {
    return !0;
  },
  /**
   * Creates an XML Document object of the specified type with its document element.
   *
   * __It behaves slightly different from the description in the living standard__:
   * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
   * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
   * - this implementation is not validating names or qualified names
   *   (when parsing XML strings, the SAX parser takes care of that)
   *
   * @param {string|null} namespaceURI
   * @param {string} qualifiedName
   * @param {DocumentType=null} doctype
   * @returns {Document}
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
   * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
   *
   * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
   * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
   * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
   */
  createDocument: function(t, e, n) {
    var r = new ga();
    if (r.implementation = this, r.childNodes = new ti(), r.doctype = n || null, n && r.appendChild(n), e) {
      var i = r.createElementNS(t, e);
      r.appendChild(i);
    }
    return r;
  },
  /**
   * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
   *
   * __This behavior is slightly different from the in the specs__:
   * - this implementation is not validating names or qualified names
   *   (when parsing XML strings, the SAX parser takes care of that)
   *
   * @param {string} qualifiedName
   * @param {string} [publicId]
   * @param {string} [systemId]
   * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
   * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
   * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
   *
   * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
   * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
   * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
   */
  createDocumentType: function(t, e, n) {
    var r = new vu();
    return r.name = t, r.nodeName = t, r.publicId = e || "", r.systemId = n || "", r;
  }
};
function It() {
}
It.prototype = {
  firstChild: null,
  lastChild: null,
  previousSibling: null,
  nextSibling: null,
  attributes: null,
  parentNode: null,
  childNodes: null,
  ownerDocument: null,
  nodeValue: null,
  namespaceURI: null,
  prefix: null,
  localName: null,
  // Modified in DOM Level 2:
  insertBefore: function(t, e) {
    return Ll(this, t, e);
  },
  replaceChild: function(t, e) {
    Ll(this, t, e, b0), e && this.removeChild(e);
  },
  removeChild: function(t) {
    return y0(this, t);
  },
  appendChild: function(t) {
    return this.insertBefore(t, null);
  },
  hasChildNodes: function() {
    return this.firstChild != null;
  },
  cloneNode: function(t) {
    return pd(this.ownerDocument || this, this, t);
  },
  // Modified in DOM Level 2:
  normalize: function() {
    for (var t = this.firstChild; t; ) {
      var e = t.nextSibling;
      e && e.nodeType == Bl && t.nodeType == Bl ? (this.removeChild(e), t.appendData(e.data)) : (t.normalize(), t = e);
    }
  },
  // Introduced in DOM Level 2:
  isSupported: function(t, e) {
    return this.ownerDocument.implementation.hasFeature(t, e);
  },
  // Introduced in DOM Level 2:
  hasAttributes: function() {
    return this.attributes.length > 0;
  },
  /**
   * Look up the prefix associated to the given namespace URI, starting from this node.
   * **The default namespace declarations are ignored by this method.**
   * See Namespace Prefix Lookup for details on the algorithm used by this method.
   *
   * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
   *
   * @param {string | null} namespaceURI
   * @returns {string | null}
   * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
   * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
   * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
   * @see https://github.com/xmldom/xmldom/issues/322
   */
  lookupPrefix: function(t) {
    for (var e = this; e; ) {
      var n = e._nsMap;
      if (n) {
        for (var r in n)
          if (Object.prototype.hasOwnProperty.call(n, r) && n[r] === t)
            return r;
      }
      e = e.nodeType == Ws ? e.ownerDocument : e.parentNode;
    }
    return null;
  },
  // Introduced in DOM Level 3:
  lookupNamespaceURI: function(t) {
    for (var e = this; e; ) {
      var n = e._nsMap;
      if (n && t in n && Object.prototype.hasOwnProperty.call(n, t))
        return n[t];
      e = e.nodeType == Ws ? e.ownerDocument : e.parentNode;
    }
    return null;
  },
  // Introduced in DOM Level 3:
  isDefaultNamespace: function(t) {
    var e = this.lookupPrefix(t);
    return e == null;
  }
};
function g0(t) {
  return t == "<" && "&lt;" || t == ">" && "&gt;" || t == "&" && "&amp;" || t == '"' && "&quot;" || "&#" + t.charCodeAt() + ";";
}
va($n, It);
va($n, It.prototype);
function Jo(t, e) {
  if (e(t))
    return !0;
  if (t = t.firstChild)
    do
      if (Jo(t, e))
        return !0;
    while (t = t.nextSibling);
}
function ga() {
  this.ownerDocument = this;
}
function H8(t, e, n) {
  t && t._inc++;
  var r = n.namespaceURI;
  r === qo.XMLNS && (e._nsMap[n.prefix ? n.localName : ""] = n.value);
}
function m0(t, e, n, r) {
  t && t._inc++;
  var i = n.namespaceURI;
  i === qo.XMLNS && delete e._nsMap[n.prefix ? n.localName : ""];
}
function Df(t, e, n) {
  if (t && t._inc) {
    t._inc++;
    var r = e.childNodes;
    if (n)
      r[r.length++] = n;
    else {
      for (var i = e.firstChild, s = 0; i; )
        r[s++] = i, i = i.nextSibling;
      r.length = s, delete r[r.length];
    }
  }
}
function y0(t, e) {
  var n = e.previousSibling, r = e.nextSibling;
  return n ? n.nextSibling = r : t.firstChild = r, r ? r.previousSibling = n : t.lastChild = n, e.parentNode = null, e.previousSibling = null, e.nextSibling = null, Df(t.ownerDocument, t), e;
}
function U8(t) {
  return t && (t.nodeType === It.DOCUMENT_NODE || t.nodeType === It.DOCUMENT_FRAGMENT_NODE || t.nodeType === It.ELEMENT_NODE);
}
function V8(t) {
  return t && (Rr(t) || Bf(t) || ai(t) || t.nodeType === It.DOCUMENT_FRAGMENT_NODE || t.nodeType === It.COMMENT_NODE || t.nodeType === It.PROCESSING_INSTRUCTION_NODE);
}
function ai(t) {
  return t && t.nodeType === It.DOCUMENT_TYPE_NODE;
}
function Rr(t) {
  return t && t.nodeType === It.ELEMENT_NODE;
}
function Bf(t) {
  return t && t.nodeType === It.TEXT_NODE;
}
function dv(t, e) {
  var n = t.childNodes || [];
  if (Nr(n, Rr) || ai(e))
    return !1;
  var r = Nr(n, ai);
  return !(e && r && n.indexOf(r) > n.indexOf(e));
}
function fv(t, e) {
  var n = t.childNodes || [];
  function r(s) {
    return Rr(s) && s !== e;
  }
  if (Nr(n, r))
    return !1;
  var i = Nr(n, ai);
  return !(e && i && n.indexOf(i) > n.indexOf(e));
}
function W8(t, e, n) {
  if (!U8(t))
    throw new tn(jn, "Unexpected parent node type " + t.nodeType);
  if (n && n.parentNode !== t)
    throw new tn(h0, "child not in parent");
  if (
    // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
    !V8(e) || // 5. If either `node` is a Text node and `parent` is a document,
    // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
    // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
    // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
    ai(e) && t.nodeType !== It.DOCUMENT_NODE
  )
    throw new tn(
      jn,
      "Unexpected node type " + e.nodeType + " for parent node type " + t.nodeType
    );
}
function $8(t, e, n) {
  var r = t.childNodes || [], i = e.childNodes || [];
  if (e.nodeType === It.DOCUMENT_FRAGMENT_NODE) {
    var s = i.filter(Rr);
    if (s.length > 1 || Nr(i, Bf))
      throw new tn(jn, "More than one element or text in fragment");
    if (s.length === 1 && !dv(t, n))
      throw new tn(jn, "Element in fragment can not be inserted before doctype");
  }
  if (Rr(e) && !dv(t, n))
    throw new tn(jn, "Only one element can be added and only after doctype");
  if (ai(e)) {
    if (Nr(r, ai))
      throw new tn(jn, "Only one doctype is allowed");
    var o = Nr(r, Rr);
    if (n && r.indexOf(o) < r.indexOf(n))
      throw new tn(jn, "Doctype can only be inserted before an element");
    if (!n && o)
      throw new tn(jn, "Doctype can not be appended since element is present");
  }
}
function b0(t, e, n) {
  var r = t.childNodes || [], i = e.childNodes || [];
  if (e.nodeType === It.DOCUMENT_FRAGMENT_NODE) {
    var s = i.filter(Rr);
    if (s.length > 1 || Nr(i, Bf))
      throw new tn(jn, "More than one element or text in fragment");
    if (s.length === 1 && !fv(t, n))
      throw new tn(jn, "Element in fragment can not be inserted before doctype");
  }
  if (Rr(e) && !fv(t, n))
    throw new tn(jn, "Only one element can be added and only after doctype");
  if (ai(e)) {
    if (Nr(r, function(l) {
      return ai(l) && l !== n;
    }))
      throw new tn(jn, "Only one doctype is allowed");
    var o = Nr(r, Rr);
    if (n && r.indexOf(o) < r.indexOf(n))
      throw new tn(jn, "Doctype can only be inserted before an element");
  }
}
function Ll(t, e, n, r) {
  W8(t, e, n), t.nodeType === It.DOCUMENT_NODE && (r || $8)(t, e, n);
  var i = e.parentNode;
  if (i && i.removeChild(e), e.nodeType === oi) {
    var s = e.firstChild;
    if (s == null)
      return e;
    var o = e.lastChild;
  } else
    s = o = e;
  var a = n ? n.previousSibling : t.lastChild;
  s.previousSibling = a, o.nextSibling = n, a ? a.nextSibling = s : t.firstChild = s, n == null ? t.lastChild = o : n.previousSibling = o;
  do
    s.parentNode = t;
  while (s !== o && (s = s.nextSibling));
  return Df(t.ownerDocument || t, t), e.nodeType == oi && (e.firstChild = e.lastChild = null), e;
}
function K8(t, e) {
  return e.parentNode && e.parentNode.removeChild(e), e.parentNode = t, e.previousSibling = t.lastChild, e.nextSibling = null, e.previousSibling ? e.previousSibling.nextSibling = e : t.firstChild = e, t.lastChild = e, Df(t.ownerDocument, t, e), e;
}
ga.prototype = {
  //implementation : null,
  nodeName: "#document",
  nodeType: d0,
  /**
   * The DocumentType node of the document.
   *
   * @readonly
   * @type DocumentType
   */
  doctype: null,
  documentElement: null,
  _inc: 1,
  insertBefore: function(t, e) {
    if (t.nodeType == oi) {
      for (var n = t.firstChild; n; ) {
        var r = n.nextSibling;
        this.insertBefore(n, e), n = r;
      }
      return t;
    }
    return Ll(this, t, e), t.ownerDocument = this, this.documentElement === null && t.nodeType === wr && (this.documentElement = t), t;
  },
  removeChild: function(t) {
    return this.documentElement == t && (this.documentElement = null), y0(this, t);
  },
  replaceChild: function(t, e) {
    Ll(this, t, e, b0), t.ownerDocument = this, e && this.removeChild(e), Rr(t) && (this.documentElement = t);
  },
  // Introduced in DOM Level 2:
  importNode: function(t, e) {
    return x0(this, t, e);
  },
  // Introduced in DOM Level 2:
  getElementById: function(t) {
    var e = null;
    return Jo(this.documentElement, function(n) {
      if (n.nodeType == wr && n.getAttribute("id") == t)
        return e = n, !0;
    }), e;
  },
  /**
   * The `getElementsByClassName` method of `Document` interface returns an array-like object
   * of all child elements which have **all** of the given class name(s).
   *
   * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
   *
   *
   * Warning: This is a live LiveNodeList.
   * Changes in the DOM will reflect in the array as the changes occur.
   * If an element selected by this array no longer qualifies for the selector,
   * it will automatically be removed. Be aware of this for iteration purposes.
   *
   * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
   * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
   */
  getElementsByClassName: function(t) {
    var e = av(t);
    return new $s(this, function(n) {
      var r = [];
      return e.length > 0 && Jo(n.documentElement, function(i) {
        if (i !== n && i.nodeType === wr) {
          var s = i.getAttribute("class");
          if (s) {
            var o = t === s;
            if (!o) {
              var a = av(s);
              o = e.every(z8(a));
            }
            o && r.push(i);
          }
        }
      }), r;
    });
  },
  //document factory method:
  createElement: function(t) {
    var e = new Qi();
    e.ownerDocument = this, e.nodeName = t, e.tagName = t, e.localName = t, e.childNodes = new ti();
    var n = e.attributes = new Ml();
    return n._ownerElement = e, e;
  },
  createDocumentFragment: function() {
    var t = new gu();
    return t.ownerDocument = this, t.childNodes = new ti(), t;
  },
  createTextNode: function(t) {
    var e = new Mf();
    return e.ownerDocument = this, e.appendData(t), e;
  },
  createComment: function(t) {
    var e = new Lf();
    return e.ownerDocument = this, e.appendData(t), e;
  },
  createCDATASection: function(t) {
    var e = new zf();
    return e.ownerDocument = this, e.appendData(t), e;
  },
  createProcessingInstruction: function(t, e) {
    var n = new Ff();
    return n.ownerDocument = this, n.tagName = n.target = t, n.nodeValue = n.data = e, n;
  },
  createAttribute: function(t) {
    var e = new zl();
    return e.ownerDocument = this, e.name = t, e.nodeName = t, e.localName = t, e.specified = !0, e;
  },
  createEntityReference: function(t) {
    var e = new jf();
    return e.ownerDocument = this, e.nodeName = t, e;
  },
  // Introduced in DOM Level 2:
  createElementNS: function(t, e) {
    var n = new Qi(), r = e.split(":"), i = n.attributes = new Ml();
    return n.childNodes = new ti(), n.ownerDocument = this, n.nodeName = e, n.tagName = e, n.namespaceURI = t, r.length == 2 ? (n.prefix = r[0], n.localName = r[1]) : n.localName = e, i._ownerElement = n, n;
  },
  // Introduced in DOM Level 2:
  createAttributeNS: function(t, e) {
    var n = new zl(), r = e.split(":");
    return n.ownerDocument = this, n.nodeName = e, n.name = e, n.namespaceURI = t, n.specified = !0, r.length == 2 ? (n.prefix = r[0], n.localName = r[1]) : n.localName = e, n;
  }
};
Wn(ga, It);
function Qi() {
  this._nsMap = {};
}
Qi.prototype = {
  nodeType: wr,
  hasAttribute: function(t) {
    return this.getAttributeNode(t) != null;
  },
  getAttribute: function(t) {
    var e = this.getAttributeNode(t);
    return e && e.value || "";
  },
  getAttributeNode: function(t) {
    return this.attributes.getNamedItem(t);
  },
  setAttribute: function(t, e) {
    var n = this.ownerDocument.createAttribute(t);
    n.value = n.nodeValue = "" + e, this.setAttributeNode(n);
  },
  removeAttribute: function(t) {
    var e = this.getAttributeNode(t);
    e && this.removeAttributeNode(e);
  },
  //four real opeartion method
  appendChild: function(t) {
    return t.nodeType === oi ? this.insertBefore(t, null) : K8(this, t);
  },
  setAttributeNode: function(t) {
    return this.attributes.setNamedItem(t);
  },
  setAttributeNodeNS: function(t) {
    return this.attributes.setNamedItemNS(t);
  },
  removeAttributeNode: function(t) {
    return this.attributes.removeNamedItem(t.nodeName);
  },
  //get real attribute name,and remove it by removeAttributeNode
  removeAttributeNS: function(t, e) {
    var n = this.getAttributeNodeNS(t, e);
    n && this.removeAttributeNode(n);
  },
  hasAttributeNS: function(t, e) {
    return this.getAttributeNodeNS(t, e) != null;
  },
  getAttributeNS: function(t, e) {
    var n = this.getAttributeNodeNS(t, e);
    return n && n.value || "";
  },
  setAttributeNS: function(t, e, n) {
    var r = this.ownerDocument.createAttributeNS(t, e);
    r.value = r.nodeValue = "" + n, this.setAttributeNode(r);
  },
  getAttributeNodeNS: function(t, e) {
    return this.attributes.getNamedItemNS(t, e);
  },
  getElementsByTagName: function(t) {
    return new $s(this, function(e) {
      var n = [];
      return Jo(e, function(r) {
        r !== e && r.nodeType == wr && (t === "*" || r.tagName == t) && n.push(r);
      }), n;
    });
  },
  getElementsByTagNameNS: function(t, e) {
    return new $s(this, function(n) {
      var r = [];
      return Jo(n, function(i) {
        i !== n && i.nodeType === wr && (t === "*" || i.namespaceURI === t) && (e === "*" || i.localName == e) && r.push(i);
      }), r;
    });
  }
};
ga.prototype.getElementsByTagName = Qi.prototype.getElementsByTagName;
ga.prototype.getElementsByTagNameNS = Qi.prototype.getElementsByTagNameNS;
Wn(Qi, It);
function zl() {
}
zl.prototype.nodeType = Ws;
Wn(zl, It);
function ma() {
}
ma.prototype = {
  data: "",
  substringData: function(t, e) {
    return this.data.substring(t, t + e);
  },
  appendData: function(t) {
    t = this.data + t, this.nodeValue = this.data = t, this.length = t.length;
  },
  insertData: function(t, e) {
    this.replaceData(t, 0, e);
  },
  appendChild: function(t) {
    throw new Error(vn[jn]);
  },
  deleteData: function(t, e) {
    this.replaceData(t, e, "");
  },
  replaceData: function(t, e, n) {
    var r = this.data.substring(0, t), i = this.data.substring(t + e);
    n = r + n + i, this.nodeValue = this.data = n, this.length = n.length;
  }
};
Wn(ma, It);
function Mf() {
}
Mf.prototype = {
  nodeName: "#text",
  nodeType: Bl,
  splitText: function(t) {
    var e = this.data, n = e.substring(t);
    e = e.substring(0, t), this.data = this.nodeValue = e, this.length = e.length;
    var r = this.ownerDocument.createTextNode(n);
    return this.parentNode && this.parentNode.insertBefore(r, this.nextSibling), r;
  }
};
Wn(Mf, ma);
function Lf() {
}
Lf.prototype = {
  nodeName: "#comment",
  nodeType: c0
};
Wn(Lf, ma);
function zf() {
}
zf.prototype = {
  nodeName: "#cdata-section",
  nodeType: a0
};
Wn(zf, ma);
function vu() {
}
vu.prototype.nodeType = f0;
Wn(vu, It);
function w0() {
}
w0.prototype.nodeType = F8;
Wn(w0, It);
function _0() {
}
_0.prototype.nodeType = j8;
Wn(_0, It);
function jf() {
}
jf.prototype.nodeType = l0;
Wn(jf, It);
function gu() {
}
gu.prototype.nodeName = "#document-fragment";
gu.prototype.nodeType = oi;
Wn(gu, It);
function Ff() {
}
Ff.prototype.nodeType = u0;
Wn(Ff, It);
function S0() {
}
S0.prototype.serializeToString = function(t, e, n) {
  return E0.call(t, e, n);
};
It.prototype.toString = E0;
function E0(t, e) {
  var n = [], r = this.nodeType == 9 && this.documentElement || this, i = r.prefix, s = r.namespaceURI;
  if (s && i == null) {
    var i = r.lookupPrefix(s);
    if (i == null)
      var o = [
        { namespace: s, prefix: null }
        //{namespace:uri,prefix:''}
      ];
  }
  return Ts(this, n, t, e, o), n.join("");
}
function hv(t, e, n) {
  var r = t.prefix || "", i = t.namespaceURI;
  if (!i || r === "xml" && i === qo.XML || i === qo.XMLNS)
    return !1;
  for (var s = n.length; s--; ) {
    var o = n[s];
    if (o.prefix === r)
      return o.namespace !== i;
  }
  return !0;
}
function nc(t, e, n) {
  t.push(" ", e, '="', n.replace(/[<&"]/g, g0), '"');
}
function Ts(t, e, n, r, i) {
  if (i || (i = []), r)
    if (t = r(t), t) {
      if (typeof t == "string") {
        e.push(t);
        return;
      }
    } else
      return;
  switch (t.nodeType) {
    case wr:
      var s = t.attributes, o = s.length, f = t.firstChild, a = t.tagName;
      n = qo.isHTML(t.namespaceURI) || n;
      var l = a;
      if (!n && !t.prefix && t.namespaceURI) {
        for (var u, c = 0; c < s.length; c++)
          if (s.item(c).name === "xmlns") {
            u = s.item(c).value;
            break;
          }
        if (!u)
          for (var d = i.length - 1; d >= 0; d--) {
            var h = i[d];
            if (h.prefix === "" && h.namespace === t.namespaceURI) {
              u = h.namespace;
              break;
            }
          }
        if (u !== t.namespaceURI)
          for (var d = i.length - 1; d >= 0; d--) {
            var h = i[d];
            if (h.namespace === t.namespaceURI) {
              h.prefix && (l = h.prefix + ":" + a);
              break;
            }
          }
      }
      e.push("<", l);
      for (var v = 0; v < o; v++) {
        var m = s.item(v);
        m.prefix == "xmlns" ? i.push({ prefix: m.localName, namespace: m.value }) : m.nodeName == "xmlns" && i.push({ prefix: "", namespace: m.value });
      }
      for (var v = 0; v < o; v++) {
        var m = s.item(v);
        if (hv(m, n, i)) {
          var b = m.prefix || "", p = m.namespaceURI;
          nc(e, b ? "xmlns:" + b : "xmlns", p), i.push({ prefix: b, namespace: p });
        }
        Ts(m, e, n, r, i);
      }
      if (a === l && hv(t, n, i)) {
        var b = t.prefix || "", p = t.namespaceURI;
        nc(e, b ? "xmlns:" + b : "xmlns", p), i.push({ prefix: b, namespace: p });
      }
      if (f || n && !/^(?:meta|link|img|br|hr|input)$/i.test(a)) {
        if (e.push(">"), n && /^script$/i.test(a))
          for (; f; )
            f.data ? e.push(f.data) : Ts(f, e, n, r, i.slice()), f = f.nextSibling;
        else
          for (; f; )
            Ts(f, e, n, r, i.slice()), f = f.nextSibling;
        e.push("</", l, ">");
      } else
        e.push("/>");
      return;
    case d0:
    case oi:
      for (var f = t.firstChild; f; )
        Ts(f, e, n, r, i.slice()), f = f.nextSibling;
      return;
    case Ws:
      return nc(e, t.name, t.value);
    case Bl:
      return e.push(
        t.data.replace(/[<&]/g, g0).replace(/]]>/g, "]]&gt;")
      );
    case a0:
      return e.push("<![CDATA[", t.data, "]]>");
    case c0:
      return e.push("<!--", t.data, "-->");
    case f0:
      var g = t.publicId, y = t.systemId;
      if (e.push("<!DOCTYPE ", t.name), g)
        e.push(" PUBLIC ", g), y && y != "." && e.push(" ", y), e.push(">");
      else if (y && y != ".")
        e.push(" SYSTEM ", y, ">");
      else {
        var w = t.internalSubset;
        w && e.push(" [", w, "]"), e.push(">");
      }
      return;
    case u0:
      return e.push("<?", t.target, " ", t.data, "?>");
    case l0:
      return e.push("&", t.nodeName, ";");
    default:
      e.push("??", t.nodeName);
  }
}
function x0(t, e, n) {
  var r;
  switch (e.nodeType) {
    case wr:
      r = e.cloneNode(!1), r.ownerDocument = t;
    case oi:
      break;
    case Ws:
      n = !0;
      break;
  }
  if (r || (r = e.cloneNode(!1)), r.ownerDocument = t, r.parentNode = null, n)
    for (var i = e.firstChild; i; )
      r.appendChild(x0(t, i, n)), i = i.nextSibling;
  return r;
}
function pd(t, e, n) {
  var r = new e.constructor();
  for (var i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      var s = e[i];
      typeof s != "object" && s != r[i] && (r[i] = s);
    }
  switch (e.childNodes && (r.childNodes = new ti()), r.ownerDocument = t, r.nodeType) {
    case wr:
      var o = e.attributes, a = r.attributes = new Ml(), l = o.length;
      a._ownerElement = r;
      for (var u = 0; u < l; u++)
        r.setAttributeNode(pd(t, o.item(u), !0));
      break;
    case Ws:
      n = !0;
  }
  if (n)
    for (var c = e.firstChild; c; )
      r.appendChild(pd(t, c, n)), c = c.nextSibling;
  return r;
}
function A0(t, e, n) {
  t[e] = n;
}
try {
  if (Object.defineProperty) {
    let t = function(e) {
      switch (e.nodeType) {
        case wr:
        case oi:
          var n = [];
          for (e = e.firstChild; e; )
            e.nodeType !== 7 && e.nodeType !== 8 && n.push(t(e)), e = e.nextSibling;
          return n.join("");
        default:
          return e.nodeValue;
      }
    };
    Object.defineProperty($s.prototype, "length", {
      get: function() {
        return Pf(this), this.$$length;
      }
    }), Object.defineProperty(It.prototype, "textContent", {
      get: function() {
        return t(this);
      },
      set: function(e) {
        switch (this.nodeType) {
          case wr:
          case oi:
            for (; this.firstChild; )
              this.removeChild(this.firstChild);
            (e || String(e)) && this.appendChild(this.ownerDocument.createTextNode(e));
            break;
          default:
            this.data = e, this.value = e, this.nodeValue = e;
        }
      }
    }), A0 = function(e, n, r) {
      e["$$" + n] = r;
    };
  }
} catch {
}
Oi.DocumentType = vu;
Oi.DOMException = tn;
Oi.DOMImplementation = v0;
Oi.Element = Qi;
Oi.Node = It;
Oi.NodeList = ti;
Oi.XMLSerializer = S0;
var ya = {}, k0 = {};
(function(t) {
  var e = Ii.freeze;
  t.XML_ENTITIES = e({ amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' }), t.HTML_ENTITIES = e({
    lt: "<",
    gt: ">",
    amp: "&",
    quot: '"',
    apos: "'",
    Agrave: "À",
    Aacute: "Á",
    Acirc: "Â",
    Atilde: "Ã",
    Auml: "Ä",
    Aring: "Å",
    AElig: "Æ",
    Ccedil: "Ç",
    Egrave: "È",
    Eacute: "É",
    Ecirc: "Ê",
    Euml: "Ë",
    Igrave: "Ì",
    Iacute: "Í",
    Icirc: "Î",
    Iuml: "Ï",
    ETH: "Ð",
    Ntilde: "Ñ",
    Ograve: "Ò",
    Oacute: "Ó",
    Ocirc: "Ô",
    Otilde: "Õ",
    Ouml: "Ö",
    Oslash: "Ø",
    Ugrave: "Ù",
    Uacute: "Ú",
    Ucirc: "Û",
    Uuml: "Ü",
    Yacute: "Ý",
    THORN: "Þ",
    szlig: "ß",
    agrave: "à",
    aacute: "á",
    acirc: "â",
    atilde: "ã",
    auml: "ä",
    aring: "å",
    aelig: "æ",
    ccedil: "ç",
    egrave: "è",
    eacute: "é",
    ecirc: "ê",
    euml: "ë",
    igrave: "ì",
    iacute: "í",
    icirc: "î",
    iuml: "ï",
    eth: "ð",
    ntilde: "ñ",
    ograve: "ò",
    oacute: "ó",
    ocirc: "ô",
    otilde: "õ",
    ouml: "ö",
    oslash: "ø",
    ugrave: "ù",
    uacute: "ú",
    ucirc: "û",
    uuml: "ü",
    yacute: "ý",
    thorn: "þ",
    yuml: "ÿ",
    nbsp: " ",
    iexcl: "¡",
    cent: "¢",
    pound: "£",
    curren: "¤",
    yen: "¥",
    brvbar: "¦",
    sect: "§",
    uml: "¨",
    copy: "©",
    ordf: "ª",
    laquo: "«",
    not: "¬",
    shy: "­­",
    reg: "®",
    macr: "¯",
    deg: "°",
    plusmn: "±",
    sup2: "²",
    sup3: "³",
    acute: "´",
    micro: "µ",
    para: "¶",
    middot: "·",
    cedil: "¸",
    sup1: "¹",
    ordm: "º",
    raquo: "»",
    frac14: "¼",
    frac12: "½",
    frac34: "¾",
    iquest: "¿",
    times: "×",
    divide: "÷",
    forall: "∀",
    part: "∂",
    exist: "∃",
    empty: "∅",
    nabla: "∇",
    isin: "∈",
    notin: "∉",
    ni: "∋",
    prod: "∏",
    sum: "∑",
    minus: "−",
    lowast: "∗",
    radic: "√",
    prop: "∝",
    infin: "∞",
    ang: "∠",
    and: "∧",
    or: "∨",
    cap: "∩",
    cup: "∪",
    int: "∫",
    there4: "∴",
    sim: "∼",
    cong: "≅",
    asymp: "≈",
    ne: "≠",
    equiv: "≡",
    le: "≤",
    ge: "≥",
    sub: "⊂",
    sup: "⊃",
    nsub: "⊄",
    sube: "⊆",
    supe: "⊇",
    oplus: "⊕",
    otimes: "⊗",
    perp: "⊥",
    sdot: "⋅",
    Alpha: "Α",
    Beta: "Β",
    Gamma: "Γ",
    Delta: "Δ",
    Epsilon: "Ε",
    Zeta: "Ζ",
    Eta: "Η",
    Theta: "Θ",
    Iota: "Ι",
    Kappa: "Κ",
    Lambda: "Λ",
    Mu: "Μ",
    Nu: "Ν",
    Xi: "Ξ",
    Omicron: "Ο",
    Pi: "Π",
    Rho: "Ρ",
    Sigma: "Σ",
    Tau: "Τ",
    Upsilon: "Υ",
    Phi: "Φ",
    Chi: "Χ",
    Psi: "Ψ",
    Omega: "Ω",
    alpha: "α",
    beta: "β",
    gamma: "γ",
    delta: "δ",
    epsilon: "ε",
    zeta: "ζ",
    eta: "η",
    theta: "θ",
    iota: "ι",
    kappa: "κ",
    lambda: "λ",
    mu: "μ",
    nu: "ν",
    xi: "ξ",
    omicron: "ο",
    pi: "π",
    rho: "ρ",
    sigmaf: "ς",
    sigma: "σ",
    tau: "τ",
    upsilon: "υ",
    phi: "φ",
    chi: "χ",
    psi: "ψ",
    omega: "ω",
    thetasym: "ϑ",
    upsih: "ϒ",
    piv: "ϖ",
    OElig: "Œ",
    oelig: "œ",
    Scaron: "Š",
    scaron: "š",
    Yuml: "Ÿ",
    fnof: "ƒ",
    circ: "ˆ",
    tilde: "˜",
    ensp: " ",
    emsp: " ",
    thinsp: " ",
    zwnj: "‌",
    zwj: "‍",
    lrm: "‎",
    rlm: "‏",
    ndash: "–",
    mdash: "—",
    lsquo: "‘",
    rsquo: "’",
    sbquo: "‚",
    ldquo: "“",
    rdquo: "”",
    bdquo: "„",
    dagger: "†",
    Dagger: "‡",
    bull: "•",
    hellip: "…",
    permil: "‰",
    prime: "′",
    Prime: "″",
    lsaquo: "‹",
    rsaquo: "›",
    oline: "‾",
    euro: "€",
    trade: "™",
    larr: "←",
    uarr: "↑",
    rarr: "→",
    darr: "↓",
    harr: "↔",
    crarr: "↵",
    lceil: "⌈",
    rceil: "⌉",
    lfloor: "⌊",
    rfloor: "⌋",
    loz: "◊",
    spades: "♠",
    clubs: "♣",
    hearts: "♥",
    diams: "♦"
  }), t.entityMap = t.HTML_ENTITIES;
})(k0);
var Hf = {}, Yo = Ii.NAMESPACE, vd = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, pv = new RegExp("[\\-\\.0-9" + vd.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"), vv = new RegExp("^" + vd.source + pv.source + "*(?::" + vd.source + pv.source + "*)?$"), ao = 0, pi = 1, vs = 2, lo = 3, gs = 4, ms = 5, uo = 6, Ha = 7;
function Ks(t, e) {
  this.message = t, this.locator = e, Error.captureStackTrace && Error.captureStackTrace(this, Ks);
}
Ks.prototype = new Error();
Ks.prototype.name = Ks.name;
function C0() {
}
C0.prototype = {
  parse: function(t, e, n) {
    var r = this.domBuilder;
    r.startDocument(), T0(e, e = {}), G8(
      t,
      e,
      n,
      r,
      this.errorHandler
    ), r.endDocument();
  }
};
function G8(t, e, n, r, i) {
  function s(te) {
    if (te > 65535) {
      te -= 65536;
      var L = 55296 + (te >> 10), V = 56320 + (te & 1023);
      return String.fromCharCode(L, V);
    } else
      return String.fromCharCode(te);
  }
  function o(te) {
    var L = te.slice(1, -1);
    return L in n ? n[L] : L.charAt(0) === "#" ? s(parseInt(L.substr(1).replace("x", "0x"))) : (i.error("entity not found:" + te), te);
  }
  function a(te) {
    if (te > b) {
      var L = t.substring(b, te).replace(/&#?\w+;/g, o);
      h && l(b), r.characters(L, 0, te - b), b = te;
    }
  }
  function l(te, L) {
    for (; te >= c && (L = d.exec(t)); )
      u = L.index, c = u + L[0].length, h.lineNumber++;
    h.columnNumber = te - u + 1;
  }
  for (var u = 0, c = 0, d = /.*(?:\r\n?|\n)|.*$/g, h = r.locator, v = [{ currentNSMap: e }], m = {}, b = 0; ; ) {
    try {
      var p = t.indexOf("<", b);
      if (p < 0) {
        if (!t.substr(b).match(/^\s*$/)) {
          var f = r.doc, g = f.createTextNode(t.substr(b));
          f.appendChild(g), r.currentElement = g;
        }
        return;
      }
      switch (p > b && a(p), t.charAt(p + 1)) {
        case "/":
          var N = t.indexOf(">", p + 3), y = t.substring(p + 2, N).replace(/[ \t\n\r]+$/g, ""), w = v.pop();
          N < 0 ? (y = t.substring(p + 2).replace(/[\s<].*/, ""), i.error("end tag name: " + y + " is not complete:" + w.tagName), N = p + 1 + y.length) : y.match(/\s</) && (y = y.replace(/[\s<].*/, ""), i.error("end tag name: " + y + " maybe not complete"), N = p + 1 + y.length);
          var _ = w.localNSMap, S = w.tagName == y, A = S || w.tagName && w.tagName.toLowerCase() == y.toLowerCase();
          if (A) {
            if (r.endElement(w.uri, w.localName, y), _)
              for (var C in _)
                Object.prototype.hasOwnProperty.call(_, C) && r.endPrefixMapping(C);
            S || i.fatalError("end tag name: " + y + " is not match the current start tagName:" + w.tagName);
          } else
            v.push(w);
          N++;
          break;
        case "?":
          h && l(p), N = Z8(t, p, r);
          break;
        case "!":
          h && l(p), N = Q8(t, p, r, i);
          break;
        default:
          h && l(p);
          var k = new O0(), O = v[v.length - 1].currentNSMap, N = q8(t, p, k, O, o, i), B = k.length;
          if (!k.closed && Y8(t, N, k.tagName, m) && (k.closed = !0, n.nbsp || i.warning("unclosed xml attribute")), h && B) {
            for (var D = gv(h, {}), F = 0; F < B; F++) {
              var Z = k[F];
              l(Z.offset), Z.locator = gv(h, {});
            }
            r.locator = D, mv(k, r, O) && v.push(k), r.locator = h;
          } else
            mv(k, r, O) && v.push(k);
          Yo.isHTML(k.uri) && !k.closed ? N = J8(t, N, k.tagName, o, r) : N++;
      }
    } catch (te) {
      if (te instanceof Ks)
        throw te;
      i.error("element parse error: " + te), N = -1;
    }
    N > b ? b = N : a(Math.max(p, b) + 1);
  }
}
function gv(t, e) {
  return e.lineNumber = t.lineNumber, e.columnNumber = t.columnNumber, e;
}
function q8(t, e, n, r, i, s) {
  function o(h, v, m) {
    n.attributeNames.hasOwnProperty(h) && s.fatalError("Attribute " + h + " redefined"), n.addValue(h, v, m);
  }
  for (var a, l, u = ++e, c = ao; ; ) {
    var d = t.charAt(u);
    switch (d) {
      case "=":
        if (c === pi)
          a = t.slice(e, u), c = lo;
        else if (c === vs)
          c = lo;
        else
          throw new Error("attribute equal must after attrName");
        break;
      case "'":
      case '"':
        if (c === lo || c === pi)
          if (c === pi && (s.warning('attribute value must after "="'), a = t.slice(e, u)), e = u + 1, u = t.indexOf(d, e), u > 0)
            l = t.slice(e, u).replace(/&#?\w+;/g, i), o(a, l, e - 1), c = ms;
          else
            throw new Error("attribute value no end '" + d + "' match");
        else if (c == gs)
          l = t.slice(e, u).replace(/&#?\w+;/g, i), o(a, l, e), s.warning('attribute "' + a + '" missed start quot(' + d + ")!!"), e = u + 1, c = ms;
        else
          throw new Error('attribute value must after "="');
        break;
      case "/":
        switch (c) {
          case ao:
            n.setTagName(t.slice(e, u));
          case ms:
          case uo:
          case Ha:
            c = Ha, n.closed = !0;
          case gs:
          case pi:
            break;
          case vs:
            n.closed = !0;
            break;
          default:
            throw new Error("attribute invalid close char('/')");
        }
        break;
      case "":
        return s.error("unexpected end of input"), c == ao && n.setTagName(t.slice(e, u)), u;
      case ">":
        switch (c) {
          case ao:
            n.setTagName(t.slice(e, u));
          case ms:
          case uo:
          case Ha:
            break;
          case gs:
          case pi:
            l = t.slice(e, u), l.slice(-1) === "/" && (n.closed = !0, l = l.slice(0, -1));
          case vs:
            c === vs && (l = a), c == gs ? (s.warning('attribute "' + l + '" missed quot(")!'), o(a, l.replace(/&#?\w+;/g, i), e)) : ((!Yo.isHTML(r[""]) || !l.match(/^(?:disabled|checked|selected)$/i)) && s.warning('attribute "' + l + '" missed value!! "' + l + '" instead!!'), o(l, l, e));
            break;
          case lo:
            throw new Error("attribute value missed!!");
        }
        return u;
      case "":
        d = " ";
      default:
        if (d <= " ")
          switch (c) {
            case ao:
              n.setTagName(t.slice(e, u)), c = uo;
              break;
            case pi:
              a = t.slice(e, u), c = vs;
              break;
            case gs:
              var l = t.slice(e, u).replace(/&#?\w+;/g, i);
              s.warning('attribute "' + l + '" missed quot(")!!'), o(a, l, e);
            case ms:
              c = uo;
              break;
          }
        else
          switch (c) {
            case vs:
              n.tagName, (!Yo.isHTML(r[""]) || !a.match(/^(?:disabled|checked|selected)$/i)) && s.warning('attribute "' + a + '" missed value!! "' + a + '" instead2!!'), o(a, a, e), e = u, c = pi;
              break;
            case ms:
              s.warning('attribute space is required"' + a + '"!!');
            case uo:
              c = pi, e = u;
              break;
            case lo:
              c = gs, e = u;
              break;
            case Ha:
              throw new Error("elements closed character '/' and '>' must be connected to");
          }
    }
    u++;
  }
}
function mv(t, e, n) {
  for (var r = t.tagName, i = null, d = t.length; d--; ) {
    var s = t[d], o = s.qName, a = s.value, h = o.indexOf(":");
    if (h > 0)
      var l = s.prefix = o.slice(0, h), u = o.slice(h + 1), c = l === "xmlns" && u;
    else
      u = o, l = null, c = o === "xmlns" && "";
    s.localName = u, c !== !1 && (i == null && (i = {}, T0(n, n = {})), n[c] = i[c] = a, s.uri = Yo.XMLNS, e.startPrefixMapping(c, a));
  }
  for (var d = t.length; d--; ) {
    s = t[d];
    var l = s.prefix;
    l && (l === "xml" && (s.uri = Yo.XML), l !== "xmlns" && (s.uri = n[l || ""]));
  }
  var h = r.indexOf(":");
  h > 0 ? (l = t.prefix = r.slice(0, h), u = t.localName = r.slice(h + 1)) : (l = null, u = t.localName = r);
  var v = t.uri = n[l || ""];
  if (e.startElement(v, u, r, t), t.closed) {
    if (e.endElement(v, u, r), i)
      for (l in i)
        Object.prototype.hasOwnProperty.call(i, l) && e.endPrefixMapping(l);
  } else
    return t.currentNSMap = n, t.localNSMap = i, !0;
}
function J8(t, e, n, r, i) {
  if (/^(?:script|textarea)$/i.test(n)) {
    var s = t.indexOf("</" + n + ">", e), o = t.substring(e + 1, s);
    if (/[&<]/.test(o))
      return /^script$/i.test(n) ? (i.characters(o, 0, o.length), s) : (o = o.replace(/&#?\w+;/g, r), i.characters(o, 0, o.length), s);
  }
  return e + 1;
}
function Y8(t, e, n, r) {
  var i = r[n];
  return i == null && (i = t.lastIndexOf("</" + n + ">"), i < e && (i = t.lastIndexOf("</" + n)), r[n] = i), i < e;
}
function T0(t, e) {
  for (var n in t)
    Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
}
function Q8(t, e, n, r) {
  var i = t.charAt(e + 2);
  switch (i) {
    case "-":
      if (t.charAt(e + 3) === "-") {
        var s = t.indexOf("-->", e + 4);
        return s > e ? (n.comment(t, e + 4, s - e - 4), s + 3) : (r.error("Unclosed comment"), -1);
      } else
        return -1;
    default:
      if (t.substr(e + 3, 6) == "CDATA[") {
        var s = t.indexOf("]]>", e + 9);
        return n.startCDATA(), n.characters(t, e + 9, s - e - 9), n.endCDATA(), s + 3;
      }
      var o = X8(t, e), a = o.length;
      if (a > 1 && /!doctype/i.test(o[0][0])) {
        var l = o[1][0], u = !1, c = !1;
        a > 3 && (/^public$/i.test(o[2][0]) ? (u = o[3][0], c = a > 4 && o[4][0]) : /^system$/i.test(o[2][0]) && (c = o[3][0]));
        var d = o[a - 1];
        return n.startDTD(l, u, c), n.endDTD(), d.index + d[0].length;
      }
  }
  return -1;
}
function Z8(t, e, n) {
  var r = t.indexOf("?>", e);
  if (r) {
    var i = t.substring(e, r).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
    return i ? (i[0].length, n.processingInstruction(i[1], i[2]), r + 2) : -1;
  }
  return -1;
}
function O0() {
  this.attributeNames = {};
}
O0.prototype = {
  setTagName: function(t) {
    if (!vv.test(t))
      throw new Error("invalid tagName:" + t);
    this.tagName = t;
  },
  addValue: function(t, e, n) {
    if (!vv.test(t))
      throw new Error("invalid attribute:" + t);
    this.attributeNames[t] = this.length, this[this.length++] = { qName: t, value: e, offset: n };
  },
  length: 0,
  getLocalName: function(t) {
    return this[t].localName;
  },
  getLocator: function(t) {
    return this[t].locator;
  },
  getQName: function(t) {
    return this[t].qName;
  },
  getURI: function(t) {
    return this[t].uri;
  },
  getValue: function(t) {
    return this[t].value;
  }
  //	,getIndex:function(uri, localName)){
  //		if(localName){
  //
  //		}else{
  //			var qName = uri
  //		}
  //	},
  //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
  //	getType:function(uri,localName){}
  //	getType:function(i){},
};
function X8(t, e) {
  var n, r = [], i = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
  for (i.lastIndex = e, i.exec(t); n = i.exec(t); )
    if (r.push(n), n[1])
      return r;
}
Hf.XMLReader = C0;
Hf.ParseError = Ks;
var e6 = Ii, Uf = Oi, yv = k0, I0 = Hf, t6 = Uf.DOMImplementation, bv = e6.NAMESPACE, n6 = I0.ParseError, r6 = I0.XMLReader;
function N0(t) {
  this.options = t || { locator: {} };
}
N0.prototype.parseFromString = function(t, e) {
  var n = this.options, r = new r6(), i = n.domBuilder || new ba(), s = n.errorHandler, o = n.locator, a = n.xmlns || {}, l = /\/x?html?$/.test(e), u = l ? yv.HTML_ENTITIES : yv.XML_ENTITIES;
  return o && i.setDocumentLocator(o), r.errorHandler = i6(s, i, o), r.domBuilder = n.domBuilder || i, l && (a[""] = bv.HTML), a.xml = a.xml || bv.XML, t && typeof t == "string" ? r.parse(t, a, u) : r.errorHandler.error("invalid doc source"), i.doc;
};
function i6(t, e, n) {
  if (!t) {
    if (e instanceof ba)
      return e;
    t = e;
  }
  var r = {}, i = t instanceof Function;
  n = n || {};
  function s(o) {
    var a = t[o];
    !a && i && (a = t.length == 2 ? function(l) {
      t(o, l);
    } : t), r[o] = a && function(l) {
      a("[xmldom " + o + "]	" + l + gd(n));
    } || function() {
    };
  }
  return s("warning"), s("error"), s("fatalError"), r;
}
function ba() {
  this.cdata = !1;
}
function ys(t, e) {
  e.lineNumber = t.lineNumber, e.columnNumber = t.columnNumber;
}
ba.prototype = {
  startDocument: function() {
    this.doc = new t6().createDocument(null, null, null), this.locator && (this.doc.documentURI = this.locator.systemId);
  },
  startElement: function(t, e, n, r) {
    var i = this.doc, s = i.createElementNS(t, n || e), o = r.length;
    Ua(this, s), this.currentElement = s, this.locator && ys(this.locator, s);
    for (var a = 0; a < o; a++) {
      var t = r.getURI(a), l = r.getValue(a), n = r.getQName(a), u = i.createAttributeNS(t, n);
      this.locator && ys(r.getLocator(a), u), u.value = u.nodeValue = l, s.setAttributeNode(u);
    }
  },
  endElement: function(t, e, n) {
    var r = this.currentElement;
    r.tagName, this.currentElement = r.parentNode;
  },
  startPrefixMapping: function(t, e) {
  },
  endPrefixMapping: function(t) {
  },
  processingInstruction: function(t, e) {
    var n = this.doc.createProcessingInstruction(t, e);
    this.locator && ys(this.locator, n), Ua(this, n);
  },
  ignorableWhitespace: function(t, e, n) {
  },
  characters: function(t, e, n) {
    if (t = wv.apply(this, arguments), t) {
      if (this.cdata)
        var r = this.doc.createCDATASection(t);
      else
        var r = this.doc.createTextNode(t);
      this.currentElement ? this.currentElement.appendChild(r) : /^\s*$/.test(t) && this.doc.appendChild(r), this.locator && ys(this.locator, r);
    }
  },
  skippedEntity: function(t) {
  },
  endDocument: function() {
    this.doc.normalize();
  },
  setDocumentLocator: function(t) {
    (this.locator = t) && (t.lineNumber = 0);
  },
  //LexicalHandler
  comment: function(t, e, n) {
    t = wv.apply(this, arguments);
    var r = this.doc.createComment(t);
    this.locator && ys(this.locator, r), Ua(this, r);
  },
  startCDATA: function() {
    this.cdata = !0;
  },
  endCDATA: function() {
    this.cdata = !1;
  },
  startDTD: function(t, e, n) {
    var r = this.doc.implementation;
    if (r && r.createDocumentType) {
      var i = r.createDocumentType(t, e, n);
      this.locator && ys(this.locator, i), Ua(this, i), this.doc.doctype = i;
    }
  },
  /**
   * @see org.xml.sax.ErrorHandler
   * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
   */
  warning: function(t) {
    console.warn("[xmldom warning]	" + t, gd(this.locator));
  },
  error: function(t) {
    console.error("[xmldom error]	" + t, gd(this.locator));
  },
  fatalError: function(t) {
    throw new n6(t, this.locator);
  }
};
function gd(t) {
  if (t)
    return `
@` + (t.systemId || "") + "#[line:" + t.lineNumber + ",col:" + t.columnNumber + "]";
}
function wv(t, e, n) {
  return typeof t == "string" ? t.substr(e, n) : t.length >= e + n || e ? new java.lang.String(t, e, n) + "" : t;
}
"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(t) {
  ba.prototype[t] = function() {
    return null;
  };
});
function Ua(t, e) {
  t.currentElement ? t.currentElement.appendChild(e) : t.doc.appendChild(e);
}
ya.__DOMHandler = ba;
ya.DOMParser = N0;
ya.DOMImplementation = Uf.DOMImplementation;
ya.XMLSerializer = Uf.XMLSerializer;
var R0 = ya.DOMParser;
const Vf = typeof window < "u" ? window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame : !1, s6 = 1, o6 = 3, P0 = typeof URL < "u" ? URL : typeof window < "u" ? window.URL || window.webkitURL || window.mozURL : void 0;
function mu() {
  var t = (/* @__PURE__ */ new Date()).getTime(), e = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(n) {
    var r = (t + Math.random() * 16) % 16 | 0;
    return t = Math.floor(t / 16), (n == "x" ? r : r & 7 | 8).toString(16);
  });
  return e;
}
function a6() {
  return Math.max(
    document.documentElement.clientHeight,
    document.body.scrollHeight,
    document.documentElement.scrollHeight,
    document.body.offsetHeight,
    document.documentElement.offsetHeight
  );
}
function D0(t) {
  return !!(t && t.nodeType == 1);
}
function Yt(t) {
  return !isNaN(parseFloat(t)) && isFinite(t);
}
function B0(t) {
  let e = parseFloat(t);
  return Yt(t) === !1 ? !1 : typeof t == "string" && t.indexOf(".") > -1 ? !0 : Math.floor(e) !== e;
}
function Es(t) {
  var e = ["Webkit", "webkit", "Moz", "O", "ms"], n = ["-webkit-", "-webkit-", "-moz-", "-o-", "-ms-"], r = t.toLowerCase(), i = e.length;
  if (typeof document > "u" || typeof document.body.style[r] < "u")
    return t;
  for (var s = 0; s < i; s++)
    if (typeof document.body.style[n[s] + r] < "u")
      return n[s] + r;
  return t;
}
function M0(t) {
  for (var e = 1, n = arguments.length; e < n; e++) {
    var r = arguments[e];
    for (var i in r)
      t[i] === void 0 && (t[i] = r[i]);
  }
  return t;
}
function En(t) {
  var e = [].slice.call(arguments, 1);
  return e.forEach(function(n) {
    n && Object.getOwnPropertyNames(n).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }), t;
}
function l6(t, e, n) {
  var r = Gs(t, e, n);
  return e.splice(r, 0, t), r;
}
function Gs(t, e, n, r, i) {
  var s = r || 0, o = i || e.length, a = parseInt(s + (o - s) / 2), l;
  return n || (n = function(u, c) {
    if (u > c)
      return 1;
    if (u < c)
      return -1;
    if (u == c)
      return 0;
  }), o - s <= 0 ? a : (l = n(e[a], t), o - s === 1 ? l >= 0 ? a : a + 1 : l === 0 ? a : l === -1 ? Gs(t, e, n, a, o) : Gs(t, e, n, s, a));
}
function jl(t, e, n, r, i) {
  var s = r || 0, o = i || e.length, a = parseInt(s + (o - s) / 2), l;
  return n || (n = function(u, c) {
    if (u > c)
      return 1;
    if (u < c)
      return -1;
    if (u == c)
      return 0;
  }), o - s <= 0 ? -1 : (l = n(e[a], t), o - s === 1 ? l === 0 ? a : -1 : l === 0 ? a : l === -1 ? jl(t, e, n, a, o) : jl(t, e, n, s, a));
}
function fl(t) {
  var e = window.getComputedStyle(t), n = ["width", "paddingRight", "paddingLeft", "marginRight", "marginLeft", "borderRightWidth", "borderLeftWidth"], r = ["height", "paddingTop", "paddingBottom", "marginTop", "marginBottom", "borderTopWidth", "borderBottomWidth"], i = 0, s = 0;
  return n.forEach(function(o) {
    i += parseFloat(e[o]) || 0;
  }), r.forEach(function(o) {
    s += parseFloat(e[o]) || 0;
  }), {
    height: s,
    width: i
  };
}
function Fl(t) {
  var e = window.getComputedStyle(t), n = ["paddingRight", "paddingLeft", "marginRight", "marginLeft", "borderRightWidth", "borderLeftWidth"], r = ["paddingTop", "paddingBottom", "marginTop", "marginBottom", "borderTopWidth", "borderBottomWidth"], i = 0, s = 0;
  return n.forEach(function(o) {
    i += parseFloat(e[o]) || 0;
  }), r.forEach(function(o) {
    s += parseFloat(e[o]) || 0;
  }), {
    height: s,
    width: i
  };
}
function md(t) {
  let e, n = t.ownerDocument;
  if (t.nodeType == Node.TEXT_NODE) {
    let r = n.createRange();
    r.selectNodeContents(t), e = r.getBoundingClientRect();
  } else
    e = t.getBoundingClientRect();
  return e;
}
function Hl() {
  var t = window.innerWidth, e = window.innerHeight;
  return {
    top: 0,
    left: 0,
    right: t,
    bottom: e,
    width: t,
    height: e
  };
}
function Wf(t, e) {
  for (var n = t.parentNode, r = n.childNodes, i, s = -1, o = 0; o < r.length && (i = r[o], i.nodeType === e && s++, i != t); o++)
    ;
  return s;
}
function u6(t) {
  return Wf(t, o6);
}
function L0(t) {
  return Wf(t, s6);
}
function Qo(t) {
  return ["xml", "opf", "ncx"].indexOf(t) > -1;
}
function z0(t, e) {
  return new Blob([t], { type: e });
}
function Ul(t, e) {
  var n, r = z0(t, e);
  return n = P0.createObjectURL(r), n;
}
function j0(t) {
  return P0.revokeObjectURL(t);
}
function yd(t, e) {
  var n, r;
  if (typeof t == "string")
    return n = btoa(t), r = "data:" + e + ";base64," + n, r;
}
function F0(t) {
  return Object.prototype.toString.call(t).slice(8, -1);
}
function Pr(t, e, n) {
  var r, i;
  return typeof DOMParser > "u" || n ? i = R0 : i = DOMParser, t.charCodeAt(0) === 65279 && (t = t.slice(1)), r = new i().parseFromString(t, e), r;
}
function zt(t, e) {
  var n;
  if (!t)
    throw new Error("No Element Provided");
  if (typeof t.querySelector < "u")
    return t.querySelector(e);
  if (n = t.getElementsByTagName(e), n.length)
    return n[0];
}
function li(t, e) {
  return typeof t.querySelector < "u" ? t.querySelectorAll(e) : t.getElementsByTagName(e);
}
function xs(t, e, n) {
  var r, i;
  if (typeof t.querySelector < "u") {
    e += "[";
    for (var s in n)
      e += s + "~='" + n[s] + "'";
    return e += "]", t.querySelector(e);
  } else if (r = t.getElementsByTagName(e), i = Array.prototype.slice.call(r, 0).filter(function(o) {
    for (var a in n)
      if (o.getAttribute(a) === n[a])
        return !0;
    return !1;
  }), i)
    return i[0];
}
function Vl(t, e) {
  var n = t.ownerDocument || t;
  typeof n.createTreeWalker < "u" ? H0(t, e, NodeFilter.SHOW_TEXT) : $f(t, function(r) {
    r && r.nodeType === 3 && e(r);
  });
}
function H0(t, e, n) {
  var r = document.createTreeWalker(t, n, null, !1);
  let i;
  for (; i = r.nextNode(); )
    e(i);
}
function $f(t, e) {
  if (e(t))
    return !0;
  if (t = t.firstChild, t)
    do {
      if ($f(t, e))
        return !0;
      t = t.nextSibling;
    } while (t);
}
function U0(t) {
  return new Promise(function(e, n) {
    var r = new FileReader();
    r.readAsDataURL(t), r.onloadend = function() {
      e(r.result);
    };
  });
}
function vt() {
  this.resolve = null, this.reject = null, this.id = mu(), this.promise = new Promise((t, e) => {
    this.resolve = t, this.reject = e;
  }), Object.freeze(this);
}
function Wl(t, e, n) {
  var r;
  if (typeof t.querySelector < "u" && (r = t.querySelector(`${e}[*|type="${n}"]`)), !r || r.length === 0) {
    r = li(t, e);
    for (var i = 0; i < r.length; i++)
      if (r[i].getAttributeNS("http://www.idpf.org/2007/ops", "type") === n || r[i].getAttribute("epub:type") === n)
        return r[i];
  } else
    return r;
}
function bd(t) {
  for (var e = [], n = t.childNodes, r = 0; r < n.length; r++) {
    let i = n[r];
    i.nodeType === 1 && e.push(i);
  }
  return e;
}
function wd(t) {
  for (var e = [t]; t; t = t.parentNode)
    e.unshift(t);
  return e;
}
function As(t, e, n) {
  for (var r = [], i = t.childNodes, s = 0; s < i.length; s++) {
    let o = i[s];
    if (o.nodeType === 1 && o.nodeName.toLowerCase() === e) {
      if (n)
        return o;
      r.push(o);
    }
  }
  if (!n)
    return r;
}
function c6(t, e) {
  let n;
  if (!(t === null || e === ""))
    for (n = t.parentNode; n.nodeType === 1; ) {
      if (n.tagName.toLowerCase() === e)
        return n;
      n = n.parentNode;
    }
}
class V0 {
  constructor() {
    this.collapsed = !1, this.commonAncestorContainer = void 0, this.endContainer = void 0, this.endOffset = void 0, this.startContainer = void 0, this.startOffset = void 0;
  }
  setStart(e, n) {
    this.startContainer = e, this.startOffset = n, this.endContainer ? this.commonAncestorContainer = this._commonAncestorContainer() : this.collapse(!0), this._checkCollapsed();
  }
  setEnd(e, n) {
    this.endContainer = e, this.endOffset = n, this.startContainer ? (this.collapsed = !1, this.commonAncestorContainer = this._commonAncestorContainer()) : this.collapse(!1), this._checkCollapsed();
  }
  collapse(e) {
    this.collapsed = !0, e ? (this.endContainer = this.startContainer, this.endOffset = this.startOffset, this.commonAncestorContainer = this.startContainer.parentNode) : (this.startContainer = this.endContainer, this.startOffset = this.endOffset, this.commonAncestorContainer = this.endOffset.parentNode);
  }
  selectNode(e) {
    let n = e.parentNode, r = Array.prototype.indexOf.call(n.childNodes, e);
    this.setStart(n, r), this.setEnd(n, r + 1);
  }
  selectNodeContents(e) {
    e.childNodes[e.childNodes - 1];
    let n = e.nodeType === 3 ? e.textContent.length : parent.childNodes.length;
    this.setStart(e, 0), this.setEnd(e, n);
  }
  _commonAncestorContainer(e, n) {
    var r = wd(e || this.startContainer), i = wd(n || this.endContainer);
    if (r[0] == i[0]) {
      for (var s = 0; s < r.length; s++)
        if (r[s] != i[s])
          return r[s - 1];
    }
  }
  _checkCollapsed() {
    this.startContainer === this.endContainer && this.startOffset === this.endOffset ? this.collapsed = !0 : this.collapsed = !1;
  }
  toString() {
  }
}
const d6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RangeObject: V0,
  blob2base64: U0,
  borders: Fl,
  bounds: fl,
  createBase64Url: yd,
  createBlob: z0,
  createBlobUrl: Ul,
  defaults: M0,
  defer: vt,
  documentHeight: a6,
  extend: En,
  filterChildren: As,
  findChildren: bd,
  getParentByTagName: c6,
  indexOfElementNode: L0,
  indexOfNode: Wf,
  indexOfSorted: jl,
  indexOfTextNode: u6,
  insert: l6,
  isElement: D0,
  isFloat: B0,
  isNumber: Yt,
  isXml: Qo,
  locationOf: Gs,
  nodeBounds: md,
  parents: wd,
  parse: Pr,
  prefixed: Es,
  qs: zt,
  qsa: li,
  qsp: xs,
  querySelectorByType: Wl,
  requestAnimationFrame: Vf,
  revokeBlobUrl: j0,
  sprint: Vl,
  treeWalker: H0,
  type: F0,
  uuid: mu,
  walk: $f,
  windowBounds: Hl
}, Symbol.toStringTag, { value: "Module" }));
if (!W0)
  var W0 = {
    cwd: function() {
      return "/";
    }
  };
function Ar(t) {
  if (typeof t != "string")
    throw new TypeError("Path must be a string. Received " + t);
}
function _v(t, e) {
  for (var n = "", r = -1, i = 0, s, o = 0; o <= t.length; ++o) {
    if (o < t.length)
      s = t.charCodeAt(o);
    else {
      if (s === 47)
        break;
      s = 47;
    }
    if (s === 47) {
      if (!(r === o - 1 || i === 1))
        if (r !== o - 1 && i === 2) {
          if (n.length < 2 || n.charCodeAt(n.length - 1) !== 46 || n.charCodeAt(n.length - 2) !== 46) {
            if (n.length > 2) {
              for (var a = n.length - 1, l = a; l >= 0 && n.charCodeAt(l) !== 47; --l)
                ;
              if (l !== a) {
                l === -1 ? n = "" : n = n.slice(0, l), r = o, i = 0;
                continue;
              }
            } else if (n.length === 2 || n.length === 1) {
              n = "", r = o, i = 0;
              continue;
            }
          }
          e && (n.length > 0 ? n += "/.." : n = "..");
        } else
          n.length > 0 ? n += "/" + t.slice(r + 1, o) : n = t.slice(r + 1, o);
      r = o, i = 0;
    } else
      s === 46 && i !== -1 ? ++i : i = -1;
  }
  return n;
}
function f6(t, e) {
  var n = e.dir || e.root, r = e.base || (e.name || "") + (e.ext || "");
  return n ? n === e.root ? n + r : n + t + r : r;
}
var hl = {
  // path.resolve([from ...], to)
  resolve: function() {
    for (var e = "", n = !1, r, i = arguments.length - 1; i >= -1 && !n; i--) {
      var s;
      i >= 0 ? s = arguments[i] : (r === void 0 && (r = W0.cwd()), s = r), Ar(s), s.length !== 0 && (e = s + "/" + e, n = s.charCodeAt(0) === 47);
    }
    return e = _v(e, !n), n ? e.length > 0 ? "/" + e : "/" : e.length > 0 ? e : ".";
  },
  normalize: function(e) {
    if (Ar(e), e.length === 0)
      return ".";
    var n = e.charCodeAt(0) === 47, r = e.charCodeAt(e.length - 1) === 47;
    return e = _v(e, !n), e.length === 0 && !n && (e = "."), e.length > 0 && r && (e += "/"), n ? "/" + e : e;
  },
  isAbsolute: function(e) {
    return Ar(e), e.length > 0 && e.charCodeAt(0) === 47;
  },
  join: function() {
    if (arguments.length === 0)
      return ".";
    for (var e, n = 0; n < arguments.length; ++n) {
      var r = arguments[n];
      Ar(r), r.length > 0 && (e === void 0 ? e = r : e += "/" + r);
    }
    return e === void 0 ? "." : hl.normalize(e);
  },
  relative: function(e, n) {
    if (Ar(e), Ar(n), e === n || (e = hl.resolve(e), n = hl.resolve(n), e === n))
      return "";
    for (var r = 1; r < e.length && e.charCodeAt(r) === 47; ++r)
      ;
    for (var i = e.length, s = i - r, o = 1; o < n.length && n.charCodeAt(o) === 47; ++o)
      ;
    for (var a = n.length, l = a - o, u = s < l ? s : l, c = -1, d = 0; d <= u; ++d) {
      if (d === u) {
        if (l > u) {
          if (n.charCodeAt(o + d) === 47)
            return n.slice(o + d + 1);
          if (d === 0)
            return n.slice(o + d);
        } else
          s > u && (e.charCodeAt(r + d) === 47 ? c = d : d === 0 && (c = 0));
        break;
      }
      var h = e.charCodeAt(r + d), v = n.charCodeAt(o + d);
      if (h !== v)
        break;
      h === 47 && (c = d);
    }
    var m = "";
    for (d = r + c + 1; d <= i; ++d)
      (d === i || e.charCodeAt(d) === 47) && (m.length === 0 ? m += ".." : m += "/..");
    return m.length > 0 ? m + n.slice(o + c) : (o += c, n.charCodeAt(o) === 47 && ++o, n.slice(o));
  },
  _makeLong: function(e) {
    return e;
  },
  dirname: function(e) {
    if (Ar(e), e.length === 0)
      return ".";
    for (var n = e.charCodeAt(0), r = n === 47, i = -1, s = !0, o = e.length - 1; o >= 1; --o)
      if (n = e.charCodeAt(o), n === 47) {
        if (!s) {
          i = o;
          break;
        }
      } else
        s = !1;
    return i === -1 ? r ? "/" : "." : r && i === 1 ? "//" : e.slice(0, i);
  },
  basename: function(e, n) {
    if (n !== void 0 && typeof n != "string")
      throw new TypeError('"ext" argument must be a string');
    Ar(e);
    var r = 0, i = -1, s = !0, o;
    if (n !== void 0 && n.length > 0 && n.length <= e.length) {
      if (n.length === e.length && n === e)
        return "";
      var a = n.length - 1, l = -1;
      for (o = e.length - 1; o >= 0; --o) {
        var u = e.charCodeAt(o);
        if (u === 47) {
          if (!s) {
            r = o + 1;
            break;
          }
        } else
          l === -1 && (s = !1, l = o + 1), a >= 0 && (u === n.charCodeAt(a) ? --a === -1 && (i = o) : (a = -1, i = l));
      }
      return r === i ? i = l : i === -1 && (i = e.length), e.slice(r, i);
    } else {
      for (o = e.length - 1; o >= 0; --o)
        if (e.charCodeAt(o) === 47) {
          if (!s) {
            r = o + 1;
            break;
          }
        } else
          i === -1 && (s = !1, i = o + 1);
      return i === -1 ? "" : e.slice(r, i);
    }
  },
  extname: function(e) {
    Ar(e);
    for (var n = -1, r = 0, i = -1, s = !0, o = 0, a = e.length - 1; a >= 0; --a) {
      var l = e.charCodeAt(a);
      if (l === 47) {
        if (!s) {
          r = a + 1;
          break;
        }
        continue;
      }
      i === -1 && (s = !1, i = a + 1), l === 46 ? n === -1 ? n = a : o !== 1 && (o = 1) : n !== -1 && (o = -1);
    }
    return n === -1 || i === -1 || // We saw a non-dot character immediately before the dot
    o === 0 || // The (right-most) trimmed path component is exactly '..'
    o === 1 && n === i - 1 && n === r + 1 ? "" : e.slice(n, i);
  },
  format: function(e) {
    if (e === null || typeof e != "object")
      throw new TypeError(
        'Parameter "pathObject" must be an object, not ' + typeof e
      );
    return f6("/", e);
  },
  parse: function(e) {
    Ar(e);
    var n = { root: "", dir: "", base: "", ext: "", name: "" };
    if (e.length === 0)
      return n;
    var r = e.charCodeAt(0), i = r === 47, s;
    i ? (n.root = "/", s = 1) : s = 0;
    for (var o = -1, a = 0, l = -1, u = !0, c = e.length - 1, d = 0; c >= s; --c) {
      if (r = e.charCodeAt(c), r === 47) {
        if (!u) {
          a = c + 1;
          break;
        }
        continue;
      }
      l === -1 && (u = !1, l = c + 1), r === 46 ? o === -1 ? o = c : d !== 1 && (d = 1) : o !== -1 && (d = -1);
    }
    return o === -1 || l === -1 || // We saw a non-dot character immediately before the dot
    d === 0 || // The (right-most) trimmed path component is exactly '..'
    d === 1 && o === l - 1 && o === a + 1 ? l !== -1 && (a === 0 && i ? n.base = n.name = e.slice(1, l) : n.base = n.name = e.slice(a, l)) : (a === 0 && i ? (n.name = e.slice(1, o), n.base = e.slice(1, l)) : (n.name = e.slice(a, o), n.base = e.slice(a, l)), n.ext = e.slice(o, l)), a > 0 ? n.dir = e.slice(0, a - 1) : i && (n.dir = "/"), n;
  },
  sep: "/",
  delimiter: ":",
  posix: null
}, Si = hl;
class ui {
  constructor(e) {
    var n, r;
    n = e.indexOf("://"), n > -1 && (e = new URL(e).pathname), r = this.parse(e), this.path = e, this.isDirectory(e) ? this.directory = e : this.directory = r.dir + "/", this.filename = r.base, this.extension = r.ext.slice(1);
  }
  /**
   * Parse the path: https://nodejs.org/api/path.html#path_path_parse_path
   * @param	{string} what
   * @returns {object}
   */
  parse(e) {
    return Si.parse(e);
  }
  /**
   * @param	{string} what
   * @returns {boolean}
   */
  isAbsolute(e) {
    return Si.isAbsolute(e || this.path);
  }
  /**
   * Check if path ends with a directory
   * @param	{string} what
   * @returns {boolean}
   */
  isDirectory(e) {
    return e.charAt(e.length - 1) === "/";
  }
  /**
   * Resolve a path against the directory of the Path
   *
   * https://nodejs.org/api/path.html#path_path_resolve_paths
   * @param	{string} what
   * @returns {string} resolved
   */
  resolve(e) {
    return Si.resolve(this.directory, e);
  }
  /**
   * Resolve a path relative to the directory of the Path
   *
   * https://nodejs.org/api/path.html#path_path_relative_from_to
   * @param	{string} what
   * @returns {string} relative
   */
  relative(e) {
    var n = e && e.indexOf("://") > -1;
    return n ? e : Si.relative(this.directory, e);
  }
  splitPath(e) {
    return this.splitPathRe.exec(e).slice(1);
  }
  /**
   * Return the path string
   * @returns {string} path
   */
  toString() {
    return this.path;
  }
}
class vr {
  constructor(e, n) {
    var r = e.indexOf("://") > -1, i = e, s;
    if (this.Url = void 0, this.href = e, this.protocol = "", this.origin = "", this.hash = "", this.hash = "", this.search = "", this.base = n, !r && n !== !1 && typeof n != "string" && window && window.location && (this.base = window.location.href), r || this.base)
      try {
        this.base ? this.Url = new URL(e, this.base) : this.Url = new URL(e), this.href = this.Url.href, this.protocol = this.Url.protocol, this.origin = this.Url.origin, this.hash = this.Url.hash, this.search = this.Url.search, i = this.Url.pathname + (this.Url.search ? this.Url.search : "");
      } catch {
        this.Url = void 0, this.base && (s = new ui(this.base), i = s.resolve(i));
      }
    this.Path = new ui(i), this.directory = this.Path.directory, this.filename = this.Path.filename, this.extension = this.Path.extension;
  }
  /**
   * @returns {Path}
   */
  path() {
    return this.Path;
  }
  /**
   * Resolves a relative path to a absolute url
   * @param {string} what
   * @returns {string} url
   */
  resolve(e) {
    var n = e.indexOf("://") > -1, r;
    return n ? e : (r = Si.resolve(this.directory, e), this.origin + r);
  }
  /**
   * Resolve a path relative to the url
   * @param {string} what
   * @returns {string} path
   */
  relative(e) {
    return Si.relative(e, this.directory);
  }
  /**
   * @returns {string}
   */
  toString() {
    return this.href;
  }
}
const bs = 1, tr = 3, h6 = 9;
class gt {
  constructor(e, n, r) {
    var i;
    if (this.str = "", this.base = {}, this.spinePos = 0, this.range = !1, this.path = {}, this.start = null, this.end = null, !(this instanceof gt))
      return new gt(e, n, r);
    if (typeof n == "string" ? this.base = this.parseComponent(n) : typeof n == "object" && n.steps && (this.base = n), i = this.checkType(e), i === "string")
      return this.str = e, En(this, this.parse(e));
    if (i === "range")
      return En(this, this.fromRange(e, this.base, r));
    if (i === "node")
      return En(this, this.fromNode(e, this.base, r));
    if (i === "EpubCFI" && e.path)
      return e;
    if (e)
      throw new TypeError("not a valid argument for EpubCFI");
    return this;
  }
  /**
   * Check the type of constructor input
   * @private
   */
  checkType(e) {
    return this.isCfiString(e) ? "string" : e && typeof e == "object" && (F0(e) === "Range" || typeof e.startContainer < "u") ? "range" : e && typeof e == "object" && typeof e.nodeType < "u" ? "node" : e && typeof e == "object" && e instanceof gt ? "EpubCFI" : !1;
  }
  /**
   * Parse a cfi string to a CFI object representation
   * @param {string} cfiStr
   * @returns {object} cfi
   */
  parse(e) {
    var n = {
      spinePos: -1,
      range: !1,
      base: {},
      path: {},
      start: null,
      end: null
    }, r, i, s;
    return typeof e != "string" ? { spinePos: -1 } : (e.indexOf("epubcfi(") === 0 && e[e.length - 1] === ")" && (e = e.slice(8, e.length - 1)), r = this.getChapterComponent(e), r ? (n.base = this.parseComponent(r), i = this.getPathComponent(e), n.path = this.parseComponent(i), s = this.getRange(e), s && (n.range = !0, n.start = this.parseComponent(s[0]), n.end = this.parseComponent(s[1])), n.spinePos = n.base.steps[1].index, n) : { spinePos: -1 });
  }
  parseComponent(e) {
    var n = {
      steps: [],
      terminal: {
        offset: null,
        assertion: null
      }
    }, r = e.split(":"), i = r[0].split("/"), s;
    return r.length > 1 && (s = r[1], n.terminal = this.parseTerminal(s)), i[0] === "" && i.shift(), n.steps = i.map(function(o) {
      return this.parseStep(o);
    }.bind(this)), n;
  }
  parseStep(e) {
    var n, r, i, s, o;
    if (s = e.match(/\[(.*)\]/), s && s[1] && (o = s[1]), r = parseInt(e), !isNaN(r))
      return r % 2 === 0 ? (n = "element", i = r / 2 - 1) : (n = "text", i = (r - 1) / 2), {
        type: n,
        index: i,
        id: o || null
      };
  }
  parseTerminal(e) {
    var n, r, i = e.match(/\[(.*)\]/);
    return i && i[1] ? (n = parseInt(e.split("[")[0]), r = i[1]) : n = parseInt(e), Yt(n) || (n = null), {
      offset: n,
      assertion: r
    };
  }
  getChapterComponent(e) {
    var n = e.split("!");
    return n[0];
  }
  getPathComponent(e) {
    var n = e.split("!");
    if (n[1])
      return n[1].split(",")[0];
  }
  getRange(e) {
    var n = e.split(",");
    return n.length === 3 ? [
      n[1],
      n[2]
    ] : !1;
  }
  getCharecterOffsetComponent(e) {
    var n = e.split(":");
    return n[1] || "";
  }
  joinSteps(e) {
    return e ? e.map(function(n) {
      var r = "";
      return n.type === "element" && (r += (n.index + 1) * 2), n.type === "text" && (r += 1 + 2 * n.index), n.id && (r += "[" + n.id + "]"), r;
    }).join("/") : "";
  }
  segmentString(e) {
    var n = "/";
    return n += this.joinSteps(e.steps), e.terminal && e.terminal.offset != null && (n += ":" + e.terminal.offset), e.terminal && e.terminal.assertion != null && (n += "[" + e.terminal.assertion + "]"), n;
  }
  /**
   * Convert CFI to a epubcfi(...) string
   * @returns {string} epubcfi
   */
  toString() {
    var e = "epubcfi(";
    return e += this.segmentString(this.base), e += "!", e += this.segmentString(this.path), this.range && this.start && (e += ",", e += this.segmentString(this.start)), this.range && this.end && (e += ",", e += this.segmentString(this.end)), e += ")", e;
  }
  /**
   * Compare which of two CFIs is earlier in the text
   * @returns {number} First is earlier = -1, Second is earlier = 1, They are equal = 0
   */
  compare(e, n) {
    var r, i, s, o;
    if (typeof e == "string" && (e = new gt(e)), typeof n == "string" && (n = new gt(n)), e.spinePos > n.spinePos)
      return 1;
    if (e.spinePos < n.spinePos)
      return -1;
    e.range ? (r = e.path.steps.concat(e.start.steps), s = e.start.terminal) : (r = e.path.steps, s = e.path.terminal), n.range ? (i = n.path.steps.concat(n.start.steps), o = n.start.terminal) : (i = n.path.steps, o = n.path.terminal);
    for (var a = 0; a < r.length; a++) {
      if (!r[a])
        return -1;
      if (!i[a] || r[a].index > i[a].index)
        return 1;
      if (r[a].index < i[a].index)
        return -1;
    }
    return r.length < i.length ? -1 : s.offset > o.offset ? 1 : s.offset < o.offset ? -1 : 0;
  }
  step(e) {
    var n = e.nodeType === tr ? "text" : "element";
    return {
      id: e.id,
      tagName: e.tagName,
      type: n,
      index: this.position(e)
    };
  }
  filteredStep(e, n) {
    var r = this.filter(e, n), i;
    if (r)
      return i = r.nodeType === tr ? "text" : "element", {
        id: r.id,
        tagName: r.tagName,
        type: i,
        index: this.filteredPosition(r, n)
      };
  }
  pathTo(e, n, r) {
    for (var i = {
      steps: [],
      terminal: {
        offset: null,
        assertion: null
      }
    }, s = e, o; s && s.parentNode && s.parentNode.nodeType != h6; )
      r ? o = this.filteredStep(s, r) : o = this.step(s), o && i.steps.unshift(o), s = s.parentNode;
    return n != null && n >= 0 && (i.terminal.offset = n, i.steps[i.steps.length - 1].type != "text" && i.steps.push({
      type: "text",
      index: 0
    })), i;
  }
  equalStep(e, n) {
    return !e || !n ? !1 : e.index === n.index && e.id === n.id && e.type === n.type;
  }
  /**
   * Create a CFI object from a Range
   * @param {Range} range
   * @param {string | object} base
   * @param {string} [ignoreClass]
   * @returns {object} cfi
   */
  fromRange(e, n, r) {
    var i = {
      range: !1,
      base: {},
      path: {},
      start: null,
      end: null
    }, s = e.startContainer, o = e.endContainer, a = e.startOffset, l = e.endOffset, u = !1;
    if (r && (u = s.ownerDocument.querySelector("." + r) != null), typeof n == "string" ? (i.base = this.parseComponent(n), i.spinePos = i.base.steps[1].index) : typeof n == "object" && (i.base = n), e.collapsed)
      u && (a = this.patchOffset(s, a, r)), i.path = this.pathTo(s, a, r);
    else {
      i.range = !0, u && (a = this.patchOffset(s, a, r)), i.start = this.pathTo(s, a, r), u && (l = this.patchOffset(o, l, r)), i.end = this.pathTo(o, l, r), i.path = {
        steps: [],
        terminal: null
      };
      var c = i.start.steps.length, d;
      for (d = 0; d < c && this.equalStep(i.start.steps[d], i.end.steps[d]); d++)
        d === c - 1 ? i.start.terminal === i.end.terminal && (i.path.steps.push(i.start.steps[d]), i.range = !1) : i.path.steps.push(i.start.steps[d]);
      i.start.steps = i.start.steps.slice(i.path.steps.length), i.end.steps = i.end.steps.slice(i.path.steps.length);
    }
    return i;
  }
  /**
   * Create a CFI object from a Node
   * @param {Node} anchor
   * @param {string | object} base
   * @param {string} [ignoreClass]
   * @returns {object} cfi
   */
  fromNode(e, n, r) {
    var i = {
      range: !1,
      base: {},
      path: {},
      start: null,
      end: null
    };
    return typeof n == "string" ? (i.base = this.parseComponent(n), i.spinePos = i.base.steps[1].index) : typeof n == "object" && (i.base = n), i.path = this.pathTo(e, null, r), i;
  }
  filter(e, n) {
    var r, i, s, o, a, l = !1;
    return e.nodeType === tr ? (l = !0, s = e.parentNode, r = e.parentNode.classList.contains(n)) : (l = !1, r = e.classList.contains(n)), r && l ? (o = s.previousSibling, a = s.nextSibling, o && o.nodeType === tr ? i = o : a && a.nodeType === tr && (i = a), i || e) : r && !l ? !1 : e;
  }
  patchOffset(e, n, r) {
    if (e.nodeType != tr)
      throw new Error("Anchor must be a text node");
    var i = e, s = n;
    for (e.parentNode.classList.contains(r) && (i = e.parentNode); i.previousSibling; ) {
      if (i.previousSibling.nodeType === bs)
        if (i.previousSibling.classList.contains(r))
          s += i.previousSibling.textContent.length;
        else
          break;
      else
        s += i.previousSibling.textContent.length;
      i = i.previousSibling;
    }
    return s;
  }
  normalizedMap(e, n, r) {
    var i = {}, s = -1, o, a = e.length, l, u;
    for (o = 0; o < a; o++)
      l = e[o].nodeType, l === bs && e[o].classList.contains(r) && (l = tr), o > 0 && l === tr && u === tr ? i[o] = s : n === l && (s = s + 1, i[o] = s), u = l;
    return i;
  }
  position(e) {
    var n, r;
    return e.nodeType === bs ? (n = e.parentNode.children, n || (n = bd(e.parentNode)), r = Array.prototype.indexOf.call(n, e)) : (n = this.textNodes(e.parentNode), r = n.indexOf(e)), r;
  }
  filteredPosition(e, n) {
    var r, i, s;
    return e.nodeType === bs ? (r = e.parentNode.children, s = this.normalizedMap(r, bs, n)) : (r = e.parentNode.childNodes, e.parentNode.classList.contains(n) && (e = e.parentNode, r = e.parentNode.childNodes), s = this.normalizedMap(r, tr, n)), i = Array.prototype.indexOf.call(r, e), s[i];
  }
  stepsToXpath(e) {
    var n = [".", "*"];
    return e.forEach(function(r) {
      var i = r.index + 1;
      r.id ? n.push("*[position()=" + i + " and @id='" + r.id + "']") : r.type === "text" ? n.push("text()[" + i + "]") : n.push("*[" + i + "]");
    }), n.join("/");
  }
  /*
  
  	To get the last step if needed:
  
  	// Get the terminal step
  	lastStep = steps[steps.length-1];
  	// Get the query string
  	query = this.stepsToQuery(steps);
  	// Find the containing element
  	startContainerParent = doc.querySelector(query);
  	// Find the text node within that element
  	if(startContainerParent && lastStep.type == "text") {
  		container = startContainerParent.childNodes[lastStep.index];
  	}
  	*/
  stepsToQuerySelector(e) {
    var n = ["html"];
    return e.forEach(function(r) {
      var i = r.index + 1;
      r.id ? n.push("#" + r.id) : r.type === "text" || n.push("*:nth-child(" + i + ")");
    }), n.join(">");
  }
  textNodes(e, n) {
    return Array.prototype.slice.call(e.childNodes).filter(function(r) {
      return r.nodeType === tr ? !0 : !!(n && r.classList.contains(n));
    });
  }
  walkToNode(e, n, r) {
    var i = n || document, s = i.documentElement, o, a, l = e.length, u;
    for (u = 0; u < l && (a = e[u], a.type === "element" ? a.id ? s = i.getElementById(a.id) : (o = s.children || bd(s), s = o[a.index]) : a.type === "text" && (s = this.textNodes(s, r)[a.index]), !!s); u++)
      ;
    return s;
  }
  findNode(e, n, r) {
    var i = n || document, s, o;
    return !r && typeof i.evaluate < "u" ? (o = this.stepsToXpath(e), s = i.evaluate(o, i, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue) : r ? s = this.walkToNode(e, i, r) : s = this.walkToNode(e, i), s;
  }
  fixMiss(e, n, r, i) {
    var s = this.findNode(e.slice(0, -1), r, i), o = s.childNodes, a = this.normalizedMap(o, tr, i), l, u, c = e[e.length - 1].index;
    for (let d in a) {
      if (!a.hasOwnProperty(d))
        return;
      if (a[d] === c)
        if (l = o[d], u = l.textContent.length, n > u)
          n = n - u;
        else {
          l.nodeType === bs ? s = l.childNodes[0] : s = l;
          break;
        }
    }
    return {
      container: s,
      offset: n
    };
  }
  /**
   * Creates a DOM range representing a CFI
   * @param {document} _doc document referenced in the base
   * @param {string} [ignoreClass]
   * @return {Range}
   */
  toRange(e, n) {
    var r = e || document, i, s, o, a, l, u = this, c, d, h = n ? r.querySelector("." + n) != null : !1, v;
    if (typeof r.createRange < "u" ? i = r.createRange() : i = new V0(), u.range ? (s = u.start, c = u.path.steps.concat(s.steps), a = this.findNode(c, r, h ? n : null), o = u.end, d = u.path.steps.concat(o.steps), l = this.findNode(d, r, h ? n : null)) : (s = u.path, c = u.path.steps, a = this.findNode(u.path.steps, r, h ? n : null)), a)
      try {
        s.terminal.offset != null ? i.setStart(a, s.terminal.offset) : i.setStart(a, 0);
      } catch {
        v = this.fixMiss(c, s.terminal.offset, r, h ? n : null), i.setStart(v.container, v.offset);
      }
    else
      return console.log("No startContainer found for", this.toString()), null;
    if (l)
      try {
        o.terminal.offset != null ? i.setEnd(l, o.terminal.offset) : i.setEnd(l, 0);
      } catch {
        v = this.fixMiss(d, u.end.terminal.offset, r, h ? n : null), i.setEnd(v.container, v.offset);
      }
    return i;
  }
  /**
   * Check if a string is wrapped with "epubcfi()"
   * @param {string} str
   * @returns {boolean}
   */
  isCfiString(e) {
    return typeof e == "string" && e.indexOf("epubcfi(") === 0 && e[e.length - 1] === ")";
  }
  generateChapterComponent(e, n, r) {
    var i = parseInt(n), s = (e + 1) * 2, o = "/" + s + "/";
    return o += (i + 1) * 2, r && (o += "[" + r + "]"), o;
  }
  /**
   * Collapse a CFI Range to a single CFI Position
   * @param {boolean} [toStart=false]
   */
  collapse(e) {
    this.range && (this.range = !1, e ? (this.path.steps = this.path.steps.concat(this.start.steps), this.path.terminal = this.start.terminal) : (this.path.steps = this.path.steps.concat(this.end.steps), this.path.terminal = this.end.terminal));
  }
}
class gr {
  constructor(e) {
    this.context = e || this, this.hooks = [];
  }
  /**
   * Adds a function to be run before a hook completes
   * @example this.content.register(function(){...});
   */
  register() {
    for (var e = 0; e < arguments.length; ++e)
      if (typeof arguments[e] == "function")
        this.hooks.push(arguments[e]);
      else
        for (var n = 0; n < arguments[e].length; ++n)
          this.hooks.push(arguments[e][n]);
  }
  /**
   * Removes a function
   * @example this.content.deregister(function(){...});
   */
  deregister(e) {
    let n;
    for (let r = 0; r < this.hooks.length; r++)
      if (n = this.hooks[r], n === e) {
        this.hooks.splice(r, 1);
        break;
      }
  }
  /**
   * Triggers a hook to run all functions
   * @example this.content.trigger(args).then(function(){...});
   */
  trigger() {
    var e = arguments, n = this.context, r = [];
    return this.hooks.forEach(function(i) {
      try {
        var s = i.apply(n, e);
      } catch (o) {
        console.log(o);
      }
      s && typeof s.then == "function" && r.push(s);
    }), Promise.all(r);
  }
  // Adds a function to be run before a hook completes
  list() {
    return this.hooks;
  }
  clear() {
    return this.hooks = [];
  }
}
function $0(t, e) {
  var n, r, i = e.url, s = i.indexOf("://") > -1;
  t && (r = zt(t, "head"), n = zt(r, "base"), n || (n = t.createElement("base"), r.insertBefore(n, r.firstChild)), !s && window && window.location && (i = window.location.origin + i), n.setAttribute("href", i));
}
function p6(t, e) {
  var n, r, i = e.canonical;
  t && (n = zt(t, "head"), r = zt(n, "link[rel='canonical']"), r ? r.setAttribute("href", i) : (r = t.createElement("link"), r.setAttribute("rel", "canonical"), r.setAttribute("href", i), n.appendChild(r)));
}
function v6(t, e) {
  var n, r, i = e.idref;
  t && (n = zt(t, "head"), r = zt(n, "link[property='dc.identifier']"), r ? r.setAttribute("content", i) : (r = t.createElement("meta"), r.setAttribute("name", "dc.identifier"), r.setAttribute("content", i), n.appendChild(r)));
}
function g6(t, e) {
  var n = t.querySelectorAll("a[href]");
  if (n.length)
    for (var r = zt(t.ownerDocument, "base"), i = r ? r.getAttribute("href") : void 0, s = function(a) {
      var l = a.getAttribute("href");
      if (l.indexOf("mailto:") !== 0) {
        var u = l.indexOf("://") > -1;
        if (u)
          a.setAttribute("target", "_blank");
        else {
          var c;
          try {
            c = new vr(l, i);
          } catch {
          }
          a.onclick = function() {
            return c && c.hash ? e(c.Path.path + c.hash) : e(c ? c.Path.path : l), !1;
          };
        }
      }
    }.bind(this), o = 0; o < n.length; o++)
      s(n[o]);
}
function Sv(t, e, n) {
  return e.forEach(function(r, i) {
    r && n[i] && (r = r.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), t = t.replace(new RegExp(r, "g"), n[i]));
  }), t;
}
function Zo(t, e, n, r) {
  var i = typeof window < "u" ? window.URL : !1, s = i ? "blob" : "arraybuffer", o = new vt(), a = new XMLHttpRequest(), l = XMLHttpRequest.prototype, u;
  "overrideMimeType" in l || Object.defineProperty(l, "overrideMimeType", {
    value: function() {
    }
  }), n && (a.withCredentials = !0), a.onreadystatechange = d, a.onerror = c, a.open("GET", t, !0);
  for (u in r)
    a.setRequestHeader(u, r[u]);
  e == "json" && a.setRequestHeader("Accept", "application/json"), e || (e = new ui(t).extension), e == "blob" && (a.responseType = s), Qo(e) && a.overrideMimeType("text/xml"), e == "binary" && (a.responseType = "arraybuffer"), a.send();
  function c(h) {
    o.reject(h);
  }
  function d() {
    if (this.readyState === XMLHttpRequest.DONE) {
      var h = !1;
      if ((this.responseType === "" || this.responseType === "document") && (h = this.responseXML), this.status === 200 || this.status === 0 || h) {
        var v;
        if (!this.response && !h)
          return o.reject({
            status: this.status,
            message: "Empty Response",
            stack: new Error().stack
          }), o.promise;
        if (this.status === 403)
          return o.reject({
            status: this.status,
            response: this.response,
            message: "Forbidden",
            stack: new Error().stack
          }), o.promise;
        h ? v = this.responseXML : Qo(e) ? v = Pr(this.response, "text/xml") : e == "xhtml" ? v = Pr(this.response, "application/xhtml+xml") : e == "html" || e == "htm" ? v = Pr(this.response, "text/html") : e == "json" ? v = JSON.parse(this.response) : e == "blob" ? i ? v = this.response : v = new Blob([this.response]) : v = this.response, o.resolve(v);
      } else
        o.reject({
          status: this.status,
          message: this.response,
          stack: new Error().stack
        });
    }
  }
  return o.promise;
}
class m6 {
  constructor(e, n) {
    this.idref = e.idref, this.linear = e.linear === "yes", this.properties = e.properties, this.index = e.index, this.href = e.href, this.url = e.url, this.canonical = e.canonical, this.next = e.next, this.prev = e.prev, this.cfiBase = e.cfiBase, n ? this.hooks = n : (this.hooks = {}, this.hooks.serialize = new gr(this), this.hooks.content = new gr(this)), this.document = void 0, this.contents = void 0, this.output = void 0;
  }
  /**
   * Load the section from its url
   * @param  {method} [_request] a request method to use for loading
   * @return {document} a promise with the xml document
   */
  load(e) {
    var n = e || this.request || Zo, r = new vt(), i = r.promise;
    return this.contents ? r.resolve(this.contents) : n(this.url).then(function(s) {
      return this.document = s, this.contents = s.documentElement, this.hooks.content.trigger(this.document, this);
    }.bind(this)).then(function() {
      r.resolve(this.contents);
    }.bind(this)).catch(function(s) {
      r.reject(s);
    }), i;
  }
  /**
   * Adds a base tag for resolving urls in the section
   * @private
   */
  base() {
    return $0(this.document, this);
  }
  /**
   * Render the contents of a section
   * @param  {method} [_request] a request method to use for loading
   * @return {string} output a serialized XML Document
   */
  render(e) {
    var n = new vt(), r = n.promise;
    return this.output, this.load(e).then(function(i) {
      var s = typeof navigator < "u" && navigator.userAgent || "", o = s.indexOf("Trident") >= 0, a;
      typeof XMLSerializer > "u" || o ? a = R0 : a = XMLSerializer;
      var l = new a();
      return this.output = l.serializeToString(i), this.output;
    }.bind(this)).then(function() {
      return this.hooks.serialize.trigger(this.output, this);
    }.bind(this)).then(function() {
      n.resolve(this.output);
    }.bind(this)).catch(function(i) {
      n.reject(i);
    }), r;
  }
  /**
   * Find a string in a section
   * @param  {string} _query The query string to find
   * @return {object[]} A list of matches, with form {cfi, excerpt}
   */
  find(e) {
    var n = this, r = [], i = e.toLowerCase(), s = function(o) {
      for (var a = o.textContent.toLowerCase(), l = n.document.createRange(), u, c, d = -1, h, v = 150; c != -1; )
        c = a.indexOf(i, d + 1), c != -1 && (l = n.document.createRange(), l.setStart(o, c), l.setEnd(o, c + i.length), u = n.cfiFromRange(l), o.textContent.length < v ? h = o.textContent : (h = o.textContent.substring(c - v / 2, c + v / 2), h = "..." + h + "..."), r.push({
          cfi: u,
          excerpt: h
        })), d = c;
    };
    return Vl(n.document, function(o) {
      s(o);
    }), r;
  }
  /**
   * Search a string in multiple sequential Element of the section. If the document.createTreeWalker api is missed(eg: IE8), use `find` as a fallback.
   * @param  {string} _query The query string to search
   * @param  {int} maxSeqEle The maximum number of Element that are combined for search, default value is 5.
   * @return {object[]} A list of matches, with form {cfi, excerpt}
   */
  search(e, n = 5) {
    if (typeof document.createTreeWalker > "u")
      return this.find(e);
    let r = [];
    const i = 150, s = this, o = e.toLowerCase(), a = function(d) {
      const m = d.reduce((b, p) => b + p.textContent, "").toLowerCase().indexOf(o);
      if (m != -1) {
        const p = m + o.length;
        let f = 0, g = 0;
        if (m < d[0].length) {
          let y;
          for (; f < d.length - 1 && (g += d[f].length, !(p <= g)); )
            f += 1;
          let w = d[0], _ = d[f], S = s.document.createRange();
          S.setStart(w, m);
          let A = d.slice(0, f).reduce((k, O) => k + O.textContent.length, 0);
          S.setEnd(_, A > p ? p : p - A), y = s.cfiFromRange(S);
          let C = d.slice(0, f + 1).reduce((k, O) => k + O.textContent, "");
          C.length > i && (C = C.substring(m - i / 2, m + i / 2), C = "..." + C + "..."), r.push({
            cfi: y,
            excerpt: C
          });
        }
      }
    }, l = document.createTreeWalker(s.document, NodeFilter.SHOW_TEXT, null, !1);
    let u, c = [];
    for (; u = l.nextNode(); )
      c.push(u), c.length == n && (a(c.slice(0, n)), c = c.slice(1, n));
    return c.length > 0 && a(c), r;
  }
  /**
  * Reconciles the current chapters layout properties with
  * the global layout properties.
  * @param {object} globalLayout  The global layout settings object, chapter properties string
  * @return {object} layoutProperties Object with layout properties
  */
  reconcileLayoutSettings(e) {
    var n = {
      layout: e.layout,
      spread: e.spread,
      orientation: e.orientation
    };
    return this.properties.forEach(function(r) {
      var i = r.replace("rendition:", ""), s = i.indexOf("-"), o, a;
      s != -1 && (o = i.slice(0, s), a = i.slice(s + 1), n[o] = a);
    }), n;
  }
  /**
   * Get a CFI from a Range in the Section
   * @param  {range} _range
   * @return {string} cfi an EpubCFI string
   */
  cfiFromRange(e) {
    return new gt(e, this.cfiBase).toString();
  }
  /**
   * Get a CFI from an Element in the Section
   * @param  {element} el
   * @return {string} cfi an EpubCFI string
   */
  cfiFromElement(e) {
    return new gt(e, this.cfiBase).toString();
  }
  /**
   * Unload the section document
   */
  unload() {
    this.document = void 0, this.contents = void 0, this.output = void 0;
  }
  destroy() {
    this.unload(), this.hooks.serialize.clear(), this.hooks.content.clear(), this.hooks = void 0, this.idref = void 0, this.linear = void 0, this.properties = void 0, this.index = void 0, this.href = void 0, this.url = void 0, this.next = void 0, this.prev = void 0, this.cfiBase = void 0;
  }
}
class y6 {
  constructor() {
    this.spineItems = [], this.spineByHref = {}, this.spineById = {}, this.hooks = {}, this.hooks.serialize = new gr(), this.hooks.content = new gr(), this.hooks.content.register($0), this.hooks.content.register(p6), this.hooks.content.register(v6), this.epubcfi = new gt(), this.loaded = !1, this.items = void 0, this.manifest = void 0, this.spineNodeIndex = void 0, this.baseUrl = void 0, this.length = void 0;
  }
  /**
   * Unpack items from a opf into spine items
   * @param  {Packaging} _package
   * @param  {method} resolver URL resolver
   * @param  {method} canonical Resolve canonical url
   */
  unpack(e, n, r) {
    this.items = e.spine, this.manifest = e.manifest, this.spineNodeIndex = e.spineNodeIndex, this.baseUrl = e.baseUrl || e.basePath || "", this.length = this.items.length, this.items.forEach((i, s) => {
      var o = this.manifest[i.idref], a;
      i.index = s, i.cfiBase = this.epubcfi.generateChapterComponent(this.spineNodeIndex, i.index, i.id), i.href && (i.url = n(i.href, !0), i.canonical = r(i.href)), o && (i.href = o.href, i.url = n(i.href, !0), i.canonical = r(i.href), o.properties.length && i.properties.push.apply(i.properties, o.properties)), i.linear === "yes" ? (i.prev = function() {
        let l = i.index;
        for (; l > 0; ) {
          let u = this.get(l - 1);
          if (u && u.linear)
            return u;
          l -= 1;
        }
      }.bind(this), i.next = function() {
        let l = i.index;
        for (; l < this.spineItems.length - 1; ) {
          let u = this.get(l + 1);
          if (u && u.linear)
            return u;
          l += 1;
        }
      }.bind(this)) : (i.prev = function() {
      }, i.next = function() {
      }), a = new m6(i, this.hooks), this.append(a);
    }), this.loaded = !0;
  }
  /**
   * Get an item from the spine
   * @param  {string|number} [target]
   * @return {Section} section
   * @example spine.get();
   * @example spine.get(1);
   * @example spine.get("chap1.html");
   * @example spine.get("#id1234");
   */
  get(e) {
    var n = 0;
    if (typeof e > "u")
      for (; n < this.spineItems.length; ) {
        let r = this.spineItems[n];
        if (r && r.linear)
          break;
        n += 1;
      }
    else
      this.epubcfi.isCfiString(e) ? n = new gt(e).spinePos : typeof e == "number" || isNaN(e) === !1 ? n = e : typeof e == "string" && e.indexOf("#") === 0 ? n = this.spineById[e.substring(1)] : typeof e == "string" && (e = e.split("#")[0], n = this.spineByHref[e] || this.spineByHref[encodeURI(e)]);
    return this.spineItems[n] || null;
  }
  /**
   * Append a Section to the Spine
   * @private
   * @param  {Section} section
   */
  append(e) {
    var n = this.spineItems.length;
    return e.index = n, this.spineItems.push(e), this.spineByHref[decodeURI(e.href)] = n, this.spineByHref[encodeURI(e.href)] = n, this.spineByHref[e.href] = n, this.spineById[e.idref] = n, n;
  }
  /**
   * Prepend a Section to the Spine
   * @private
   * @param  {Section} section
   */
  prepend(e) {
    return this.spineByHref[e.href] = 0, this.spineById[e.idref] = 0, this.spineItems.forEach(function(n, r) {
      n.index = r;
    }), 0;
  }
  // insert(section, index) {
  //
  // };
  /**
   * Remove a Section from the Spine
   * @private
   * @param  {Section} section
   */
  remove(e) {
    var n = this.spineItems.indexOf(e);
    if (n > -1)
      return delete this.spineByHref[e.href], delete this.spineById[e.idref], this.spineItems.splice(n, 1);
  }
  /**
   * Loop over the Sections in the Spine
   * @return {method} forEach
   */
  each() {
    return this.spineItems.forEach.apply(this.spineItems, arguments);
  }
  /**
   * Find the first Section in the Spine
   * @return {Section} first section
   */
  first() {
    let e = 0;
    do {
      let n = this.get(e);
      if (n && n.linear)
        return n;
      e += 1;
    } while (e < this.spineItems.length);
  }
  /**
   * Find the last Section in the Spine
   * @return {Section} last section
   */
  last() {
    let e = this.spineItems.length - 1;
    do {
      let n = this.get(e);
      if (n && n.linear)
        return n;
      e -= 1;
    } while (e >= 0);
  }
  destroy() {
    this.each((e) => e.destroy()), this.spineItems = void 0, this.spineByHref = void 0, this.spineById = void 0, this.hooks.serialize.clear(), this.hooks.content.clear(), this.hooks = void 0, this.epubcfi = void 0, this.loaded = !1, this.items = void 0, this.manifest = void 0, this.spineNodeIndex = void 0, this.baseUrl = void 0, this.length = void 0;
  }
}
class Kf {
  constructor(e) {
    this._q = [], this.context = e, this.tick = Vf, this.running = !1, this.paused = !1;
  }
  /**
   * Add an item to the queue
   * @return {Promise}
   */
  enqueue() {
    var e, n, r, i = [].shift.call(arguments), s = arguments;
    if (!i)
      throw new Error("No Task Provided");
    return typeof i == "function" ? (e = new vt(), n = e.promise, r = {
      task: i,
      args: s,
      //"context"  : context,
      deferred: e,
      promise: n
    }) : r = {
      promise: i
    }, this._q.push(r), this.paused == !1 && !this.running && this.run(), r.promise;
  }
  /**
   * Run one item
   * @return {Promise}
   */
  dequeue() {
    var e, n, r;
    if (this._q.length && !this.paused) {
      if (e = this._q.shift(), n = e.task, n)
        return r = n.apply(this.context, e.args), r && typeof r.then == "function" ? r.then(function() {
          e.deferred.resolve.apply(this.context, arguments);
        }.bind(this), function() {
          e.deferred.reject.apply(this.context, arguments);
        }.bind(this)) : (e.deferred.resolve.apply(this.context, r), e.promise);
      if (e.promise)
        return e.promise;
    } else
      return e = new vt(), e.deferred.resolve(), e.promise;
  }
  // Run All Immediately
  dump() {
    for (; this._q.length; )
      this.dequeue();
  }
  /**
   * Run all tasks sequentially, at convince
   * @return {Promise}
   */
  run() {
    return this.running || (this.running = !0, this.defered = new vt()), this.tick.call(window, () => {
      this._q.length ? this.dequeue().then(function() {
        this.run();
      }.bind(this)) : (this.defered.resolve(), this.running = void 0);
    }), this.paused == !0 && (this.paused = !1), this.defered.promise;
  }
  /**
   * Flush all, as quickly as possible
   * @return {Promise}
   */
  flush() {
    if (this.running)
      return this.running;
    if (this._q.length)
      return this.running = this.dequeue().then(function() {
        return this.running = void 0, this.flush();
      }.bind(this)), this.running;
  }
  /**
   * Clear all items in wait
   */
  clear() {
    this._q = [];
  }
  /**
   * Get the number of tasks in the queue
   * @return {number} tasks
   */
  length() {
    return this._q.length;
  }
  /**
   * Pause a running queue
   */
  pause() {
    this.paused = !0;
  }
  /**
   * End the queue
   */
  stop() {
    this._q = [], this.running = !1, this.paused = !0;
  }
}
const yu = "0.3", pl = ["keydown", "keyup", "keypressed", "mouseup", "mousedown", "mousemove", "click", "touchend", "touchstart", "touchmove"], Re = {
  BOOK: {
    OPEN_FAILED: "openFailed"
  },
  CONTENTS: {
    EXPAND: "expand",
    RESIZE: "resize",
    SELECTED: "selected",
    SELECTED_RANGE: "selectedRange",
    LINK_CLICKED: "linkClicked"
  },
  LOCATIONS: {
    CHANGED: "changed"
  },
  MANAGERS: {
    RESIZE: "resize",
    RESIZED: "resized",
    ORIENTATION_CHANGE: "orientationchange",
    ADDED: "added",
    SCROLL: "scroll",
    SCROLLED: "scrolled",
    REMOVED: "removed"
  },
  VIEWS: {
    AXIS: "axis",
    WRITING_MODE: "writingMode",
    LOAD_ERROR: "loaderror",
    RENDERED: "rendered",
    RESIZED: "resized",
    DISPLAYED: "displayed",
    SHOWN: "shown",
    HIDDEN: "hidden",
    MARK_CLICKED: "markClicked"
  },
  RENDITION: {
    STARTED: "started",
    ATTACHED: "attached",
    DISPLAYED: "displayed",
    DISPLAY_ERROR: "displayerror",
    RENDERED: "rendered",
    REMOVED: "removed",
    RESIZED: "resized",
    ORIENTATION_CHANGE: "orientationchange",
    LOCATION_CHANGED: "locationChanged",
    RELOCATED: "relocated",
    MARK_CLICKED: "markClicked",
    SELECTED: "selected",
    LAYOUT: "layout"
  },
  LAYOUT: {
    UPDATED: "updated"
  },
  ANNOTATION: {
    ATTACH: "attach",
    DETACH: "detach"
  }
};
class K0 {
  constructor(e, n, r) {
    this.spine = e, this.request = n, this.pause = r || 100, this.q = new Kf(this), this.epubcfi = new gt(), this._locations = [], this._locationsWords = [], this.total = 0, this.break = 150, this._current = 0, this._wordCounter = 0, this.currentLocation = "", this._currentCfi = "", this.processingTimeout = void 0;
  }
  /**
   * Load all of sections in the book to generate locations
   * @param  {int} chars how many chars to split on
   * @return {Promise<Array<string>>} locations
   */
  generate(e) {
    return e && (this.break = e), this.q.pause(), this.spine.each(function(n) {
      n.linear && this.q.enqueue(this.process.bind(this), n);
    }.bind(this)), this.q.run().then(function() {
      return this.total = this._locations.length - 1, this._currentCfi && (this.currentLocation = this._currentCfi), this._locations;
    }.bind(this));
  }
  createRange() {
    return {
      startContainer: void 0,
      startOffset: void 0,
      endContainer: void 0,
      endOffset: void 0
    };
  }
  process(e) {
    return e.load(this.request).then(function(n) {
      var r = new vt(), i = this.parse(n, e.cfiBase);
      return this._locations = this._locations.concat(i), e.unload(), this.processingTimeout = setTimeout(() => r.resolve(i), this.pause), r.promise;
    }.bind(this));
  }
  parse(e, n, r) {
    var i = [], s, o = e.ownerDocument, a = zt(o, "body"), l = 0, u, c = r || this.break, d = function(h) {
      var v = h.length, m, b = 0;
      if (h.textContent.trim().length === 0)
        return !1;
      for (l == 0 && (s = this.createRange(), s.startContainer = h, s.startOffset = 0), m = c - l, m > v && (l += v, b = v); b < v; )
        if (m = c - l, l === 0 && (b += 1, s = this.createRange(), s.startContainer = h, s.startOffset = b), b + m >= v)
          l += v - b, b = v;
        else {
          b += m, s.endContainer = h, s.endOffset = b;
          let p = new gt(s, n).toString();
          i.push(p), l = 0;
        }
      u = h;
    };
    if (Vl(a, d.bind(this)), s && s.startContainer && u) {
      s.endContainer = u, s.endOffset = u.length;
      let h = new gt(s, n).toString();
      i.push(h), l = 0;
    }
    return i;
  }
  /**
   * Load all of sections in the book to generate locations
   * @param  {string} startCfi start position
   * @param  {int} wordCount how many words to split on
   * @param  {int} count result count
   * @return {object} locations
   */
  generateFromWords(e, n, r) {
    var i = e ? new gt(e) : void 0;
    return this.q.pause(), this._locationsWords = [], this._wordCounter = 0, this.spine.each(function(s) {
      s.linear && (i ? s.index >= i.spinePos && this.q.enqueue(this.processWords.bind(this), s, n, i, r) : this.q.enqueue(this.processWords.bind(this), s, n, i, r));
    }.bind(this)), this.q.run().then(function() {
      return this._currentCfi && (this.currentLocation = this._currentCfi), this._locationsWords;
    }.bind(this));
  }
  processWords(e, n, r, i) {
    return i && this._locationsWords.length >= i ? Promise.resolve() : e.load(this.request).then(function(s) {
      var o = new vt(), a = this.parseWords(s, e, n, r), l = i - this._locationsWords.length;
      return this._locationsWords = this._locationsWords.concat(a.length >= i ? a.slice(0, l) : a), e.unload(), this.processingTimeout = setTimeout(() => o.resolve(a), this.pause), o.promise;
    }.bind(this));
  }
  //http://stackoverflow.com/questions/18679576/counting-words-in-string
  countWords(e) {
    return e = e.replace(/(^\s*)|(\s*$)/gi, ""), e = e.replace(/[ ]{2,}/gi, " "), e = e.replace(/\n /, `
`), e.split(" ").length;
  }
  parseWords(e, n, r, i) {
    var s = n.cfiBase, o = [], a = e.ownerDocument, l = zt(a, "body"), u = r, c = i ? i.spinePos !== n.index : !0, d;
    i && n.index === i.spinePos && (d = i.findNode(i.range ? i.path.steps.concat(i.start.steps) : i.path.steps, e.ownerDocument));
    var h = function(v) {
      if (!c)
        if (v === d)
          c = !0;
        else
          return !1;
      if (v.textContent.length < 10 && v.textContent.trim().length === 0)
        return !1;
      var m = this.countWords(v.textContent), b, p = 0;
      if (m === 0)
        return !1;
      for (b = u - this._wordCounter, b > m && (this._wordCounter += m, p = m); p < m; )
        if (b = u - this._wordCounter, p + b >= m)
          this._wordCounter += m - p, p = m;
        else {
          p += b;
          let f = new gt(v, s);
          o.push({ cfi: f.toString(), wordCount: this._wordCounter }), this._wordCounter = 0;
        }
    };
    return Vl(l, h.bind(this)), o;
  }
  /**
   * Get a location from an EpubCFI
   * @param {EpubCFI} cfi
   * @return {number}
   */
  locationFromCfi(e) {
    let n;
    return gt.prototype.isCfiString(e) && (e = new gt(e)), this._locations.length === 0 ? -1 : (n = Gs(e, this._locations, this.epubcfi.compare), n > this.total ? this.total : n);
  }
  /**
   * Get a percentage position in locations from an EpubCFI
   * @param {EpubCFI} cfi
   * @return {number}
   */
  percentageFromCfi(e) {
    if (this._locations.length === 0)
      return null;
    var n = this.locationFromCfi(e);
    return this.percentageFromLocation(n);
  }
  /**
   * Get a percentage position from a location index
   * @param {number} location
   * @return {number}
   */
  percentageFromLocation(e) {
    return !e || !this.total ? 0 : e / this.total;
  }
  /**
   * Get an EpubCFI from location index
   * @param {number} loc
   * @return {EpubCFI} cfi
   */
  cfiFromLocation(e) {
    var n = -1;
    return typeof e != "number" && (e = parseInt(e)), e >= 0 && e < this._locations.length && (n = this._locations[e]), n;
  }
  /**
   * Get an EpubCFI from location percentage
   * @param {number} percentage
   * @return {EpubCFI} cfi
   */
  cfiFromPercentage(e) {
    let n;
    if (e > 1 && console.warn("Normalize cfiFromPercentage value to between 0 - 1"), e >= 1) {
      let r = new gt(this._locations[this.total]);
      return r.collapse(), r.toString();
    }
    return n = Math.ceil(this.total * e), this.cfiFromLocation(n);
  }
  /**
   * Load locations from JSON
   * @param {json} locations
   */
  load(e) {
    return typeof e == "string" ? this._locations = JSON.parse(e) : this._locations = e, this.total = this._locations.length - 1, this._locations;
  }
  /**
   * Save locations to JSON
   * @return {json}
   */
  save() {
    return JSON.stringify(this._locations);
  }
  getCurrent() {
    return this._current;
  }
  setCurrent(e) {
    var n;
    if (typeof e == "string")
      this._currentCfi = e;
    else if (typeof e == "number")
      this._current = e;
    else
      return;
    this._locations.length !== 0 && (typeof e == "string" ? (n = this.locationFromCfi(e), this._current = n) : n = e, this.emit(Re.LOCATIONS.CHANGED, {
      percentage: this.percentageFromLocation(n)
    }));
  }
  /**
   * Get the current location
   */
  get currentLocation() {
    return this._current;
  }
  /**
   * Set the current location
   */
  set currentLocation(e) {
    this.setCurrent(e);
  }
  /**
   * Locations length
   */
  length() {
    return this._locations.length;
  }
  destroy() {
    this.spine = void 0, this.request = void 0, this.pause = void 0, this.q.stop(), this.q = void 0, this.epubcfi = void 0, this._locations = void 0, this.total = void 0, this.break = void 0, this._current = void 0, this.currentLocation = void 0, this._currentCfi = void 0, clearTimeout(this.processingTimeout);
  }
}
Vr(K0.prototype);
class b6 {
  constructor(e) {
    this.packagePath = "", this.directory = "", this.encoding = "", e && this.parse(e);
  }
  /**
   * Parse the Container XML
   * @param  {document} containerDocument
   */
  parse(e) {
    var n;
    if (!e)
      throw new Error("Container File Not Found");
    if (n = zt(e, "rootfile"), !n)
      throw new Error("No RootFile Found");
    this.packagePath = n.getAttribute("full-path"), this.directory = Si.dirname(this.packagePath), this.encoding = e.xmlEncoding;
  }
  destroy() {
    this.packagePath = void 0, this.directory = void 0, this.encoding = void 0;
  }
}
class Ev {
  constructor(e) {
    this.manifest = {}, this.navPath = "", this.ncxPath = "", this.coverPath = "", this.spineNodeIndex = 0, this.spine = [], this.metadata = {}, e && this.parse(e);
  }
  /**
   * Parse OPF XML
   * @param  {document} packageDocument OPF XML
   * @return {object} parsed package parts
   */
  parse(e) {
    var n, r, i;
    if (!e)
      throw new Error("Package File Not Found");
    if (n = zt(e, "metadata"), !n)
      throw new Error("No Metadata Found");
    if (r = zt(e, "manifest"), !r)
      throw new Error("No Manifest Found");
    if (i = zt(e, "spine"), !i)
      throw new Error("No Spine Found");
    return this.manifest = this.parseManifest(r), this.navPath = this.findNavPath(r), this.ncxPath = this.findNcxPath(r, i), this.coverPath = this.findCoverPath(e), this.spineNodeIndex = L0(i), this.spine = this.parseSpine(i, this.manifest), this.uniqueIdentifier = this.findUniqueIdentifier(e), this.metadata = this.parseMetadata(n), this.metadata.direction = i.getAttribute("page-progression-direction"), {
      metadata: this.metadata,
      spine: this.spine,
      manifest: this.manifest,
      navPath: this.navPath,
      ncxPath: this.ncxPath,
      coverPath: this.coverPath,
      spineNodeIndex: this.spineNodeIndex
    };
  }
  /**
   * Parse Metadata
   * @private
   * @param  {node} xml
   * @return {object} metadata
   */
  parseMetadata(e) {
    var n = {};
    return n.title = this.getElementText(e, "title"), n.creator = this.getElementText(e, "creator"), n.description = this.getElementText(e, "description"), n.pubdate = this.getElementText(e, "date"), n.publisher = this.getElementText(e, "publisher"), n.identifier = this.getElementText(e, "identifier"), n.language = this.getElementText(e, "language"), n.rights = this.getElementText(e, "rights"), n.modified_date = this.getPropertyText(e, "dcterms:modified"), n.layout = this.getPropertyText(e, "rendition:layout"), n.orientation = this.getPropertyText(e, "rendition:orientation"), n.flow = this.getPropertyText(e, "rendition:flow"), n.viewport = this.getPropertyText(e, "rendition:viewport"), n.media_active_class = this.getPropertyText(e, "media:active-class"), n.spread = this.getPropertyText(e, "rendition:spread"), n;
  }
  /**
   * Parse Manifest
   * @private
   * @param  {node} manifestXml
   * @return {object} manifest
   */
  parseManifest(e) {
    var n = {}, r = li(e, "item"), i = Array.prototype.slice.call(r);
    return i.forEach(function(s) {
      var o = s.getAttribute("id"), a = s.getAttribute("href") || "", l = s.getAttribute("media-type") || "", u = s.getAttribute("media-overlay") || "", c = s.getAttribute("properties") || "";
      n[o] = {
        href: a,
        // "url" : href,
        type: l,
        overlay: u,
        properties: c.length ? c.split(" ") : []
      };
    }), n;
  }
  /**
   * Parse Spine
   * @private
   * @param  {node} spineXml
   * @param  {Packaging.manifest} manifest
   * @return {object} spine
   */
  parseSpine(e, n) {
    var r = [], i = li(e, "itemref"), s = Array.prototype.slice.call(i);
    return s.forEach(function(o, a) {
      var l = o.getAttribute("idref"), u = o.getAttribute("properties") || "", c = u.length ? u.split(" ") : [], d = {
        id: o.getAttribute("id"),
        idref: l,
        linear: o.getAttribute("linear") || "yes",
        properties: c,
        // "href" : manifest[Id].href,
        // "url" :  manifest[Id].url,
        index: a
        // "cfiBase" : cfiBase
      };
      r.push(d);
    }), r;
  }
  /**
   * Find Unique Identifier
   * @private
   * @param  {node} packageXml
   * @return {string} Unique Identifier text
   */
  findUniqueIdentifier(e) {
    var n = e.documentElement.getAttribute("unique-identifier");
    if (!n)
      return "";
    var r = e.getElementById(n);
    return r && r.localName === "identifier" && r.namespaceURI === "http://purl.org/dc/elements/1.1/" && r.childNodes.length > 0 ? r.childNodes[0].nodeValue.trim() : "";
  }
  /**
   * Find TOC NAV
   * @private
   * @param {element} manifestNode
   * @return {string}
   */
  findNavPath(e) {
    var n = xs(e, "item", { properties: "nav" });
    return n ? n.getAttribute("href") : !1;
  }
  /**
   * Find TOC NCX
   * media-type="application/x-dtbncx+xml" href="toc.ncx"
   * @private
   * @param {element} manifestNode
   * @param {element} spineNode
   * @return {string}
   */
  findNcxPath(e, n) {
    var r = xs(e, "item", { "media-type": "application/x-dtbncx+xml" }), i;
    return r || (i = n.getAttribute("toc"), i && (r = e.querySelector(`#${i}`))), r ? r.getAttribute("href") : !1;
  }
  /**
   * Find the Cover Path
   * <item properties="cover-image" id="ci" href="cover.svg" media-type="image/svg+xml" />
   * Fallback for Epub 2.0
   * @private
   * @param  {node} packageXml
   * @return {string} href
   */
  findCoverPath(e) {
    var n = zt(e, "package");
    n.getAttribute("version");
    var r = xs(e, "item", { properties: "cover-image" });
    if (r)
      return r.getAttribute("href");
    var i = xs(e, "meta", { name: "cover" });
    if (i) {
      var s = i.getAttribute("content"), o = e.getElementById(s);
      return o ? o.getAttribute("href") : "";
    } else
      return !1;
  }
  /**
   * Get text of a namespaced element
   * @private
   * @param  {node} xml
   * @param  {string} tag
   * @return {string} text
   */
  getElementText(e, n) {
    var r = e.getElementsByTagNameNS("http://purl.org/dc/elements/1.1/", n), i;
    return !r || r.length === 0 ? "" : (i = r[0], i.childNodes.length ? i.childNodes[0].nodeValue : "");
  }
  /**
   * Get text by property
   * @private
   * @param  {node} xml
   * @param  {string} property
   * @return {string} text
   */
  getPropertyText(e, n) {
    var r = xs(e, "meta", { property: n });
    return r && r.childNodes.length ? r.childNodes[0].nodeValue : "";
  }
  /**
   * Load JSON Manifest
   * @param  {document} packageDocument OPF XML
   * @return {object} parsed package parts
   */
  load(e) {
    this.metadata = e.metadata;
    let n = e.readingOrder || e.spine;
    return this.spine = n.map((r, i) => (r.index = i, r.linear = r.linear || "yes", r)), e.resources.forEach((r, i) => {
      this.manifest[i] = r, r.rel && r.rel[0] === "cover" && (this.coverPath = r.href);
    }), this.spineNodeIndex = 0, this.toc = e.toc.map((r, i) => (r.label = r.title, r)), {
      metadata: this.metadata,
      spine: this.spine,
      manifest: this.manifest,
      navPath: this.navPath,
      ncxPath: this.ncxPath,
      coverPath: this.coverPath,
      spineNodeIndex: this.spineNodeIndex,
      toc: this.toc
    };
  }
  destroy() {
    this.manifest = void 0, this.navPath = void 0, this.ncxPath = void 0, this.coverPath = void 0, this.spineNodeIndex = void 0, this.spine = void 0, this.metadata = void 0;
  }
}
class rc {
  constructor(e) {
    this.toc = [], this.tocByHref = {}, this.tocById = {}, this.landmarks = [], this.landmarksByType = {}, this.length = 0, e && this.parse(e);
  }
  /**
   * Parse out the navigation items
   * @param {document} xml navigation html / xhtml / ncx
   */
  parse(e) {
    let n = e.nodeType, r, i;
    n && (r = zt(e, "html"), i = zt(e, "ncx")), n ? r ? (this.toc = this.parseNav(e), this.landmarks = this.parseLandmarks(e)) : i && (this.toc = this.parseNcx(e)) : this.toc = this.load(e), this.length = 0, this.unpack(this.toc);
  }
  /**
   * Unpack navigation items
   * @private
   * @param  {array} toc
   */
  unpack(e) {
    for (var n, r = 0; r < e.length; r++)
      n = e[r], n.href && (this.tocByHref[n.href] = r), n.id && (this.tocById[n.id] = r), this.length++, n.subitems.length && this.unpack(n.subitems);
  }
  /**
   * Get an item from the navigation
   * @param  {string} target
   * @return {object} navItem
   */
  get(e) {
    var n;
    return e ? (e.indexOf("#") === 0 ? n = this.tocById[e.substring(1)] : e in this.tocByHref && (n = this.tocByHref[e]), this.getByIndex(e, n, this.toc)) : this.toc;
  }
  /**
   * Get an item from navigation subitems recursively by index
   * @param  {string} target
   * @param  {number} index
   * @param  {array} navItems
   * @return {object} navItem
   */
  getByIndex(e, n, r) {
    if (r.length === 0)
      return;
    const i = r[n];
    if (i && (e === i.id || e === i.href))
      return i;
    {
      let s;
      for (let o = 0; o < r.length && (s = this.getByIndex(e, n, r[o].subitems), !s); ++o)
        ;
      return s;
    }
  }
  /**
   * Get a landmark by type
   * List of types: https://idpf.github.io/epub-vocabs/structure/
   * @param  {string} type
   * @return {object} landmarkItem
   */
  landmark(e) {
    var n;
    return e ? (n = this.landmarksByType[e], this.landmarks[n]) : this.landmarks;
  }
  /**
   * Parse toc from a Epub > 3.0 Nav
   * @private
   * @param  {document} navHtml
   * @return {array} navigation list
   */
  parseNav(e) {
    var n = Wl(e, "nav", "toc"), r = [];
    if (!n)
      return r;
    let i = As(n, "ol", !0);
    return i && (r = this.parseNavList(i)), r;
  }
  /**
   * Parses lists in the toc
   * @param  {document} navListHtml
   * @param  {string} parent id
   * @return {array} navigation list
   */
  parseNavList(e, n) {
    const r = [];
    if (!e || !e.children)
      return r;
    for (let i = 0; i < e.children.length; i++) {
      const s = this.navItem(e.children[i], n);
      s && r.push(s);
    }
    return r;
  }
  /**
   * Create a navItem
   * @private
   * @param  {element} item
   * @return {object} navItem
   */
  navItem(e, n) {
    let r = e.getAttribute("id") || void 0, i = As(e, "a", !0) || As(e, "span", !0);
    if (!i)
      return;
    let s = i.getAttribute("href") || "";
    r || (r = s);
    let o = i.textContent || "", a = [], l = As(e, "ol", !0);
    return l && (a = this.parseNavList(l, r)), {
      id: r,
      href: s,
      label: o,
      subitems: a,
      parent: n
    };
  }
  /**
   * Parse landmarks from a Epub > 3.0 Nav
   * @private
   * @param  {document} navHtml
   * @return {array} landmarks list
   */
  parseLandmarks(e) {
    var n = Wl(e, "nav", "landmarks"), r = n ? li(n, "li") : [], i = r.length, s, o = [], a;
    if (!r || i === 0)
      return o;
    for (s = 0; s < i; ++s)
      a = this.landmarkItem(r[s]), a && (o.push(a), this.landmarksByType[a.type] = s);
    return o;
  }
  /**
   * Create a landmarkItem
   * @private
   * @param  {element} item
   * @return {object} landmarkItem
   */
  landmarkItem(e) {
    let n = As(e, "a", !0);
    if (!n)
      return;
    let r = n.getAttributeNS("http://www.idpf.org/2007/ops", "type") || void 0, i = n.getAttribute("href") || "", s = n.textContent || "";
    return {
      href: i,
      label: s,
      type: r
    };
  }
  /**
   * Parse from a Epub > 3.0 NC
   * @private
   * @param  {document} navHtml
   * @return {array} navigation list
   */
  parseNcx(e) {
    var n = li(e, "navPoint"), r = n.length, i, s = {}, o = [], a, l;
    if (!n || r === 0)
      return o;
    for (i = 0; i < r; ++i)
      a = this.ncxItem(n[i]), s[a.id] = a, a.parent ? (l = s[a.parent], l.subitems.push(a)) : o.push(a);
    return o;
  }
  /**
   * Create a ncxItem
   * @private
   * @param  {element} item
   * @return {object} ncxItem
   */
  ncxItem(e) {
    var n = e.getAttribute("id") || !1, r = zt(e, "content"), i = r.getAttribute("src"), s = zt(e, "navLabel"), o = s.textContent ? s.textContent : "", a = [], l = e.parentNode, u;
    return l && (l.nodeName === "navPoint" || l.nodeName.split(":").slice(-1)[0] === "navPoint") && (u = l.getAttribute("id")), {
      id: n,
      href: i,
      label: o,
      subitems: a,
      parent: u
    };
  }
  /**
   * Load Spine Items
   * @param  {object} json the items to be loaded
   * @return {Array} navItems
   */
  load(e) {
    return e.map((n) => (n.label = n.title, n.subitems = n.children ? this.load(n.children) : [], n));
  }
  /**
   * forEach pass through
   * @param  {Function} fn function to run on each item
   * @return {method} forEach loop
   */
  forEach(e) {
    return this.toc.forEach(e);
  }
}
var co = {
  application: {
    ecmascript: ["es", "ecma"],
    javascript: "js",
    ogg: "ogx",
    pdf: "pdf",
    postscript: ["ps", "ai", "eps", "epsi", "epsf", "eps2", "eps3"],
    "rdf+xml": "rdf",
    smil: ["smi", "smil"],
    "xhtml+xml": ["xhtml", "xht"],
    xml: ["xml", "xsl", "xsd", "opf", "ncx"],
    zip: "zip",
    "x-httpd-eruby": "rhtml",
    "x-latex": "latex",
    "x-maker": ["frm", "maker", "frame", "fm", "fb", "book", "fbdoc"],
    "x-object": "o",
    "x-shockwave-flash": ["swf", "swfl"],
    "x-silverlight": "scr",
    "epub+zip": "epub",
    "font-tdpfr": "pfr",
    "inkml+xml": ["ink", "inkml"],
    json: "json",
    "jsonml+json": "jsonml",
    "mathml+xml": "mathml",
    "metalink+xml": "metalink",
    mp4: "mp4s",
    // "oebps-package+xml" : "opf",
    "omdoc+xml": "omdoc",
    oxps: "oxps",
    "vnd.amazon.ebook": "azw",
    widget: "wgt",
    // "x-dtbncx+xml" : "ncx",
    "x-dtbook+xml": "dtb",
    "x-dtbresource+xml": "res",
    "x-font-bdf": "bdf",
    "x-font-ghostscript": "gsf",
    "x-font-linux-psf": "psf",
    "x-font-otf": "otf",
    "x-font-pcf": "pcf",
    "x-font-snf": "snf",
    "x-font-ttf": ["ttf", "ttc"],
    "x-font-type1": ["pfa", "pfb", "pfm", "afm"],
    "x-font-woff": "woff",
    "x-mobipocket-ebook": ["prc", "mobi"],
    "x-mspublisher": "pub",
    "x-nzb": "nzb",
    "x-tgif": "obj",
    "xaml+xml": "xaml",
    "xml-dtd": "dtd",
    "xproc+xml": "xpl",
    "xslt+xml": "xslt",
    "internet-property-stream": "acx",
    "x-compress": "z",
    "x-compressed": "tgz",
    "x-gzip": "gz"
  },
  audio: {
    flac: "flac",
    midi: ["mid", "midi", "kar", "rmi"],
    mpeg: ["mpga", "mpega", "mp2", "mp3", "m4a", "mp2a", "m2a", "m3a"],
    mpegurl: "m3u",
    ogg: ["oga", "ogg", "spx"],
    "x-aiff": ["aif", "aiff", "aifc"],
    "x-ms-wma": "wma",
    "x-wav": "wav",
    adpcm: "adp",
    mp4: "mp4a",
    webm: "weba",
    "x-aac": "aac",
    "x-caf": "caf",
    "x-matroska": "mka",
    "x-pn-realaudio-plugin": "rmp",
    xm: "xm",
    mid: ["mid", "rmi"]
  },
  image: {
    gif: "gif",
    ief: "ief",
    jpeg: ["jpeg", "jpg", "jpe"],
    pcx: "pcx",
    png: "png",
    "svg+xml": ["svg", "svgz"],
    tiff: ["tiff", "tif"],
    "x-icon": "ico",
    bmp: "bmp",
    webp: "webp",
    "x-pict": ["pic", "pct"],
    "x-tga": "tga",
    "cis-cod": "cod"
  },
  text: {
    "cache-manifest": ["manifest", "appcache"],
    css: "css",
    csv: "csv",
    html: ["html", "htm", "shtml", "stm"],
    mathml: "mml",
    plain: ["txt", "text", "brf", "conf", "def", "list", "log", "in", "bas"],
    richtext: "rtx",
    "tab-separated-values": "tsv",
    "x-bibtex": "bib"
  },
  video: {
    mpeg: ["mpeg", "mpg", "mpe", "m1v", "m2v", "mp2", "mpa", "mpv2"],
    mp4: ["mp4", "mp4v", "mpg4"],
    quicktime: ["qt", "mov"],
    ogg: "ogv",
    "vnd.mpegurl": ["mxu", "m4u"],
    "x-flv": "flv",
    "x-la-asf": ["lsf", "lsx"],
    "x-mng": "mng",
    "x-ms-asf": ["asf", "asx", "asr"],
    "x-ms-wm": "wm",
    "x-ms-wmv": "wmv",
    "x-ms-wmx": "wmx",
    "x-ms-wvx": "wvx",
    "x-msvideo": "avi",
    "x-sgi-movie": "movie",
    "x-matroska": ["mpv", "mkv", "mk3d", "mks"],
    "3gpp2": "3g2",
    h261: "h261",
    h263: "h263",
    h264: "h264",
    jpeg: "jpgv",
    jpm: ["jpm", "jpgm"],
    mj2: ["mj2", "mjp2"],
    "vnd.ms-playready.media.pyv": "pyv",
    "vnd.uvvu.mp4": ["uvu", "uvvu"],
    "vnd.vivo": "viv",
    webm: "webm",
    "x-f4v": "f4v",
    "x-m4v": "m4v",
    "x-ms-vob": "vob",
    "x-smv": "smv"
  }
}, w6 = function() {
  var t, e, n, r, i = {};
  for (t in co)
    if (co.hasOwnProperty(t)) {
      for (e in co[t])
        if (co[t].hasOwnProperty(e))
          if (n = co[t][e], typeof n == "string")
            i[n] = t + "/" + e;
          else
            for (r = 0; r < n.length; r++)
              i[n[r]] = t + "/" + e;
    }
  return i;
}(), _6 = "text/plain";
function S6(t) {
  return t && w6[t.split(".").pop().toLowerCase()] || _6;
}
const Ps = { lookup: S6 };
class E6 {
  constructor(e, n) {
    this.settings = {
      replacements: n && n.replacements || "base64",
      archive: n && n.archive,
      resolver: n && n.resolver,
      request: n && n.request
    }, this.process(e);
  }
  /**
   * Process resources
   * @param {Manifest} manifest
   */
  process(e) {
    this.manifest = e, this.resources = Object.keys(e).map(function(n) {
      return e[n];
    }), this.replacementUrls = [], this.html = [], this.assets = [], this.css = [], this.urls = [], this.cssUrls = [], this.split(), this.splitUrls();
  }
  /**
   * Split resources by type
   * @private
   */
  split() {
    this.html = this.resources.filter(function(e) {
      if (e.type === "application/xhtml+xml" || e.type === "text/html")
        return !0;
    }), this.assets = this.resources.filter(function(e) {
      if (e.type !== "application/xhtml+xml" && e.type !== "text/html")
        return !0;
    }), this.css = this.resources.filter(function(e) {
      if (e.type === "text/css")
        return !0;
    });
  }
  /**
   * Convert split resources into Urls
   * @private
   */
  splitUrls() {
    this.urls = this.assets.map(function(e) {
      return e.href;
    }.bind(this)), this.cssUrls = this.css.map(function(e) {
      return e.href;
    });
  }
  /**
   * Create a url to a resource
   * @param {string} url
   * @return {Promise<string>} Promise resolves with url string
   */
  createUrl(e) {
    var n = new vr(e), r = Ps.lookup(n.filename);
    return this.settings.archive ? this.settings.archive.createUrl(e, { base64: this.settings.replacements === "base64" }) : this.settings.replacements === "base64" ? this.settings.request(e, "blob").then((i) => U0(i)).then((i) => yd(i, r)) : this.settings.request(e, "blob").then((i) => Ul(i, r));
  }
  /**
   * Create blob urls for all the assets
   * @return {Promise}         returns replacement urls
   */
  replacements() {
    if (this.settings.replacements === "none")
      return new Promise(function(n) {
        n(this.urls);
      }.bind(this));
    var e = this.urls.map((n) => {
      var r = this.settings.resolver(n);
      return this.createUrl(r).catch((i) => (console.error(i), null));
    });
    return Promise.all(e).then((n) => (this.replacementUrls = n.filter((r) => typeof r == "string"), n));
  }
  /**
   * Replace URLs in CSS resources
   * @private
   * @param  {Archive} [archive]
   * @param  {method} [resolver]
   * @return {Promise}
   */
  replaceCss(e, n) {
    var r = [];
    return e = e || this.settings.archive, n = n || this.settings.resolver, this.cssUrls.forEach(function(i) {
      var s = this.createCssFile(i, e, n).then(function(o) {
        var a = this.urls.indexOf(i);
        a > -1 && (this.replacementUrls[a] = o);
      }.bind(this));
      r.push(s);
    }.bind(this)), Promise.all(r);
  }
  /**
   * Create a new CSS file with the replaced URLs
   * @private
   * @param  {string} href the original css file
   * @return {Promise}  returns a BlobUrl to the new CSS file or a data url
   */
  createCssFile(e) {
    var n;
    if (Si.isAbsolute(e))
      return new Promise(function(o) {
        o();
      });
    var r = this.settings.resolver(e), i;
    this.settings.archive ? i = this.settings.archive.getText(r) : i = this.settings.request(r, "text");
    var s = this.urls.map((o) => {
      var a = this.settings.resolver(o), l = new ui(r).relative(a);
      return l;
    });
    return i ? i.then((o) => (o = Sv(o, s, this.replacementUrls), this.settings.replacements === "base64" ? n = yd(o, "text/css") : n = Ul(o, "text/css"), n), (o) => new Promise(function(a) {
      a();
    })) : new Promise(function(o) {
      o();
    });
  }
  /**
   * Resolve all resources URLs relative to an absolute URL
   * @param  {string} absolute to be resolved to
   * @param  {resolver} [resolver]
   * @return {string[]} array with relative Urls
   */
  relativeTo(e, n) {
    return n = n || this.settings.resolver, this.urls.map(function(r) {
      var i = n(r), s = new ui(e).relative(i);
      return s;
    }.bind(this));
  }
  /**
   * Get a URL for a resource
   * @param  {string} path
   * @return {string} url
   */
  get(e) {
    var n = this.urls.indexOf(e);
    if (n !== -1)
      return this.replacementUrls.length ? new Promise(function(r, i) {
        r(this.replacementUrls[n]);
      }.bind(this)) : this.createUrl(e);
  }
  /**
   * Substitute urls in content, with replacements,
   * relative to a url if provided
   * @param  {string} content
   * @param  {string} [url]   url to resolve to
   * @return {string}         content with urls substituted
   */
  substitute(e, n) {
    var r;
    return n ? r = this.relativeTo(n) : r = this.urls, Sv(e, r, this.replacementUrls);
  }
  destroy() {
    this.settings = void 0, this.manifest = void 0, this.resources = void 0, this.replacementUrls = void 0, this.html = void 0, this.assets = void 0, this.css = void 0, this.urls = void 0, this.cssUrls = void 0;
  }
}
class ic {
  constructor(e) {
    this.pages = [], this.locations = [], this.epubcfi = new gt(), this.firstPage = 0, this.lastPage = 0, this.totalPages = 0, this.toc = void 0, this.ncx = void 0, e && (this.pageList = this.parse(e)), this.pageList && this.pageList.length && this.process(this.pageList);
  }
  /**
   * Parse PageList Xml
   * @param  {document} xml
   */
  parse(e) {
    var n = zt(e, "html"), r = zt(e, "ncx");
    if (n)
      return this.parseNav(e);
    if (r)
      return this.parseNcx(e);
  }
  /**
   * Parse a Nav PageList
   * @private
   * @param  {node} navHtml
   * @return {PageList.item[]} list
   */
  parseNav(e) {
    var n = Wl(e, "nav", "page-list"), r = n ? li(n, "li") : [], i = r.length, s, o = [], a;
    if (!r || i === 0)
      return o;
    for (s = 0; s < i; ++s)
      a = this.item(r[s]), o.push(a);
    return o;
  }
  parseNcx(e) {
    var n = [], r = 0, i, s, o, a = 0;
    if (s = zt(e, "pageList"), !s || (o = li(s, "pageTarget"), a = o.length, !o || o.length === 0))
      return n;
    for (r = 0; r < a; ++r)
      i = this.ncxItem(o[r]), n.push(i);
    return n;
  }
  ncxItem(e) {
    var n = zt(e, "navLabel"), r = zt(n, "text"), i = r.textContent, s = zt(e, "content"), o = s.getAttribute("src"), a = parseInt(i, 10);
    return {
      href: o,
      page: a
    };
  }
  /**
   * Page List Item
   * @private
   * @param  {node} item
   * @return {object} pageListItem
   */
  item(e) {
    var n = zt(e, "a"), r = n.getAttribute("href") || "", i = n.textContent || "", s = parseInt(i), o = r.indexOf("epubcfi"), a, l, u;
    return o != -1 ? (a = r.split("#"), l = a[0], u = a.length > 1 ? a[1] : !1, {
      cfi: u,
      href: r,
      packageUrl: l,
      page: s
    }) : {
      href: r,
      page: s
    };
  }
  /**
   * Process pageList items
   * @private
   * @param  {array} pageList
   */
  process(e) {
    e.forEach(function(n) {
      this.pages.push(n.page), n.cfi && this.locations.push(n.cfi);
    }, this), this.firstPage = parseInt(this.pages[0]), this.lastPage = parseInt(this.pages[this.pages.length - 1]), this.totalPages = this.lastPage - this.firstPage;
  }
  /**
   * Get a PageList result from a EpubCFI
   * @param  {string} cfi EpubCFI String
   * @return {number} page
   */
  pageFromCfi(e) {
    var n = -1;
    if (this.locations.length === 0)
      return -1;
    var r = jl(e, this.locations, this.epubcfi.compare);
    return r != -1 ? n = this.pages[r] : (r = Gs(e, this.locations, this.epubcfi.compare), n = r - 1 >= 0 ? this.pages[r - 1] : this.pages[0], n !== void 0 || (n = -1)), n;
  }
  /**
   * Get an EpubCFI from a Page List Item
   * @param  {string | number} pg
   * @return {string} cfi
   */
  cfiFromPage(e) {
    var n = -1;
    typeof e != "number" && (e = parseInt(e));
    var r = this.pages.indexOf(e);
    return r != -1 && (n = this.locations[r]), n;
  }
  /**
   * Get a Page from Book percentage
   * @param  {number} percent
   * @return {number} page
   */
  pageFromPercentage(e) {
    var n = Math.round(this.totalPages * e);
    return n;
  }
  /**
   * Returns a value between 0 - 1 corresponding to the location of a page
   * @param  {number} pg the page
   * @return {number} percentage
   */
  percentageFromPage(e) {
    var n = (e - this.firstPage) / this.totalPages;
    return Math.round(n * 1e3) / 1e3;
  }
  /**
   * Returns a value between 0 - 1 corresponding to the location of a cfi
   * @param  {string} cfi EpubCFI String
   * @return {number} percentage
   */
  percentageFromCfi(e) {
    var n = this.pageFromCfi(e), r = this.percentageFromPage(n);
    return r;
  }
  /**
   * Destroy
   */
  destroy() {
    this.pages = void 0, this.locations = void 0, this.epubcfi = void 0, this.pageList = void 0, this.toc = void 0, this.ncx = void 0;
  }
}
class G0 {
  constructor(e) {
    this.settings = e, this.name = e.layout || "reflowable", this._spread = e.spread !== "none", this._minSpreadWidth = e.minSpreadWidth || 800, this._evenSpreads = e.evenSpreads || !1, e.flow === "scrolled" || e.flow === "scrolled-continuous" || e.flow === "scrolled-doc" ? this._flow = "scrolled" : this._flow = "paginated", this.width = 0, this.height = 0, this.spreadWidth = 0, this.delta = 0, this.columnWidth = 0, this.gap = 0, this.divisor = 1, this.props = {
      name: this.name,
      spread: this._spread,
      flow: this._flow,
      width: 0,
      height: 0,
      spreadWidth: 0,
      delta: 0,
      columnWidth: 0,
      gap: 0,
      divisor: 1
    };
  }
  /**
   * Switch the flow between paginated and scrolled
   * @param  {string} flow paginated | scrolled
   * @return {string} simplified flow
   */
  flow(e) {
    return typeof e < "u" && (e === "scrolled" || e === "scrolled-continuous" || e === "scrolled-doc" ? this._flow = "scrolled" : this._flow = "paginated", this.update({ flow: this._flow })), this._flow;
  }
  /**
   * Switch between using spreads or not, and set the
   * width at which they switch to single.
   * @param  {string} spread "none" | "always" | "auto"
   * @param  {number} min integer in pixels
   * @return {boolean} spread true | false
   */
  spread(e, n) {
    return e && (this._spread = e !== "none", this.update({ spread: this._spread })), n >= 0 && (this._minSpreadWidth = n), this._spread;
  }
  /**
   * Calculate the dimensions of the pagination
   * @param  {number} _width  width of the rendering
   * @param  {number} _height height of the rendering
   * @param  {number} _gap    width of the gap between columns
   */
  calculate(e, n, r) {
    var i = 1, s = r || 0, o = e, a = n, l = Math.floor(o / 12), u, c, d, h;
    this._spread && o >= this._minSpreadWidth ? i = 2 : i = 1, this.name === "reflowable" && this._flow === "paginated" && !(r >= 0) && (s = l % 2 === 0 ? l : l - 1), this.name === "pre-paginated" && (s = 0), i > 1 ? (u = o / i - s, d = u + s) : (u = o, d = o), this.name === "pre-paginated" && i > 1 && (o = u), c = u * i + s, h = o, this.width = o, this.height = a, this.spreadWidth = c, this.pageWidth = d, this.delta = h, this.columnWidth = u, this.gap = s, this.divisor = i, this.update({
      width: o,
      height: a,
      spreadWidth: c,
      pageWidth: d,
      delta: h,
      columnWidth: u,
      gap: s,
      divisor: i
    });
  }
  /**
   * Apply Css to a Document
   * @param  {Contents} contents
   * @return {Promise}
   */
  format(e, n, r) {
    var i;
    return this.name === "pre-paginated" ? i = e.fit(this.columnWidth, this.height, n) : this._flow === "paginated" ? i = e.columns(this.width, this.height, this.columnWidth, this.gap, this.settings.direction) : r && r === "horizontal" ? i = e.size(null, this.height) : i = e.size(this.width, null), i;
  }
  /**
   * Count number of pages
   * @param  {number} totalLength
   * @param  {number} pageLength
   * @return {{spreads: Number, pages: Number}}
   */
  count(e, n) {
    let r, i;
    return this.name === "pre-paginated" ? (r = 1, i = 1) : this._flow === "paginated" ? (n = n || this.delta, r = Math.ceil(e / n), i = r * this.divisor) : (n = n || this.height, r = Math.ceil(e / n), i = r), {
      spreads: r,
      pages: i
    };
  }
  /**
   * Update props that have changed
   * @private
   * @param  {object} props
   */
  update(e) {
    if (Object.keys(e).forEach((n) => {
      this.props[n] === e[n] && delete e[n];
    }), Object.keys(e).length > 0) {
      let n = En(this.props, e);
      this.emit(Re.LAYOUT.UPDATED, n, e);
    }
  }
}
Vr(G0.prototype);
class x6 {
  constructor(e) {
    this.rendition = e, this._themes = {
      default: {
        rules: {},
        url: "",
        serialized: ""
      }
    }, this._overrides = {}, this._current = "default", this._injected = [], this.rendition.hooks.content.register(this.inject.bind(this)), this.rendition.hooks.content.register(this.overrides.bind(this));
  }
  /**
   * Add themes to be used by a rendition
   * @param {object | Array<object> | string}
   * @example themes.register("light", "http://example.com/light.css")
   * @example themes.register("light", { "body": { "color": "purple"}})
   * @example themes.register({ "light" : {...}, "dark" : {...}})
   */
  register() {
    if (arguments.length !== 0) {
      if (arguments.length === 1 && typeof arguments[0] == "object")
        return this.registerThemes(arguments[0]);
      if (arguments.length === 1 && typeof arguments[0] == "string")
        return this.default(arguments[0]);
      if (arguments.length === 2 && typeof arguments[1] == "string")
        return this.registerUrl(arguments[0], arguments[1]);
      if (arguments.length === 2 && typeof arguments[1] == "object")
        return this.registerRules(arguments[0], arguments[1]);
    }
  }
  /**
   * Add a default theme to be used by a rendition
   * @param {object | string} theme
   * @example themes.register("http://example.com/default.css")
   * @example themes.register({ "body": { "color": "purple"}})
   */
  default(e) {
    if (e) {
      if (typeof e == "string")
        return this.registerUrl("default", e);
      if (typeof e == "object")
        return this.registerRules("default", e);
    }
  }
  /**
   * Register themes object
   * @param {object} themes
   */
  registerThemes(e) {
    for (var n in e)
      e.hasOwnProperty(n) && (typeof e[n] == "string" ? this.registerUrl(n, e[n]) : this.registerRules(n, e[n]));
  }
  /**
   * Register a theme by passing its css as string
   * @param {string} name 
   * @param {string} css 
   */
  registerCss(e, n) {
    this._themes[e] = { serialized: n }, (this._injected[e] || e == "default") && this.update(e);
  }
  /**
   * Register a url
   * @param {string} name
   * @param {string} input
   */
  registerUrl(e, n) {
    var r = new vr(n);
    this._themes[e] = { url: r.toString() }, (this._injected[e] || e == "default") && this.update(e);
  }
  /**
   * Register rule
   * @param {string} name
   * @param {object} rules
   */
  registerRules(e, n) {
    this._themes[e] = { rules: n }, (this._injected[e] || e == "default") && this.update(e);
  }
  /**
   * Select a theme
   * @param {string} name
   */
  select(e) {
    var n = this._current, r;
    this._current = e, this.update(e), r = this.rendition.getContents(), r.forEach((i) => {
      i.removeClass(n), i.addClass(e);
    });
  }
  /**
   * Update a theme
   * @param {string} name
   */
  update(e) {
    var n = this.rendition.getContents();
    n.forEach((r) => {
      this.add(e, r);
    });
  }
  /**
   * Inject all themes into contents
   * @param {Contents} contents
   */
  inject(e) {
    var n = [], r = this._themes, i;
    for (var s in r)
      r.hasOwnProperty(s) && (s === this._current || s === "default") && (i = r[s], (i.rules && Object.keys(i.rules).length > 0 || i.url && n.indexOf(i.url) === -1) && this.add(s, e), this._injected.push(s));
    this._current != "default" && e.addClass(this._current);
  }
  /**
   * Add Theme to contents
   * @param {string} name
   * @param {Contents} contents
   */
  add(e, n) {
    var r = this._themes[e];
    !r || !n || (r.url ? n.addStylesheet(r.url) : r.serialized ? (n.addStylesheetCss(r.serialized, e), r.injected = !0) : r.rules && (n.addStylesheetRules(r.rules, e), r.injected = !0));
  }
  /**
   * Add override
   * @param {string} name
   * @param {string} value
   * @param {boolean} priority
   */
  override(e, n, r) {
    var i = this.rendition.getContents();
    this._overrides[e] = {
      value: n,
      priority: r === !0
    }, i.forEach((s) => {
      s.css(e, this._overrides[e].value, this._overrides[e].priority);
    });
  }
  removeOverride(e) {
    var n = this.rendition.getContents();
    delete this._overrides[e], n.forEach((r) => {
      r.css(e);
    });
  }
  /**
   * Add all overrides
   * @param {Content} content
   */
  overrides(e) {
    var n = this._overrides;
    for (var r in n)
      n.hasOwnProperty(r) && e.css(r, n[r].value, n[r].priority);
  }
  /**
   * Adjust the font size of a rendition
   * @param {number} size
   */
  fontSize(e) {
    this.override("font-size", e);
  }
  /**
   * Adjust the font-family of a rendition
   * @param {string} f
   */
  font(e) {
    this.override("font-family", e, !0);
  }
  destroy() {
    this.rendition = void 0, this._themes = void 0, this._overrides = void 0, this._current = void 0, this._injected = void 0;
  }
}
class $l {
  constructor(e, n, r, i = !1) {
    this.layout = e, this.horizontal = r === "horizontal", this.direction = n || "ltr", this._dev = i;
  }
  /**
   * Find CFI pairs for entire section at once
   */
  section(e) {
    var n = this.findRanges(e), r = this.rangeListToCfiList(e.section.cfiBase, n);
    return r;
  }
  /**
   * Find CFI pairs for a page
   * @param {Contents} contents Contents from view
   * @param {string} cfiBase string of the base for a cfi
   * @param {number} start position to start at
   * @param {number} end position to end at
   */
  page(e, n, r, i) {
    var s = e && e.document ? e.document.body : !1, o;
    if (s) {
      if (o = this.rangePairToCfiPair(n, {
        start: this.findStart(s, r, i),
        end: this.findEnd(s, r, i)
      }), this._dev === !0) {
        let a = e.document, l = new gt(o.start).toRange(a), u = new gt(o.end).toRange(a), c = a.defaultView.getSelection(), d = a.createRange();
        c.removeAllRanges(), d.setStart(l.startContainer, l.startOffset), d.setEnd(u.endContainer, u.endOffset), c.addRange(d);
      }
      return o;
    }
  }
  /**
   * Walk a node, preforming a function on each node it finds
   * @private
   * @param {Node} root Node to walkToNode
   * @param {function} func walk function
   * @return {*} returns the result of the walk function
   */
  walk(e, n) {
    if (!(e && e.nodeType === Node.TEXT_NODE)) {
      var r = {
        acceptNode: function(l) {
          return l.data.trim().length > 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
        }
      }, i = r.acceptNode;
      i.acceptNode = r.acceptNode;
      for (var s = document.createTreeWalker(e, NodeFilter.SHOW_TEXT, i, !1), o, a; (o = s.nextNode()) && (a = n(o), !a); )
        ;
      return a;
    }
  }
  findRanges(e) {
    for (var n = [], r = e.contents.scrollWidth(), i = Math.ceil(r / this.layout.spreadWidth), s = i * this.layout.divisor, o = this.layout.columnWidth, a = this.layout.gap, l, u, c = 0; c < s.pages; c++)
      l = (o + a) * c, u = o * (c + 1) + a * c, n.push({
        start: this.findStart(e.document.body, l, u),
        end: this.findEnd(e.document.body, l, u)
      });
    return n;
  }
  /**
   * Find Start Range
   * @private
   * @param {Node} root root node
   * @param {number} start position to start at
   * @param {number} end position to end at
   * @return {Range}
   */
  findStart(e, n, r) {
    for (var i = [e], s, o, a = e; i.length; )
      if (s = i.shift(), o = this.walk(s, (l) => {
        var u, c, d, h, v;
        if (v = md(l), this.horizontal && this.direction === "ltr") {
          if (u = this.horizontal ? v.left : v.top, c = this.horizontal ? v.right : v.bottom, u >= n && u <= r)
            return l;
          if (c > n)
            return l;
          a = l, i.push(l);
        } else if (this.horizontal && this.direction === "rtl") {
          if (u = v.left, c = v.right, c <= r && c >= n)
            return l;
          if (u < r)
            return l;
          a = l, i.push(l);
        } else {
          if (d = v.top, h = v.bottom, d >= n && d <= r)
            return l;
          if (h > n)
            return l;
          a = l, i.push(l);
        }
      }), o)
        return this.findTextStartRange(o, n, r);
    return this.findTextStartRange(a, n, r);
  }
  /**
   * Find End Range
   * @private
   * @param {Node} root root node
   * @param {number} start position to start at
   * @param {number} end position to end at
   * @return {Range}
   */
  findEnd(e, n, r) {
    for (var i = [e], s, o = e, a; i.length; )
      if (s = i.shift(), a = this.walk(s, (l) => {
        var u, c, d, h, v;
        if (v = md(l), this.horizontal && this.direction === "ltr") {
          if (u = Math.round(v.left), c = Math.round(v.right), u > r && o)
            return o;
          if (c > r)
            return l;
          o = l, i.push(l);
        } else if (this.horizontal && this.direction === "rtl") {
          if (u = Math.round(this.horizontal ? v.left : v.top), c = Math.round(this.horizontal ? v.right : v.bottom), c < n && o)
            return o;
          if (u < n)
            return l;
          o = l, i.push(l);
        } else {
          if (d = Math.round(v.top), h = Math.round(v.bottom), d > r && o)
            return o;
          if (h > r)
            return l;
          o = l, i.push(l);
        }
      }), a)
        return this.findTextEndRange(a, n, r);
    return this.findTextEndRange(o, n, r);
  }
  /**
   * Find Text Start Range
   * @private
   * @param {Node} root root node
   * @param {number} start position to start at
   * @param {number} end position to end at
   * @return {Range}
   */
  findTextStartRange(e, n, r) {
    for (var i = this.splitTextNodeIntoRanges(e), s, o, a, l, u, c = 0; c < i.length; c++)
      if (s = i[c], o = s.getBoundingClientRect(), this.horizontal && this.direction === "ltr") {
        if (a = o.left, a >= n)
          return s;
      } else if (this.horizontal && this.direction === "rtl") {
        if (u = o.right, u <= r)
          return s;
      } else if (l = o.top, l >= n)
        return s;
    return i[0];
  }
  /**
   * Find Text End Range
   * @private
   * @param {Node} root root node
   * @param {number} start position to start at
   * @param {number} end position to end at
   * @return {Range}
   */
  findTextEndRange(e, n, r) {
    for (var i = this.splitTextNodeIntoRanges(e), s, o, a, l, u, c, d, h = 0; h < i.length; h++) {
      if (o = i[h], a = o.getBoundingClientRect(), this.horizontal && this.direction === "ltr") {
        if (l = a.left, u = a.right, l > r && s)
          return s;
        if (u > r)
          return o;
      } else if (this.horizontal && this.direction === "rtl") {
        if (l = a.left, u = a.right, u < n && s)
          return s;
        if (l < n)
          return o;
      } else {
        if (c = a.top, d = a.bottom, c > r && s)
          return s;
        if (d > r)
          return o;
      }
      s = o;
    }
    return i[i.length - 1];
  }
  /**
   * Split up a text node into ranges for each word
   * @private
   * @param {Node} root root node
   * @param {string} [_splitter] what to split on
   * @return {Range[]}
   */
  splitTextNodeIntoRanges(e, n) {
    var r = [], i = e.textContent || "", s = i.trim(), o, a = e.ownerDocument, l = n || " ", u = s.indexOf(l);
    if (u === -1 || e.nodeType != Node.TEXT_NODE)
      return o = a.createRange(), o.selectNodeContents(e), [o];
    for (o = a.createRange(), o.setStart(e, 0), o.setEnd(e, u), r.push(o), o = !1; u != -1; )
      u = s.indexOf(l, u + 1), u > 0 && (o && (o.setEnd(e, u), r.push(o)), o = a.createRange(), o.setStart(e, u + 1));
    return o && (o.setEnd(e, s.length), r.push(o)), r;
  }
  /**
   * Turn a pair of ranges into a pair of CFIs
   * @private
   * @param {string} cfiBase base string for an EpubCFI
   * @param {object} rangePair { start: Range, end: Range }
   * @return {object} { start: "epubcfi(...)", end: "epubcfi(...)" }
   */
  rangePairToCfiPair(e, n) {
    var r = n.start, i = n.end;
    r.collapse(!0), i.collapse(!1);
    let s = new gt(r, e).toString(), o = new gt(i, e).toString();
    return {
      start: s,
      end: o
    };
  }
  rangeListToCfiList(e, n) {
    for (var r = [], i, s = 0; s < n.length; s++)
      i = this.rangePairToCfiPair(e, n[s]), r.push(i);
    return r;
  }
  /**
   * Set the axis for mapping
   * @param {string} axis horizontal | vertical
   * @return {boolean} is it horizontal?
   */
  axis(e) {
    return e && (this.horizontal = e === "horizontal"), this.horizontal;
  }
}
const q0 = typeof navigator < "u", A6 = q0 && /Chrome/.test(navigator.userAgent), xv = q0 && !A6 && /AppleWebKit/.test(navigator.userAgent), k6 = 1;
class Gf {
  constructor(e, n, r, i) {
    this.epubcfi = new gt(), this.document = e, this.documentElement = this.document.documentElement, this.content = n || this.document.body, this.window = this.document.defaultView, this._size = {
      width: 0,
      height: 0
    }, this.sectionIndex = i || 0, this.cfiBase = r || "", this.epubReadingSystem("epub.js", yu), this.called = 0, this.active = !0, this.listeners();
  }
  /**
  	* Get DOM events that are listened for and passed along
  	*/
  static get listenedEvents() {
    return pl;
  }
  /**
  	* Get or Set width
  	* @param {number} [w]
  	* @returns {number} width
  	*/
  width(e) {
    var n = this.content;
    return e && Yt(e) && (e = e + "px"), e && (n.style.width = e), parseInt(this.window.getComputedStyle(n).width);
  }
  /**
  	* Get or Set height
  	* @param {number} [h]
  	* @returns {number} height
  	*/
  height(e) {
    var n = this.content;
    return e && Yt(e) && (e = e + "px"), e && (n.style.height = e), parseInt(this.window.getComputedStyle(n).height);
  }
  /**
  	* Get or Set width of the contents
  	* @param {number} [w]
  	* @returns {number} width
  	*/
  contentWidth(e) {
    var n = this.content || this.document.body;
    return e && Yt(e) && (e = e + "px"), e && (n.style.width = e), parseInt(this.window.getComputedStyle(n).width);
  }
  /**
  	* Get or Set height of the contents
  	* @param {number} [h]
  	* @returns {number} height
  	*/
  contentHeight(e) {
    var n = this.content || this.document.body;
    return e && Yt(e) && (e = e + "px"), e && (n.style.height = e), parseInt(this.window.getComputedStyle(n).height);
  }
  /**
  	* Get the width of the text using Range
  	* @returns {number} width
  	*/
  textWidth() {
    let e, n, r = this.document.createRange(), i = this.content || this.document.body, s = Fl(i);
    return r.selectNodeContents(i), e = r.getBoundingClientRect(), n = e.width, s && s.width && (n += s.width), Math.round(n);
  }
  /**
  	* Get the height of the text using Range
  	* @returns {number} height
  	*/
  textHeight() {
    let e, n, r = this.document.createRange(), i = this.content || this.document.body;
    return r.selectNodeContents(i), e = r.getBoundingClientRect(), n = e.bottom, Math.round(n);
  }
  /**
  	* Get documentElement scrollWidth
  	* @returns {number} width
  	*/
  scrollWidth() {
    var e = this.documentElement.scrollWidth;
    return e;
  }
  /**
  	* Get documentElement scrollHeight
  	* @returns {number} height
  	*/
  scrollHeight() {
    var e = this.documentElement.scrollHeight;
    return e;
  }
  /**
  	* Set overflow css style of the contents
  	* @param {string} [overflow]
  	*/
  overflow(e) {
    return e && (this.documentElement.style.overflow = e), this.window.getComputedStyle(this.documentElement).overflow;
  }
  /**
  	* Set overflowX css style of the documentElement
  	* @param {string} [overflow]
  	*/
  overflowX(e) {
    return e && (this.documentElement.style.overflowX = e), this.window.getComputedStyle(this.documentElement).overflowX;
  }
  /**
  	* Set overflowY css style of the documentElement
  	* @param {string} [overflow]
  	*/
  overflowY(e) {
    return e && (this.documentElement.style.overflowY = e), this.window.getComputedStyle(this.documentElement).overflowY;
  }
  /**
  	* Set Css styles on the contents element (typically Body)
  	* @param {string} property
  	* @param {string} value
  	* @param {boolean} [priority] set as "important"
  	*/
  css(e, n, r) {
    var i = this.content || this.document.body;
    return n ? i.style.setProperty(e, n, r ? "important" : "") : i.style.removeProperty(e), this.window.getComputedStyle(i)[e];
  }
  /**
  	* Get or Set the viewport element
  	* @param {object} [options]
  	* @param {string} [options.width]
  	* @param {string} [options.height]
  	* @param {string} [options.scale]
  	* @param {string} [options.minimum]
  	* @param {string} [options.maximum]
  	* @param {string} [options.scalable]
  	*/
  viewport(e) {
    var n = this.document.querySelector("meta[name='viewport']"), r = {
      width: void 0,
      height: void 0,
      scale: void 0,
      minimum: void 0,
      maximum: void 0,
      scalable: void 0
    }, i = [], s = {};
    if (n && n.hasAttribute("content")) {
      let o = n.getAttribute("content"), a = o.match(/width\s*=\s*([^,]*)/), l = o.match(/height\s*=\s*([^,]*)/), u = o.match(/initial-scale\s*=\s*([^,]*)/), c = o.match(/minimum-scale\s*=\s*([^,]*)/), d = o.match(/maximum-scale\s*=\s*([^,]*)/), h = o.match(/user-scalable\s*=\s*([^,]*)/);
      a && a.length && typeof a[1] < "u" && (r.width = a[1]), l && l.length && typeof l[1] < "u" && (r.height = l[1]), u && u.length && typeof u[1] < "u" && (r.scale = u[1]), c && c.length && typeof c[1] < "u" && (r.minimum = c[1]), d && d.length && typeof d[1] < "u" && (r.maximum = d[1]), h && h.length && typeof h[1] < "u" && (r.scalable = h[1]);
    }
    return s = M0(e || {}, r), e && (s.width && i.push("width=" + s.width), s.height && i.push("height=" + s.height), s.scale && i.push("initial-scale=" + s.scale), s.scalable === "no" ? (i.push("minimum-scale=" + s.scale), i.push("maximum-scale=" + s.scale), i.push("user-scalable=" + s.scalable)) : (s.scalable && i.push("user-scalable=" + s.scalable), s.minimum && i.push("minimum-scale=" + s.minimum), s.maximum && i.push("minimum-scale=" + s.maximum)), n || (n = this.document.createElement("meta"), n.setAttribute("name", "viewport"), this.document.querySelector("head").appendChild(n)), n.setAttribute("content", i.join(", ")), this.window.scrollTo(0, 0)), s;
  }
  /**
   * Event emitter for when the contents has expanded
   * @private
   */
  expand() {
    this.emit(Re.CONTENTS.EXPAND);
  }
  /**
   * Add DOM listeners
   * @private
   */
  listeners() {
    this.imageLoadListeners(), this.mediaQueryListeners(), this.addEventListeners(), this.addSelectionListeners(), typeof ResizeObserver > "u" ? (this.resizeListeners(), this.visibilityListeners()) : this.resizeObservers(), this.linksHandler();
  }
  /**
   * Remove DOM listeners
   * @private
   */
  removeListeners() {
    this.removeEventListeners(), this.removeSelectionListeners(), this.observer && this.observer.disconnect(), clearTimeout(this.expanding);
  }
  /**
   * Check if size of contents has changed and
   * emit 'resize' event if it has.
   * @private
   */
  resizeCheck() {
    let e = this.textWidth(), n = this.textHeight();
    (e != this._size.width || n != this._size.height) && (this._size = {
      width: e,
      height: n
    }, this.onResize && this.onResize(this._size), this.emit(Re.CONTENTS.RESIZE, this._size));
  }
  /**
   * Poll for resize detection
   * @private
   */
  resizeListeners() {
    clearTimeout(this.expanding), requestAnimationFrame(this.resizeCheck.bind(this)), this.expanding = setTimeout(this.resizeListeners.bind(this), 350);
  }
  /**
   * Listen for visibility of tab to change
   * @private
   */
  visibilityListeners() {
    document.addEventListener("visibilitychange", () => {
      document.visibilityState === "visible" && this.active === !1 ? (this.active = !0, this.resizeListeners()) : (this.active = !1, clearTimeout(this.expanding));
    });
  }
  /**
   * Use css transitions to detect resize
   * @private
   */
  transitionListeners() {
    let e = this.content;
    e.style.transitionProperty = "font, font-size, font-size-adjust, font-stretch, font-variation-settings, font-weight, width, height", e.style.transitionDuration = "0.001ms", e.style.transitionTimingFunction = "linear", e.style.transitionDelay = "0", this._resizeCheck = this.resizeCheck.bind(this), this.document.addEventListener("transitionend", this._resizeCheck);
  }
  /**
   * Listen for media query changes and emit 'expand' event
   * Adapted from: https://github.com/tylergaw/media-query-events/blob/master/js/mq-events.js
   * @private
   */
  mediaQueryListeners() {
    for (var e = this.document.styleSheets, n = function(a) {
      a.matches && !this._expanding && setTimeout(this.expand.bind(this), 1);
    }.bind(this), r = 0; r < e.length; r += 1) {
      var i;
      try {
        i = e[r].cssRules;
      } catch {
        return;
      }
      if (!i)
        return;
      for (var s = 0; s < i.length; s += 1)
        if (i[s].media) {
          var o = this.window.matchMedia(i[s].media.mediaText);
          o.addListener(n);
        }
    }
  }
  /**
   * Use ResizeObserver to listen for changes in the DOM and check for resize
   * @private
   */
  resizeObservers() {
    this.observer = new ResizeObserver((e) => {
      requestAnimationFrame(this.resizeCheck.bind(this));
    }), this.observer.observe(this.document.documentElement);
  }
  /**
   * Use MutationObserver to listen for changes in the DOM and check for resize
   * @private
   */
  mutationObservers() {
    this.observer = new MutationObserver((n) => {
      this.resizeCheck();
    });
    let e = { attributes: !0, childList: !0, characterData: !0, subtree: !0 };
    this.observer.observe(this.document, e);
  }
  /**
   * Test if images are loaded or add listener for when they load
   * @private
   */
  imageLoadListeners() {
    for (var e = this.document.querySelectorAll("img"), n, r = 0; r < e.length; r++)
      n = e[r], typeof n.naturalWidth < "u" && n.naturalWidth === 0 && (n.onload = this.expand.bind(this));
  }
  /**
   * Listen for font load and check for resize when loaded
   * @private
   */
  fontLoadListeners() {
    !this.document || !this.document.fonts || this.document.fonts.ready.then(function() {
      this.resizeCheck();
    }.bind(this));
  }
  /**
   * Get the documentElement
   * @returns {element} documentElement
   */
  root() {
    return this.document ? this.document.documentElement : null;
  }
  /**
   * Get the location offset of a EpubCFI or an #id
   * @param {string | EpubCFI} target
   * @param {string} [ignoreClass] for the cfi
   * @returns { {left: Number, top: Number }
   */
  locationOf(e, n) {
    var r, i = { left: 0, top: 0 };
    if (!this.document)
      return i;
    if (this.epubcfi.isCfiString(e)) {
      let s = new gt(e).toRange(this.document, n);
      if (s) {
        try {
          if (!s.endContainer || s.startContainer == s.endContainer && s.startOffset == s.endOffset) {
            let o = s.startContainer.textContent.indexOf(" ", s.startOffset);
            o == -1 && (o = s.startContainer.textContent.length), s.setEnd(s.startContainer, o);
          }
        } catch (o) {
          console.error("setting end offset to start container length failed", o);
        }
        if (s.startContainer.nodeType === Node.ELEMENT_NODE)
          r = s.startContainer.getBoundingClientRect(), i.left = r.left, i.top = r.top;
        else if (xv) {
          let o = s.startContainer, a = new Range();
          try {
            o.nodeType === k6 ? r = o.getBoundingClientRect() : s.startOffset + 2 < o.length ? (a.setStart(o, s.startOffset), a.setEnd(o, s.startOffset + 2), r = a.getBoundingClientRect()) : s.startOffset - 2 > 0 ? (a.setStart(o, s.startOffset - 2), a.setEnd(o, s.startOffset), r = a.getBoundingClientRect()) : r = o.parentNode.getBoundingClientRect();
          } catch (l) {
            console.error(l, l.stack);
          }
        } else
          r = s.getBoundingClientRect();
      }
    } else if (typeof e == "string" && e.indexOf("#") > -1) {
      let s = e.substring(e.indexOf("#") + 1), o = this.document.getElementById(s);
      if (o)
        if (xv) {
          let a = new Range();
          a.selectNode(o), r = a.getBoundingClientRect();
        } else
          r = o.getBoundingClientRect();
    }
    return r && (i.left = r.left, i.top = r.top), i;
  }
  /**
   * Append a stylesheet link to the document head
   * @param {string} src url
   */
  addStylesheet(e) {
    return new Promise(function(n, r) {
      var i, s = !1;
      if (!this.document) {
        n(!1);
        return;
      }
      if (i = this.document.querySelector("link[href='" + e + "']"), i) {
        n(!0);
        return;
      }
      i = this.document.createElement("link"), i.type = "text/css", i.rel = "stylesheet", i.href = e, i.onload = i.onreadystatechange = function() {
        !s && (!this.readyState || this.readyState == "complete") && (s = !0, setTimeout(() => {
          n(!0);
        }, 1));
      }, this.document.head.appendChild(i);
    }.bind(this));
  }
  _getStylesheetNode(e) {
    var n;
    return e = "epubjs-inserted-css-" + (e || ""), this.document ? (n = this.document.getElementById(e), n || (n = this.document.createElement("style"), n.id = e, this.document.head.appendChild(n)), n) : !1;
  }
  /**
   * Append stylesheet css
   * @param {string} serializedCss
   * @param {string} key If the key is the same, the CSS will be replaced instead of inserted
   */
  addStylesheetCss(e, n) {
    if (!this.document || !e)
      return !1;
    var r;
    return r = this._getStylesheetNode(n), r.innerHTML = e, !0;
  }
  /**
   * Append stylesheet rules to a generate stylesheet
   * Array: https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/insertRule
   * Object: https://github.com/desirable-objects/json-to-css
   * @param {array | object} rules
   * @param {string} key If the key is the same, the CSS will be replaced instead of inserted
   */
  addStylesheetRules(e, n) {
    var r;
    if (!(!this.document || !e || e.length === 0))
      if (r = this._getStylesheetNode(n).sheet, Object.prototype.toString.call(e) === "[object Array]")
        for (var i = 0, s = e.length; i < s; i++) {
          var o = 1, a = e[i], l = e[i][0], u = "";
          Object.prototype.toString.call(a[1][0]) === "[object Array]" && (a = a[1], o = 0);
          for (var c = a.length; o < c; o++) {
            var d = a[o];
            u += d[0] + ":" + d[1] + (d[2] ? " !important" : "") + `;
`;
          }
          r.insertRule(l + "{" + u + "}", r.cssRules.length);
        }
      else
        Object.keys(e).forEach((v) => {
          const m = e[v];
          if (Array.isArray(m))
            m.forEach((b) => {
              const f = Object.keys(b).map((g) => `${g}:${b[g]}`).join(";");
              r.insertRule(`${v}{${f}}`, r.cssRules.length);
            });
          else {
            const p = Object.keys(m).map((f) => `${f}:${m[f]}`).join(";");
            r.insertRule(`${v}{${p}}`, r.cssRules.length);
          }
        });
  }
  /**
   * Append a script tag to the document head
   * @param {string} src url
   * @returns {Promise} loaded
   */
  addScript(e) {
    return new Promise(function(n, r) {
      var i, s = !1;
      if (!this.document) {
        n(!1);
        return;
      }
      i = this.document.createElement("script"), i.type = "text/javascript", i.async = !0, i.src = e, i.onload = i.onreadystatechange = function() {
        !s && (!this.readyState || this.readyState == "complete") && (s = !0, setTimeout(function() {
          n(!0);
        }, 1));
      }, this.document.head.appendChild(i);
    }.bind(this));
  }
  /**
   * Add a class to the contents container
   * @param {string} className
   */
  addClass(e) {
    var n;
    this.document && (n = this.content || this.document.body, n && n.classList.add(e));
  }
  /**
   * Remove a class from the contents container
   * @param {string} removeClass
   */
  removeClass(e) {
    var n;
    this.document && (n = this.content || this.document.body, n && n.classList.remove(e));
  }
  /**
   * Add DOM event listeners
   * @private
   */
  addEventListeners() {
    this.document && (this._triggerEvent = this.triggerEvent.bind(this), pl.forEach(function(e) {
      this.document.addEventListener(e, this._triggerEvent, { passive: !0 });
    }, this));
  }
  /**
   * Remove DOM event listeners
   * @private
   */
  removeEventListeners() {
    this.document && (pl.forEach(function(e) {
      this.document.removeEventListener(e, this._triggerEvent, { passive: !0 });
    }, this), this._triggerEvent = void 0);
  }
  /**
   * Emit passed browser events
   * @private
   */
  triggerEvent(e) {
    this.emit(e.type, e);
  }
  /**
   * Add listener for text selection
   * @private
   */
  addSelectionListeners() {
    this.document && (this._onSelectionChange = this.onSelectionChange.bind(this), this.document.addEventListener("selectionchange", this._onSelectionChange, { passive: !0 }));
  }
  /**
   * Remove listener for text selection
   * @private
   */
  removeSelectionListeners() {
    this.document && (this.document.removeEventListener("selectionchange", this._onSelectionChange, { passive: !0 }), this._onSelectionChange = void 0);
  }
  /**
   * Handle getting text on selection
   * @private
   */
  onSelectionChange(e) {
    this.selectionEndTimeout && clearTimeout(this.selectionEndTimeout), this.selectionEndTimeout = setTimeout(function() {
      var n = this.window.getSelection();
      this.triggerSelectedEvent(n);
    }.bind(this), 250);
  }
  /**
   * Emit event on text selection
   * @private
   */
  triggerSelectedEvent(e) {
    var n, r;
    e && e.rangeCount > 0 && (n = e.getRangeAt(0), n.collapsed || (r = new gt(n, this.cfiBase).toString(), this.emit(Re.CONTENTS.SELECTED, r), this.emit(Re.CONTENTS.SELECTED_RANGE, n)));
  }
  /**
   * Get a Dom Range from EpubCFI
   * @param {EpubCFI} _cfi
   * @param {string} [ignoreClass]
   * @returns {Range} range
   */
  range(e, n) {
    var r = new gt(e);
    return r.toRange(this.document, n);
  }
  /**
   * Get an EpubCFI from a Dom Range
   * @param {Range} range
   * @param {string} [ignoreClass]
   * @returns {EpubCFI} cfi
   */
  cfiFromRange(e, n) {
    return new gt(e, this.cfiBase, n).toString();
  }
  /**
   * Get an EpubCFI from a Dom node
   * @param {node} node
   * @param {string} [ignoreClass]
   * @returns {EpubCFI} cfi
   */
  cfiFromNode(e, n) {
    return new gt(e, this.cfiBase, n).toString();
  }
  // TODO: find where this is used - remove?
  map(e) {
    var n = new $l(e);
    return n.section();
  }
  /**
   * Size the contents to a given width and height
   * @param {number} [width]
   * @param {number} [height]
   */
  size(e, n) {
    var r = { scale: 1, scalable: "no" };
    this.layoutStyle("scrolling"), e >= 0 && (this.width(e), r.width = e, this.css("padding", "0 " + e / 12 + "px")), n >= 0 && (this.height(n), r.height = n), this.css("margin", "0"), this.css("box-sizing", "border-box"), this.viewport(r);
  }
  /**
   * Apply columns to the contents for pagination
   * @param {number} width
   * @param {number} height
   * @param {number} columnWidth
   * @param {number} gap
   */
  columns(e, n, r, i, s) {
    let o = Es("column-axis"), a = Es("column-gap"), l = Es("column-width"), u = Es("column-fill"), d = this.writingMode().indexOf("vertical") === 0 ? "vertical" : "horizontal";
    this.layoutStyle("paginated"), s === "rtl" && d === "horizontal" && this.direction(s), this.width(e), this.height(n), this.viewport({ width: e, height: n, scale: 1, scalable: "no" }), this.css("overflow-y", "hidden"), this.css("margin", "0", !0), d === "vertical" ? (this.css("padding-top", i / 2 + "px", !0), this.css("padding-bottom", i / 2 + "px", !0), this.css("padding-left", "20px"), this.css("padding-right", "20px"), this.css(o, "vertical")) : (this.css("padding-top", "20px"), this.css("padding-bottom", "20px"), this.css("padding-left", i / 2 + "px", !0), this.css("padding-right", i / 2 + "px", !0), this.css(o, "horizontal")), this.css("box-sizing", "border-box"), this.css("max-width", "inherit"), this.css(u, "auto"), this.css(a, i + "px"), this.css(l, r + "px"), this.css("-webkit-line-box-contain", "block glyphs replaced");
  }
  /**
   * Scale contents from center
   * @param {number} scale
   * @param {number} offsetX
   * @param {number} offsetY
   */
  scaler(e, n, r) {
    var i = "scale(" + e + ")", s = "";
    this.css("transform-origin", "top left"), (n >= 0 || r >= 0) && (s = " translate(" + (n || 0) + "px, " + (r || 0) + "px )"), this.css("transform", i + s);
  }
  /**
   * Fit contents into a fixed width and height
   * @param {number} width
   * @param {number} height
   */
  fit(e, n, r) {
    var i = this.viewport(), s = parseInt(i.width), o = parseInt(i.height), a = e / s, l = n / o, u = a < l ? a : l;
    if (this.layoutStyle("paginated"), this.width(s), this.height(o), this.overflow("hidden"), this.scaler(u, 0, 0), this.css("background-size", s * u + "px " + o * u + "px"), this.css("background-color", "transparent"), r && r.properties.includes("page-spread-left")) {
      var c = e - s * u;
      this.css("margin-left", c + "px");
    }
  }
  /**
   * Set the direction of the text
   * @param {string} [dir="ltr"] "rtl" | "ltr"
   */
  direction(e) {
    this.documentElement && (this.documentElement.style.direction = e);
  }
  mapPage(e, n, r, i, s) {
    var o = new $l(n, s);
    return o.page(this, e, r, i);
  }
  /**
   * Emit event when link in content is clicked
   * @private
   */
  linksHandler() {
    g6(this.content, (e) => {
      this.emit(Re.CONTENTS.LINK_CLICKED, e);
    });
  }
  /**
   * Set the writingMode of the text
   * @param {string} [mode="horizontal-tb"] "horizontal-tb" | "vertical-rl" | "vertical-lr"
   */
  writingMode(e) {
    let n = Es("writing-mode");
    return e && this.documentElement && (this.documentElement.style[n] = e), this.window.getComputedStyle(this.documentElement)[n] || "";
  }
  /**
   * Set the layoutStyle of the content
   * @param {string} [style="paginated"] "scrolling" | "paginated"
   * @private
   */
  layoutStyle(e) {
    return e && (this._layoutStyle = e, navigator.epubReadingSystem.layoutStyle = this._layoutStyle), this._layoutStyle || "paginated";
  }
  /**
   * Add the epubReadingSystem object to the navigator
   * @param {string} name
   * @param {string} version
   * @private
   */
  epubReadingSystem(e, n) {
    return navigator.epubReadingSystem = {
      name: e,
      version: n,
      layoutStyle: this.layoutStyle(),
      hasFeature: function(r) {
        switch (r) {
          case "dom-manipulation":
            return !0;
          case "layout-changes":
            return !0;
          case "touch-events":
            return !0;
          case "mouse-events":
            return !0;
          case "keyboard-events":
            return !0;
          case "spine-scripting":
            return !1;
          default:
            return !1;
        }
      }
    }, navigator.epubReadingSystem;
  }
  destroy() {
    this.removeListeners();
  }
}
Vr(Gf.prototype);
class C6 {
  constructor(e) {
    this.rendition = e, this.highlights = [], this.underlines = [], this.marks = [], this._annotations = {}, this._annotationsBySectionIndex = {}, this.rendition.hooks.render.register(this.inject.bind(this)), this.rendition.hooks.unloaded.register(this.clear.bind(this));
  }
  /**
   * Add an annotation to store
   * @param {string} type Type of annotation to add: "highlight", "underline", "mark"
   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to
   * @param {object} data Data to assign to annotation
   * @param {function} [cb] Callback after annotation is added
   * @param {string} className CSS class to assign to annotation
   * @param {object} styles CSS styles to assign to annotation
   * @returns {Annotation} annotation
   */
  add(e, n, r, i, s, o) {
    let a = encodeURI(n + e), u = new gt(n).spinePos, c = new J0({
      type: e,
      cfiRange: n,
      data: r,
      sectionIndex: u,
      cb: i,
      className: s,
      styles: o
    });
    return this._annotations[a] = c, u in this._annotationsBySectionIndex ? this._annotationsBySectionIndex[u].push(a) : this._annotationsBySectionIndex[u] = [a], this.rendition.views().forEach((h) => {
      c.sectionIndex === h.index && c.attach(h);
    }), c;
  }
  /**
   * Remove an annotation from store
   * @param {EpubCFI} cfiRange EpubCFI range the annotation is attached to
   * @param {string} type Type of annotation to add: "highlight", "underline", "mark"
   */
  remove(e, n) {
    let r = encodeURI(e + n);
    if (r in this._annotations) {
      let i = this._annotations[r];
      if (n && i.type !== n)
        return;
      this.rendition.views().forEach((o) => {
        this._removeFromAnnotationBySectionIndex(i.sectionIndex, r), i.sectionIndex === o.index && i.detach(o);
      }), delete this._annotations[r];
    }
  }
  /**
   * Remove an annotations by Section Index
   * @private
   */
  _removeFromAnnotationBySectionIndex(e, n) {
    this._annotationsBySectionIndex[e] = this._annotationsAt(e).filter((r) => r !== n);
  }
  /**
   * Get annotations by Section Index
   * @private
   */
  _annotationsAt(e) {
    return this._annotationsBySectionIndex[e];
  }
  /**
   * Add a highlight to the store
   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to
   * @param {object} data Data to assign to annotation
   * @param {function} cb Callback after annotation is clicked
   * @param {string} className CSS class to assign to annotation
   * @param {object} styles CSS styles to assign to annotation
   */
  highlight(e, n, r, i, s) {
    return this.add("highlight", e, n, r, i, s);
  }
  /**
   * Add a underline to the store
   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to
   * @param {object} data Data to assign to annotation
   * @param {function} cb Callback after annotation is clicked
   * @param {string} className CSS class to assign to annotation
   * @param {object} styles CSS styles to assign to annotation
   */
  underline(e, n, r, i, s) {
    return this.add("underline", e, n, r, i, s);
  }
  /**
   * Add a mark to the store
   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to
   * @param {object} data Data to assign to annotation
   * @param {function} cb Callback after annotation is clicked
   */
  mark(e, n, r) {
    return this.add("mark", e, n, r);
  }
  /**
   * iterate over annotations in the store
   */
  each() {
    return this._annotations.forEach.apply(this._annotations, arguments);
  }
  /**
   * Hook for injecting annotation into a view
   * @param {View} view
   * @private
   */
  inject(e) {
    let n = e.index;
    n in this._annotationsBySectionIndex && this._annotationsBySectionIndex[n].forEach((i) => {
      this._annotations[i].attach(e);
    });
  }
  /**
   * Hook for removing annotation from a view
   * @param {View} view
   * @private
   */
  clear(e) {
    let n = e.index;
    n in this._annotationsBySectionIndex && this._annotationsBySectionIndex[n].forEach((i) => {
      this._annotations[i].detach(e);
    });
  }
  /**
   * [Not Implemented] Show annotations
   * @TODO: needs implementation in View
   */
  show() {
  }
  /**
   * [Not Implemented] Hide annotations
   * @TODO: needs implementation in View
   */
  hide() {
  }
}
class J0 {
  constructor({
    type: e,
    cfiRange: n,
    data: r,
    sectionIndex: i,
    cb: s,
    className: o,
    styles: a
  }) {
    this.type = e, this.cfiRange = n, this.data = r, this.sectionIndex = i, this.mark = void 0, this.cb = s, this.className = o, this.styles = a;
  }
  /**
   * Update stored data
   * @param {object} data
   */
  update(e) {
    this.data = e;
  }
  /**
   * Add to a view
   * @param {View} view
   */
  attach(e) {
    let { cfiRange: n, data: r, type: i, mark: s, cb: o, className: a, styles: l } = this, u;
    return i === "highlight" ? u = e.highlight(n, r, o, a, l) : i === "underline" ? u = e.underline(n, r, o, a, l) : i === "mark" && (u = e.mark(n, r, o)), this.mark = u, this.emit(Re.ANNOTATION.ATTACH, u), u;
  }
  /**
   * Remove from a view
   * @param {View} view
   */
  detach(e) {
    let { cfiRange: n, type: r } = this, i;
    return e && (r === "highlight" ? i = e.unhighlight(n) : r === "underline" ? i = e.ununderline(n) : r === "mark" && (i = e.unmark(n))), this.mark = void 0, this.emit(Re.ANNOTATION.DETACH, i), i;
  }
  /**
   * [Not Implemented] Get text of an annotation
   * @TODO: needs implementation in contents
   */
  text() {
  }
}
Vr(J0.prototype);
var Zr = {}, bu = {};
Object.defineProperty(bu, "__esModule", {
  value: !0
});
bu.createElement = Y0;
function Y0(t) {
  return document.createElementNS("http://www.w3.org/2000/svg", t);
}
bu.default = {
  createElement: Y0
};
var wa = {};
Object.defineProperty(wa, "__esModule", {
  value: !0
});
wa.proxyMouse = Q0;
wa.clone = Z0;
wa.default = {
  proxyMouse: Q0
};
function Q0(t, e) {
  function n(o) {
    for (var a = e.length - 1; a >= 0; a--) {
      var l = e[a], u = o.clientX, c = o.clientY;
      if (o.touches && o.touches.length && (u = o.touches[0].clientX, c = o.touches[0].clientY), !!T6(l, t, u, c)) {
        l.dispatchEvent(Z0(o));
        break;
      }
    }
  }
  if (t.nodeName === "iframe" || t.nodeName === "IFRAME")
    try {
      this.target = t.contentDocument;
    } catch {
      this.target = t;
    }
  else
    this.target = t;
  for (var r = ["mouseup", "mousedown", "click", "touchstart"], i = 0; i < r.length; i++) {
    var s = r[i];
    this.target.addEventListener(s, function(o) {
      return n(o);
    }, !1);
  }
}
function Z0(t) {
  var e = Object.assign({}, t, { bubbles: !1 });
  try {
    return new MouseEvent(t.type, e);
  } catch {
    var n = document.createEvent("MouseEvents");
    return n.initMouseEvent(t.type, !1, e.cancelable, e.view, e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget), n;
  }
}
function T6(t, e, n, r) {
  var i = e.getBoundingClientRect();
  function s(c, d, h) {
    var v = c.top - i.top, m = c.left - i.left, b = v + c.height, p = m + c.width;
    return v <= h && m <= d && b > h && p > d;
  }
  var o = t.getBoundingClientRect();
  if (!s(o, n, r))
    return !1;
  for (var a = t.getClientRects(), l = 0, u = a.length; l < u; l++)
    if (s(a[l], n, r))
      return !0;
  return !1;
}
var Kl, qf;
Object.defineProperty(Zr, "__esModule", {
  value: !0
});
var X0 = Zr.Underline = qf = Zr.Highlight = Zr.Mark = Kl = Zr.Pane = void 0, O6 = function t(e, n, r) {
  e === null && (e = Function.prototype);
  var i = Object.getOwnPropertyDescriptor(e, n);
  if (i === void 0) {
    var s = Object.getPrototypeOf(e);
    return s === null ? void 0 : t(s, n, r);
  } else {
    if ("value" in i)
      return i.value;
    var o = i.get;
    return o === void 0 ? void 0 : o.call(r);
  }
}, wu = function() {
  function t(e, n) {
    for (var r = 0; r < n.length; r++) {
      var i = n[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  return function(e, n, r) {
    return n && t(e.prototype, n), r && t(e, r), e;
  };
}(), I6 = bu, Xo = eb(I6), N6 = wa, R6 = eb(N6);
function eb(t) {
  return t && t.__esModule ? t : { default: t };
}
function tb(t, e) {
  if (!t)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e && (typeof e == "object" || typeof e == "function") ? e : t;
}
function nb(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof e);
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
}
function _u(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
Kl = Zr.Pane = function() {
  function t(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : document.body;
    _u(this, t), this.target = e, this.element = Xo.default.createElement("svg"), this.marks = [], this.element.style.position = "absolute", this.element.setAttribute("pointer-events", "none"), R6.default.proxyMouse(this.target, this.marks), this.container = n, this.container.appendChild(this.element), this.render();
  }
  return wu(t, [{
    key: "addMark",
    value: function(n) {
      var r = Xo.default.createElement("g");
      return this.element.appendChild(r), n.bind(r, this.container), this.marks.push(n), n.render(), n;
    }
  }, {
    key: "removeMark",
    value: function(n) {
      var r = this.marks.indexOf(n);
      if (r !== -1) {
        var i = n.unbind();
        this.element.removeChild(i), this.marks.splice(r, 1);
      }
    }
  }, {
    key: "render",
    value: function() {
      M6(this.element, B6(this.target, this.container));
      var n = !0, r = !1, i = void 0;
      try {
        for (var s = this.marks[Symbol.iterator](), o; !(n = (o = s.next()).done); n = !0) {
          var a = o.value;
          a.render();
        }
      } catch (l) {
        r = !0, i = l;
      } finally {
        try {
          !n && s.return && s.return();
        } finally {
          if (r)
            throw i;
        }
      }
    }
  }]), t;
}();
var P6 = Zr.Mark = function() {
  function t() {
    _u(this, t), this.element = null;
  }
  return wu(t, [{
    key: "bind",
    value: function(n, r) {
      this.element = n, this.container = r;
    }
  }, {
    key: "unbind",
    value: function() {
      var n = this.element;
      return this.element = null, n;
    }
  }, {
    key: "render",
    value: function() {
    }
  }, {
    key: "dispatchEvent",
    value: function(n) {
      this.element && this.element.dispatchEvent(n);
    }
  }, {
    key: "getBoundingClientRect",
    value: function() {
      return this.element.getBoundingClientRect();
    }
  }, {
    key: "getClientRects",
    value: function() {
      for (var n = [], r = this.element.firstChild; r; )
        n.push(r.getBoundingClientRect()), r = r.nextSibling;
      return n;
    }
  }, {
    key: "filteredRanges",
    value: function() {
      var n = Array.from(this.range.getClientRects());
      return n.filter(function(r) {
        for (var i = 0; i < n.length; i++) {
          if (n[i] === r)
            return !0;
          var s = L6(n[i], r);
          if (s)
            return !1;
        }
        return !0;
      });
    }
  }]), t;
}(), D6 = qf = Zr.Highlight = function(t) {
  nb(e, t);
  function e(n, r, i, s) {
    _u(this, e);
    var o = tb(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
    return o.range = n, o.className = r, o.data = i || {}, o.attributes = s || {}, o;
  }
  return wu(e, [{
    key: "bind",
    value: function(r, i) {
      O6(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "bind", this).call(this, r, i);
      for (var s in this.data)
        this.data.hasOwnProperty(s) && (this.element.dataset[s] = this.data[s]);
      for (var s in this.attributes)
        this.attributes.hasOwnProperty(s) && this.element.setAttribute(s, this.attributes[s]);
      this.className && this.element.classList.add(this.className);
    }
  }, {
    key: "render",
    value: function() {
      for (; this.element.firstChild; )
        this.element.removeChild(this.element.firstChild);
      for (var r = this.element.ownerDocument.createDocumentFragment(), i = this.filteredRanges(), s = this.element.getBoundingClientRect(), o = this.container.getBoundingClientRect(), a = 0, l = i.length; a < l; a++) {
        var u = i[a], c = Xo.default.createElement("rect");
        c.setAttribute("x", u.left - s.left + o.left), c.setAttribute("y", u.top - s.top + o.top), c.setAttribute("height", u.height), c.setAttribute("width", u.width), r.appendChild(c);
      }
      this.element.appendChild(r);
    }
  }]), e;
}(P6);
X0 = Zr.Underline = function(t) {
  nb(e, t);
  function e(n, r, i, s) {
    return _u(this, e), tb(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, n, r, i, s));
  }
  return wu(e, [{
    key: "render",
    value: function() {
      for (; this.element.firstChild; )
        this.element.removeChild(this.element.firstChild);
      for (var r = this.element.ownerDocument.createDocumentFragment(), i = this.filteredRanges(), s = this.element.getBoundingClientRect(), o = this.container.getBoundingClientRect(), a = 0, l = i.length; a < l; a++) {
        var u = i[a], c = Xo.default.createElement("rect");
        c.setAttribute("x", u.left - s.left + o.left), c.setAttribute("y", u.top - s.top + o.top), c.setAttribute("height", u.height), c.setAttribute("width", u.width), c.setAttribute("fill", "none");
        var d = Xo.default.createElement("line");
        d.setAttribute("x1", u.left - s.left + o.left), d.setAttribute("x2", u.left - s.left + o.left + u.width), d.setAttribute("y1", u.top - s.top + o.top + u.height - 1), d.setAttribute("y2", u.top - s.top + o.top + u.height - 1), d.setAttribute("stroke-width", 1), d.setAttribute("stroke", "black"), d.setAttribute("stroke-linecap", "square"), r.appendChild(c), r.appendChild(d);
      }
      this.element.appendChild(r);
    }
  }]), e;
}(D6);
function B6(t, e) {
  var n = e.getBoundingClientRect(), r = t.getBoundingClientRect();
  return {
    top: r.top - n.top,
    left: r.left - n.left,
    height: t.scrollHeight,
    width: t.scrollWidth
  };
}
function M6(t, e) {
  t.style.setProperty("top", e.top + "px", "important"), t.style.setProperty("left", e.left + "px", "important"), t.style.setProperty("height", e.height + "px", "important"), t.style.setProperty("width", e.width + "px", "important");
}
function L6(t, e) {
  return e.right <= t.right && e.left >= t.left && e.top >= t.top && e.bottom <= t.bottom;
}
class rb {
  constructor(e, n) {
    this.settings = En({
      ignoreClass: "",
      axis: void 0,
      //options.layout && options.layout.props.flow === "scrolled" ? "vertical" : "horizontal",
      direction: void 0,
      width: 0,
      height: 0,
      layout: void 0,
      globalLayoutProperties: {},
      method: void 0,
      forceRight: !1,
      allowScriptedContent: !1,
      allowPopups: !1
    }, n || {}), this.id = "epubjs-view-" + mu(), this.section = e, this.index = e.index, this.element = this.container(this.settings.axis), this.added = !1, this.displayed = !1, this.rendered = !1, this.fixedWidth = 0, this.fixedHeight = 0, this.epubcfi = new gt(), this.layout = this.settings.layout, this.pane = void 0, this.highlights = {}, this.underlines = {}, this.marks = {};
  }
  container(e) {
    var n = document.createElement("div");
    return n.classList.add("epub-view"), n.style.height = "0px", n.style.width = "0px", n.style.overflow = "hidden", n.style.position = "relative", n.style.display = "block", e && e == "horizontal" ? n.style.flex = "none" : n.style.flex = "initial", n;
  }
  create() {
    return this.iframe ? this.iframe : (this.element || (this.element = this.createContainer()), this.iframe = document.createElement("iframe"), this.iframe.id = this.id, this.iframe.scrolling = "no", this.iframe.style.overflow = "hidden", this.iframe.seamless = "seamless", this.iframe.style.border = "none", this.iframe.sandbox = "allow-same-origin", this.settings.allowScriptedContent && (this.iframe.sandbox += " allow-scripts"), this.settings.allowPopups && (this.iframe.sandbox += " allow-popups"), this.iframe.setAttribute("enable-annotation", "true"), this.resizing = !0, this.element.style.visibility = "hidden", this.iframe.style.visibility = "hidden", this.iframe.style.width = "0", this.iframe.style.height = "0", this._width = 0, this._height = 0, this.element.setAttribute("ref", this.index), this.added = !0, this.elementBounds = fl(this.element), "srcdoc" in this.iframe ? this.supportsSrcdoc = !0 : this.supportsSrcdoc = !1, this.settings.method || (this.settings.method = this.supportsSrcdoc ? "srcdoc" : "write"), this.iframe);
  }
  render(e, n) {
    return this.create(), this.size(), this.sectionRender || (this.sectionRender = this.section.render(e)), this.sectionRender.then(function(r) {
      return this.load(r);
    }.bind(this)).then(function() {
      let r = this.contents.writingMode(), i;
      return this.settings.flow === "scrolled" ? i = r.indexOf("vertical") === 0 ? "horizontal" : "vertical" : i = r.indexOf("vertical") === 0 ? "vertical" : "horizontal", r.indexOf("vertical") === 0 && this.settings.flow === "paginated" && (this.layout.delta = this.layout.height), this.setAxis(i), this.emit(Re.VIEWS.AXIS, i), this.setWritingMode(r), this.emit(Re.VIEWS.WRITING_MODE, r), this.layout.format(this.contents, this.section, this.axis), this.addListeners(), new Promise((s, o) => {
        this.expand(), this.settings.forceRight && (this.element.style.marginLeft = this.width() + "px"), s();
      });
    }.bind(this), function(r) {
      return this.emit(Re.VIEWS.LOAD_ERROR, r), new Promise((i, s) => {
        s(r);
      });
    }.bind(this)).then(function() {
      this.emit(Re.VIEWS.RENDERED, this.section);
    }.bind(this));
  }
  reset() {
    this.iframe && (this.iframe.style.width = "0", this.iframe.style.height = "0", this._width = 0, this._height = 0, this._textWidth = void 0, this._contentWidth = void 0, this._textHeight = void 0, this._contentHeight = void 0), this._needsReframe = !0;
  }
  // Determine locks base on settings
  size(e, n) {
    var r = e || this.settings.width, i = n || this.settings.height;
    this.layout.name === "pre-paginated" ? this.lock("both", r, i) : this.settings.axis === "horizontal" ? this.lock("height", r, i) : this.lock("width", r, i), this.settings.width = r, this.settings.height = i;
  }
  // Lock an axis to element dimensions, taking borders into account
  lock(e, n, r) {
    var i = Fl(this.element), s;
    this.iframe ? s = Fl(this.iframe) : s = { width: 0, height: 0 }, e == "width" && Yt(n) && (this.lockedWidth = n - i.width - s.width), e == "height" && Yt(r) && (this.lockedHeight = r - i.height - s.height), e === "both" && Yt(n) && Yt(r) && (this.lockedWidth = n - i.width - s.width, this.lockedHeight = r - i.height - s.height), this.displayed && this.iframe && this.expand();
  }
  // Resize a single axis based on content dimensions
  expand(e) {
    var n = this.lockedWidth, r = this.lockedHeight, i;
    !this.iframe || this._expanding || (this._expanding = !0, this.layout.name === "pre-paginated" ? (n = this.layout.columnWidth, r = this.layout.height) : this.settings.axis === "horizontal" ? (n = this.contents.textWidth(), n % this.layout.pageWidth > 0 && (n = Math.ceil(n / this.layout.pageWidth) * this.layout.pageWidth), this.settings.forceEvenPages && (i = n / this.layout.pageWidth, this.layout.divisor > 1 && this.layout.name === "reflowable" && i % 2 > 0 && (n += this.layout.pageWidth))) : this.settings.axis === "vertical" && (r = this.contents.textHeight(), this.settings.flow === "paginated" && r % this.layout.height > 0 && (r = Math.ceil(r / this.layout.height) * this.layout.height)), (this._needsReframe || n != this._width || r != this._height) && this.reframe(n, r), this._expanding = !1);
  }
  reframe(e, n) {
    var r;
    Yt(e) && (this.element.style.width = e + "px", this.iframe.style.width = e + "px", this._width = e), Yt(n) && (this.element.style.height = n + "px", this.iframe.style.height = n + "px", this._height = n);
    let i = this.prevBounds ? e - this.prevBounds.width : e, s = this.prevBounds ? n - this.prevBounds.height : n;
    r = {
      width: e,
      height: n,
      widthDelta: i,
      heightDelta: s
    }, this.pane && this.pane.render(), requestAnimationFrame(() => {
      let o;
      for (let a in this.marks)
        this.marks.hasOwnProperty(a) && (o = this.marks[a], this.placeMark(o.element, o.range));
    }), this.onResize(this, r), this.emit(Re.VIEWS.RESIZED, r), this.prevBounds = r, this.elementBounds = fl(this.element);
  }
  load(e) {
    var n = new vt(), r = n.promise;
    if (!this.iframe)
      return n.reject(new Error("No Iframe Available")), r;
    if (this.iframe.onload = function(s) {
      this.onLoad(s, n);
    }.bind(this), this.settings.method === "blobUrl")
      this.blobUrl = Ul(e, "application/xhtml+xml"), this.iframe.src = this.blobUrl, this.element.appendChild(this.iframe);
    else if (this.settings.method === "srcdoc")
      this.iframe.srcdoc = e, this.element.appendChild(this.iframe);
    else {
      if (this.element.appendChild(this.iframe), this.document = this.iframe.contentDocument, !this.document)
        return n.reject(new Error("No Document Available")), r;
      if (this.iframe.contentDocument.open(), window.MSApp && MSApp.execUnsafeLocalFunction) {
        var i = this;
        MSApp.execUnsafeLocalFunction(function() {
          i.iframe.contentDocument.write(e);
        });
      } else
        this.iframe.contentDocument.write(e);
      this.iframe.contentDocument.close();
    }
    return r;
  }
  onLoad(e, n) {
    this.window = this.iframe.contentWindow, this.document = this.iframe.contentDocument, this.contents = new Gf(this.document, this.document.body, this.section.cfiBase, this.section.index), this.rendering = !1;
    var r = this.document.querySelector("link[rel='canonical']");
    r ? r.setAttribute("href", this.section.canonical) : (r = this.document.createElement("link"), r.setAttribute("rel", "canonical"), r.setAttribute("href", this.section.canonical), this.document.querySelector("head").appendChild(r)), this.contents.on(Re.CONTENTS.EXPAND, () => {
      this.displayed && this.iframe && (this.expand(), this.contents && this.layout.format(this.contents));
    }), this.contents.on(Re.CONTENTS.RESIZE, (i) => {
      this.displayed && this.iframe && (this.expand(), this.contents && this.layout.format(this.contents));
    }), n.resolve(this.contents);
  }
  setLayout(e) {
    this.layout = e, this.contents && (this.layout.format(this.contents), this.expand());
  }
  setAxis(e) {
    this.settings.axis = e, e == "horizontal" ? this.element.style.flex = "none" : this.element.style.flex = "initial", this.size();
  }
  setWritingMode(e) {
    this.writingMode = e;
  }
  addListeners() {
  }
  removeListeners(e) {
  }
  display(e) {
    var n = new vt();
    return this.displayed ? n.resolve(this) : this.render(e).then(function() {
      this.emit(Re.VIEWS.DISPLAYED, this), this.onDisplayed(this), this.displayed = !0, n.resolve(this);
    }.bind(this), function(r) {
      n.reject(r, this);
    }), n.promise;
  }
  show() {
    this.element.style.visibility = "visible", this.iframe && (this.iframe.style.visibility = "visible", this.iframe.style.transform = "translateZ(0)", this.iframe.offsetWidth, this.iframe.style.transform = null), this.emit(Re.VIEWS.SHOWN, this);
  }
  hide() {
    this.element.style.visibility = "hidden", this.iframe.style.visibility = "hidden", this.stopExpanding = !0, this.emit(Re.VIEWS.HIDDEN, this);
  }
  offset() {
    return {
      top: this.element.offsetTop,
      left: this.element.offsetLeft
    };
  }
  width() {
    return this._width;
  }
  height() {
    return this._height;
  }
  position() {
    return this.element.getBoundingClientRect();
  }
  locationOf(e) {
    this.iframe.getBoundingClientRect();
    var n = this.contents.locationOf(e, this.settings.ignoreClass);
    return {
      left: n.left,
      top: n.top
    };
  }
  onDisplayed(e) {
  }
  onResize(e, n) {
  }
  bounds(e) {
    return (e || !this.elementBounds) && (this.elementBounds = fl(this.element)), this.elementBounds;
  }
  highlight(e, n = {}, r, i = "epubjs-hl", s = {}) {
    if (!this.contents)
      return;
    const o = Object.assign({ fill: "yellow", "fill-opacity": "0.3", "mix-blend-mode": "multiply" }, s);
    let a = this.contents.range(e), l = () => {
      this.emit(Re.VIEWS.MARK_CLICKED, e, n);
    };
    n.epubcfi = e, this.pane || (this.pane = new Kl(this.iframe, this.element));
    let u = new qf(a, i, n, o), c = this.pane.addMark(u);
    return this.highlights[e] = { mark: c, element: c.element, listeners: [l, r] }, c.element.setAttribute("ref", i), c.element.addEventListener("click", l), c.element.addEventListener("touchstart", l), r && (c.element.addEventListener("click", r), c.element.addEventListener("touchstart", r)), c;
  }
  underline(e, n = {}, r, i = "epubjs-ul", s = {}) {
    if (!this.contents)
      return;
    const o = Object.assign({ stroke: "black", "stroke-opacity": "0.3", "mix-blend-mode": "multiply" }, s);
    let a = this.contents.range(e), l = () => {
      this.emit(Re.VIEWS.MARK_CLICKED, e, n);
    };
    n.epubcfi = e, this.pane || (this.pane = new Kl(this.iframe, this.element));
    let u = new X0(a, i, n, o), c = this.pane.addMark(u);
    return this.underlines[e] = { mark: c, element: c.element, listeners: [l, r] }, c.element.setAttribute("ref", i), c.element.addEventListener("click", l), c.element.addEventListener("touchstart", l), r && (c.element.addEventListener("click", r), c.element.addEventListener("touchstart", r)), c;
  }
  mark(e, n = {}, r) {
    if (!this.contents)
      return;
    if (e in this.marks)
      return this.marks[e];
    let i = this.contents.range(e);
    if (!i)
      return;
    let s = i.commonAncestorContainer, o = s.nodeType === 1 ? s : s.parentNode, a = (u) => {
      this.emit(Re.VIEWS.MARK_CLICKED, e, n);
    };
    i.collapsed && s.nodeType === 1 ? (i = new Range(), i.selectNodeContents(s)) : i.collapsed && (i = new Range(), i.selectNodeContents(o));
    let l = this.document.createElement("a");
    return l.setAttribute("ref", "epubjs-mk"), l.style.position = "absolute", l.dataset.epubcfi = e, n && Object.keys(n).forEach((u) => {
      l.dataset[u] = n[u];
    }), r && (l.addEventListener("click", r), l.addEventListener("touchstart", r)), l.addEventListener("click", a), l.addEventListener("touchstart", a), this.placeMark(l, i), this.element.appendChild(l), this.marks[e] = { element: l, range: i, listeners: [a, r] }, o;
  }
  placeMark(e, n) {
    let r, i, s;
    if (this.layout.name === "pre-paginated" || this.settings.axis !== "horizontal") {
      let a = n.getBoundingClientRect();
      r = a.top, i = a.right;
    } else {
      let a = n.getClientRects(), l;
      for (var o = 0; o != a.length; o++)
        l = a[o], (!s || l.left < s) && (s = l.left, i = Math.ceil(s / this.layout.props.pageWidth) * this.layout.props.pageWidth - this.layout.gap / 2, r = l.top);
    }
    e.style.top = `${r}px`, e.style.left = `${i}px`;
  }
  unhighlight(e) {
    let n;
    e in this.highlights && (n = this.highlights[e], this.pane.removeMark(n.mark), n.listeners.forEach((r) => {
      r && (n.element.removeEventListener("click", r), n.element.removeEventListener("touchstart", r));
    }), delete this.highlights[e]);
  }
  ununderline(e) {
    let n;
    e in this.underlines && (n = this.underlines[e], this.pane.removeMark(n.mark), n.listeners.forEach((r) => {
      r && (n.element.removeEventListener("click", r), n.element.removeEventListener("touchstart", r));
    }), delete this.underlines[e]);
  }
  unmark(e) {
    let n;
    e in this.marks && (n = this.marks[e], this.element.removeChild(n.element), n.listeners.forEach((r) => {
      r && (n.element.removeEventListener("click", r), n.element.removeEventListener("touchstart", r));
    }), delete this.marks[e]);
  }
  destroy() {
    for (let e in this.highlights)
      this.unhighlight(e);
    for (let e in this.underlines)
      this.ununderline(e);
    for (let e in this.marks)
      this.unmark(e);
    this.blobUrl && j0(this.blobUrl), this.displayed && (this.displayed = !1, this.removeListeners(), this.contents.destroy(), this.stopExpanding = !0, this.element.removeChild(this.iframe), this.pane && (this.pane.element.remove(), this.pane = void 0), this.iframe = void 0, this.contents = void 0, this._textWidth = null, this._textHeight = null, this._width = null, this._height = null);
  }
}
Vr(rb.prototype);
function z6() {
  var t = "reverse", e = j6();
  return document.body.appendChild(e), e.scrollLeft > 0 ? t = "default" : typeof Element < "u" && Element.prototype.scrollIntoView ? (e.children[0].children[1].scrollIntoView(), e.scrollLeft < 0 && (t = "negative")) : (e.scrollLeft = 1, e.scrollLeft === 0 && (t = "negative")), document.body.removeChild(e), t;
}
function j6() {
  var t = document.createElement("div");
  t.dir = "rtl", t.style.position = "fixed", t.style.width = "1px", t.style.height = "1px", t.style.top = "0px", t.style.left = "0px", t.style.overflow = "hidden";
  var e = document.createElement("div");
  e.style.width = "2px";
  var n = document.createElement("span");
  n.style.width = "1px", n.style.display = "inline-block";
  var r = document.createElement("span");
  return r.style.width = "1px", r.style.display = "inline-block", e.appendChild(n), e.appendChild(r), t.appendChild(e), t;
}
function F6(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var Jf = F6, H6 = typeof yn == "object" && yn && yn.Object === Object && yn, U6 = H6, V6 = U6, W6 = typeof self == "object" && self && self.Object === Object && self, $6 = V6 || W6 || Function("return this")(), ib = $6, K6 = ib, G6 = function() {
  return K6.Date.now();
}, q6 = G6, J6 = /\s/;
function Y6(t) {
  for (var e = t.length; e-- && J6.test(t.charAt(e)); )
    ;
  return e;
}
var Q6 = Y6, Z6 = Q6, X6 = /^\s+/;
function eM(t) {
  return t && t.slice(0, Z6(t) + 1).replace(X6, "");
}
var tM = eM, nM = ib, rM = nM.Symbol, sb = rM, Av = sb, ob = Object.prototype, iM = ob.hasOwnProperty, sM = ob.toString, fo = Av ? Av.toStringTag : void 0;
function oM(t) {
  var e = iM.call(t, fo), n = t[fo];
  try {
    t[fo] = void 0;
    var r = !0;
  } catch {
  }
  var i = sM.call(t);
  return r && (e ? t[fo] = n : delete t[fo]), i;
}
var aM = oM, lM = Object.prototype, uM = lM.toString;
function cM(t) {
  return uM.call(t);
}
var dM = cM, kv = sb, fM = aM, hM = dM, pM = "[object Null]", vM = "[object Undefined]", Cv = kv ? kv.toStringTag : void 0;
function gM(t) {
  return t == null ? t === void 0 ? vM : pM : Cv && Cv in Object(t) ? fM(t) : hM(t);
}
var mM = gM;
function yM(t) {
  return t != null && typeof t == "object";
}
var bM = yM, wM = mM, _M = bM, SM = "[object Symbol]";
function EM(t) {
  return typeof t == "symbol" || _M(t) && wM(t) == SM;
}
var xM = EM, AM = tM, Tv = Jf, kM = xM, Ov = 0 / 0, CM = /^[-+]0x[0-9a-f]+$/i, TM = /^0b[01]+$/i, OM = /^0o[0-7]+$/i, IM = parseInt;
function NM(t) {
  if (typeof t == "number")
    return t;
  if (kM(t))
    return Ov;
  if (Tv(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = Tv(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = AM(t);
  var n = TM.test(t);
  return n || OM.test(t) ? IM(t.slice(2), n ? 2 : 8) : CM.test(t) ? Ov : +t;
}
var RM = NM, PM = Jf, sc = q6, Iv = RM, DM = "Expected a function", BM = Math.max, MM = Math.min;
function LM(t, e, n) {
  var r, i, s, o, a, l, u = 0, c = !1, d = !1, h = !0;
  if (typeof t != "function")
    throw new TypeError(DM);
  e = Iv(e) || 0, PM(n) && (c = !!n.leading, d = "maxWait" in n, s = d ? BM(Iv(n.maxWait) || 0, e) : s, h = "trailing" in n ? !!n.trailing : h);
  function v(S) {
    var A = r, C = i;
    return r = i = void 0, u = S, o = t.apply(C, A), o;
  }
  function m(S) {
    return u = S, a = setTimeout(f, e), c ? v(S) : o;
  }
  function b(S) {
    var A = S - l, C = S - u, k = e - A;
    return d ? MM(k, s - C) : k;
  }
  function p(S) {
    var A = S - l, C = S - u;
    return l === void 0 || A >= e || A < 0 || d && C >= s;
  }
  function f() {
    var S = sc();
    if (p(S))
      return g(S);
    a = setTimeout(f, b(S));
  }
  function g(S) {
    return a = void 0, h && r ? v(S) : (r = i = void 0, o);
  }
  function y() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = i = a = void 0;
  }
  function w() {
    return a === void 0 ? o : g(sc());
  }
  function _() {
    var S = sc(), A = p(S);
    if (r = arguments, i = this, l = S, A) {
      if (a === void 0)
        return m(l);
      if (d)
        return clearTimeout(a), a = setTimeout(f, e), v(l);
    }
    return a === void 0 && (a = setTimeout(f, e)), o;
  }
  return _.cancel = y, _.flush = w, _;
}
var ab = LM, zM = ab, jM = Jf, FM = "Expected a function";
function HM(t, e, n) {
  var r = !0, i = !0;
  if (typeof t != "function")
    throw new TypeError(FM);
  return jM(n) && (r = "leading" in n ? !!n.leading : r, i = "trailing" in n ? !!n.trailing : i), zM(t, e, {
    leading: r,
    maxWait: e,
    trailing: i
  });
}
var UM = HM;
class VM {
  constructor(e) {
    this.settings = e || {}, this.id = "epubjs-container-" + mu(), this.container = this.create(this.settings), this.settings.hidden && (this.wrapper = this.wrap(this.container));
  }
  /*
  * Creates an element to render to.
  * Resizes to passed width and height or to the elements size
  */
  create(e) {
    let n = e.height, r = e.width, i = e.overflow || !1, s = e.axis || "vertical", o = e.direction;
    En(this.settings, e), e.height && Yt(e.height) && (n = e.height + "px"), e.width && Yt(e.width) && (r = e.width + "px");
    let a = document.createElement("div");
    return a.id = this.id, a.classList.add("epub-container"), a.style.wordSpacing = "0", a.style.lineHeight = "0", a.style.verticalAlign = "top", a.style.position = "relative", s === "horizontal" && (a.style.display = "flex", a.style.flexDirection = "row", a.style.flexWrap = "nowrap"), r && (a.style.width = r), n && (a.style.height = n), i && (i === "scroll" && s === "vertical" ? (a.style["overflow-y"] = i, a.style["overflow-x"] = "hidden") : i === "scroll" && s === "horizontal" ? (a.style["overflow-y"] = "hidden", a.style["overflow-x"] = i) : a.style.overflow = i), o && (a.dir = o, a.style.direction = o), o && this.settings.fullsize && (document.body.style.direction = o), a;
  }
  wrap(e) {
    var n = document.createElement("div");
    return n.style.visibility = "hidden", n.style.overflow = "hidden", n.style.width = "0", n.style.height = "0", n.appendChild(e), n;
  }
  getElement(e) {
    var n;
    if (D0(e) ? n = e : typeof e == "string" && (n = document.getElementById(e)), !n)
      throw new Error("Not an Element");
    return n;
  }
  attachTo(e) {
    var n = this.getElement(e), r;
    if (n)
      return this.settings.hidden ? r = this.wrapper : r = this.container, n.appendChild(r), this.element = n, n;
  }
  getContainer() {
    return this.container;
  }
  onResize(e) {
    (!Yt(this.settings.width) || !Yt(this.settings.height)) && (this.resizeFunc = UM(e, 50), window.addEventListener("resize", this.resizeFunc, !1));
  }
  onOrientationChange(e) {
    this.orientationChangeFunc = e, window.addEventListener("orientationchange", this.orientationChangeFunc, !1);
  }
  size(e, n) {
    var r;
    let i = e || this.settings.width, s = n || this.settings.height;
    e === null ? (r = this.element.getBoundingClientRect(), r.width && (e = Math.floor(r.width), this.container.style.width = e + "px")) : Yt(e) ? this.container.style.width = e + "px" : this.container.style.width = e, n === null ? (r = r || this.element.getBoundingClientRect(), r.height && (n = r.height, this.container.style.height = n + "px")) : Yt(n) ? this.container.style.height = n + "px" : this.container.style.height = n, Yt(e) || (e = this.container.clientWidth), Yt(n) || (n = this.container.clientHeight), this.containerStyles = window.getComputedStyle(this.container), this.containerPadding = {
      left: parseFloat(this.containerStyles["padding-left"]) || 0,
      right: parseFloat(this.containerStyles["padding-right"]) || 0,
      top: parseFloat(this.containerStyles["padding-top"]) || 0,
      bottom: parseFloat(this.containerStyles["padding-bottom"]) || 0
    };
    let o = Hl(), a = window.getComputedStyle(document.body), l = {
      left: parseFloat(a["padding-left"]) || 0,
      right: parseFloat(a["padding-right"]) || 0,
      top: parseFloat(a["padding-top"]) || 0,
      bottom: parseFloat(a["padding-bottom"]) || 0
    };
    return i || (e = o.width - l.left - l.right), (this.settings.fullsize && !s || !s) && (n = o.height - l.top - l.bottom), {
      width: e - this.containerPadding.left - this.containerPadding.right,
      height: n - this.containerPadding.top - this.containerPadding.bottom
    };
  }
  bounds() {
    let e;
    return this.container.style.overflow !== "visible" && (e = this.container && this.container.getBoundingClientRect()), !e || !e.width || !e.height ? Hl() : e;
  }
  getSheet() {
    var e = document.createElement("style");
    return e.appendChild(document.createTextNode("")), document.head.appendChild(e), e.sheet;
  }
  addStyleRules(e, n) {
    var r = "#" + this.id + " ", i = "";
    this.sheet || (this.sheet = this.getSheet()), n.forEach(function(s) {
      for (var o in s)
        s.hasOwnProperty(o) && (i += o + ":" + s[o] + ";");
    }), this.sheet.insertRule(r + e + " {" + i + "}", 0);
  }
  axis(e) {
    e === "horizontal" ? (this.container.style.display = "flex", this.container.style.flexDirection = "row", this.container.style.flexWrap = "nowrap") : this.container.style.display = "block", this.settings.axis = e;
  }
  // orientation(orientation) {
  // 	if (orientation === "landscape") {
  //
  // 	} else {
  //
  // 	}
  //
  // 	this.orientation = orientation;
  // }
  direction(e) {
    this.container && (this.container.dir = e, this.container.style.direction = e), this.settings.fullsize && (document.body.style.direction = e), this.settings.dir = e;
  }
  overflow(e) {
    this.container && (e === "scroll" && this.settings.axis === "vertical" ? (this.container.style["overflow-y"] = e, this.container.style["overflow-x"] = "hidden") : e === "scroll" && this.settings.axis === "horizontal" ? (this.container.style["overflow-y"] = "hidden", this.container.style["overflow-x"] = e) : this.container.style.overflow = e), this.settings.overflow = e;
  }
  destroy() {
    this.element && (this.settings.hidden ? this.wrapper : this.container, this.element.contains(this.container) && this.element.removeChild(this.container), window.removeEventListener("resize", this.resizeFunc), window.removeEventListener("orientationChange", this.orientationChangeFunc));
  }
}
class WM {
  constructor(e) {
    this.container = e, this._views = [], this.length = 0, this.hidden = !1;
  }
  all() {
    return this._views;
  }
  first() {
    return this._views[0];
  }
  last() {
    return this._views[this._views.length - 1];
  }
  indexOf(e) {
    return this._views.indexOf(e);
  }
  slice() {
    return this._views.slice.apply(this._views, arguments);
  }
  get(e) {
    return this._views[e];
  }
  append(e) {
    return this._views.push(e), this.container && this.container.appendChild(e.element), this.length++, e;
  }
  prepend(e) {
    return this._views.unshift(e), this.container && this.container.insertBefore(e.element, this.container.firstChild), this.length++, e;
  }
  insert(e, n) {
    return this._views.splice(n, 0, e), this.container && (n < this.container.children.length ? this.container.insertBefore(e.element, this.container.children[n]) : this.container.appendChild(e.element)), this.length++, e;
  }
  remove(e) {
    var n = this._views.indexOf(e);
    n > -1 && this._views.splice(n, 1), this.destroy(e), this.length--;
  }
  destroy(e) {
    e.displayed && e.destroy(), this.container && this.container.removeChild(e.element), e = null;
  }
  // Iterators
  forEach() {
    return this._views.forEach.apply(this._views, arguments);
  }
  clear() {
    var e, n = this.length;
    if (this.length) {
      for (var r = 0; r < n; r++)
        e = this._views[r], this.destroy(e);
      this._views = [], this.length = 0;
    }
  }
  find(e) {
    for (var n, r = this.length, i = 0; i < r; i++)
      if (n = this._views[i], n.displayed && n.section.index == e.index)
        return n;
  }
  displayed() {
    for (var e = [], n, r = this.length, i = 0; i < r; i++)
      n = this._views[i], n.displayed && e.push(n);
    return e;
  }
  show() {
    for (var e, n = this.length, r = 0; r < n; r++)
      e = this._views[r], e.displayed && e.show();
    this.hidden = !1;
  }
  hide() {
    for (var e, n = this.length, r = 0; r < n; r++)
      e = this._views[r], e.displayed && e.hide();
    this.hidden = !0;
  }
}
class Gl {
  constructor(e) {
    this.name = "default", this.optsSettings = e.settings, this.View = e.view, this.request = e.request, this.renditionQueue = e.queue, this.q = new Kf(this), this.settings = En(this.settings || {}, {
      infinite: !0,
      hidden: !1,
      width: void 0,
      height: void 0,
      axis: void 0,
      writingMode: void 0,
      flow: "scrolled",
      ignoreClass: "",
      fullsize: void 0,
      allowScriptedContent: !1,
      allowPopups: !1
    }), En(this.settings, e.settings || {}), this.viewSettings = {
      ignoreClass: this.settings.ignoreClass,
      axis: this.settings.axis,
      flow: this.settings.flow,
      layout: this.layout,
      method: this.settings.method,
      // srcdoc, blobUrl, write
      width: 0,
      height: 0,
      forceEvenPages: !0,
      allowScriptedContent: this.settings.allowScriptedContent,
      allowPopups: this.settings.allowPopups
    }, this.rendered = !1;
  }
  render(e, n) {
    let r = e.tagName;
    typeof this.settings.fullsize > "u" && r && (r.toLowerCase() == "body" || r.toLowerCase() == "html") && (this.settings.fullsize = !0), this.settings.fullsize && (this.settings.overflow = "visible", this.overflow = this.settings.overflow), this.settings.size = n, this.settings.rtlScrollType = z6(), this.stage = new VM({
      width: n.width,
      height: n.height,
      overflow: this.overflow,
      hidden: this.settings.hidden,
      axis: this.settings.axis,
      fullsize: this.settings.fullsize,
      direction: this.settings.direction
    }), this.stage.attachTo(e), this.container = this.stage.getContainer(), this.views = new WM(this.container), this._bounds = this.bounds(), this._stageSize = this.stage.size(), this.viewSettings.width = this._stageSize.width, this.viewSettings.height = this._stageSize.height, this.stage.onResize(this.onResized.bind(this)), this.stage.onOrientationChange(this.onOrientationChange.bind(this)), this.addEventListeners(), this.layout && this.updateLayout(), this.rendered = !0;
  }
  addEventListeners() {
    var e;
    window.addEventListener("unload", function(n) {
      this.destroy();
    }.bind(this)), this.settings.fullsize ? e = window : e = this.container, this._onScroll = this.onScroll.bind(this), e.addEventListener("scroll", this._onScroll);
  }
  removeEventListeners() {
    var e;
    this.settings.fullsize ? e = window : e = this.container, e.removeEventListener("scroll", this._onScroll), this._onScroll = void 0;
  }
  destroy() {
    clearTimeout(this.orientationTimeout), clearTimeout(this.resizeTimeout), clearTimeout(this.afterScrolled), this.clear(), this.removeEventListeners(), this.stage.destroy(), this.rendered = !1;
  }
  onOrientationChange(e) {
    let { orientation: n } = window;
    this.optsSettings.resizeOnOrientationChange && this.resize(), clearTimeout(this.orientationTimeout), this.orientationTimeout = setTimeout(function() {
      this.orientationTimeout = void 0, this.optsSettings.resizeOnOrientationChange && this.resize(), this.emit(Re.MANAGERS.ORIENTATION_CHANGE, n);
    }.bind(this), 500);
  }
  onResized(e) {
    this.resize();
  }
  resize(e, n, r) {
    let i = this.stage.size(e, n);
    if (this.winBounds = Hl(), this.orientationTimeout && this.winBounds.width === this.winBounds.height) {
      this._stageSize = void 0;
      return;
    }
    this._stageSize && this._stageSize.width === i.width && this._stageSize.height === i.height || (this._stageSize = i, this._bounds = this.bounds(), this.clear(), this.viewSettings.width = this._stageSize.width, this.viewSettings.height = this._stageSize.height, this.updateLayout(), this.emit(Re.MANAGERS.RESIZED, {
      width: this._stageSize.width,
      height: this._stageSize.height
    }, r));
  }
  createView(e, n) {
    return new this.View(e, En(this.viewSettings, { forceRight: n }));
  }
  handleNextPrePaginated(e, n, r) {
    let i;
    if (this.layout.name === "pre-paginated" && this.layout.divisor > 1) {
      if (e || n.index === 0)
        return;
      if (i = n.next(), i && !i.properties.includes("page-spread-left"))
        return r.call(this, i);
    }
  }
  display(e, n) {
    var r = new vt(), i = r.promise;
    (n === e.href || Yt(n)) && (n = void 0);
    var s = this.views.find(e);
    if (s && e && this.layout.name !== "pre-paginated") {
      let a = s.offset();
      if (this.settings.direction === "ltr")
        this.scrollTo(a.left, a.top, !0);
      else {
        let l = s.width();
        this.scrollTo(a.left + l, a.top, !0);
      }
      if (n) {
        let l = s.locationOf(n), u = s.width();
        this.moveTo(l, u);
      }
      return r.resolve(), i;
    }
    this.clear();
    let o = !1;
    return this.layout.name === "pre-paginated" && this.layout.divisor === 2 && e.properties.includes("page-spread-right") && (o = !0), this.add(e, o).then(function(a) {
      if (n) {
        let l = a.locationOf(n), u = a.width();
        this.moveTo(l, u);
      }
    }.bind(this), (a) => {
      r.reject(a);
    }).then(function() {
      return this.handleNextPrePaginated(o, e, this.add);
    }.bind(this)).then(function() {
      this.views.show(), r.resolve();
    }.bind(this)), i;
  }
  afterDisplayed(e) {
    this.emit(Re.MANAGERS.ADDED, e);
  }
  afterResized(e) {
    this.emit(Re.MANAGERS.RESIZE, e.section);
  }
  moveTo(e, n) {
    var r = 0, i = 0;
    this.isPaginated ? (r = Math.floor(e.left / this.layout.delta) * this.layout.delta, r + this.layout.delta > this.container.scrollWidth && (r = this.container.scrollWidth - this.layout.delta), i = Math.floor(e.top / this.layout.delta) * this.layout.delta, i + this.layout.delta > this.container.scrollHeight && (i = this.container.scrollHeight - this.layout.delta)) : i = e.top, this.settings.direction === "rtl" && (r = r + this.layout.delta, r = r - n), this.scrollTo(r, i, !0);
  }
  add(e, n) {
    var r = this.createView(e, n);
    return this.views.append(r), r.onDisplayed = this.afterDisplayed.bind(this), r.onResize = this.afterResized.bind(this), r.on(Re.VIEWS.AXIS, (i) => {
      this.updateAxis(i);
    }), r.on(Re.VIEWS.WRITING_MODE, (i) => {
      this.updateWritingMode(i);
    }), r.display(this.request);
  }
  append(e, n) {
    var r = this.createView(e, n);
    return this.views.append(r), r.onDisplayed = this.afterDisplayed.bind(this), r.onResize = this.afterResized.bind(this), r.on(Re.VIEWS.AXIS, (i) => {
      this.updateAxis(i);
    }), r.on(Re.VIEWS.WRITING_MODE, (i) => {
      this.updateWritingMode(i);
    }), r.display(this.request);
  }
  prepend(e, n) {
    var r = this.createView(e, n);
    return r.on(Re.VIEWS.RESIZED, (i) => {
      this.counter(i);
    }), this.views.prepend(r), r.onDisplayed = this.afterDisplayed.bind(this), r.onResize = this.afterResized.bind(this), r.on(Re.VIEWS.AXIS, (i) => {
      this.updateAxis(i);
    }), r.on(Re.VIEWS.WRITING_MODE, (i) => {
      this.updateWritingMode(i);
    }), r.display(this.request);
  }
  counter(e) {
    this.settings.axis === "vertical" ? this.scrollBy(0, e.heightDelta, !0) : this.scrollBy(e.widthDelta, 0, !0);
  }
  // resizeView(view) {
  //
  // 	if(this.settings.globalLayoutProperties.layout === "pre-paginated") {
  // 		view.lock("both", this.bounds.width, this.bounds.height);
  // 	} else {
  // 		view.lock("width", this.bounds.width, this.bounds.height);
  // 	}
  //
  // };
  next() {
    var e, n;
    let r = this.settings.direction;
    if (this.views.length && (this.isPaginated && this.settings.axis === "horizontal" && (!r || r === "ltr") ? (this.scrollLeft = this.container.scrollLeft, n = this.container.scrollLeft + this.container.offsetWidth + this.layout.delta, n <= this.container.scrollWidth ? this.scrollBy(this.layout.delta, 0, !0) : e = this.views.last().section.next()) : this.isPaginated && this.settings.axis === "horizontal" && r === "rtl" ? (this.scrollLeft = this.container.scrollLeft, this.settings.rtlScrollType === "default" ? (n = this.container.scrollLeft, n > 0 ? this.scrollBy(this.layout.delta, 0, !0) : e = this.views.last().section.next()) : (n = this.container.scrollLeft + this.layout.delta * -1, n > this.container.scrollWidth * -1 ? this.scrollBy(this.layout.delta, 0, !0) : e = this.views.last().section.next())) : this.isPaginated && this.settings.axis === "vertical" ? (this.scrollTop = this.container.scrollTop, this.container.scrollTop + this.container.offsetHeight < this.container.scrollHeight ? this.scrollBy(0, this.layout.height, !0) : e = this.views.last().section.next()) : e = this.views.last().section.next(), e)) {
      this.clear(), this.updateLayout();
      let i = !1;
      return this.layout.name === "pre-paginated" && this.layout.divisor === 2 && e.properties.includes("page-spread-right") && (i = !0), this.append(e, i).then(function() {
        return this.handleNextPrePaginated(i, e, this.append);
      }.bind(this), (s) => s).then(function() {
        !this.isPaginated && this.settings.axis === "horizontal" && this.settings.direction === "rtl" && this.settings.rtlScrollType === "default" && this.scrollTo(this.container.scrollWidth, 0, !0), this.views.show();
      }.bind(this));
    }
  }
  prev() {
    var e, n;
    let r = this.settings.direction;
    if (this.views.length && (this.isPaginated && this.settings.axis === "horizontal" && (!r || r === "ltr") ? (this.scrollLeft = this.container.scrollLeft, n = this.container.scrollLeft, n > 0 ? this.scrollBy(-this.layout.delta, 0, !0) : e = this.views.first().section.prev()) : this.isPaginated && this.settings.axis === "horizontal" && r === "rtl" ? (this.scrollLeft = this.container.scrollLeft, this.settings.rtlScrollType === "default" ? (n = this.container.scrollLeft + this.container.offsetWidth, n < this.container.scrollWidth ? this.scrollBy(-this.layout.delta, 0, !0) : e = this.views.first().section.prev()) : (n = this.container.scrollLeft, n < 0 ? this.scrollBy(-this.layout.delta, 0, !0) : e = this.views.first().section.prev())) : this.isPaginated && this.settings.axis === "vertical" ? (this.scrollTop = this.container.scrollTop, this.container.scrollTop > 0 ? this.scrollBy(0, -this.layout.height, !0) : e = this.views.first().section.prev()) : e = this.views.first().section.prev(), e)) {
      this.clear(), this.updateLayout();
      let i = !1;
      return this.layout.name === "pre-paginated" && this.layout.divisor === 2 && typeof e.prev() != "object" && (i = !0), this.prepend(e, i).then(function() {
        var s;
        if (this.layout.name === "pre-paginated" && this.layout.divisor > 1 && (s = e.prev(), s))
          return this.prepend(s);
      }.bind(this), (s) => s).then(function() {
        this.isPaginated && this.settings.axis === "horizontal" && (this.settings.direction === "rtl" ? this.settings.rtlScrollType === "default" ? this.scrollTo(0, 0, !0) : this.scrollTo(this.container.scrollWidth * -1 + this.layout.delta, 0, !0) : this.scrollTo(this.container.scrollWidth - this.layout.delta, 0, !0)), this.views.show();
      }.bind(this));
    }
  }
  current() {
    var e = this.visible();
    return e.length ? e[e.length - 1] : null;
  }
  clear() {
    this.views && (this.views.hide(), this.scrollTo(0, 0, !0), this.views.clear());
  }
  currentLocation() {
    return this.updateLayout(), this.isPaginated && this.settings.axis === "horizontal" ? this.location = this.paginatedLocation() : this.location = this.scrolledLocation(), this.location;
  }
  scrolledLocation() {
    let e = this.visible(), n = this.container.getBoundingClientRect(), r = n.height < window.innerHeight ? n.height : window.innerHeight, i = n.width < window.innerWidth ? n.width : window.innerWidth, s = this.settings.axis === "vertical";
    this.settings.direction;
    let o = 0, a = 0;
    return this.settings.fullsize && (o = s ? window.scrollY : window.scrollX), e.map((u) => {
      let { index: c, href: d } = u.section, h = u.position(), v = u.width(), m = u.height(), b, p, f, g;
      s ? (b = o + n.top - h.top + a, p = b + r - a, g = this.layout.count(m, r).pages, f = r) : (b = o + n.left - h.left + a, p = b + i - a, g = this.layout.count(v, i).pages, f = i);
      let y = Math.ceil(b / f), w = [], _ = Math.ceil(p / f);
      if (this.settings.direction === "rtl" && !s) {
        let C = y;
        y = g - _, _ = g - C;
      }
      w = [];
      for (var S = y; S <= _; S++) {
        let C = S + 1;
        w.push(C);
      }
      let A = this.mapping.page(u.contents, u.section.cfiBase, b, p);
      return {
        index: c,
        href: d,
        pages: w,
        totalPages: g,
        mapping: A
      };
    });
  }
  paginatedLocation() {
    let e = this.visible(), n = this.container.getBoundingClientRect(), r = 0, i = 0;
    return this.settings.fullsize && (r = window.scrollX), e.map((o) => {
      let { index: a, href: l } = o.section, u, c = o.position(), d = o.width(), h, v, m;
      this.settings.direction === "rtl" ? (u = n.right - r, m = Math.min(Math.abs(u - c.left), this.layout.width) - i, v = c.width - (c.right - u) - i, h = v - m) : (u = n.left + r, m = Math.min(c.right - u, this.layout.width) - i, h = u - c.left + i, v = h + m), i += m;
      let b = this.mapping.page(o.contents, o.section.cfiBase, h, v), p = this.layout.count(d).pages, f = Math.floor(h / this.layout.pageWidth), g = [], y = Math.floor(v / this.layout.pageWidth);
      if (f < 0 && (f = 0, y = y + 1), this.settings.direction === "rtl") {
        let _ = f;
        f = p - y, y = p - _;
      }
      for (var w = f + 1; w <= y; w++) {
        let _ = w;
        g.push(_);
      }
      return {
        index: a,
        href: l,
        pages: g,
        totalPages: p,
        mapping: b
      };
    });
  }
  isVisible(e, n, r, i) {
    var s = e.position(), o = i || this.bounds();
    return this.settings.axis === "horizontal" && s.right > o.left - n && s.left < o.right + r ? !0 : this.settings.axis === "vertical" && s.bottom > o.top - n && s.top < o.bottom + r;
  }
  visible() {
    for (var e = this.bounds(), n = this.views.displayed(), r = n.length, i = [], s, o, a = 0; a < r; a++)
      o = n[a], s = this.isVisible(o, 0, 0, e), s === !0 && i.push(o);
    return i;
  }
  scrollBy(e, n, r) {
    let i = this.settings.direction === "rtl" ? -1 : 1;
    r && (this.ignore = !0), this.settings.fullsize ? window.scrollBy(e * i, n * i) : (e && (this.container.scrollLeft += e * i), n && (this.container.scrollTop += n)), this.scrolled = !0;
  }
  scrollTo(e, n, r) {
    r && (this.ignore = !0), this.settings.fullsize ? window.scrollTo(e, n) : (this.container.scrollLeft = e, this.container.scrollTop = n), this.scrolled = !0;
  }
  onScroll() {
    let e, n;
    this.settings.fullsize ? (e = window.scrollY, n = window.scrollX) : (e = this.container.scrollTop, n = this.container.scrollLeft), this.scrollTop = e, this.scrollLeft = n, this.ignore ? this.ignore = !1 : (this.emit(Re.MANAGERS.SCROLL, {
      top: e,
      left: n
    }), clearTimeout(this.afterScrolled), this.afterScrolled = setTimeout(function() {
      this.emit(Re.MANAGERS.SCROLLED, {
        top: this.scrollTop,
        left: this.scrollLeft
      });
    }.bind(this), 20));
  }
  bounds() {
    var e;
    return e = this.stage.bounds(), e;
  }
  applyLayout(e) {
    this.layout = e, this.updateLayout(), this.views && this.views.length > 0 && this.layout.name === "pre-paginated" && this.display(this.views.first().section);
  }
  updateLayout() {
    this.stage && (this._stageSize = this.stage.size(), this.isPaginated ? (this.layout.calculate(
      this._stageSize.width,
      this._stageSize.height,
      this.settings.gap
    ), this.settings.offset = this.layout.delta / this.layout.divisor) : this.layout.calculate(this._stageSize.width, this._stageSize.height), this.viewSettings.width = this.layout.width, this.viewSettings.height = this.layout.height, this.setLayout(this.layout));
  }
  setLayout(e) {
    this.viewSettings.layout = e, this.mapping = new $l(e.props, this.settings.direction, this.settings.axis), this.views && this.views.forEach(function(n) {
      n && n.setLayout(e);
    });
  }
  updateWritingMode(e) {
    this.writingMode = e;
  }
  updateAxis(e, n) {
    !n && e === this.settings.axis || (this.settings.axis = e, this.stage && this.stage.axis(e), this.viewSettings.axis = e, this.mapping && (this.mapping = new $l(this.layout.props, this.settings.direction, this.settings.axis)), this.layout && (e === "vertical" ? this.layout.spread("none") : this.layout.spread(this.layout.settings.spread)));
  }
  updateFlow(e, n = "auto") {
    let r = e === "paginated" || e === "auto";
    this.isPaginated = r, e === "scrolled-doc" || e === "scrolled-continuous" || e === "scrolled" ? this.updateAxis("vertical") : this.updateAxis("horizontal"), this.viewSettings.flow = e, this.settings.overflow ? this.overflow = this.settings.overflow : this.overflow = r ? "hidden" : n, this.stage && this.stage.overflow(this.overflow), this.updateLayout();
  }
  getContents() {
    var e = [];
    return this.views && this.views.forEach(function(n) {
      const r = n && n.contents;
      r && e.push(r);
    }), e;
  }
  direction(e = "ltr") {
    this.settings.direction = e, this.stage && this.stage.direction(e), this.viewSettings.direction = e, this.updateLayout();
  }
  isRendered() {
    return this.rendered;
  }
}
Vr(Gl.prototype);
const $M = Math.PI / 2, KM = {
  easeOutSine: function(t) {
    return Math.sin(t * $M);
  },
  easeInOutSine: function(t) {
    return -0.5 * (Math.cos(Math.PI * t) - 1);
  },
  easeInOutQuint: function(t) {
    return (t /= 0.5) < 1 ? 0.5 * Math.pow(t, 5) : 0.5 * (Math.pow(t - 2, 5) + 2);
  },
  easeInCubic: function(t) {
    return Math.pow(t, 3);
  }
};
class _d {
  constructor(e, n) {
    this.settings = En({
      duration: 80,
      minVelocity: 0.2,
      minDistance: 10,
      easing: KM.easeInCubic
    }, n || {}), this.supportsTouch = this.supportsTouch(), this.supportsTouch && this.setup(e);
  }
  setup(e) {
    this.manager = e, this.layout = this.manager.layout, this.fullsize = this.manager.settings.fullsize, this.fullsize ? (this.element = this.manager.stage.element, this.scroller = window, this.disableScroll()) : (this.element = this.manager.stage.container, this.scroller = this.element, this.element.style.WebkitOverflowScrolling = "touch"), this.manager.settings.offset = this.layout.width, this.manager.settings.afterScrolledTimeout = this.settings.duration * 2, this.isVertical = this.manager.settings.axis === "vertical", !(!this.manager.isPaginated || this.isVertical) && (this.touchCanceler = !1, this.resizeCanceler = !1, this.snapping = !1, this.scrollLeft, this.scrollTop, this.startTouchX = void 0, this.startTouchY = void 0, this.startTime = void 0, this.endTouchX = void 0, this.endTouchY = void 0, this.endTime = void 0, this.addListeners());
  }
  supportsTouch() {
    return !!("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch);
  }
  disableScroll() {
    this.element.style.overflow = "hidden";
  }
  enableScroll() {
    this.element.style.overflow = "";
  }
  addListeners() {
    this._onResize = this.onResize.bind(this), window.addEventListener("resize", this._onResize), this._onScroll = this.onScroll.bind(this), this.scroller.addEventListener("scroll", this._onScroll), this._onTouchStart = this.onTouchStart.bind(this), this.scroller.addEventListener("touchstart", this._onTouchStart, { passive: !0 }), this.on("touchstart", this._onTouchStart), this._onTouchMove = this.onTouchMove.bind(this), this.scroller.addEventListener("touchmove", this._onTouchMove, { passive: !0 }), this.on("touchmove", this._onTouchMove), this._onTouchEnd = this.onTouchEnd.bind(this), this.scroller.addEventListener("touchend", this._onTouchEnd, { passive: !0 }), this.on("touchend", this._onTouchEnd), this._afterDisplayed = this.afterDisplayed.bind(this), this.manager.on(Re.MANAGERS.ADDED, this._afterDisplayed);
  }
  removeListeners() {
    window.removeEventListener("resize", this._onResize), this._onResize = void 0, this.scroller.removeEventListener("scroll", this._onScroll), this._onScroll = void 0, this.scroller.removeEventListener("touchstart", this._onTouchStart, { passive: !0 }), this.off("touchstart", this._onTouchStart), this._onTouchStart = void 0, this.scroller.removeEventListener("touchmove", this._onTouchMove, { passive: !0 }), this.off("touchmove", this._onTouchMove), this._onTouchMove = void 0, this.scroller.removeEventListener("touchend", this._onTouchEnd, { passive: !0 }), this.off("touchend", this._onTouchEnd), this._onTouchEnd = void 0, this.manager.off(Re.MANAGERS.ADDED, this._afterDisplayed), this._afterDisplayed = void 0;
  }
  afterDisplayed(e) {
    let n = e.contents;
    ["touchstart", "touchmove", "touchend"].forEach((r) => {
      n.on(r, (i) => this.triggerViewEvent(i, n));
    });
  }
  triggerViewEvent(e, n) {
    this.emit(e.type, e, n);
  }
  onScroll(e) {
    this.scrollLeft = this.fullsize ? window.scrollX : this.scroller.scrollLeft, this.scrollTop = this.fullsize ? window.scrollY : this.scroller.scrollTop;
  }
  onResize(e) {
    this.resizeCanceler = !0;
  }
  onTouchStart(e) {
    let { screenX: n, screenY: r } = e.touches[0];
    this.fullsize && this.enableScroll(), this.touchCanceler = !0, this.startTouchX || (this.startTouchX = n, this.startTouchY = r, this.startTime = this.now()), this.endTouchX = n, this.endTouchY = r, this.endTime = this.now();
  }
  onTouchMove(e) {
    let { screenX: n, screenY: r } = e.touches[0], i = Math.abs(r - this.endTouchY);
    this.touchCanceler = !0, !this.fullsize && i < 10 && (this.element.scrollLeft -= n - this.endTouchX), this.endTouchX = n, this.endTouchY = r, this.endTime = this.now();
  }
  onTouchEnd(e) {
    this.fullsize && this.disableScroll(), this.touchCanceler = !1;
    let n = this.wasSwiped();
    n !== 0 ? this.snap(n) : this.snap(), this.startTouchX = void 0, this.startTouchY = void 0, this.startTime = void 0, this.endTouchX = void 0, this.endTouchY = void 0, this.endTime = void 0;
  }
  wasSwiped() {
    let e = this.layout.pageWidth * this.layout.divisor, n = this.endTouchX - this.startTouchX, r = Math.abs(n), i = this.endTime - this.startTime, s = n / i, o = this.settings.minVelocity;
    if (r <= this.settings.minDistance || r >= e)
      return 0;
    if (s > o)
      return -1;
    if (s < -o)
      return 1;
  }
  needsSnap() {
    let e = this.scrollLeft, n = this.layout.pageWidth * this.layout.divisor;
    return e % n !== 0;
  }
  snap(e = 0) {
    let n = this.scrollLeft, r = this.layout.pageWidth * this.layout.divisor, i = Math.round(n / r) * r;
    return e && (i += e * r), this.smoothScrollTo(i);
  }
  smoothScrollTo(e) {
    const n = new vt(), r = this.scrollLeft, i = this.now(), s = this.settings.duration, o = this.settings.easing;
    this.snapping = !0;
    function a() {
      const l = this.now(), u = Math.min(1, (l - i) / s);
      if (o(u), this.touchCanceler || this.resizeCanceler) {
        this.resizeCanceler = !1, this.snapping = !1, n.resolve();
        return;
      }
      u < 1 ? (window.requestAnimationFrame(a.bind(this)), this.scrollTo(r + (e - r) * u, 0)) : (this.scrollTo(e, 0), this.snapping = !1, n.resolve());
    }
    return a.call(this), n.promise;
  }
  scrollTo(e = 0, n = 0) {
    this.fullsize ? window.scroll(e, n) : (this.scroller.scrollLeft = e, this.scroller.scrollTop = n);
  }
  now() {
    return "now" in window.performance ? performance.now() : (/* @__PURE__ */ new Date()).getTime();
  }
  destroy() {
    this.scroller && (this.fullsize && this.enableScroll(), this.removeListeners(), this.scroller = void 0);
  }
}
Vr(_d.prototype);
class GM extends Gl {
  constructor(e) {
    super(e), this.name = "continuous", this.settings = En(this.settings || {}, {
      infinite: !0,
      overflow: void 0,
      axis: void 0,
      writingMode: void 0,
      flow: "scrolled",
      offset: 500,
      offsetDelta: 250,
      width: void 0,
      height: void 0,
      snap: !1,
      afterScrolledTimeout: 10,
      allowScriptedContent: !1,
      allowPopups: !1
    }), En(this.settings, e.settings || {}), e.settings.gap != "undefined" && e.settings.gap === 0 && (this.settings.gap = e.settings.gap), this.viewSettings = {
      ignoreClass: this.settings.ignoreClass,
      axis: this.settings.axis,
      flow: this.settings.flow,
      layout: this.layout,
      width: 0,
      height: 0,
      forceEvenPages: !1,
      allowScriptedContent: this.settings.allowScriptedContent,
      allowPopups: this.settings.allowPopups
    }, this.scrollTop = 0, this.scrollLeft = 0;
  }
  display(e, n) {
    return Gl.prototype.display.call(this, e, n).then(function() {
      return this.fill();
    }.bind(this));
  }
  fill(e) {
    var n = e || new vt();
    return this.q.enqueue(() => this.check()).then((r) => {
      r ? this.fill(n) : n.resolve();
    }), n.promise;
  }
  moveTo(e) {
    var n = 0, r = 0;
    this.isPaginated ? (n = Math.floor(e.left / this.layout.delta) * this.layout.delta, n + this.settings.offsetDelta) : (r = e.top, e.top + this.settings.offsetDelta), (n > 0 || r > 0) && this.scrollBy(n, r, !0);
  }
  afterResized(e) {
    this.emit(Re.MANAGERS.RESIZE, e.section);
  }
  // Remove Previous Listeners if present
  removeShownListeners(e) {
    e.onDisplayed = function() {
    };
  }
  add(e) {
    var n = this.createView(e);
    return this.views.append(n), n.on(Re.VIEWS.RESIZED, (r) => {
      n.expanded = !0;
    }), n.on(Re.VIEWS.AXIS, (r) => {
      this.updateAxis(r);
    }), n.on(Re.VIEWS.WRITING_MODE, (r) => {
      this.updateWritingMode(r);
    }), n.onDisplayed = this.afterDisplayed.bind(this), n.onResize = this.afterResized.bind(this), n.display(this.request);
  }
  append(e) {
    var n = this.createView(e);
    return n.on(Re.VIEWS.RESIZED, (r) => {
      n.expanded = !0;
    }), n.on(Re.VIEWS.AXIS, (r) => {
      this.updateAxis(r);
    }), n.on(Re.VIEWS.WRITING_MODE, (r) => {
      this.updateWritingMode(r);
    }), this.views.append(n), n.onDisplayed = this.afterDisplayed.bind(this), n;
  }
  prepend(e) {
    var n = this.createView(e);
    return n.on(Re.VIEWS.RESIZED, (r) => {
      this.counter(r), n.expanded = !0;
    }), n.on(Re.VIEWS.AXIS, (r) => {
      this.updateAxis(r);
    }), n.on(Re.VIEWS.WRITING_MODE, (r) => {
      this.updateWritingMode(r);
    }), this.views.prepend(n), n.onDisplayed = this.afterDisplayed.bind(this), n;
  }
  counter(e) {
    this.settings.axis === "vertical" ? this.scrollBy(0, e.heightDelta, !0) : this.scrollBy(e.widthDelta, 0, !0);
  }
  update(e) {
    for (var n = this.bounds(), r = this.views.all(), i = r.length, s = typeof e < "u" ? e : this.settings.offset || 0, o, a, l = new vt(), u = [], c = 0; c < i; c++)
      if (a = r[c], o = this.isVisible(a, s, s, n), o === !0)
        if (a.displayed)
          a.show();
        else {
          let d = a.display(this.request).then(function(h) {
            h.show();
          }, (h) => {
            a.hide();
          });
          u.push(d);
        }
      else
        this.q.enqueue(a.destroy.bind(a)), clearTimeout(this.trimTimeout), this.trimTimeout = setTimeout(function() {
          this.q.enqueue(this.trim.bind(this));
        }.bind(this), 250);
    return u.length ? Promise.all(u).catch((d) => {
      l.reject(d);
    }) : (l.resolve(), l.promise);
  }
  check(e, n) {
    var r = new vt(), i = [], s = this.settings.axis === "horizontal", o = this.settings.offset || 0;
    e && s && (o = e), n && !s && (o = n);
    var a = this._bounds;
    let l = s ? this.scrollLeft : this.scrollTop, u = s ? Math.floor(a.width) : a.height, c = s ? this.container.scrollWidth : this.container.scrollHeight, d = this.writingMode && this.writingMode.indexOf("vertical") === 0 ? "vertical" : "horizontal", h = this.settings.rtlScrollType, v = this.settings.direction === "rtl";
    this.settings.fullsize ? (s && v && h === "negative" || !s && v && h === "default") && (l = l * -1) : (v && h === "default" && d === "horizontal" && (l = c - u - l), v && h === "negative" && d === "horizontal" && (l = l * -1));
    let m = () => {
      let y = this.views.first(), w = y && y.section.prev();
      w && i.push(this.prepend(w));
    }, b = () => {
      let y = this.views.last(), w = y && y.section.next();
      w && i.push(this.append(w));
    }, p = l + u + o, f = l - o;
    p >= c && b(), f < 0 && m();
    let g = i.map((y) => y.display(this.request));
    return i.length ? Promise.all(g).then(() => this.check()).then(() => this.update(o), (y) => y) : (this.q.enqueue(function() {
      this.update();
    }.bind(this)), r.resolve(!1), r.promise);
  }
  trim() {
    for (var e = new vt(), n = this.views.displayed(), r = n[0], i = n[n.length - 1], s = this.views.indexOf(r), o = this.views.indexOf(i), a = this.views.slice(0, s), l = this.views.slice(o + 1), u = 0; u < a.length - 1; u++)
      this.erase(a[u], a);
    for (var c = 1; c < l.length; c++)
      this.erase(l[c]);
    return e.resolve(), e.promise;
  }
  erase(e, n) {
    var r, i;
    this.settings.fullsize ? (r = window.scrollY, i = window.scrollX) : (r = this.container.scrollTop, i = this.container.scrollLeft);
    var s = e.bounds();
    this.views.remove(e), n && (this.settings.axis === "vertical" ? this.scrollTo(0, r - s.height, !0) : this.settings.direction === "rtl" ? this.settings.fullsize ? this.scrollTo(i + Math.floor(s.width), 0, !0) : this.scrollTo(i, 0, !0) : this.scrollTo(i - Math.floor(s.width), 0, !0));
  }
  addEventListeners(e) {
    window.addEventListener("unload", function(n) {
      this.ignore = !0, this.destroy();
    }.bind(this)), this.addScrollListeners(), this.isPaginated && this.settings.snap && (this.snapper = new _d(this, this.settings.snap && typeof this.settings.snap == "object" && this.settings.snap));
  }
  addScrollListeners() {
    var e;
    this.tick = Vf;
    let n = this.settings.direction === "rtl" && this.settings.rtlScrollType === "default" ? -1 : 1;
    this.scrollDeltaVert = 0, this.scrollDeltaHorz = 0, this.settings.fullsize ? (e = window, this.scrollTop = window.scrollY * n, this.scrollLeft = window.scrollX * n) : (e = this.container, this.scrollTop = this.container.scrollTop, this.scrollLeft = this.container.scrollLeft), this._onScroll = this.onScroll.bind(this), e.addEventListener("scroll", this._onScroll), this._scrolled = ab(this.scrolled.bind(this), 30), this.didScroll = !1;
  }
  removeEventListeners() {
    var e;
    this.settings.fullsize ? e = window : e = this.container, e.removeEventListener("scroll", this._onScroll), this._onScroll = void 0;
  }
  onScroll() {
    let e, n, r = this.settings.direction === "rtl" && this.settings.rtlScrollType === "default" ? -1 : 1;
    this.settings.fullsize ? (e = window.scrollY * r, n = window.scrollX * r) : (e = this.container.scrollTop, n = this.container.scrollLeft), this.scrollTop = e, this.scrollLeft = n, this.ignore ? this.ignore = !1 : this._scrolled(), this.scrollDeltaVert += Math.abs(e - this.prevScrollTop), this.scrollDeltaHorz += Math.abs(n - this.prevScrollLeft), this.prevScrollTop = e, this.prevScrollLeft = n, clearTimeout(this.scrollTimeout), this.scrollTimeout = setTimeout(function() {
      this.scrollDeltaVert = 0, this.scrollDeltaHorz = 0;
    }.bind(this), 150), clearTimeout(this.afterScrolled), this.didScroll = !1;
  }
  scrolled() {
    this.q.enqueue(function() {
      return this.check();
    }.bind(this)), this.emit(Re.MANAGERS.SCROLL, {
      top: this.scrollTop,
      left: this.scrollLeft
    }), clearTimeout(this.afterScrolled), this.afterScrolled = setTimeout(function() {
      this.snapper && this.snapper.supportsTouch && this.snapper.needsSnap() || this.emit(Re.MANAGERS.SCROLLED, {
        top: this.scrollTop,
        left: this.scrollLeft
      });
    }.bind(this), this.settings.afterScrolledTimeout);
  }
  next() {
    let e = this.layout.props.name === "pre-paginated" && this.layout.props.spread ? this.layout.props.delta * 2 : this.layout.props.delta;
    this.views.length && (this.isPaginated && this.settings.axis === "horizontal" ? this.scrollBy(e, 0, !0) : this.scrollBy(0, this.layout.height, !0), this.q.enqueue(function() {
      return this.check();
    }.bind(this)));
  }
  prev() {
    let e = this.layout.props.name === "pre-paginated" && this.layout.props.spread ? this.layout.props.delta * 2 : this.layout.props.delta;
    this.views.length && (this.isPaginated && this.settings.axis === "horizontal" ? this.scrollBy(-e, 0, !0) : this.scrollBy(0, -this.layout.height, !0), this.q.enqueue(function() {
      return this.check();
    }.bind(this)));
  }
  updateFlow(e) {
    this.rendered && this.snapper && (this.snapper.destroy(), this.snapper = void 0), super.updateFlow(e, "scroll"), this.rendered && this.isPaginated && this.settings.snap && (this.snapper = new _d(this, this.settings.snap && typeof this.settings.snap == "object" && this.settings.snap));
  }
  destroy() {
    super.destroy(), this.snapper && this.snapper.destroy();
  }
}
class Yf {
  constructor(e, n) {
    this.settings = En(this.settings || {}, {
      width: null,
      height: null,
      ignoreClass: "",
      manager: "default",
      view: "iframe",
      flow: null,
      layout: null,
      spread: null,
      minSpreadWidth: 800,
      stylesheet: null,
      resizeOnOrientationChange: !0,
      script: null,
      snap: !1,
      defaultDirection: "ltr",
      allowScriptedContent: !1,
      allowPopups: !1
    }), En(this.settings, n), typeof this.settings.manager == "object" && (this.manager = this.settings.manager), this.book = e, this.hooks = {}, this.hooks.display = new gr(this), this.hooks.serialize = new gr(this), this.hooks.content = new gr(this), this.hooks.unloaded = new gr(this), this.hooks.layout = new gr(this), this.hooks.render = new gr(this), this.hooks.show = new gr(this), this.hooks.content.register(this.handleLinks.bind(this)), this.hooks.content.register(this.passEvents.bind(this)), this.hooks.content.register(this.adjustImages.bind(this)), this.book.spine.hooks.content.register(this.injectIdentifier.bind(this)), this.settings.stylesheet && this.book.spine.hooks.content.register(this.injectStylesheet.bind(this)), this.settings.script && this.book.spine.hooks.content.register(this.injectScript.bind(this)), this.themes = new x6(this), this.annotations = new C6(this), this.epubcfi = new gt(), this.q = new Kf(this), this.location = void 0, this.q.enqueue(this.book.opened), this.starting = new vt(), this.started = this.starting.promise, this.q.enqueue(this.start);
  }
  /**
   * Set the manager function
   * @param {function} manager
   */
  setManager(e) {
    this.manager = e;
  }
  /**
   * Require the manager from passed string, or as a class function
   * @param  {string|object} manager [description]
   * @return {method}
   */
  requireManager(e) {
    var n;
    return typeof e == "string" && e === "default" ? n = Gl : typeof e == "string" && e === "continuous" ? n = GM : n = e, n;
  }
  /**
   * Require the view from passed string, or as a class function
   * @param  {string|object} view
   * @return {view}
   */
  requireView(e) {
    var n;
    return typeof e == "string" && e === "iframe" ? n = rb : n = e, n;
  }
  /**
   * Start the rendering
   * @return {Promise} rendering has started
   */
  start() {
    switch (!this.settings.layout && (this.book.package.metadata.layout === "pre-paginated" || this.book.displayOptions.fixedLayout === "true") && (this.settings.layout = "pre-paginated"), this.book.package.metadata.spread) {
      case "none":
        this.settings.spread = "none";
        break;
      case "both":
        this.settings.spread = !0;
        break;
    }
    this.manager || (this.ViewManager = this.requireManager(this.settings.manager), this.View = this.requireView(this.settings.view), this.manager = new this.ViewManager({
      view: this.View,
      queue: this.q,
      request: this.book.load.bind(this.book),
      settings: this.settings
    })), this.direction(this.book.package.metadata.direction || this.settings.defaultDirection), this.settings.globalLayoutProperties = this.determineLayoutProperties(this.book.package.metadata), this.flow(this.settings.globalLayoutProperties.flow), this.layout(this.settings.globalLayoutProperties), this.manager.on(Re.MANAGERS.ADDED, this.afterDisplayed.bind(this)), this.manager.on(Re.MANAGERS.REMOVED, this.afterRemoved.bind(this)), this.manager.on(Re.MANAGERS.RESIZED, this.onResized.bind(this)), this.manager.on(Re.MANAGERS.ORIENTATION_CHANGE, this.onOrientationChange.bind(this)), this.manager.on(Re.MANAGERS.SCROLLED, this.reportLocation.bind(this)), this.emit(Re.RENDITION.STARTED), this.starting.resolve();
  }
  /**
   * Call to attach the container to an element in the dom
   * Container must be attached before rendering can begin
   * @param  {element} element to attach to
   * @return {Promise}
   */
  attachTo(e) {
    return this.q.enqueue(function() {
      this.manager.render(e, {
        width: this.settings.width,
        height: this.settings.height
      }), this.emit(Re.RENDITION.ATTACHED);
    }.bind(this));
  }
  /**
   * Display a point in the book
   * The request will be added to the rendering Queue,
   * so it will wait until book is opened, rendering started
   * and all other rendering tasks have finished to be called.
   * @param  {string} target Url or EpubCFI
   * @return {Promise}
   */
  display(e) {
    return this.displaying && this.displaying.resolve(), this.q.enqueue(this._display, e);
  }
  /**
   * Tells the manager what to display immediately
   * @private
   * @param  {string} target Url or EpubCFI
   * @return {Promise}
   */
  _display(e) {
    if (this.book) {
      this.epubcfi.isCfiString(e);
      var n = new vt(), r = n.promise, i;
      return this.displaying = n, this.book.locations.length() && B0(e) && (e = this.book.locations.cfiFromPercentage(parseFloat(e))), i = this.book.spine.get(e), i ? (this.manager.display(i, e).then(() => {
        n.resolve(i), this.displaying = void 0, this.emit(Re.RENDITION.DISPLAYED, i), this.reportLocation();
      }, (s) => {
        this.emit(Re.RENDITION.DISPLAY_ERROR, s);
      }), r) : (n.reject(new Error("No Section Found")), r);
    }
  }
  /*
  	render(view, show) {
  
  		// view.onLayout = this.layout.format.bind(this.layout);
  		view.create();
  
  		// Fit to size of the container, apply padding
  		this.manager.resizeView(view);
  
  		// Render Chain
  		return view.section.render(this.book.request)
  			.then(function(contents){
  				return view.load(contents);
  			}.bind(this))
  			.then(function(doc){
  				return this.hooks.content.trigger(view, this);
  			}.bind(this))
  			.then(function(){
  				this.layout.format(view.contents);
  				return this.hooks.layout.trigger(view, this);
  			}.bind(this))
  			.then(function(){
  				return view.display();
  			}.bind(this))
  			.then(function(){
  				return this.hooks.render.trigger(view, this);
  			}.bind(this))
  			.then(function(){
  				if(show !== false) {
  					this.q.enqueue(function(view){
  						view.show();
  					}, view);
  				}
  				// this.map = new Map(view, this.layout);
  				this.hooks.show.trigger(view, this);
  				this.trigger("rendered", view.section);
  
  			}.bind(this))
  			.catch(function(e){
  				this.trigger("loaderror", e);
  			}.bind(this));
  
  	}
  	*/
  /**
   * Report what section has been displayed
   * @private
   * @param  {*} view
   */
  afterDisplayed(e) {
    e.on(Re.VIEWS.MARK_CLICKED, (n, r) => this.triggerMarkEvent(n, r, e.contents)), this.hooks.render.trigger(e, this).then(() => {
      e.contents ? this.hooks.content.trigger(e.contents, this).then(() => {
        this.emit(Re.RENDITION.RENDERED, e.section, e);
      }) : this.emit(Re.RENDITION.RENDERED, e.section, e);
    });
  }
  /**
   * Report what has been removed
   * @private
   * @param  {*} view
   */
  afterRemoved(e) {
    this.hooks.unloaded.trigger(e, this).then(() => {
      this.emit(Re.RENDITION.REMOVED, e.section, e);
    });
  }
  /**
   * Report resize events and display the last seen location
   * @private
   */
  onResized(e, n) {
    this.emit(Re.RENDITION.RESIZED, {
      width: e.width,
      height: e.height
    }, n), this.location && this.location.start && this.display(n || this.location.start.cfi);
  }
  /**
   * Report orientation events and display the last seen location
   * @private
   */
  onOrientationChange(e) {
    this.emit(Re.RENDITION.ORIENTATION_CHANGE, e);
  }
  /**
   * Move the Rendition to a specific offset
   * Usually you would be better off calling display()
   * @param {object} offset
   */
  moveTo(e) {
    this.manager.moveTo(e);
  }
  /**
   * Trigger a resize of the views
   * @param {number} [width]
   * @param {number} [height]
   * @param {string} [epubcfi] (optional)
   */
  resize(e, n, r) {
    e && (this.settings.width = e), n && (this.settings.height = n), this.manager.resize(e, n, r);
  }
  /**
   * Clear all rendered views
   */
  clear() {
    this.manager.clear();
  }
  /**
   * Go to the next "page" in the rendition
   * @return {Promise}
   */
  next() {
    return this.q.enqueue(this.manager.next.bind(this.manager)).then(this.reportLocation.bind(this));
  }
  /**
   * Go to the previous "page" in the rendition
   * @return {Promise}
   */
  prev() {
    return this.q.enqueue(this.manager.prev.bind(this.manager)).then(this.reportLocation.bind(this));
  }
  //-- http://www.idpf.org/epub/301/spec/epub-publications.html#meta-properties-rendering
  /**
   * Determine the Layout properties from metadata and settings
   * @private
   * @param  {object} metadata
   * @return {object} properties
   */
  determineLayoutProperties(e) {
    var n, r = this.settings.layout || e.layout || "reflowable", i = this.settings.spread || e.spread || "auto", s = this.settings.orientation || e.orientation || "auto", o = this.settings.flow || e.flow || "auto", a = e.viewport || "", l = this.settings.minSpreadWidth || e.minSpreadWidth || 800, u = this.settings.direction || e.direction || "ltr";
    return (this.settings.width === 0 || this.settings.width > 0) && (this.settings.height === 0 || this.settings.height > 0), n = {
      layout: r,
      spread: i,
      orientation: s,
      flow: o,
      viewport: a,
      minSpreadWidth: l,
      direction: u
    }, n;
  }
  /**
   * Adjust the flow of the rendition to paginated or scrolled
   * (scrolled-continuous vs scrolled-doc are handled by different view managers)
   * @param  {string} flow
   */
  flow(e) {
    var n = e;
    (e === "scrolled" || e === "scrolled-doc" || e === "scrolled-continuous") && (n = "scrolled"), (e === "auto" || e === "paginated") && (n = "paginated"), this.settings.flow = e, this._layout && this._layout.flow(n), this.manager && this._layout && this.manager.applyLayout(this._layout), this.manager && this.manager.updateFlow(n), this.manager && this.manager.isRendered() && this.location && (this.manager.clear(), this.display(this.location.start.cfi));
  }
  /**
   * Adjust the layout of the rendition to reflowable or pre-paginated
   * @param  {object} settings
   */
  layout(e) {
    return e && (this._layout = new G0(e), this._layout.spread(e.spread, this.settings.minSpreadWidth), this._layout.on(Re.LAYOUT.UPDATED, (n, r) => {
      this.emit(Re.RENDITION.LAYOUT, n, r);
    })), this.manager && this._layout && this.manager.applyLayout(this._layout), this._layout;
  }
  /**
   * Adjust if the rendition uses spreads
   * @param  {string} spread none | auto (TODO: implement landscape, portrait, both)
   * @param  {int} [min] min width to use spreads at
   */
  spread(e, n) {
    this.settings.spread = e, n && (this.settings.minSpreadWidth = n), this._layout && this._layout.spread(e, n), this.manager && this.manager.isRendered() && this.manager.updateLayout();
  }
  /**
   * Adjust the direction of the rendition
   * @param  {string} dir
   */
  direction(e) {
    this.settings.direction = e || "ltr", this.manager && this.manager.direction(this.settings.direction), this.manager && this.manager.isRendered() && this.location && (this.manager.clear(), this.display(this.location.start.cfi));
  }
  /**
   * Report the current location
   * @fires relocated
   * @fires locationChanged
   */
  reportLocation() {
    return this.q.enqueue(function() {
      requestAnimationFrame(function() {
        var r = this.manager.currentLocation();
        if (r && r.then && typeof r.then == "function")
          r.then(function(i) {
            let s = this.located(i);
            !s || !s.start || !s.end || (this.location = s, this.emit(Re.RENDITION.LOCATION_CHANGED, {
              index: this.location.start.index,
              href: this.location.start.href,
              start: this.location.start.cfi,
              end: this.location.end.cfi,
              percentage: this.location.start.percentage
            }), this.emit(Re.RENDITION.RELOCATED, this.location));
          }.bind(this));
        else if (r) {
          let i = this.located(r);
          if (!i || !i.start || !i.end)
            return;
          this.location = i, this.emit(Re.RENDITION.LOCATION_CHANGED, {
            index: this.location.start.index,
            href: this.location.start.href,
            start: this.location.start.cfi,
            end: this.location.end.cfi,
            percentage: this.location.start.percentage
          }), this.emit(Re.RENDITION.RELOCATED, this.location);
        }
      }.bind(this));
    }.bind(this));
  }
  /**
   * Get the Current Location object
   * @return {displayedLocation | promise} location (may be a promise)
   */
  currentLocation() {
    var e = this.manager.currentLocation();
    if (e && e.then && typeof e.then == "function")
      e.then(function(n) {
        return this.located(n);
      }.bind(this));
    else if (e)
      return this.located(e);
  }
  /**
   * Creates a Rendition#locationRange from location
   * passed by the Manager
   * @returns {displayedLocation}
   * @private
   */
  located(e) {
    if (!e.length)
      return {};
    let n = e[0], r = e[e.length - 1], i = {
      start: {
        index: n.index,
        href: n.href,
        cfi: n.mapping.start,
        displayed: {
          page: n.pages[0] || 1,
          total: n.totalPages
        }
      },
      end: {
        index: r.index,
        href: r.href,
        cfi: r.mapping.end,
        displayed: {
          page: r.pages[r.pages.length - 1] || 1,
          total: r.totalPages
        }
      }
    }, s = this.book.locations.locationFromCfi(n.mapping.start), o = this.book.locations.locationFromCfi(r.mapping.end);
    s != null && (i.start.location = s, i.start.percentage = this.book.locations.percentageFromLocation(s)), o != null && (i.end.location = o, i.end.percentage = this.book.locations.percentageFromLocation(o));
    let a = this.book.pageList.pageFromCfi(n.mapping.start), l = this.book.pageList.pageFromCfi(r.mapping.end);
    return a != -1 && (i.start.page = a), l != -1 && (i.end.page = l), r.index === this.book.spine.last().index && i.end.displayed.page >= i.end.displayed.total && (i.atEnd = !0), n.index === this.book.spine.first().index && i.start.displayed.page === 1 && (i.atStart = !0), i;
  }
  /**
   * Remove and Clean Up the Rendition
   */
  destroy() {
    this.manager && this.manager.destroy(), this.book = void 0;
  }
  /**
   * Pass the events from a view's Contents
   * @private
   * @param  {Contents} view contents
   */
  passEvents(e) {
    pl.forEach((n) => {
      e.on(n, (r) => this.triggerViewEvent(r, e));
    }), e.on(Re.CONTENTS.SELECTED, (n) => this.triggerSelectedEvent(n, e));
  }
  /**
   * Emit events passed by a view
   * @private
   * @param  {event} e
   */
  triggerViewEvent(e, n) {
    this.emit(e.type, e, n);
  }
  /**
   * Emit a selection event's CFI Range passed from a a view
   * @private
   * @param  {string} cfirange
   */
  triggerSelectedEvent(e, n) {
    this.emit(Re.RENDITION.SELECTED, e, n);
  }
  /**
   * Emit a markClicked event with the cfiRange and data from a mark
   * @private
   * @param  {EpubCFI} cfirange
   */
  triggerMarkEvent(e, n, r) {
    this.emit(Re.RENDITION.MARK_CLICKED, e, n, r);
  }
  /**
   * Get a Range from a Visible CFI
   * @param  {string} cfi EpubCfi String
   * @param  {string} ignoreClass
   * @return {range}
   */
  getRange(e, n) {
    var r = new gt(e), i = this.manager.visible().filter(function(s) {
      if (r.spinePos === s.index)
        return !0;
    });
    if (i.length)
      return i[0].contents.range(r, n);
  }
  /**
   * Hook to adjust images to fit in columns
   * @param  {Contents} contents
   * @private
   */
  adjustImages(e) {
    if (this._layout.name === "pre-paginated")
      return new Promise(function(s) {
        s();
      });
    let n = e.window.getComputedStyle(e.content, null), r = (e.content.offsetHeight - (parseFloat(n.paddingTop) + parseFloat(n.paddingBottom))) * 0.95, i = parseFloat(n.paddingLeft) + parseFloat(n.paddingRight);
    return e.addStylesheetRules({
      img: {
        "max-width": (this._layout.columnWidth ? this._layout.columnWidth - i + "px" : "100%") + "!important",
        "max-height": r + "px!important",
        "object-fit": "contain",
        "page-break-inside": "avoid",
        "break-inside": "avoid",
        "box-sizing": "border-box"
      },
      svg: {
        "max-width": (this._layout.columnWidth ? this._layout.columnWidth - i + "px" : "100%") + "!important",
        "max-height": r + "px!important",
        "page-break-inside": "avoid",
        "break-inside": "avoid"
      }
    }), new Promise(function(s, o) {
      setTimeout(function() {
        s();
      }, 1);
    });
  }
  /**
   * Get the Contents object of each rendered view
   * @returns {Contents[]}
   */
  getContents() {
    return this.manager ? this.manager.getContents() : [];
  }
  /**
   * Get the views member from the manager
   * @returns {Views}
   */
  views() {
    return (this.manager ? this.manager.views : void 0) || [];
  }
  /**
   * Hook to handle link clicks in rendered content
   * @param  {Contents} contents
   * @private
   */
  handleLinks(e) {
    e && e.on(Re.CONTENTS.LINK_CLICKED, (n) => {
      let r = this.book.path.relative(n);
      this.display(r);
    });
  }
  /**
   * Hook to handle injecting stylesheet before
   * a Section is serialized
   * @param  {document} doc
   * @param  {Section} section
   * @private
   */
  injectStylesheet(e, n) {
    let r = e.createElement("link");
    r.setAttribute("type", "text/css"), r.setAttribute("rel", "stylesheet"), r.setAttribute("href", this.settings.stylesheet), e.getElementsByTagName("head")[0].appendChild(r);
  }
  /**
   * Hook to handle injecting scripts before
   * a Section is serialized
   * @param  {document} doc
   * @param  {Section} section
   * @private
   */
  injectScript(e, n) {
    let r = e.createElement("script");
    r.setAttribute("type", "text/javascript"), r.setAttribute("src", this.settings.script), r.textContent = " ", e.getElementsByTagName("head")[0].appendChild(r);
  }
  /**
   * Hook to handle the document identifier before
   * a Section is serialized
   * @param  {document} doc
   * @param  {Section} section
   * @private
   */
  injectIdentifier(e, n) {
    let r = this.book.packaging.metadata.identifier, i = e.createElement("meta");
    i.setAttribute("name", "dc.relation.ispartof"), r && i.setAttribute("content", r), e.getElementsByTagName("head")[0].appendChild(i);
  }
}
Vr(Yf.prototype);
function Ei(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Sd = {}, qM = {
  get exports() {
    return Sd;
  },
  set exports(t) {
    Sd = t;
  }
};
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(t, e) {
  (function(n) {
    t.exports = n();
  })(function() {
    return function n(r, i, s) {
      function o(u, c) {
        if (!i[u]) {
          if (!r[u]) {
            var d = typeof Ei == "function" && Ei;
            if (!c && d)
              return d(u, !0);
            if (a)
              return a(u, !0);
            var h = new Error("Cannot find module '" + u + "'");
            throw h.code = "MODULE_NOT_FOUND", h;
          }
          var v = i[u] = { exports: {} };
          r[u][0].call(v.exports, function(m) {
            var b = r[u][1][m];
            return o(b || m);
          }, v, v.exports, n, r, i, s);
        }
        return i[u].exports;
      }
      for (var a = typeof Ei == "function" && Ei, l = 0; l < s.length; l++)
        o(s[l]);
      return o;
    }({ 1: [function(n, r, i) {
      var s = n("./utils"), o = n("./support"), a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      i.encode = function(l) {
        for (var u = [], c, d, h, v, m, b, p, f = 0, g = l.length, y = g, w = s.getTypeOf(l) !== "string"; f < l.length; )
          y = g - f, w ? (c = l[f++], d = f < g ? l[f++] : 0, h = f < g ? l[f++] : 0) : (c = l.charCodeAt(f++), d = f < g ? l.charCodeAt(f++) : 0, h = f < g ? l.charCodeAt(f++) : 0), v = c >> 2, m = (c & 3) << 4 | d >> 4, b = y > 1 ? (d & 15) << 2 | h >> 6 : 64, p = y > 2 ? h & 63 : 64, u.push(a.charAt(v) + a.charAt(m) + a.charAt(b) + a.charAt(p));
        return u.join("");
      }, i.decode = function(l) {
        var u, c, d, h, v, m, b, p = 0, f = 0, g = "data:";
        if (l.substr(0, g.length) === g)
          throw new Error("Invalid base64 input, it looks like a data url.");
        l = l.replace(/[^A-Za-z0-9+/=]/g, "");
        var y = l.length * 3 / 4;
        if (l.charAt(l.length - 1) === a.charAt(64) && y--, l.charAt(l.length - 2) === a.charAt(64) && y--, y % 1 !== 0)
          throw new Error("Invalid base64 input, bad content length.");
        var w;
        for (o.uint8array ? w = new Uint8Array(y | 0) : w = new Array(y | 0); p < l.length; )
          h = a.indexOf(l.charAt(p++)), v = a.indexOf(l.charAt(p++)), m = a.indexOf(l.charAt(p++)), b = a.indexOf(l.charAt(p++)), u = h << 2 | v >> 4, c = (v & 15) << 4 | m >> 2, d = (m & 3) << 6 | b, w[f++] = u, m !== 64 && (w[f++] = c), b !== 64 && (w[f++] = d);
        return w;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(n, r, i) {
      var s = n("./external"), o = n("./stream/DataWorker"), a = n("./stream/Crc32Probe"), l = n("./stream/DataLengthProbe");
      function u(c, d, h, v, m) {
        this.compressedSize = c, this.uncompressedSize = d, this.crc32 = h, this.compression = v, this.compressedContent = m;
      }
      u.prototype = {
        /**
         * Create a worker to get the uncompressed content.
         * @return {GenericWorker} the worker.
         */
        getContentWorker: function() {
          var c = new o(s.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new l("data_length")), d = this;
          return c.on("end", function() {
            if (this.streamInfo.data_length !== d.uncompressedSize)
              throw new Error("Bug : uncompressed data size mismatch");
          }), c;
        },
        /**
         * Create a worker to get the compressed content.
         * @return {GenericWorker} the worker.
         */
        getCompressedWorker: function() {
          return new o(s.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        }
      }, u.createWorkerFrom = function(c, d, h) {
        return c.pipe(new a()).pipe(new l("uncompressedSize")).pipe(d.compressWorker(h)).pipe(new l("compressedSize")).withStreamInfo("compression", d);
      }, r.exports = u;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(n, r, i) {
      var s = n("./stream/GenericWorker");
      i.STORE = {
        magic: "\0\0",
        compressWorker: function() {
          return new s("STORE compression");
        },
        uncompressWorker: function() {
          return new s("STORE decompression");
        }
      }, i.DEFLATE = n("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(n, r, i) {
      var s = n("./utils");
      function o() {
        for (var c, d = [], h = 0; h < 256; h++) {
          c = h;
          for (var v = 0; v < 8; v++)
            c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
          d[h] = c;
        }
        return d;
      }
      var a = o();
      function l(c, d, h, v) {
        var m = a, b = v + h;
        c = c ^ -1;
        for (var p = v; p < b; p++)
          c = c >>> 8 ^ m[(c ^ d[p]) & 255];
        return c ^ -1;
      }
      function u(c, d, h, v) {
        var m = a, b = v + h;
        c = c ^ -1;
        for (var p = v; p < b; p++)
          c = c >>> 8 ^ m[(c ^ d.charCodeAt(p)) & 255];
        return c ^ -1;
      }
      r.exports = function(d, h) {
        if (typeof d > "u" || !d.length)
          return 0;
        var v = s.getTypeOf(d) !== "string";
        return v ? l(h | 0, d, d.length, 0) : u(h | 0, d, d.length, 0);
      };
    }, { "./utils": 32 }], 5: [function(n, r, i) {
      i.base64 = !1, i.binary = !1, i.dir = !1, i.createFolders = !0, i.date = null, i.compression = null, i.compressionOptions = null, i.comment = null, i.unixPermissions = null, i.dosPermissions = null;
    }, {}], 6: [function(n, r, i) {
      var s = null;
      typeof Promise < "u" ? s = Promise : s = n("lie"), r.exports = {
        Promise: s
      };
    }, { lie: 37 }], 7: [function(n, r, i) {
      var s = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", o = n("pako"), a = n("./utils"), l = n("./stream/GenericWorker"), u = s ? "uint8array" : "array";
      i.magic = "\b\0";
      function c(d, h) {
        l.call(this, "FlateWorker/" + d), this._pako = null, this._pakoAction = d, this._pakoOptions = h, this.meta = {};
      }
      a.inherits(c, l), c.prototype.processChunk = function(d) {
        this.meta = d.meta, this._pako === null && this._createPako(), this._pako.push(a.transformTo(u, d.data), !1);
      }, c.prototype.flush = function() {
        l.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, c.prototype.cleanUp = function() {
        l.prototype.cleanUp.call(this), this._pako = null;
      }, c.prototype._createPako = function() {
        this._pako = new o[this._pakoAction]({
          raw: !0,
          level: this._pakoOptions.level || -1
          // default compression
        });
        var d = this;
        this._pako.onData = function(h) {
          d.push({
            data: h,
            meta: d.meta
          });
        };
      }, i.compressWorker = function(d) {
        return new c("Deflate", d);
      }, i.uncompressWorker = function() {
        return new c("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(n, r, i) {
      var s = n("../utils"), o = n("../stream/GenericWorker"), a = n("../utf8"), l = n("../crc32"), u = n("../signature"), c = function(f, g) {
        var y = "", w;
        for (w = 0; w < g; w++)
          y += String.fromCharCode(f & 255), f = f >>> 8;
        return y;
      }, d = function(f, g) {
        var y = f;
        return f || (y = g ? 16893 : 33204), (y & 65535) << 16;
      }, h = function(f) {
        return (f || 0) & 63;
      }, v = function(f, g, y, w, _, S) {
        var A = f.file, C = f.compression, k = S !== a.utf8encode, O = s.transformTo("string", S(A.name)), N = s.transformTo("string", a.utf8encode(A.name)), B = A.comment, D = s.transformTo("string", S(B)), F = s.transformTo("string", a.utf8encode(B)), Z = N.length !== A.name.length, te = F.length !== B.length, L, V, H = "", ie = "", ne = "", Y = A.dir, de = A.date, ue = {
          crc32: 0,
          compressedSize: 0,
          uncompressedSize: 0
        };
        (!g || y) && (ue.crc32 = f.crc32, ue.compressedSize = f.compressedSize, ue.uncompressedSize = f.uncompressedSize);
        var Te = 0;
        g && (Te |= 8), !k && (Z || te) && (Te |= 2048);
        var _e = 0, Fe = 0;
        Y && (_e |= 16), _ === "UNIX" ? (Fe = 798, _e |= d(A.unixPermissions, Y)) : (Fe = 20, _e |= h(A.dosPermissions)), L = de.getUTCHours(), L = L << 6, L = L | de.getUTCMinutes(), L = L << 5, L = L | de.getUTCSeconds() / 2, V = de.getUTCFullYear() - 1980, V = V << 4, V = V | de.getUTCMonth() + 1, V = V << 5, V = V | de.getUTCDate(), Z && (ie = // Version
        c(1, 1) + // NameCRC32
        c(l(O), 4) + // UnicodeName
        N, H += // Info-ZIP Unicode Path Extra Field
        "up" + // size
        c(ie.length, 2) + // content
        ie), te && (ne = // Version
        c(1, 1) + // CommentCRC32
        c(l(D), 4) + // UnicodeName
        F, H += // Info-ZIP Unicode Path Extra Field
        "uc" + // size
        c(ne.length, 2) + // content
        ne);
        var Ce = "";
        Ce += `
\0`, Ce += c(Te, 2), Ce += C.magic, Ce += c(L, 2), Ce += c(V, 2), Ce += c(ue.crc32, 4), Ce += c(ue.compressedSize, 4), Ce += c(ue.uncompressedSize, 4), Ce += c(O.length, 2), Ce += c(H.length, 2);
        var tt = u.LOCAL_FILE_HEADER + Ce + O + H, je = u.CENTRAL_FILE_HEADER + // version made by (00: DOS)
        c(Fe, 2) + // file header (common to file and central directory)
        Ce + // file comment length
        c(D.length, 2) + // disk number start
        "\0\0\0\0" + // external file attributes
        c(_e, 4) + // relative offset of local header
        c(w, 4) + // file name
        O + // extra field
        H + // file comment
        D;
        return {
          fileRecord: tt,
          dirRecord: je
        };
      }, m = function(f, g, y, w, _) {
        var S = "", A = s.transformTo("string", _(w));
        return S = u.CENTRAL_DIRECTORY_END + // number of this disk
        "\0\0\0\0" + // total number of entries in the central directory on this disk
        c(f, 2) + // total number of entries in the central directory
        c(f, 2) + // size of the central directory   4 bytes
        c(g, 4) + // offset of start of central directory with respect to the starting disk number
        c(y, 4) + // .ZIP file comment length
        c(A.length, 2) + // .ZIP file comment
        A, S;
      }, b = function(f) {
        var g = "";
        return g = u.DATA_DESCRIPTOR + // crc-32                          4 bytes
        c(f.crc32, 4) + // compressed size                 4 bytes
        c(f.compressedSize, 4) + // uncompressed size               4 bytes
        c(f.uncompressedSize, 4), g;
      };
      function p(f, g, y, w) {
        o.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = g, this.zipPlatform = y, this.encodeFileName = w, this.streamFiles = f, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      s.inherits(p, o), p.prototype.push = function(f) {
        var g = f.meta.percent || 0, y = this.entriesCount, w = this._sources.length;
        this.accumulate ? this.contentBuffer.push(f) : (this.bytesWritten += f.data.length, o.prototype.push.call(this, {
          data: f.data,
          meta: {
            currentFile: this.currentFile,
            percent: y ? (g + 100 * (y - w - 1)) / y : 100
          }
        }));
      }, p.prototype.openedSource = function(f) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = f.file.name;
        var g = this.streamFiles && !f.file.dir;
        if (g) {
          var y = v(f, g, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({
            data: y.fileRecord,
            meta: { percent: 0 }
          });
        } else
          this.accumulate = !0;
      }, p.prototype.closedSource = function(f) {
        this.accumulate = !1;
        var g = this.streamFiles && !f.file.dir, y = v(f, g, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(y.dirRecord), g)
          this.push({
            data: b(f),
            meta: { percent: 100 }
          });
        else
          for (this.push({
            data: y.fileRecord,
            meta: { percent: 0 }
          }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, p.prototype.flush = function() {
        for (var f = this.bytesWritten, g = 0; g < this.dirRecords.length; g++)
          this.push({
            data: this.dirRecords[g],
            meta: { percent: 100 }
          });
        var y = this.bytesWritten - f, w = m(this.dirRecords.length, y, f, this.zipComment, this.encodeFileName);
        this.push({
          data: w,
          meta: { percent: 100 }
        });
      }, p.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, p.prototype.registerPrevious = function(f) {
        this._sources.push(f);
        var g = this;
        return f.on("data", function(y) {
          g.processChunk(y);
        }), f.on("end", function() {
          g.closedSource(g.previous.streamInfo), g._sources.length ? g.prepareNextSource() : g.end();
        }), f.on("error", function(y) {
          g.error(y);
        }), this;
      }, p.prototype.resume = function() {
        if (!o.prototype.resume.call(this))
          return !1;
        if (!this.previous && this._sources.length)
          return this.prepareNextSource(), !0;
        if (!this.previous && !this._sources.length && !this.generatedError)
          return this.end(), !0;
      }, p.prototype.error = function(f) {
        var g = this._sources;
        if (!o.prototype.error.call(this, f))
          return !1;
        for (var y = 0; y < g.length; y++)
          try {
            g[y].error(f);
          } catch {
          }
        return !0;
      }, p.prototype.lock = function() {
        o.prototype.lock.call(this);
        for (var f = this._sources, g = 0; g < f.length; g++)
          f[g].lock();
      }, r.exports = p;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(n, r, i) {
      var s = n("../compressions"), o = n("./ZipFileWorker"), a = function(l, u) {
        var c = l || u, d = s[c];
        if (!d)
          throw new Error(c + " is not a valid compression method !");
        return d;
      };
      i.generateWorker = function(l, u, c) {
        var d = new o(u.streamFiles, c, u.platform, u.encodeFileName), h = 0;
        try {
          l.forEach(function(v, m) {
            h++;
            var b = a(m.options.compression, u.compression), p = m.options.compressionOptions || u.compressionOptions || {}, f = m.dir, g = m.date;
            m._compressWorker(b, p).withStreamInfo("file", {
              name: v,
              dir: f,
              date: g,
              comment: m.comment || "",
              unixPermissions: m.unixPermissions,
              dosPermissions: m.dosPermissions
            }).pipe(d);
          }), d.entriesCount = h;
        } catch (v) {
          d.error(v);
        }
        return d;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(n, r, i) {
      function s() {
        if (!(this instanceof s))
          return new s();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var o = new s();
          for (var a in this)
            typeof this[a] != "function" && (o[a] = this[a]);
          return o;
        };
      }
      s.prototype = n("./object"), s.prototype.loadAsync = n("./load"), s.support = n("./support"), s.defaults = n("./defaults"), s.version = "3.10.1", s.loadAsync = function(o, a) {
        return new s().loadAsync(o, a);
      }, s.external = n("./external"), r.exports = s;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(n, r, i) {
      var s = n("./utils"), o = n("./external"), a = n("./utf8"), l = n("./zipEntries"), u = n("./stream/Crc32Probe"), c = n("./nodejsUtils");
      function d(h) {
        return new o.Promise(function(v, m) {
          var b = h.decompressed.getContentWorker().pipe(new u());
          b.on("error", function(p) {
            m(p);
          }).on("end", function() {
            b.streamInfo.crc32 !== h.decompressed.crc32 ? m(new Error("Corrupted zip : CRC32 mismatch")) : v();
          }).resume();
        });
      }
      r.exports = function(h, v) {
        var m = this;
        return v = s.extend(v || {}, {
          base64: !1,
          checkCRC32: !1,
          optimizedBinaryString: !1,
          createFolders: !1,
          decodeFileName: a.utf8decode
        }), c.isNode && c.isStream(h) ? o.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : s.prepareContent("the loaded zip file", h, !0, v.optimizedBinaryString, v.base64).then(function(b) {
          var p = new l(v);
          return p.load(b), p;
        }).then(function(p) {
          var f = [o.Promise.resolve(p)], g = p.files;
          if (v.checkCRC32)
            for (var y = 0; y < g.length; y++)
              f.push(d(g[y]));
          return o.Promise.all(f);
        }).then(function(p) {
          for (var f = p.shift(), g = f.files, y = 0; y < g.length; y++) {
            var w = g[y], _ = w.fileNameStr, S = s.resolve(w.fileNameStr);
            m.file(S, w.decompressed, {
              binary: !0,
              optimizedBinaryString: !0,
              date: w.date,
              dir: w.dir,
              comment: w.fileCommentStr.length ? w.fileCommentStr : null,
              unixPermissions: w.unixPermissions,
              dosPermissions: w.dosPermissions,
              createFolders: v.createFolders
            }), w.dir || (m.file(S).unsafeOriginalName = _);
          }
          return f.zipComment.length && (m.comment = f.zipComment), m;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(n, r, i) {
      var s = n("../utils"), o = n("../stream/GenericWorker");
      function a(l, u) {
        o.call(this, "Nodejs stream input adapter for " + l), this._upstreamEnded = !1, this._bindStream(u);
      }
      s.inherits(a, o), a.prototype._bindStream = function(l) {
        var u = this;
        this._stream = l, l.pause(), l.on("data", function(c) {
          u.push({
            data: c,
            meta: {
              percent: 0
            }
          });
        }).on("error", function(c) {
          u.isPaused ? this.generatedError = c : u.error(c);
        }).on("end", function() {
          u.isPaused ? u._upstreamEnded = !0 : u.end();
        });
      }, a.prototype.pause = function() {
        return o.prototype.pause.call(this) ? (this._stream.pause(), !0) : !1;
      }, a.prototype.resume = function() {
        return o.prototype.resume.call(this) ? (this._upstreamEnded ? this.end() : this._stream.resume(), !0) : !1;
      }, r.exports = a;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(n, r, i) {
      var s = n("readable-stream").Readable, o = n("../utils");
      o.inherits(a, s);
      function a(l, u, c) {
        s.call(this, u), this._helper = l;
        var d = this;
        l.on("data", function(h, v) {
          d.push(h) || d._helper.pause(), c && c(v);
        }).on("error", function(h) {
          d.emit("error", h);
        }).on("end", function() {
          d.push(null);
        });
      }
      a.prototype._read = function() {
        this._helper.resume();
      }, r.exports = a;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(n, r, i) {
      r.exports = {
        /**
         * True if this is running in Nodejs, will be undefined in a browser.
         * In a browser, browserify won't include this file and the whole module
         * will be resolved an empty object.
         */
        isNode: typeof Buffer < "u",
        /**
         * Create a new nodejs Buffer from an existing content.
         * @param {Object} data the data to pass to the constructor.
         * @param {String} encoding the encoding to use.
         * @return {Buffer} a new Buffer.
         */
        newBufferFrom: function(s, o) {
          if (Buffer.from && Buffer.from !== Uint8Array.from)
            return Buffer.from(s, o);
          if (typeof s == "number")
            throw new Error('The "data" argument must not be a number');
          return new Buffer(s, o);
        },
        /**
         * Create a new nodejs Buffer with the specified size.
         * @param {Integer} size the size of the buffer.
         * @return {Buffer} a new Buffer.
         */
        allocBuffer: function(s) {
          if (Buffer.alloc)
            return Buffer.alloc(s);
          var o = new Buffer(s);
          return o.fill(0), o;
        },
        /**
         * Find out if an object is a Buffer.
         * @param {Object} b the object to test.
         * @return {Boolean} true if the object is a Buffer, false otherwise.
         */
        isBuffer: function(s) {
          return Buffer.isBuffer(s);
        },
        isStream: function(s) {
          return s && typeof s.on == "function" && typeof s.pause == "function" && typeof s.resume == "function";
        }
      };
    }, {}], 15: [function(n, r, i) {
      var s = n("./utf8"), o = n("./utils"), a = n("./stream/GenericWorker"), l = n("./stream/StreamHelper"), u = n("./defaults"), c = n("./compressedObject"), d = n("./zipObject"), h = n("./generate"), v = n("./nodejsUtils"), m = n("./nodejs/NodejsStreamInputAdapter"), b = function(_, S, A) {
        var C = o.getTypeOf(S), k, O = o.extend(A || {}, u);
        O.date = O.date || /* @__PURE__ */ new Date(), O.compression !== null && (O.compression = O.compression.toUpperCase()), typeof O.unixPermissions == "string" && (O.unixPermissions = parseInt(O.unixPermissions, 8)), O.unixPermissions && O.unixPermissions & 16384 && (O.dir = !0), O.dosPermissions && O.dosPermissions & 16 && (O.dir = !0), O.dir && (_ = f(_)), O.createFolders && (k = p(_)) && g.call(this, k, !0);
        var N = C === "string" && O.binary === !1 && O.base64 === !1;
        (!A || typeof A.binary > "u") && (O.binary = !N);
        var B = S instanceof c && S.uncompressedSize === 0;
        (B || O.dir || !S || S.length === 0) && (O.base64 = !1, O.binary = !0, S = "", O.compression = "STORE", C = "string");
        var D = null;
        S instanceof c || S instanceof a ? D = S : v.isNode && v.isStream(S) ? D = new m(_, S) : D = o.prepareContent(_, S, O.binary, O.optimizedBinaryString, O.base64);
        var F = new d(_, D, O);
        this.files[_] = F;
      }, p = function(_) {
        _.slice(-1) === "/" && (_ = _.substring(0, _.length - 1));
        var S = _.lastIndexOf("/");
        return S > 0 ? _.substring(0, S) : "";
      }, f = function(_) {
        return _.slice(-1) !== "/" && (_ += "/"), _;
      }, g = function(_, S) {
        return S = typeof S < "u" ? S : u.createFolders, _ = f(_), this.files[_] || b.call(this, _, null, {
          dir: !0,
          createFolders: S
        }), this.files[_];
      };
      function y(_) {
        return Object.prototype.toString.call(_) === "[object RegExp]";
      }
      var w = {
        /**
         * @see loadAsync
         */
        load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        },
        /**
         * Call a callback function for each entry at this folder level.
         * @param {Function} cb the callback function:
         * function (relativePath, file) {...}
         * It takes 2 arguments : the relative path and the file.
         */
        forEach: function(_) {
          var S, A, C;
          for (S in this.files)
            C = this.files[S], A = S.slice(this.root.length, S.length), A && S.slice(0, this.root.length) === this.root && _(A, C);
        },
        /**
         * Filter nested files/folders with the specified function.
         * @param {Function} search the predicate to use :
         * function (relativePath, file) {...}
         * It takes 2 arguments : the relative path and the file.
         * @return {Array} An array of matching elements.
         */
        filter: function(_) {
          var S = [];
          return this.forEach(function(A, C) {
            _(A, C) && S.push(C);
          }), S;
        },
        /**
         * Add a file to the zip file, or search a file.
         * @param   {string|RegExp} name The name of the file to add (if data is defined),
         * the name of the file to find (if no data) or a regex to match files.
         * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
         * @param   {Object} o     File options
         * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
         * a file (when searching by string) or an array of files (when searching by regex).
         */
        file: function(_, S, A) {
          if (arguments.length === 1)
            if (y(_)) {
              var C = _;
              return this.filter(function(O, N) {
                return !N.dir && C.test(O);
              });
            } else {
              var k = this.files[this.root + _];
              return k && !k.dir ? k : null;
            }
          else
            _ = this.root + _, b.call(this, _, S, A);
          return this;
        },
        /**
         * Add a directory to the zip file, or search.
         * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
         * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
         */
        folder: function(_) {
          if (!_)
            return this;
          if (y(_))
            return this.filter(function(k, O) {
              return O.dir && _.test(k);
            });
          var S = this.root + _, A = g.call(this, S), C = this.clone();
          return C.root = A.name, C;
        },
        /**
         * Delete a file, or a directory and all sub-files, from the zip
         * @param {string} name the name of the file to delete
         * @return {JSZip} this JSZip object
         */
        remove: function(_) {
          _ = this.root + _;
          var S = this.files[_];
          if (S || (_.slice(-1) !== "/" && (_ += "/"), S = this.files[_]), S && !S.dir)
            delete this.files[_];
          else
            for (var A = this.filter(function(k, O) {
              return O.name.slice(0, _.length) === _;
            }), C = 0; C < A.length; C++)
              delete this.files[A[C].name];
          return this;
        },
        /**
         * @deprecated This method has been removed in JSZip 3.0, please check the upgrade guide.
         */
        generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        },
        /**
         * Generate the complete zip file as an internal stream.
         * @param {Object} options the options to generate the zip file :
         * - compression, "STORE" by default.
         * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
         * @return {StreamHelper} the streamed zip file.
         */
        generateInternalStream: function(_) {
          var S, A = {};
          try {
            if (A = o.extend(_ || {}, {
              streamFiles: !1,
              compression: "STORE",
              compressionOptions: null,
              type: "",
              platform: "DOS",
              comment: null,
              mimeType: "application/zip",
              encodeFileName: s.utf8encode
            }), A.type = A.type.toLowerCase(), A.compression = A.compression.toUpperCase(), A.type === "binarystring" && (A.type = "string"), !A.type)
              throw new Error("No output type specified.");
            o.checkSupport(A.type), (A.platform === "darwin" || A.platform === "freebsd" || A.platform === "linux" || A.platform === "sunos") && (A.platform = "UNIX"), A.platform === "win32" && (A.platform = "DOS");
            var C = A.comment || this.comment || "";
            S = h.generateWorker(this, A, C);
          } catch (k) {
            S = new a("error"), S.error(k);
          }
          return new l(S, A.type || "string", A.mimeType);
        },
        /**
         * Generate the complete zip file asynchronously.
         * @see generateInternalStream
         */
        generateAsync: function(_, S) {
          return this.generateInternalStream(_).accumulate(S);
        },
        /**
         * Generate the complete zip file asynchronously.
         * @see generateInternalStream
         */
        generateNodeStream: function(_, S) {
          return _ = _ || {}, _.type || (_.type = "nodebuffer"), this.generateInternalStream(_).toNodejsStream(S);
        }
      };
      r.exports = w;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(n, r, i) {
      r.exports = n("stream");
    }, { stream: void 0 }], 17: [function(n, r, i) {
      var s = n("./DataReader"), o = n("../utils");
      function a(l) {
        s.call(this, l);
        for (var u = 0; u < this.data.length; u++)
          l[u] = l[u] & 255;
      }
      o.inherits(a, s), a.prototype.byteAt = function(l) {
        return this.data[this.zero + l];
      }, a.prototype.lastIndexOfSignature = function(l) {
        for (var u = l.charCodeAt(0), c = l.charCodeAt(1), d = l.charCodeAt(2), h = l.charCodeAt(3), v = this.length - 4; v >= 0; --v)
          if (this.data[v] === u && this.data[v + 1] === c && this.data[v + 2] === d && this.data[v + 3] === h)
            return v - this.zero;
        return -1;
      }, a.prototype.readAndCheckSignature = function(l) {
        var u = l.charCodeAt(0), c = l.charCodeAt(1), d = l.charCodeAt(2), h = l.charCodeAt(3), v = this.readData(4);
        return u === v[0] && c === v[1] && d === v[2] && h === v[3];
      }, a.prototype.readData = function(l) {
        if (this.checkOffset(l), l === 0)
          return [];
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, u;
      }, r.exports = a;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(n, r, i) {
      var s = n("../utils");
      function o(a) {
        this.data = a, this.length = a.length, this.index = 0, this.zero = 0;
      }
      o.prototype = {
        /**
         * Check that the offset will not go too far.
         * @param {string} offset the additional offset to check.
         * @throws {Error} an Error if the offset is out of bounds.
         */
        checkOffset: function(a) {
          this.checkIndex(this.index + a);
        },
        /**
         * Check that the specified index will not be too far.
         * @param {string} newIndex the index to check.
         * @throws {Error} an Error if the index is out of bounds.
         */
        checkIndex: function(a) {
          if (this.length < this.zero + a || a < 0)
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + a + "). Corrupted zip ?");
        },
        /**
         * Change the index.
         * @param {number} newIndex The new index.
         * @throws {Error} if the new index is out of the data.
         */
        setIndex: function(a) {
          this.checkIndex(a), this.index = a;
        },
        /**
         * Skip the next n bytes.
         * @param {number} n the number of bytes to skip.
         * @throws {Error} if the new index is out of the data.
         */
        skip: function(a) {
          this.setIndex(this.index + a);
        },
        /**
         * Get the byte at the specified index.
         * @param {number} i the index to use.
         * @return {number} a byte.
         */
        byteAt: function() {
        },
        /**
         * Get the next number with a given byte size.
         * @param {number} size the number of bytes to read.
         * @return {number} the corresponding number.
         */
        readInt: function(a) {
          var l = 0, u;
          for (this.checkOffset(a), u = this.index + a - 1; u >= this.index; u--)
            l = (l << 8) + this.byteAt(u);
          return this.index += a, l;
        },
        /**
         * Get the next string with a given byte size.
         * @param {number} size the number of bytes to read.
         * @return {string} the corresponding string.
         */
        readString: function(a) {
          return s.transformTo("string", this.readData(a));
        },
        /**
         * Get raw data without conversion, <size> bytes.
         * @param {number} size the number of bytes to read.
         * @return {Object} the raw data, implementation specific.
         */
        readData: function() {
        },
        /**
         * Find the last occurrence of a zip signature (4 bytes).
         * @param {string} sig the signature to find.
         * @return {number} the index of the last occurrence, -1 if not found.
         */
        lastIndexOfSignature: function() {
        },
        /**
         * Read the signature (4 bytes) at the current position and compare it with sig.
         * @param {string} sig the expected signature
         * @return {boolean} true if the signature matches, false otherwise.
         */
        readAndCheckSignature: function() {
        },
        /**
         * Get the next date.
         * @return {Date} the date.
         */
        readDate: function() {
          var a = this.readInt(4);
          return new Date(Date.UTC(
            (a >> 25 & 127) + 1980,
            // year
            (a >> 21 & 15) - 1,
            // month
            a >> 16 & 31,
            // day
            a >> 11 & 31,
            // hour
            a >> 5 & 63,
            // minute
            (a & 31) << 1
          ));
        }
      }, r.exports = o;
    }, { "../utils": 32 }], 19: [function(n, r, i) {
      var s = n("./Uint8ArrayReader"), o = n("../utils");
      function a(l) {
        s.call(this, l);
      }
      o.inherits(a, s), a.prototype.readData = function(l) {
        this.checkOffset(l);
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, u;
      }, r.exports = a;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(n, r, i) {
      var s = n("./DataReader"), o = n("../utils");
      function a(l) {
        s.call(this, l);
      }
      o.inherits(a, s), a.prototype.byteAt = function(l) {
        return this.data.charCodeAt(this.zero + l);
      }, a.prototype.lastIndexOfSignature = function(l) {
        return this.data.lastIndexOf(l) - this.zero;
      }, a.prototype.readAndCheckSignature = function(l) {
        var u = this.readData(4);
        return l === u;
      }, a.prototype.readData = function(l) {
        this.checkOffset(l);
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, u;
      }, r.exports = a;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(n, r, i) {
      var s = n("./ArrayReader"), o = n("../utils");
      function a(l) {
        s.call(this, l);
      }
      o.inherits(a, s), a.prototype.readData = function(l) {
        if (this.checkOffset(l), l === 0)
          return new Uint8Array(0);
        var u = this.data.subarray(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, u;
      }, r.exports = a;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(n, r, i) {
      var s = n("../utils"), o = n("../support"), a = n("./ArrayReader"), l = n("./StringReader"), u = n("./NodeBufferReader"), c = n("./Uint8ArrayReader");
      r.exports = function(d) {
        var h = s.getTypeOf(d);
        return s.checkSupport(h), h === "string" && !o.uint8array ? new l(d) : h === "nodebuffer" ? new u(d) : o.uint8array ? new c(s.transformTo("uint8array", d)) : new a(s.transformTo("array", d));
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(n, r, i) {
      i.LOCAL_FILE_HEADER = "PK", i.CENTRAL_FILE_HEADER = "PK", i.CENTRAL_DIRECTORY_END = "PK", i.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", i.ZIP64_CENTRAL_DIRECTORY_END = "PK", i.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(n, r, i) {
      var s = n("./GenericWorker"), o = n("../utils");
      function a(l) {
        s.call(this, "ConvertWorker to " + l), this.destType = l;
      }
      o.inherits(a, s), a.prototype.processChunk = function(l) {
        this.push({
          data: o.transformTo(this.destType, l.data),
          meta: l.meta
        });
      }, r.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(n, r, i) {
      var s = n("./GenericWorker"), o = n("../crc32"), a = n("../utils");
      function l() {
        s.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      a.inherits(l, s), l.prototype.processChunk = function(u) {
        this.streamInfo.crc32 = o(u.data, this.streamInfo.crc32 || 0), this.push(u);
      }, r.exports = l;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(n, r, i) {
      var s = n("../utils"), o = n("./GenericWorker");
      function a(l) {
        o.call(this, "DataLengthProbe for " + l), this.propName = l, this.withStreamInfo(l, 0);
      }
      s.inherits(a, o), a.prototype.processChunk = function(l) {
        if (l) {
          var u = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = u + l.data.length;
        }
        o.prototype.processChunk.call(this, l);
      }, r.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(n, r, i) {
      var s = n("../utils"), o = n("./GenericWorker"), a = 16 * 1024;
      function l(u) {
        o.call(this, "DataWorker");
        var c = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, u.then(function(d) {
          c.dataIsReady = !0, c.data = d, c.max = d && d.length || 0, c.type = s.getTypeOf(d), c.isPaused || c._tickAndRepeat();
        }, function(d) {
          c.error(d);
        });
      }
      s.inherits(l, o), l.prototype.cleanUp = function() {
        o.prototype.cleanUp.call(this), this.data = null;
      }, l.prototype.resume = function() {
        return o.prototype.resume.call(this) ? (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, s.delay(this._tickAndRepeat, [], this)), !0) : !1;
      }, l.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, !(this.isPaused || this.isFinished) && (this._tick(), this.isFinished || (s.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, l.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return !1;
        var u = a, c = null, d = Math.min(this.max, this.index + u);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            c = this.data.substring(this.index, d);
            break;
          case "uint8array":
            c = this.data.subarray(this.index, d);
            break;
          case "array":
          case "nodebuffer":
            c = this.data.slice(this.index, d);
            break;
        }
        return this.index = d, this.push({
          data: c,
          meta: {
            percent: this.max ? this.index / this.max * 100 : 0
          }
        });
      }, r.exports = l;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(n, r, i) {
      function s(o) {
        this.name = o || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = {
          data: [],
          end: [],
          error: []
        }, this.previous = null;
      }
      s.prototype = {
        /**
         * Push a chunk to the next workers.
         * @param {Object} chunk the chunk to push
         */
        push: function(o) {
          this.emit("data", o);
        },
        /**
         * End the stream.
         * @return {Boolean} true if this call ended the worker, false otherwise.
         */
        end: function() {
          if (this.isFinished)
            return !1;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = !0;
          } catch (o) {
            this.emit("error", o);
          }
          return !0;
        },
        /**
         * End the stream with an error.
         * @param {Error} e the error which caused the premature end.
         * @return {Boolean} true if this call ended the worker with an error, false otherwise.
         */
        error: function(o) {
          return this.isFinished ? !1 : (this.isPaused ? this.generatedError = o : (this.isFinished = !0, this.emit("error", o), this.previous && this.previous.error(o), this.cleanUp()), !0);
        },
        /**
         * Add a callback on an event.
         * @param {String} name the name of the event (data, end, error)
         * @param {Function} listener the function to call when the event is triggered
         * @return {GenericWorker} the current object for chainability
         */
        on: function(o, a) {
          return this._listeners[o].push(a), this;
        },
        /**
         * Clean any references when a worker is ending.
         */
        cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        },
        /**
         * Trigger an event. This will call registered callback with the provided arg.
         * @param {String} name the name of the event (data, end, error)
         * @param {Object} arg the argument to call the callback with.
         */
        emit: function(o, a) {
          if (this._listeners[o])
            for (var l = 0; l < this._listeners[o].length; l++)
              this._listeners[o][l].call(this, a);
        },
        /**
         * Chain a worker with an other.
         * @param {Worker} next the worker receiving events from the current one.
         * @return {worker} the next worker for chainability
         */
        pipe: function(o) {
          return o.registerPrevious(this);
        },
        /**
         * Same as `pipe` in the other direction.
         * Using an API with `pipe(next)` is very easy.
         * Implementing the API with the point of view of the next one registering
         * a source is easier, see the ZipFileWorker.
         * @param {Worker} previous the previous worker, sending events to this one
         * @return {Worker} the current worker for chainability
         */
        registerPrevious: function(o) {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = o.streamInfo, this.mergeStreamInfo(), this.previous = o;
          var a = this;
          return o.on("data", function(l) {
            a.processChunk(l);
          }), o.on("end", function() {
            a.end();
          }), o.on("error", function(l) {
            a.error(l);
          }), this;
        },
        /**
         * Pause the stream so it doesn't send events anymore.
         * @return {Boolean} true if this call paused the worker, false otherwise.
         */
        pause: function() {
          return this.isPaused || this.isFinished ? !1 : (this.isPaused = !0, this.previous && this.previous.pause(), !0);
        },
        /**
         * Resume a paused stream.
         * @return {Boolean} true if this call resumed the worker, false otherwise.
         */
        resume: function() {
          if (!this.isPaused || this.isFinished)
            return !1;
          this.isPaused = !1;
          var o = !1;
          return this.generatedError && (this.error(this.generatedError), o = !0), this.previous && this.previous.resume(), !o;
        },
        /**
         * Flush any remaining bytes as the stream is ending.
         */
        flush: function() {
        },
        /**
         * Process a chunk. This is usually the method overridden.
         * @param {Object} chunk the chunk to process.
         */
        processChunk: function(o) {
          this.push(o);
        },
        /**
         * Add a key/value to be added in the workers chain streamInfo once activated.
         * @param {String} key the key to use
         * @param {Object} value the associated value
         * @return {Worker} the current worker for chainability
         */
        withStreamInfo: function(o, a) {
          return this.extraStreamInfo[o] = a, this.mergeStreamInfo(), this;
        },
        /**
         * Merge this worker's streamInfo into the chain's streamInfo.
         */
        mergeStreamInfo: function() {
          for (var o in this.extraStreamInfo)
            Object.prototype.hasOwnProperty.call(this.extraStreamInfo, o) && (this.streamInfo[o] = this.extraStreamInfo[o]);
        },
        /**
         * Lock the stream to prevent further updates on the workers chain.
         * After calling this method, all calls to pipe will fail.
         */
        lock: function() {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = !0, this.previous && this.previous.lock();
        },
        /**
         *
         * Pretty print the workers chain.
         */
        toString: function() {
          var o = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + o : o;
        }
      }, r.exports = s;
    }, {}], 29: [function(n, r, i) {
      var s = n("../utils"), o = n("./ConvertWorker"), a = n("./GenericWorker"), l = n("../base64"), u = n("../support"), c = n("../external"), d = null;
      if (u.nodestream)
        try {
          d = n("../nodejs/NodejsStreamOutputAdapter");
        } catch {
        }
      function h(p, f, g) {
        switch (p) {
          case "blob":
            return s.newBlob(s.transformTo("arraybuffer", f), g);
          case "base64":
            return l.encode(f);
          default:
            return s.transformTo(p, f);
        }
      }
      function v(p, f) {
        var g, y = 0, w = null, _ = 0;
        for (g = 0; g < f.length; g++)
          _ += f[g].length;
        switch (p) {
          case "string":
            return f.join("");
          case "array":
            return Array.prototype.concat.apply([], f);
          case "uint8array":
            for (w = new Uint8Array(_), g = 0; g < f.length; g++)
              w.set(f[g], y), y += f[g].length;
            return w;
          case "nodebuffer":
            return Buffer.concat(f);
          default:
            throw new Error("concat : unsupported type '" + p + "'");
        }
      }
      function m(p, f) {
        return new c.Promise(function(g, y) {
          var w = [], _ = p._internalType, S = p._outputType, A = p._mimeType;
          p.on("data", function(C, k) {
            w.push(C), f && f(k);
          }).on("error", function(C) {
            w = [], y(C);
          }).on("end", function() {
            try {
              var C = h(S, v(_, w), A);
              g(C);
            } catch (k) {
              y(k);
            }
            w = [];
          }).resume();
        });
      }
      function b(p, f, g) {
        var y = f;
        switch (f) {
          case "blob":
          case "arraybuffer":
            y = "uint8array";
            break;
          case "base64":
            y = "string";
            break;
        }
        try {
          this._internalType = y, this._outputType = f, this._mimeType = g, s.checkSupport(y), this._worker = p.pipe(new o(y)), p.lock();
        } catch (w) {
          this._worker = new a("error"), this._worker.error(w);
        }
      }
      b.prototype = {
        /**
         * Listen a StreamHelper, accumulate its content and concatenate it into a
         * complete block.
         * @param {Function} updateCb the update callback.
         * @return Promise the promise for the accumulation.
         */
        accumulate: function(p) {
          return m(this, p);
        },
        /**
         * Add a listener on an event triggered on a stream.
         * @param {String} evt the name of the event
         * @param {Function} fn the listener
         * @return {StreamHelper} the current helper.
         */
        on: function(p, f) {
          var g = this;
          return p === "data" ? this._worker.on(p, function(y) {
            f.call(g, y.data, y.meta);
          }) : this._worker.on(p, function() {
            s.delay(f, arguments, g);
          }), this;
        },
        /**
         * Resume the flow of chunks.
         * @return {StreamHelper} the current helper.
         */
        resume: function() {
          return s.delay(this._worker.resume, [], this._worker), this;
        },
        /**
         * Pause the flow of chunks.
         * @return {StreamHelper} the current helper.
         */
        pause: function() {
          return this._worker.pause(), this;
        },
        /**
         * Return a nodejs stream for this helper.
         * @param {Function} updateCb the update callback.
         * @return {NodejsStreamOutputAdapter} the nodejs stream.
         */
        toNodejsStream: function(p) {
          if (s.checkSupport("nodestream"), this._outputType !== "nodebuffer")
            throw new Error(this._outputType + " is not supported by this method");
          return new d(this, {
            objectMode: this._outputType !== "nodebuffer"
          }, p);
        }
      }, r.exports = b;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(n, r, i) {
      if (i.base64 = !0, i.array = !0, i.string = !0, i.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", i.nodebuffer = typeof Buffer < "u", i.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u")
        i.blob = !1;
      else {
        var s = new ArrayBuffer(0);
        try {
          i.blob = new Blob([s], {
            type: "application/zip"
          }).size === 0;
        } catch {
          try {
            var o = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder, a = new o();
            a.append(s), i.blob = a.getBlob("application/zip").size === 0;
          } catch {
            i.blob = !1;
          }
        }
      }
      try {
        i.nodestream = !!n("readable-stream").Readable;
      } catch {
        i.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(n, r, i) {
      for (var s = n("./utils"), o = n("./support"), a = n("./nodejsUtils"), l = n("./stream/GenericWorker"), u = new Array(256), c = 0; c < 256; c++)
        u[c] = c >= 252 ? 6 : c >= 248 ? 5 : c >= 240 ? 4 : c >= 224 ? 3 : c >= 192 ? 2 : 1;
      u[254] = u[254] = 1;
      var d = function(p) {
        var f, g, y, w, _, S = p.length, A = 0;
        for (w = 0; w < S; w++)
          g = p.charCodeAt(w), (g & 64512) === 55296 && w + 1 < S && (y = p.charCodeAt(w + 1), (y & 64512) === 56320 && (g = 65536 + (g - 55296 << 10) + (y - 56320), w++)), A += g < 128 ? 1 : g < 2048 ? 2 : g < 65536 ? 3 : 4;
        for (o.uint8array ? f = new Uint8Array(A) : f = new Array(A), _ = 0, w = 0; _ < A; w++)
          g = p.charCodeAt(w), (g & 64512) === 55296 && w + 1 < S && (y = p.charCodeAt(w + 1), (y & 64512) === 56320 && (g = 65536 + (g - 55296 << 10) + (y - 56320), w++)), g < 128 ? f[_++] = g : g < 2048 ? (f[_++] = 192 | g >>> 6, f[_++] = 128 | g & 63) : g < 65536 ? (f[_++] = 224 | g >>> 12, f[_++] = 128 | g >>> 6 & 63, f[_++] = 128 | g & 63) : (f[_++] = 240 | g >>> 18, f[_++] = 128 | g >>> 12 & 63, f[_++] = 128 | g >>> 6 & 63, f[_++] = 128 | g & 63);
        return f;
      }, h = function(p, f) {
        var g;
        for (f = f || p.length, f > p.length && (f = p.length), g = f - 1; g >= 0 && (p[g] & 192) === 128; )
          g--;
        return g < 0 || g === 0 ? f : g + u[p[g]] > f ? g : f;
      }, v = function(p) {
        var f, g, y, w, _ = p.length, S = new Array(_ * 2);
        for (g = 0, f = 0; f < _; ) {
          if (y = p[f++], y < 128) {
            S[g++] = y;
            continue;
          }
          if (w = u[y], w > 4) {
            S[g++] = 65533, f += w - 1;
            continue;
          }
          for (y &= w === 2 ? 31 : w === 3 ? 15 : 7; w > 1 && f < _; )
            y = y << 6 | p[f++] & 63, w--;
          if (w > 1) {
            S[g++] = 65533;
            continue;
          }
          y < 65536 ? S[g++] = y : (y -= 65536, S[g++] = 55296 | y >> 10 & 1023, S[g++] = 56320 | y & 1023);
        }
        return S.length !== g && (S.subarray ? S = S.subarray(0, g) : S.length = g), s.applyFromCharCode(S);
      };
      i.utf8encode = function(f) {
        return o.nodebuffer ? a.newBufferFrom(f, "utf-8") : d(f);
      }, i.utf8decode = function(f) {
        return o.nodebuffer ? s.transformTo("nodebuffer", f).toString("utf-8") : (f = s.transformTo(o.uint8array ? "uint8array" : "array", f), v(f));
      };
      function m() {
        l.call(this, "utf-8 decode"), this.leftOver = null;
      }
      s.inherits(m, l), m.prototype.processChunk = function(p) {
        var f = s.transformTo(o.uint8array ? "uint8array" : "array", p.data);
        if (this.leftOver && this.leftOver.length) {
          if (o.uint8array) {
            var g = f;
            f = new Uint8Array(g.length + this.leftOver.length), f.set(this.leftOver, 0), f.set(g, this.leftOver.length);
          } else
            f = this.leftOver.concat(f);
          this.leftOver = null;
        }
        var y = h(f), w = f;
        y !== f.length && (o.uint8array ? (w = f.subarray(0, y), this.leftOver = f.subarray(y, f.length)) : (w = f.slice(0, y), this.leftOver = f.slice(y, f.length))), this.push({
          data: i.utf8decode(w),
          meta: p.meta
        });
      }, m.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({
          data: i.utf8decode(this.leftOver),
          meta: {}
        }), this.leftOver = null);
      }, i.Utf8DecodeWorker = m;
      function b() {
        l.call(this, "utf-8 encode");
      }
      s.inherits(b, l), b.prototype.processChunk = function(p) {
        this.push({
          data: i.utf8encode(p.data),
          meta: p.meta
        });
      }, i.Utf8EncodeWorker = b;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(n, r, i) {
      var s = n("./support"), o = n("./base64"), a = n("./nodejsUtils"), l = n("./external");
      n("setimmediate");
      function u(p) {
        var f = null;
        return s.uint8array ? f = new Uint8Array(p.length) : f = new Array(p.length), d(p, f);
      }
      i.newBlob = function(p, f) {
        i.checkSupport("blob");
        try {
          return new Blob([p], {
            type: f
          });
        } catch {
          try {
            var g = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder, y = new g();
            return y.append(p), y.getBlob(f);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      function c(p) {
        return p;
      }
      function d(p, f) {
        for (var g = 0; g < p.length; ++g)
          f[g] = p.charCodeAt(g) & 255;
        return f;
      }
      var h = {
        /**
         * Transform an array of int into a string, chunk by chunk.
         * See the performances notes on arrayLikeToString.
         * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
         * @param {String} type the type of the array.
         * @param {Integer} chunk the chunk size.
         * @return {String} the resulting string.
         * @throws Error if the chunk is too big for the stack.
         */
        stringifyByChunk: function(p, f, g) {
          var y = [], w = 0, _ = p.length;
          if (_ <= g)
            return String.fromCharCode.apply(null, p);
          for (; w < _; )
            f === "array" || f === "nodebuffer" ? y.push(String.fromCharCode.apply(null, p.slice(w, Math.min(w + g, _)))) : y.push(String.fromCharCode.apply(null, p.subarray(w, Math.min(w + g, _)))), w += g;
          return y.join("");
        },
        /**
         * Call String.fromCharCode on every item in the array.
         * This is the naive implementation, which generate A LOT of intermediate string.
         * This should be used when everything else fail.
         * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
         * @return {String} the result.
         */
        stringifyByChar: function(p) {
          for (var f = "", g = 0; g < p.length; g++)
            f += String.fromCharCode(p[g]);
          return f;
        },
        applyCanBeUsed: {
          /**
           * true if the browser accepts to use String.fromCharCode on Uint8Array
           */
          uint8array: function() {
            try {
              return s.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
            } catch {
              return !1;
            }
          }(),
          /**
           * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
           */
          nodebuffer: function() {
            try {
              return s.nodebuffer && String.fromCharCode.apply(null, a.allocBuffer(1)).length === 1;
            } catch {
              return !1;
            }
          }()
        }
      };
      function v(p) {
        var f = 65536, g = i.getTypeOf(p), y = !0;
        if (g === "uint8array" ? y = h.applyCanBeUsed.uint8array : g === "nodebuffer" && (y = h.applyCanBeUsed.nodebuffer), y)
          for (; f > 1; )
            try {
              return h.stringifyByChunk(p, g, f);
            } catch {
              f = Math.floor(f / 2);
            }
        return h.stringifyByChar(p);
      }
      i.applyFromCharCode = v;
      function m(p, f) {
        for (var g = 0; g < p.length; g++)
          f[g] = p[g];
        return f;
      }
      var b = {};
      b.string = {
        string: c,
        array: function(p) {
          return d(p, new Array(p.length));
        },
        arraybuffer: function(p) {
          return b.string.uint8array(p).buffer;
        },
        uint8array: function(p) {
          return d(p, new Uint8Array(p.length));
        },
        nodebuffer: function(p) {
          return d(p, a.allocBuffer(p.length));
        }
      }, b.array = {
        string: v,
        array: c,
        arraybuffer: function(p) {
          return new Uint8Array(p).buffer;
        },
        uint8array: function(p) {
          return new Uint8Array(p);
        },
        nodebuffer: function(p) {
          return a.newBufferFrom(p);
        }
      }, b.arraybuffer = {
        string: function(p) {
          return v(new Uint8Array(p));
        },
        array: function(p) {
          return m(new Uint8Array(p), new Array(p.byteLength));
        },
        arraybuffer: c,
        uint8array: function(p) {
          return new Uint8Array(p);
        },
        nodebuffer: function(p) {
          return a.newBufferFrom(new Uint8Array(p));
        }
      }, b.uint8array = {
        string: v,
        array: function(p) {
          return m(p, new Array(p.length));
        },
        arraybuffer: function(p) {
          return p.buffer;
        },
        uint8array: c,
        nodebuffer: function(p) {
          return a.newBufferFrom(p);
        }
      }, b.nodebuffer = {
        string: v,
        array: function(p) {
          return m(p, new Array(p.length));
        },
        arraybuffer: function(p) {
          return b.nodebuffer.uint8array(p).buffer;
        },
        uint8array: function(p) {
          return m(p, new Uint8Array(p.length));
        },
        nodebuffer: c
      }, i.transformTo = function(p, f) {
        if (f || (f = ""), !p)
          return f;
        i.checkSupport(p);
        var g = i.getTypeOf(f), y = b[g][p](f);
        return y;
      }, i.resolve = function(p) {
        for (var f = p.split("/"), g = [], y = 0; y < f.length; y++) {
          var w = f[y];
          w === "." || w === "" && y !== 0 && y !== f.length - 1 || (w === ".." ? g.pop() : g.push(w));
        }
        return g.join("/");
      }, i.getTypeOf = function(p) {
        if (typeof p == "string")
          return "string";
        if (Object.prototype.toString.call(p) === "[object Array]")
          return "array";
        if (s.nodebuffer && a.isBuffer(p))
          return "nodebuffer";
        if (s.uint8array && p instanceof Uint8Array)
          return "uint8array";
        if (s.arraybuffer && p instanceof ArrayBuffer)
          return "arraybuffer";
      }, i.checkSupport = function(p) {
        var f = s[p.toLowerCase()];
        if (!f)
          throw new Error(p + " is not supported by this platform");
      }, i.MAX_VALUE_16BITS = 65535, i.MAX_VALUE_32BITS = -1, i.pretty = function(p) {
        var f = "", g, y;
        for (y = 0; y < (p || "").length; y++)
          g = p.charCodeAt(y), f += "\\x" + (g < 16 ? "0" : "") + g.toString(16).toUpperCase();
        return f;
      }, i.delay = function(p, f, g) {
        setImmediate(function() {
          p.apply(g || null, f || []);
        });
      }, i.inherits = function(p, f) {
        var g = function() {
        };
        g.prototype = f.prototype, p.prototype = new g();
      }, i.extend = function() {
        var p = {}, f, g;
        for (f = 0; f < arguments.length; f++)
          for (g in arguments[f])
            Object.prototype.hasOwnProperty.call(arguments[f], g) && typeof p[g] > "u" && (p[g] = arguments[f][g]);
        return p;
      }, i.prepareContent = function(p, f, g, y, w) {
        var _ = l.Promise.resolve(f).then(function(S) {
          var A = s.blob && (S instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(S)) !== -1);
          return A && typeof FileReader < "u" ? new l.Promise(function(C, k) {
            var O = new FileReader();
            O.onload = function(N) {
              C(N.target.result);
            }, O.onerror = function(N) {
              k(N.target.error);
            }, O.readAsArrayBuffer(S);
          }) : S;
        });
        return _.then(function(S) {
          var A = i.getTypeOf(S);
          return A ? (A === "arraybuffer" ? S = i.transformTo("uint8array", S) : A === "string" && (w ? S = o.decode(S) : g && y !== !0 && (S = u(S))), S) : l.Promise.reject(
            new Error("Can't read the data of '" + p + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")
          );
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(n, r, i) {
      var s = n("./reader/readerFor"), o = n("./utils"), a = n("./signature"), l = n("./zipEntry"), u = n("./support");
      function c(d) {
        this.files = [], this.loadOptions = d;
      }
      c.prototype = {
        /**
         * Check that the reader is on the specified signature.
         * @param {string} expectedSignature the expected signature.
         * @throws {Error} if it is an other signature.
         */
        checkSignature: function(d) {
          if (!this.reader.readAndCheckSignature(d)) {
            this.reader.index -= 4;
            var h = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + o.pretty(h) + ", expected " + o.pretty(d) + ")");
          }
        },
        /**
         * Check if the given signature is at the given index.
         * @param {number} askedIndex the index to check.
         * @param {string} expectedSignature the signature to expect.
         * @return {boolean} true if the signature is here, false otherwise.
         */
        isSignature: function(d, h) {
          var v = this.reader.index;
          this.reader.setIndex(d);
          var m = this.reader.readString(4), b = m === h;
          return this.reader.setIndex(v), b;
        },
        /**
         * Read the end of the central directory.
         */
        readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var d = this.reader.readData(this.zipCommentLength), h = u.uint8array ? "uint8array" : "array", v = o.transformTo(h, d);
          this.zipComment = this.loadOptions.decodeFileName(v);
        },
        /**
         * Read the end of the Zip 64 central directory.
         * Not merged with the method readEndOfCentral :
         * The end of central can coexist with its Zip64 brother,
         * I don't want to read the wrong number of bytes !
         */
        readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var d = this.zip64EndOfCentralSize - 44, h = 0, v, m, b; h < d; )
            v = this.reader.readInt(2), m = this.reader.readInt(4), b = this.reader.readData(m), this.zip64ExtensibleData[v] = {
              id: v,
              length: m,
              value: b
            };
        },
        /**
         * Read the end of the Zip 64 central directory locator.
         */
        readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), this.disksCount > 1)
            throw new Error("Multi-volumes zip are not supported");
        },
        /**
         * Read the local files, based on the offset read in the central part.
         */
        readLocalFiles: function() {
          var d, h;
          for (d = 0; d < this.files.length; d++)
            h = this.files[d], this.reader.setIndex(h.localHeaderOffset), this.checkSignature(a.LOCAL_FILE_HEADER), h.readLocalPart(this.reader), h.handleUTF8(), h.processAttributes();
        },
        /**
         * Read the central directory.
         */
        readCentralDir: function() {
          var d;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(a.CENTRAL_FILE_HEADER); )
            d = new l({
              zip64: this.zip64
            }, this.loadOptions), d.readCentralPart(this.reader), this.files.push(d);
          if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        },
        /**
         * Read the end of central directory.
         */
        readEndOfCentral: function() {
          var d = this.reader.lastIndexOfSignature(a.CENTRAL_DIRECTORY_END);
          if (d < 0) {
            var h = !this.isSignature(0, a.LOCAL_FILE_HEADER);
            throw h ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
          }
          this.reader.setIndex(d);
          var v = d;
          if (this.checkSignature(a.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === o.MAX_VALUE_16BITS || this.diskWithCentralDirStart === o.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === o.MAX_VALUE_16BITS || this.centralDirRecords === o.MAX_VALUE_16BITS || this.centralDirSize === o.MAX_VALUE_32BITS || this.centralDirOffset === o.MAX_VALUE_32BITS) {
            if (this.zip64 = !0, d = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR), d < 0)
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(d), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, a.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var m = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (m += 20, m += 12 + this.zip64EndOfCentralSize);
          var b = v - m;
          if (b > 0)
            this.isSignature(v, a.CENTRAL_FILE_HEADER) || (this.reader.zero = b);
          else if (b < 0)
            throw new Error("Corrupted zip: missing " + Math.abs(b) + " bytes.");
        },
        prepareReader: function(d) {
          this.reader = s(d);
        },
        /**
         * Read a zip file and create ZipEntries.
         * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
         */
        load: function(d) {
          this.prepareReader(d), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        }
      }, r.exports = c;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(n, r, i) {
      var s = n("./reader/readerFor"), o = n("./utils"), a = n("./compressedObject"), l = n("./crc32"), u = n("./utf8"), c = n("./compressions"), d = n("./support"), h = 0, v = 3, m = function(p) {
        for (var f in c)
          if (Object.prototype.hasOwnProperty.call(c, f) && c[f].magic === p)
            return c[f];
        return null;
      };
      function b(p, f) {
        this.options = p, this.loadOptions = f;
      }
      b.prototype = {
        /**
         * say if the file is encrypted.
         * @return {boolean} true if the file is encrypted, false otherwise.
         */
        isEncrypted: function() {
          return (this.bitFlag & 1) === 1;
        },
        /**
         * say if the file has utf-8 filename/comment.
         * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
         */
        useUTF8: function() {
          return (this.bitFlag & 2048) === 2048;
        },
        /**
         * Read the local part of a zip file and add the info in this object.
         * @param {DataReader} reader the reader to use.
         */
        readLocalPart: function(p) {
          var f, g;
          if (p.skip(22), this.fileNameLength = p.readInt(2), g = p.readInt(2), this.fileName = p.readData(this.fileNameLength), p.skip(g), this.compressedSize === -1 || this.uncompressedSize === -1)
            throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if (f = m(this.compressionMethod), f === null)
            throw new Error("Corrupted zip : compression " + o.pretty(this.compressionMethod) + " unknown (inner file : " + o.transformTo("string", this.fileName) + ")");
          this.decompressed = new a(this.compressedSize, this.uncompressedSize, this.crc32, f, p.readData(this.compressedSize));
        },
        /**
         * Read the central part of a zip file and add the info in this object.
         * @param {DataReader} reader the reader to use.
         */
        readCentralPart: function(p) {
          this.versionMadeBy = p.readInt(2), p.skip(2), this.bitFlag = p.readInt(2), this.compressionMethod = p.readString(2), this.date = p.readDate(), this.crc32 = p.readInt(4), this.compressedSize = p.readInt(4), this.uncompressedSize = p.readInt(4);
          var f = p.readInt(2);
          if (this.extraFieldsLength = p.readInt(2), this.fileCommentLength = p.readInt(2), this.diskNumberStart = p.readInt(2), this.internalFileAttributes = p.readInt(2), this.externalFileAttributes = p.readInt(4), this.localHeaderOffset = p.readInt(4), this.isEncrypted())
            throw new Error("Encrypted zip are not supported");
          p.skip(f), this.readExtraFields(p), this.parseZIP64ExtraField(p), this.fileComment = p.readData(this.fileCommentLength);
        },
        /**
         * Parse the external file attributes and get the unix/dos permissions.
         */
        processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var p = this.versionMadeBy >> 8;
          this.dir = !!(this.externalFileAttributes & 16), p === h && (this.dosPermissions = this.externalFileAttributes & 63), p === v && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), !this.dir && this.fileNameStr.slice(-1) === "/" && (this.dir = !0);
        },
        /**
         * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
         * @param {DataReader} reader the reader to use.
         */
        parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var p = s(this.extraFields[1].value);
            this.uncompressedSize === o.MAX_VALUE_32BITS && (this.uncompressedSize = p.readInt(8)), this.compressedSize === o.MAX_VALUE_32BITS && (this.compressedSize = p.readInt(8)), this.localHeaderOffset === o.MAX_VALUE_32BITS && (this.localHeaderOffset = p.readInt(8)), this.diskNumberStart === o.MAX_VALUE_32BITS && (this.diskNumberStart = p.readInt(4));
          }
        },
        /**
         * Read the central part of a zip file and add the info in this object.
         * @param {DataReader} reader the reader to use.
         */
        readExtraFields: function(p) {
          var f = p.index + this.extraFieldsLength, g, y, w;
          for (this.extraFields || (this.extraFields = {}); p.index + 4 < f; )
            g = p.readInt(2), y = p.readInt(2), w = p.readData(y), this.extraFields[g] = {
              id: g,
              length: y,
              value: w
            };
          p.setIndex(f);
        },
        /**
         * Apply an UTF8 transformation if needed.
         */
        handleUTF8: function() {
          var p = d.uint8array ? "uint8array" : "array";
          if (this.useUTF8())
            this.fileNameStr = u.utf8decode(this.fileName), this.fileCommentStr = u.utf8decode(this.fileComment);
          else {
            var f = this.findExtraFieldUnicodePath();
            if (f !== null)
              this.fileNameStr = f;
            else {
              var g = o.transformTo(p, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(g);
            }
            var y = this.findExtraFieldUnicodeComment();
            if (y !== null)
              this.fileCommentStr = y;
            else {
              var w = o.transformTo(p, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(w);
            }
          }
        },
        /**
         * Find the unicode path declared in the extra field, if any.
         * @return {String} the unicode path, null otherwise.
         */
        findExtraFieldUnicodePath: function() {
          var p = this.extraFields[28789];
          if (p) {
            var f = s(p.value);
            return f.readInt(1) !== 1 || l(this.fileName) !== f.readInt(4) ? null : u.utf8decode(f.readData(p.length - 5));
          }
          return null;
        },
        /**
         * Find the unicode comment declared in the extra field, if any.
         * @return {String} the unicode comment, null otherwise.
         */
        findExtraFieldUnicodeComment: function() {
          var p = this.extraFields[25461];
          if (p) {
            var f = s(p.value);
            return f.readInt(1) !== 1 || l(this.fileComment) !== f.readInt(4) ? null : u.utf8decode(f.readData(p.length - 5));
          }
          return null;
        }
      }, r.exports = b;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(n, r, i) {
      var s = n("./stream/StreamHelper"), o = n("./stream/DataWorker"), a = n("./utf8"), l = n("./compressedObject"), u = n("./stream/GenericWorker"), c = function(m, b, p) {
        this.name = m, this.dir = p.dir, this.date = p.date, this.comment = p.comment, this.unixPermissions = p.unixPermissions, this.dosPermissions = p.dosPermissions, this._data = b, this._dataBinary = p.binary, this.options = {
          compression: p.compression,
          compressionOptions: p.compressionOptions
        };
      };
      c.prototype = {
        /**
         * Create an internal stream for the content of this object.
         * @param {String} type the type of each chunk.
         * @return StreamHelper the stream.
         */
        internalStream: function(m) {
          var b = null, p = "string";
          try {
            if (!m)
              throw new Error("No output type specified.");
            p = m.toLowerCase();
            var f = p === "string" || p === "text";
            (p === "binarystring" || p === "text") && (p = "string"), b = this._decompressWorker();
            var g = !this._dataBinary;
            g && !f && (b = b.pipe(new a.Utf8EncodeWorker())), !g && f && (b = b.pipe(new a.Utf8DecodeWorker()));
          } catch (y) {
            b = new u("error"), b.error(y);
          }
          return new s(b, p, "");
        },
        /**
         * Prepare the content in the asked type.
         * @param {String} type the type of the result.
         * @param {Function} onUpdate a function to call on each internal update.
         * @return Promise the promise of the result.
         */
        async: function(m, b) {
          return this.internalStream(m).accumulate(b);
        },
        /**
         * Prepare the content as a nodejs stream.
         * @param {String} type the type of each chunk.
         * @param {Function} onUpdate a function to call on each internal update.
         * @return Stream the stream.
         */
        nodeStream: function(m, b) {
          return this.internalStream(m || "nodebuffer").toNodejsStream(b);
        },
        /**
         * Return a worker for the compressed content.
         * @private
         * @param {Object} compression the compression object to use.
         * @param {Object} compressionOptions the options to use when compressing.
         * @return Worker the worker.
         */
        _compressWorker: function(m, b) {
          if (this._data instanceof l && this._data.compression.magic === m.magic)
            return this._data.getCompressedWorker();
          var p = this._decompressWorker();
          return this._dataBinary || (p = p.pipe(new a.Utf8EncodeWorker())), l.createWorkerFrom(p, m, b);
        },
        /**
         * Return a worker for the decompressed content.
         * @private
         * @return Worker the worker.
         */
        _decompressWorker: function() {
          return this._data instanceof l ? this._data.getContentWorker() : this._data instanceof u ? this._data : new o(this._data);
        }
      };
      for (var d = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], h = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, v = 0; v < d.length; v++)
        c.prototype[d[v]] = h;
      r.exports = c;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(n, r, i) {
      (function(s) {
        var o = s.MutationObserver || s.WebKitMutationObserver, a;
        if (o) {
          var l = 0, u = new o(m), c = s.document.createTextNode("");
          u.observe(c, {
            characterData: !0
          }), a = function() {
            c.data = l = ++l % 2;
          };
        } else if (!s.setImmediate && typeof s.MessageChannel < "u") {
          var d = new s.MessageChannel();
          d.port1.onmessage = m, a = function() {
            d.port2.postMessage(0);
          };
        } else
          "document" in s && "onreadystatechange" in s.document.createElement("script") ? a = function() {
            var p = s.document.createElement("script");
            p.onreadystatechange = function() {
              m(), p.onreadystatechange = null, p.parentNode.removeChild(p), p = null;
            }, s.document.documentElement.appendChild(p);
          } : a = function() {
            setTimeout(m, 0);
          };
        var h, v = [];
        function m() {
          h = !0;
          for (var p, f, g = v.length; g; ) {
            for (f = v, v = [], p = -1; ++p < g; )
              f[p]();
            g = v.length;
          }
          h = !1;
        }
        r.exports = b;
        function b(p) {
          v.push(p) === 1 && !h && a();
        }
      }).call(this, typeof yn < "u" ? yn : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(n, r, i) {
      var s = n("immediate");
      function o() {
      }
      var a = {}, l = ["REJECTED"], u = ["FULFILLED"], c = ["PENDING"];
      r.exports = d;
      function d(_) {
        if (typeof _ != "function")
          throw new TypeError("resolver must be a function");
        this.state = c, this.queue = [], this.outcome = void 0, _ !== o && b(this, _);
      }
      d.prototype.finally = function(_) {
        if (typeof _ != "function")
          return this;
        var S = this.constructor;
        return this.then(A, C);
        function A(k) {
          function O() {
            return k;
          }
          return S.resolve(_()).then(O);
        }
        function C(k) {
          function O() {
            throw k;
          }
          return S.resolve(_()).then(O);
        }
      }, d.prototype.catch = function(_) {
        return this.then(null, _);
      }, d.prototype.then = function(_, S) {
        if (typeof _ != "function" && this.state === u || typeof S != "function" && this.state === l)
          return this;
        var A = new this.constructor(o);
        if (this.state !== c) {
          var C = this.state === u ? _ : S;
          v(A, C, this.outcome);
        } else
          this.queue.push(new h(A, _, S));
        return A;
      };
      function h(_, S, A) {
        this.promise = _, typeof S == "function" && (this.onFulfilled = S, this.callFulfilled = this.otherCallFulfilled), typeof A == "function" && (this.onRejected = A, this.callRejected = this.otherCallRejected);
      }
      h.prototype.callFulfilled = function(_) {
        a.resolve(this.promise, _);
      }, h.prototype.otherCallFulfilled = function(_) {
        v(this.promise, this.onFulfilled, _);
      }, h.prototype.callRejected = function(_) {
        a.reject(this.promise, _);
      }, h.prototype.otherCallRejected = function(_) {
        v(this.promise, this.onRejected, _);
      };
      function v(_, S, A) {
        s(function() {
          var C;
          try {
            C = S(A);
          } catch (k) {
            return a.reject(_, k);
          }
          C === _ ? a.reject(_, new TypeError("Cannot resolve promise with itself")) : a.resolve(_, C);
        });
      }
      a.resolve = function(_, S) {
        var A = p(m, S);
        if (A.status === "error")
          return a.reject(_, A.value);
        var C = A.value;
        if (C)
          b(_, C);
        else {
          _.state = u, _.outcome = S;
          for (var k = -1, O = _.queue.length; ++k < O; )
            _.queue[k].callFulfilled(S);
        }
        return _;
      }, a.reject = function(_, S) {
        _.state = l, _.outcome = S;
        for (var A = -1, C = _.queue.length; ++A < C; )
          _.queue[A].callRejected(S);
        return _;
      };
      function m(_) {
        var S = _ && _.then;
        if (_ && (typeof _ == "object" || typeof _ == "function") && typeof S == "function")
          return function() {
            S.apply(_, arguments);
          };
      }
      function b(_, S) {
        var A = !1;
        function C(B) {
          A || (A = !0, a.reject(_, B));
        }
        function k(B) {
          A || (A = !0, a.resolve(_, B));
        }
        function O() {
          S(k, C);
        }
        var N = p(O);
        N.status === "error" && C(N.value);
      }
      function p(_, S) {
        var A = {};
        try {
          A.value = _(S), A.status = "success";
        } catch (C) {
          A.status = "error", A.value = C;
        }
        return A;
      }
      d.resolve = f;
      function f(_) {
        return _ instanceof this ? _ : a.resolve(new this(o), _);
      }
      d.reject = g;
      function g(_) {
        var S = new this(o);
        return a.reject(S, _);
      }
      d.all = y;
      function y(_) {
        var S = this;
        if (Object.prototype.toString.call(_) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var A = _.length, C = !1;
        if (!A)
          return this.resolve([]);
        for (var k = new Array(A), O = 0, N = -1, B = new this(o); ++N < A; )
          D(_[N], N);
        return B;
        function D(F, Z) {
          S.resolve(F).then(te, function(L) {
            C || (C = !0, a.reject(B, L));
          });
          function te(L) {
            k[Z] = L, ++O === A && !C && (C = !0, a.resolve(B, k));
          }
        }
      }
      d.race = w;
      function w(_) {
        var S = this;
        if (Object.prototype.toString.call(_) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var A = _.length, C = !1;
        if (!A)
          return this.resolve([]);
        for (var k = -1, O = new this(o); ++k < A; )
          N(_[k]);
        return O;
        function N(B) {
          S.resolve(B).then(function(D) {
            C || (C = !0, a.resolve(O, D));
          }, function(D) {
            C || (C = !0, a.reject(O, D));
          });
        }
      }
    }, { immediate: 36 }], 38: [function(n, r, i) {
      var s = n("./lib/utils/common").assign, o = n("./lib/deflate"), a = n("./lib/inflate"), l = n("./lib/zlib/constants"), u = {};
      s(u, o, a, l), r.exports = u;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(n, r, i) {
      var s = n("./zlib/deflate"), o = n("./utils/common"), a = n("./utils/strings"), l = n("./zlib/messages"), u = n("./zlib/zstream"), c = Object.prototype.toString, d = 0, h = 4, v = 0, m = 1, b = 2, p = -1, f = 0, g = 8;
      function y(A) {
        if (!(this instanceof y))
          return new y(A);
        this.options = o.assign({
          level: p,
          method: g,
          chunkSize: 16384,
          windowBits: 15,
          memLevel: 8,
          strategy: f,
          to: ""
        }, A || {});
        var C = this.options;
        C.raw && C.windowBits > 0 ? C.windowBits = -C.windowBits : C.gzip && C.windowBits > 0 && C.windowBits < 16 && (C.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new u(), this.strm.avail_out = 0;
        var k = s.deflateInit2(
          this.strm,
          C.level,
          C.method,
          C.windowBits,
          C.memLevel,
          C.strategy
        );
        if (k !== v)
          throw new Error(l[k]);
        if (C.header && s.deflateSetHeader(this.strm, C.header), C.dictionary) {
          var O;
          if (typeof C.dictionary == "string" ? O = a.string2buf(C.dictionary) : c.call(C.dictionary) === "[object ArrayBuffer]" ? O = new Uint8Array(C.dictionary) : O = C.dictionary, k = s.deflateSetDictionary(this.strm, O), k !== v)
            throw new Error(l[k]);
          this._dict_set = !0;
        }
      }
      y.prototype.push = function(A, C) {
        var k = this.strm, O = this.options.chunkSize, N, B;
        if (this.ended)
          return !1;
        B = C === ~~C ? C : C === !0 ? h : d, typeof A == "string" ? k.input = a.string2buf(A) : c.call(A) === "[object ArrayBuffer]" ? k.input = new Uint8Array(A) : k.input = A, k.next_in = 0, k.avail_in = k.input.length;
        do {
          if (k.avail_out === 0 && (k.output = new o.Buf8(O), k.next_out = 0, k.avail_out = O), N = s.deflate(k, B), N !== m && N !== v)
            return this.onEnd(N), this.ended = !0, !1;
          (k.avail_out === 0 || k.avail_in === 0 && (B === h || B === b)) && (this.options.to === "string" ? this.onData(a.buf2binstring(o.shrinkBuf(k.output, k.next_out))) : this.onData(o.shrinkBuf(k.output, k.next_out)));
        } while ((k.avail_in > 0 || k.avail_out === 0) && N !== m);
        return B === h ? (N = s.deflateEnd(this.strm), this.onEnd(N), this.ended = !0, N === v) : (B === b && (this.onEnd(v), k.avail_out = 0), !0);
      }, y.prototype.onData = function(A) {
        this.chunks.push(A);
      }, y.prototype.onEnd = function(A) {
        A === v && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = A, this.msg = this.strm.msg;
      };
      function w(A, C) {
        var k = new y(C);
        if (k.push(A, !0), k.err)
          throw k.msg || l[k.err];
        return k.result;
      }
      function _(A, C) {
        return C = C || {}, C.raw = !0, w(A, C);
      }
      function S(A, C) {
        return C = C || {}, C.gzip = !0, w(A, C);
      }
      i.Deflate = y, i.deflate = w, i.deflateRaw = _, i.gzip = S;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(n, r, i) {
      var s = n("./zlib/inflate"), o = n("./utils/common"), a = n("./utils/strings"), l = n("./zlib/constants"), u = n("./zlib/messages"), c = n("./zlib/zstream"), d = n("./zlib/gzheader"), h = Object.prototype.toString;
      function v(p) {
        if (!(this instanceof v))
          return new v(p);
        this.options = o.assign({
          chunkSize: 16384,
          windowBits: 0,
          to: ""
        }, p || {});
        var f = this.options;
        f.raw && f.windowBits >= 0 && f.windowBits < 16 && (f.windowBits = -f.windowBits, f.windowBits === 0 && (f.windowBits = -15)), f.windowBits >= 0 && f.windowBits < 16 && !(p && p.windowBits) && (f.windowBits += 32), f.windowBits > 15 && f.windowBits < 48 && (f.windowBits & 15 || (f.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new c(), this.strm.avail_out = 0;
        var g = s.inflateInit2(
          this.strm,
          f.windowBits
        );
        if (g !== l.Z_OK)
          throw new Error(u[g]);
        this.header = new d(), s.inflateGetHeader(this.strm, this.header);
      }
      v.prototype.push = function(p, f) {
        var g = this.strm, y = this.options.chunkSize, w = this.options.dictionary, _, S, A, C, k, O, N = !1;
        if (this.ended)
          return !1;
        S = f === ~~f ? f : f === !0 ? l.Z_FINISH : l.Z_NO_FLUSH, typeof p == "string" ? g.input = a.binstring2buf(p) : h.call(p) === "[object ArrayBuffer]" ? g.input = new Uint8Array(p) : g.input = p, g.next_in = 0, g.avail_in = g.input.length;
        do {
          if (g.avail_out === 0 && (g.output = new o.Buf8(y), g.next_out = 0, g.avail_out = y), _ = s.inflate(g, l.Z_NO_FLUSH), _ === l.Z_NEED_DICT && w && (typeof w == "string" ? O = a.string2buf(w) : h.call(w) === "[object ArrayBuffer]" ? O = new Uint8Array(w) : O = w, _ = s.inflateSetDictionary(this.strm, O)), _ === l.Z_BUF_ERROR && N === !0 && (_ = l.Z_OK, N = !1), _ !== l.Z_STREAM_END && _ !== l.Z_OK)
            return this.onEnd(_), this.ended = !0, !1;
          g.next_out && (g.avail_out === 0 || _ === l.Z_STREAM_END || g.avail_in === 0 && (S === l.Z_FINISH || S === l.Z_SYNC_FLUSH)) && (this.options.to === "string" ? (A = a.utf8border(g.output, g.next_out), C = g.next_out - A, k = a.buf2string(g.output, A), g.next_out = C, g.avail_out = y - C, C && o.arraySet(g.output, g.output, A, C, 0), this.onData(k)) : this.onData(o.shrinkBuf(g.output, g.next_out))), g.avail_in === 0 && g.avail_out === 0 && (N = !0);
        } while ((g.avail_in > 0 || g.avail_out === 0) && _ !== l.Z_STREAM_END);
        return _ === l.Z_STREAM_END && (S = l.Z_FINISH), S === l.Z_FINISH ? (_ = s.inflateEnd(this.strm), this.onEnd(_), this.ended = !0, _ === l.Z_OK) : (S === l.Z_SYNC_FLUSH && (this.onEnd(l.Z_OK), g.avail_out = 0), !0);
      }, v.prototype.onData = function(p) {
        this.chunks.push(p);
      }, v.prototype.onEnd = function(p) {
        p === l.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = p, this.msg = this.strm.msg;
      };
      function m(p, f) {
        var g = new v(f);
        if (g.push(p, !0), g.err)
          throw g.msg || u[g.err];
        return g.result;
      }
      function b(p, f) {
        return f = f || {}, f.raw = !0, m(p, f);
      }
      i.Inflate = v, i.inflate = m, i.inflateRaw = b, i.ungzip = m;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(n, r, i) {
      var s = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      i.assign = function(l) {
        for (var u = Array.prototype.slice.call(arguments, 1); u.length; ) {
          var c = u.shift();
          if (c) {
            if (typeof c != "object")
              throw new TypeError(c + "must be non-object");
            for (var d in c)
              c.hasOwnProperty(d) && (l[d] = c[d]);
          }
        }
        return l;
      }, i.shrinkBuf = function(l, u) {
        return l.length === u ? l : l.subarray ? l.subarray(0, u) : (l.length = u, l);
      };
      var o = {
        arraySet: function(l, u, c, d, h) {
          if (u.subarray && l.subarray) {
            l.set(u.subarray(c, c + d), h);
            return;
          }
          for (var v = 0; v < d; v++)
            l[h + v] = u[c + v];
        },
        // Join array of chunks to single array.
        flattenChunks: function(l) {
          var u, c, d, h, v, m;
          for (d = 0, u = 0, c = l.length; u < c; u++)
            d += l[u].length;
          for (m = new Uint8Array(d), h = 0, u = 0, c = l.length; u < c; u++)
            v = l[u], m.set(v, h), h += v.length;
          return m;
        }
      }, a = {
        arraySet: function(l, u, c, d, h) {
          for (var v = 0; v < d; v++)
            l[h + v] = u[c + v];
        },
        // Join array of chunks to single array.
        flattenChunks: function(l) {
          return [].concat.apply([], l);
        }
      };
      i.setTyped = function(l) {
        l ? (i.Buf8 = Uint8Array, i.Buf16 = Uint16Array, i.Buf32 = Int32Array, i.assign(i, o)) : (i.Buf8 = Array, i.Buf16 = Array, i.Buf32 = Array, i.assign(i, a));
      }, i.setTyped(s);
    }, {}], 42: [function(n, r, i) {
      var s = n("./common"), o = !0, a = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        o = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        a = !1;
      }
      for (var l = new s.Buf8(256), u = 0; u < 256; u++)
        l[u] = u >= 252 ? 6 : u >= 248 ? 5 : u >= 240 ? 4 : u >= 224 ? 3 : u >= 192 ? 2 : 1;
      l[254] = l[254] = 1, i.string2buf = function(d) {
        var h, v, m, b, p, f = d.length, g = 0;
        for (b = 0; b < f; b++)
          v = d.charCodeAt(b), (v & 64512) === 55296 && b + 1 < f && (m = d.charCodeAt(b + 1), (m & 64512) === 56320 && (v = 65536 + (v - 55296 << 10) + (m - 56320), b++)), g += v < 128 ? 1 : v < 2048 ? 2 : v < 65536 ? 3 : 4;
        for (h = new s.Buf8(g), p = 0, b = 0; p < g; b++)
          v = d.charCodeAt(b), (v & 64512) === 55296 && b + 1 < f && (m = d.charCodeAt(b + 1), (m & 64512) === 56320 && (v = 65536 + (v - 55296 << 10) + (m - 56320), b++)), v < 128 ? h[p++] = v : v < 2048 ? (h[p++] = 192 | v >>> 6, h[p++] = 128 | v & 63) : v < 65536 ? (h[p++] = 224 | v >>> 12, h[p++] = 128 | v >>> 6 & 63, h[p++] = 128 | v & 63) : (h[p++] = 240 | v >>> 18, h[p++] = 128 | v >>> 12 & 63, h[p++] = 128 | v >>> 6 & 63, h[p++] = 128 | v & 63);
        return h;
      };
      function c(d, h) {
        if (h < 65537 && (d.subarray && a || !d.subarray && o))
          return String.fromCharCode.apply(null, s.shrinkBuf(d, h));
        for (var v = "", m = 0; m < h; m++)
          v += String.fromCharCode(d[m]);
        return v;
      }
      i.buf2binstring = function(d) {
        return c(d, d.length);
      }, i.binstring2buf = function(d) {
        for (var h = new s.Buf8(d.length), v = 0, m = h.length; v < m; v++)
          h[v] = d.charCodeAt(v);
        return h;
      }, i.buf2string = function(d, h) {
        var v, m, b, p, f = h || d.length, g = new Array(f * 2);
        for (m = 0, v = 0; v < f; ) {
          if (b = d[v++], b < 128) {
            g[m++] = b;
            continue;
          }
          if (p = l[b], p > 4) {
            g[m++] = 65533, v += p - 1;
            continue;
          }
          for (b &= p === 2 ? 31 : p === 3 ? 15 : 7; p > 1 && v < f; )
            b = b << 6 | d[v++] & 63, p--;
          if (p > 1) {
            g[m++] = 65533;
            continue;
          }
          b < 65536 ? g[m++] = b : (b -= 65536, g[m++] = 55296 | b >> 10 & 1023, g[m++] = 56320 | b & 1023);
        }
        return c(g, m);
      }, i.utf8border = function(d, h) {
        var v;
        for (h = h || d.length, h > d.length && (h = d.length), v = h - 1; v >= 0 && (d[v] & 192) === 128; )
          v--;
        return v < 0 || v === 0 ? h : v + l[d[v]] > h ? v : h;
      };
    }, { "./common": 41 }], 43: [function(n, r, i) {
      function s(o, a, l, u) {
        for (var c = o & 65535 | 0, d = o >>> 16 & 65535 | 0, h = 0; l !== 0; ) {
          h = l > 2e3 ? 2e3 : l, l -= h;
          do
            c = c + a[u++] | 0, d = d + c | 0;
          while (--h);
          c %= 65521, d %= 65521;
        }
        return c | d << 16 | 0;
      }
      r.exports = s;
    }, {}], 44: [function(n, r, i) {
      r.exports = {
        /* Allowed flush values; see deflate() and inflate() below for details */
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        /* Return codes for the compression/decompression functions. Negative values
        * are errors, positive values are used for special but normal events.
        */
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        //Z_MEM_ERROR:     -4,
        Z_BUF_ERROR: -5,
        //Z_VERSION_ERROR: -6,
        /* compression levels */
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        /* Possible values of the data_type field (though see inflate()) */
        Z_BINARY: 0,
        Z_TEXT: 1,
        //Z_ASCII:                1, // = Z_TEXT (deprecated)
        Z_UNKNOWN: 2,
        /* The deflate compression method */
        Z_DEFLATED: 8
        //Z_NULL:                 null // Use -1 or null inline, depending on var type
      };
    }, {}], 45: [function(n, r, i) {
      function s() {
        for (var l, u = [], c = 0; c < 256; c++) {
          l = c;
          for (var d = 0; d < 8; d++)
            l = l & 1 ? 3988292384 ^ l >>> 1 : l >>> 1;
          u[c] = l;
        }
        return u;
      }
      var o = s();
      function a(l, u, c, d) {
        var h = o, v = d + c;
        l ^= -1;
        for (var m = d; m < v; m++)
          l = l >>> 8 ^ h[(l ^ u[m]) & 255];
        return l ^ -1;
      }
      r.exports = a;
    }, {}], 46: [function(n, r, i) {
      var s = n("../utils/common"), o = n("./trees"), a = n("./adler32"), l = n("./crc32"), u = n("./messages"), c = 0, d = 1, h = 3, v = 4, m = 5, b = 0, p = 1, f = -2, g = -3, y = -5, w = -1, _ = 1, S = 2, A = 3, C = 4, k = 0, O = 2, N = 8, B = 9, D = 15, F = 8, Z = 29, te = 256, L = te + 1 + Z, V = 30, H = 19, ie = 2 * L + 1, ne = 15, Y = 3, de = 258, ue = de + Y + 1, Te = 32, _e = 42, Fe = 69, Ce = 73, tt = 91, je = 103, $e = 113, ht = 666, nt = 1, Et = 2, yt = 3, Nt = 4, ot = 3;
      function bt(E, J) {
        return E.msg = u[J], J;
      }
      function Kt(E) {
        return (E << 1) - (E > 4 ? 9 : 0);
      }
      function wt(E) {
        for (var J = E.length; --J >= 0; )
          E[J] = 0;
      }
      function xt(E) {
        var J = E.state, se = J.pending;
        se > E.avail_out && (se = E.avail_out), se !== 0 && (s.arraySet(E.output, J.pending_buf, J.pending_out, se, E.next_out), E.next_out += se, J.pending_out += se, E.total_out += se, E.avail_out -= se, J.pending -= se, J.pending === 0 && (J.pending_out = 0));
      }
      function lt(E, J) {
        o._tr_flush_block(E, E.block_start >= 0 ? E.block_start : -1, E.strstart - E.block_start, J), E.block_start = E.strstart, xt(E.strm);
      }
      function qe(E, J) {
        E.pending_buf[E.pending++] = J;
      }
      function Rt(E, J) {
        E.pending_buf[E.pending++] = J >>> 8 & 255, E.pending_buf[E.pending++] = J & 255;
      }
      function be(E, J, se, I) {
        var W = E.avail_in;
        return W > I && (W = I), W === 0 ? 0 : (E.avail_in -= W, s.arraySet(J, E.input, E.next_in, W, se), E.state.wrap === 1 ? E.adler = a(E.adler, J, W, se) : E.state.wrap === 2 && (E.adler = l(E.adler, J, W, se)), E.next_in += W, E.total_in += W, W);
      }
      function Ue(E, J) {
        var se = E.max_chain_length, I = E.strstart, W, re, Pe = E.prev_length, Oe = E.nice_match, Be = E.strstart > E.w_size - ue ? E.strstart - (E.w_size - ue) : 0, Ye = E.window, ln = E.w_mask, Wt = E.prev, pt = E.strstart + de, Zt = Ye[I + Pe - 1], fn = Ye[I + Pe];
        E.prev_length >= E.good_match && (se >>= 2), Oe > E.lookahead && (Oe = E.lookahead);
        do
          if (W = J, !(Ye[W + Pe] !== fn || Ye[W + Pe - 1] !== Zt || Ye[W] !== Ye[I] || Ye[++W] !== Ye[I + 1])) {
            I += 2, W++;
            do
              ;
            while (Ye[++I] === Ye[++W] && Ye[++I] === Ye[++W] && Ye[++I] === Ye[++W] && Ye[++I] === Ye[++W] && Ye[++I] === Ye[++W] && Ye[++I] === Ye[++W] && Ye[++I] === Ye[++W] && Ye[++I] === Ye[++W] && I < pt);
            if (re = de - (pt - I), I = pt - de, re > Pe) {
              if (E.match_start = J, Pe = re, re >= Oe)
                break;
              Zt = Ye[I + Pe - 1], fn = Ye[I + Pe];
            }
          }
        while ((J = Wt[J & ln]) > Be && --se !== 0);
        return Pe <= E.lookahead ? Pe : E.lookahead;
      }
      function at(E) {
        var J = E.w_size, se, I, W, re, Pe;
        do {
          if (re = E.window_size - E.lookahead - E.strstart, E.strstart >= J + (J - ue)) {
            s.arraySet(E.window, E.window, J, J, 0), E.match_start -= J, E.strstart -= J, E.block_start -= J, I = E.hash_size, se = I;
            do
              W = E.head[--se], E.head[se] = W >= J ? W - J : 0;
            while (--I);
            I = J, se = I;
            do
              W = E.prev[--se], E.prev[se] = W >= J ? W - J : 0;
            while (--I);
            re += J;
          }
          if (E.strm.avail_in === 0)
            break;
          if (I = be(E.strm, E.window, E.strstart + E.lookahead, re), E.lookahead += I, E.lookahead + E.insert >= Y)
            for (Pe = E.strstart - E.insert, E.ins_h = E.window[Pe], E.ins_h = (E.ins_h << E.hash_shift ^ E.window[Pe + 1]) & E.hash_mask; E.insert && (E.ins_h = (E.ins_h << E.hash_shift ^ E.window[Pe + Y - 1]) & E.hash_mask, E.prev[Pe & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = Pe, Pe++, E.insert--, !(E.lookahead + E.insert < Y)); )
              ;
        } while (E.lookahead < ue && E.strm.avail_in !== 0);
      }
      function Pt(E, J) {
        var se = 65535;
        for (se > E.pending_buf_size - 5 && (se = E.pending_buf_size - 5); ; ) {
          if (E.lookahead <= 1) {
            if (at(E), E.lookahead === 0 && J === c)
              return nt;
            if (E.lookahead === 0)
              break;
          }
          E.strstart += E.lookahead, E.lookahead = 0;
          var I = E.block_start + se;
          if ((E.strstart === 0 || E.strstart >= I) && (E.lookahead = E.strstart - I, E.strstart = I, lt(E, !1), E.strm.avail_out === 0) || E.strstart - E.block_start >= E.w_size - ue && (lt(E, !1), E.strm.avail_out === 0))
            return nt;
        }
        return E.insert = 0, J === v ? (lt(E, !0), E.strm.avail_out === 0 ? yt : Nt) : (E.strstart > E.block_start && (lt(E, !1), E.strm.avail_out === 0), nt);
      }
      function Qt(E, J) {
        for (var se, I; ; ) {
          if (E.lookahead < ue) {
            if (at(E), E.lookahead < ue && J === c)
              return nt;
            if (E.lookahead === 0)
              break;
          }
          if (se = 0, E.lookahead >= Y && (E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + Y - 1]) & E.hash_mask, se = E.prev[E.strstart & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = E.strstart), se !== 0 && E.strstart - se <= E.w_size - ue && (E.match_length = Ue(E, se)), E.match_length >= Y)
            if (I = o._tr_tally(E, E.strstart - E.match_start, E.match_length - Y), E.lookahead -= E.match_length, E.match_length <= E.max_lazy_match && E.lookahead >= Y) {
              E.match_length--;
              do
                E.strstart++, E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + Y - 1]) & E.hash_mask, se = E.prev[E.strstart & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = E.strstart;
              while (--E.match_length !== 0);
              E.strstart++;
            } else
              E.strstart += E.match_length, E.match_length = 0, E.ins_h = E.window[E.strstart], E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + 1]) & E.hash_mask;
          else
            I = o._tr_tally(E, 0, E.window[E.strstart]), E.lookahead--, E.strstart++;
          if (I && (lt(E, !1), E.strm.avail_out === 0))
            return nt;
        }
        return E.insert = E.strstart < Y - 1 ? E.strstart : Y - 1, J === v ? (lt(E, !0), E.strm.avail_out === 0 ? yt : Nt) : E.last_lit && (lt(E, !1), E.strm.avail_out === 0) ? nt : Et;
      }
      function Ie(E, J) {
        for (var se, I, W; ; ) {
          if (E.lookahead < ue) {
            if (at(E), E.lookahead < ue && J === c)
              return nt;
            if (E.lookahead === 0)
              break;
          }
          if (se = 0, E.lookahead >= Y && (E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + Y - 1]) & E.hash_mask, se = E.prev[E.strstart & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = E.strstart), E.prev_length = E.match_length, E.prev_match = E.match_start, E.match_length = Y - 1, se !== 0 && E.prev_length < E.max_lazy_match && E.strstart - se <= E.w_size - ue && (E.match_length = Ue(E, se), E.match_length <= 5 && (E.strategy === _ || E.match_length === Y && E.strstart - E.match_start > 4096) && (E.match_length = Y - 1)), E.prev_length >= Y && E.match_length <= E.prev_length) {
            W = E.strstart + E.lookahead - Y, I = o._tr_tally(E, E.strstart - 1 - E.prev_match, E.prev_length - Y), E.lookahead -= E.prev_length - 1, E.prev_length -= 2;
            do
              ++E.strstart <= W && (E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + Y - 1]) & E.hash_mask, se = E.prev[E.strstart & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = E.strstart);
            while (--E.prev_length !== 0);
            if (E.match_available = 0, E.match_length = Y - 1, E.strstart++, I && (lt(E, !1), E.strm.avail_out === 0))
              return nt;
          } else if (E.match_available) {
            if (I = o._tr_tally(E, 0, E.window[E.strstart - 1]), I && lt(E, !1), E.strstart++, E.lookahead--, E.strm.avail_out === 0)
              return nt;
          } else
            E.match_available = 1, E.strstart++, E.lookahead--;
        }
        return E.match_available && (I = o._tr_tally(E, 0, E.window[E.strstart - 1]), E.match_available = 0), E.insert = E.strstart < Y - 1 ? E.strstart : Y - 1, J === v ? (lt(E, !0), E.strm.avail_out === 0 ? yt : Nt) : E.last_lit && (lt(E, !1), E.strm.avail_out === 0) ? nt : Et;
      }
      function Ve(E, J) {
        for (var se, I, W, re, Pe = E.window; ; ) {
          if (E.lookahead <= de) {
            if (at(E), E.lookahead <= de && J === c)
              return nt;
            if (E.lookahead === 0)
              break;
          }
          if (E.match_length = 0, E.lookahead >= Y && E.strstart > 0 && (W = E.strstart - 1, I = Pe[W], I === Pe[++W] && I === Pe[++W] && I === Pe[++W])) {
            re = E.strstart + de;
            do
              ;
            while (I === Pe[++W] && I === Pe[++W] && I === Pe[++W] && I === Pe[++W] && I === Pe[++W] && I === Pe[++W] && I === Pe[++W] && I === Pe[++W] && W < re);
            E.match_length = de - (re - W), E.match_length > E.lookahead && (E.match_length = E.lookahead);
          }
          if (E.match_length >= Y ? (se = o._tr_tally(E, 1, E.match_length - Y), E.lookahead -= E.match_length, E.strstart += E.match_length, E.match_length = 0) : (se = o._tr_tally(E, 0, E.window[E.strstart]), E.lookahead--, E.strstart++), se && (lt(E, !1), E.strm.avail_out === 0))
            return nt;
        }
        return E.insert = 0, J === v ? (lt(E, !0), E.strm.avail_out === 0 ? yt : Nt) : E.last_lit && (lt(E, !1), E.strm.avail_out === 0) ? nt : Et;
      }
      function Je(E, J) {
        for (var se; ; ) {
          if (E.lookahead === 0 && (at(E), E.lookahead === 0)) {
            if (J === c)
              return nt;
            break;
          }
          if (E.match_length = 0, se = o._tr_tally(E, 0, E.window[E.strstart]), E.lookahead--, E.strstart++, se && (lt(E, !1), E.strm.avail_out === 0))
            return nt;
        }
        return E.insert = 0, J === v ? (lt(E, !0), E.strm.avail_out === 0 ? yt : Nt) : E.last_lit && (lt(E, !1), E.strm.avail_out === 0) ? nt : Et;
      }
      function He(E, J, se, I, W) {
        this.good_length = E, this.max_lazy = J, this.nice_length = se, this.max_chain = I, this.func = W;
      }
      var Qe;
      Qe = [
        /*      good lazy nice chain */
        new He(0, 0, 0, 0, Pt),
        /* 0 store only */
        new He(4, 4, 8, 4, Qt),
        /* 1 max speed, no lazy matches */
        new He(4, 5, 16, 8, Qt),
        /* 2 */
        new He(4, 6, 32, 32, Qt),
        /* 3 */
        new He(4, 4, 16, 16, Ie),
        /* 4 lazy matches */
        new He(8, 16, 32, 32, Ie),
        /* 5 */
        new He(8, 16, 128, 128, Ie),
        /* 6 */
        new He(8, 32, 128, 256, Ie),
        /* 7 */
        new He(32, 128, 258, 1024, Ie),
        /* 8 */
        new He(32, 258, 258, 4096, Ie)
        /* 9 max compression */
      ];
      function At(E) {
        E.window_size = 2 * E.w_size, wt(E.head), E.max_lazy_match = Qe[E.level].max_lazy, E.good_match = Qe[E.level].good_length, E.nice_match = Qe[E.level].nice_length, E.max_chain_length = Qe[E.level].max_chain, E.strstart = 0, E.block_start = 0, E.lookahead = 0, E.insert = 0, E.match_length = E.prev_length = Y - 1, E.match_available = 0, E.ins_h = 0;
      }
      function P() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = N, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new s.Buf16(ie * 2), this.dyn_dtree = new s.Buf16((2 * V + 1) * 2), this.bl_tree = new s.Buf16((2 * H + 1) * 2), wt(this.dyn_ltree), wt(this.dyn_dtree), wt(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new s.Buf16(ne + 1), this.heap = new s.Buf16(2 * L + 1), wt(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new s.Buf16(2 * L + 1), wt(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function he(E) {
        var J;
        return !E || !E.state ? bt(E, f) : (E.total_in = E.total_out = 0, E.data_type = O, J = E.state, J.pending = 0, J.pending_out = 0, J.wrap < 0 && (J.wrap = -J.wrap), J.status = J.wrap ? _e : $e, E.adler = J.wrap === 2 ? 0 : 1, J.last_flush = c, o._tr_init(J), b);
      }
      function ge(E) {
        var J = he(E);
        return J === b && At(E.state), J;
      }
      function Ne(E, J) {
        return !E || !E.state || E.state.wrap !== 2 ? f : (E.state.gzhead = J, b);
      }
      function G(E, J, se, I, W, re) {
        if (!E)
          return f;
        var Pe = 1;
        if (J === w && (J = 6), I < 0 ? (Pe = 0, I = -I) : I > 15 && (Pe = 2, I -= 16), W < 1 || W > B || se !== N || I < 8 || I > 15 || J < 0 || J > 9 || re < 0 || re > C)
          return bt(E, f);
        I === 8 && (I = 9);
        var Oe = new P();
        return E.state = Oe, Oe.strm = E, Oe.wrap = Pe, Oe.gzhead = null, Oe.w_bits = I, Oe.w_size = 1 << Oe.w_bits, Oe.w_mask = Oe.w_size - 1, Oe.hash_bits = W + 7, Oe.hash_size = 1 << Oe.hash_bits, Oe.hash_mask = Oe.hash_size - 1, Oe.hash_shift = ~~((Oe.hash_bits + Y - 1) / Y), Oe.window = new s.Buf8(Oe.w_size * 2), Oe.head = new s.Buf16(Oe.hash_size), Oe.prev = new s.Buf16(Oe.w_size), Oe.lit_bufsize = 1 << W + 6, Oe.pending_buf_size = Oe.lit_bufsize * 4, Oe.pending_buf = new s.Buf8(Oe.pending_buf_size), Oe.d_buf = 1 * Oe.lit_bufsize, Oe.l_buf = (1 + 2) * Oe.lit_bufsize, Oe.level = J, Oe.strategy = re, Oe.method = se, ge(E);
      }
      function ce(E, J) {
        return G(E, J, N, D, F, k);
      }
      function T(E, J) {
        var se, I, W, re;
        if (!E || !E.state || J > m || J < 0)
          return E ? bt(E, f) : f;
        if (I = E.state, !E.output || !E.input && E.avail_in !== 0 || I.status === ht && J !== v)
          return bt(E, E.avail_out === 0 ? y : f);
        if (I.strm = E, se = I.last_flush, I.last_flush = J, I.status === _e)
          if (I.wrap === 2)
            E.adler = 0, qe(I, 31), qe(I, 139), qe(I, 8), I.gzhead ? (qe(
              I,
              (I.gzhead.text ? 1 : 0) + (I.gzhead.hcrc ? 2 : 0) + (I.gzhead.extra ? 4 : 0) + (I.gzhead.name ? 8 : 0) + (I.gzhead.comment ? 16 : 0)
            ), qe(I, I.gzhead.time & 255), qe(I, I.gzhead.time >> 8 & 255), qe(I, I.gzhead.time >> 16 & 255), qe(I, I.gzhead.time >> 24 & 255), qe(I, I.level === 9 ? 2 : I.strategy >= S || I.level < 2 ? 4 : 0), qe(I, I.gzhead.os & 255), I.gzhead.extra && I.gzhead.extra.length && (qe(I, I.gzhead.extra.length & 255), qe(I, I.gzhead.extra.length >> 8 & 255)), I.gzhead.hcrc && (E.adler = l(E.adler, I.pending_buf, I.pending, 0)), I.gzindex = 0, I.status = Fe) : (qe(I, 0), qe(I, 0), qe(I, 0), qe(I, 0), qe(I, 0), qe(I, I.level === 9 ? 2 : I.strategy >= S || I.level < 2 ? 4 : 0), qe(I, ot), I.status = $e);
          else {
            var Pe = N + (I.w_bits - 8 << 4) << 8, Oe = -1;
            I.strategy >= S || I.level < 2 ? Oe = 0 : I.level < 6 ? Oe = 1 : I.level === 6 ? Oe = 2 : Oe = 3, Pe |= Oe << 6, I.strstart !== 0 && (Pe |= Te), Pe += 31 - Pe % 31, I.status = $e, Rt(I, Pe), I.strstart !== 0 && (Rt(I, E.adler >>> 16), Rt(I, E.adler & 65535)), E.adler = 1;
          }
        if (I.status === Fe)
          if (I.gzhead.extra) {
            for (W = I.pending; I.gzindex < (I.gzhead.extra.length & 65535) && !(I.pending === I.pending_buf_size && (I.gzhead.hcrc && I.pending > W && (E.adler = l(E.adler, I.pending_buf, I.pending - W, W)), xt(E), W = I.pending, I.pending === I.pending_buf_size)); )
              qe(I, I.gzhead.extra[I.gzindex] & 255), I.gzindex++;
            I.gzhead.hcrc && I.pending > W && (E.adler = l(E.adler, I.pending_buf, I.pending - W, W)), I.gzindex === I.gzhead.extra.length && (I.gzindex = 0, I.status = Ce);
          } else
            I.status = Ce;
        if (I.status === Ce)
          if (I.gzhead.name) {
            W = I.pending;
            do {
              if (I.pending === I.pending_buf_size && (I.gzhead.hcrc && I.pending > W && (E.adler = l(E.adler, I.pending_buf, I.pending - W, W)), xt(E), W = I.pending, I.pending === I.pending_buf_size)) {
                re = 1;
                break;
              }
              I.gzindex < I.gzhead.name.length ? re = I.gzhead.name.charCodeAt(I.gzindex++) & 255 : re = 0, qe(I, re);
            } while (re !== 0);
            I.gzhead.hcrc && I.pending > W && (E.adler = l(E.adler, I.pending_buf, I.pending - W, W)), re === 0 && (I.gzindex = 0, I.status = tt);
          } else
            I.status = tt;
        if (I.status === tt)
          if (I.gzhead.comment) {
            W = I.pending;
            do {
              if (I.pending === I.pending_buf_size && (I.gzhead.hcrc && I.pending > W && (E.adler = l(E.adler, I.pending_buf, I.pending - W, W)), xt(E), W = I.pending, I.pending === I.pending_buf_size)) {
                re = 1;
                break;
              }
              I.gzindex < I.gzhead.comment.length ? re = I.gzhead.comment.charCodeAt(I.gzindex++) & 255 : re = 0, qe(I, re);
            } while (re !== 0);
            I.gzhead.hcrc && I.pending > W && (E.adler = l(E.adler, I.pending_buf, I.pending - W, W)), re === 0 && (I.status = je);
          } else
            I.status = je;
        if (I.status === je && (I.gzhead.hcrc ? (I.pending + 2 > I.pending_buf_size && xt(E), I.pending + 2 <= I.pending_buf_size && (qe(I, E.adler & 255), qe(I, E.adler >> 8 & 255), E.adler = 0, I.status = $e)) : I.status = $e), I.pending !== 0) {
          if (xt(E), E.avail_out === 0)
            return I.last_flush = -1, b;
        } else if (E.avail_in === 0 && Kt(J) <= Kt(se) && J !== v)
          return bt(E, y);
        if (I.status === ht && E.avail_in !== 0)
          return bt(E, y);
        if (E.avail_in !== 0 || I.lookahead !== 0 || J !== c && I.status !== ht) {
          var Be = I.strategy === S ? Je(I, J) : I.strategy === A ? Ve(I, J) : Qe[I.level].func(I, J);
          if ((Be === yt || Be === Nt) && (I.status = ht), Be === nt || Be === yt)
            return E.avail_out === 0 && (I.last_flush = -1), b;
          if (Be === Et && (J === d ? o._tr_align(I) : J !== m && (o._tr_stored_block(I, 0, 0, !1), J === h && (wt(I.head), I.lookahead === 0 && (I.strstart = 0, I.block_start = 0, I.insert = 0))), xt(E), E.avail_out === 0))
            return I.last_flush = -1, b;
        }
        return J !== v ? b : I.wrap <= 0 ? p : (I.wrap === 2 ? (qe(I, E.adler & 255), qe(I, E.adler >> 8 & 255), qe(I, E.adler >> 16 & 255), qe(I, E.adler >> 24 & 255), qe(I, E.total_in & 255), qe(I, E.total_in >> 8 & 255), qe(I, E.total_in >> 16 & 255), qe(I, E.total_in >> 24 & 255)) : (Rt(I, E.adler >>> 16), Rt(I, E.adler & 65535)), xt(E), I.wrap > 0 && (I.wrap = -I.wrap), I.pending !== 0 ? b : p);
      }
      function z(E) {
        var J;
        return !E || !E.state ? f : (J = E.state.status, J !== _e && J !== Fe && J !== Ce && J !== tt && J !== je && J !== $e && J !== ht ? bt(E, f) : (E.state = null, J === $e ? bt(E, g) : b));
      }
      function ae(E, J) {
        var se = J.length, I, W, re, Pe, Oe, Be, Ye, ln;
        if (!E || !E.state || (I = E.state, Pe = I.wrap, Pe === 2 || Pe === 1 && I.status !== _e || I.lookahead))
          return f;
        for (Pe === 1 && (E.adler = a(E.adler, J, se, 0)), I.wrap = 0, se >= I.w_size && (Pe === 0 && (wt(I.head), I.strstart = 0, I.block_start = 0, I.insert = 0), ln = new s.Buf8(I.w_size), s.arraySet(ln, J, se - I.w_size, I.w_size, 0), J = ln, se = I.w_size), Oe = E.avail_in, Be = E.next_in, Ye = E.input, E.avail_in = se, E.next_in = 0, E.input = J, at(I); I.lookahead >= Y; ) {
          W = I.strstart, re = I.lookahead - (Y - 1);
          do
            I.ins_h = (I.ins_h << I.hash_shift ^ I.window[W + Y - 1]) & I.hash_mask, I.prev[W & I.w_mask] = I.head[I.ins_h], I.head[I.ins_h] = W, W++;
          while (--re);
          I.strstart = W, I.lookahead = Y - 1, at(I);
        }
        return I.strstart += I.lookahead, I.block_start = I.strstart, I.insert = I.lookahead, I.lookahead = 0, I.match_length = I.prev_length = Y - 1, I.match_available = 0, E.next_in = Be, E.input = Ye, E.avail_in = Oe, I.wrap = Pe, b;
      }
      i.deflateInit = ce, i.deflateInit2 = G, i.deflateReset = ge, i.deflateResetKeep = he, i.deflateSetHeader = Ne, i.deflate = T, i.deflateEnd = z, i.deflateSetDictionary = ae, i.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(n, r, i) {
      function s() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      }
      r.exports = s;
    }, {}], 48: [function(n, r, i) {
      var s = 30, o = 12;
      r.exports = function(l, u) {
        var c, d, h, v, m, b, p, f, g, y, w, _, S, A, C, k, O, N, B, D, F, Z, te, L, V;
        c = l.state, d = l.next_in, L = l.input, h = d + (l.avail_in - 5), v = l.next_out, V = l.output, m = v - (u - l.avail_out), b = v + (l.avail_out - 257), p = c.dmax, f = c.wsize, g = c.whave, y = c.wnext, w = c.window, _ = c.hold, S = c.bits, A = c.lencode, C = c.distcode, k = (1 << c.lenbits) - 1, O = (1 << c.distbits) - 1;
        e:
          do {
            S < 15 && (_ += L[d++] << S, S += 8, _ += L[d++] << S, S += 8), N = A[_ & k];
            t:
              for (; ; ) {
                if (B = N >>> 24, _ >>>= B, S -= B, B = N >>> 16 & 255, B === 0)
                  V[v++] = N & 65535;
                else if (B & 16) {
                  D = N & 65535, B &= 15, B && (S < B && (_ += L[d++] << S, S += 8), D += _ & (1 << B) - 1, _ >>>= B, S -= B), S < 15 && (_ += L[d++] << S, S += 8, _ += L[d++] << S, S += 8), N = C[_ & O];
                  n:
                    for (; ; ) {
                      if (B = N >>> 24, _ >>>= B, S -= B, B = N >>> 16 & 255, B & 16) {
                        if (F = N & 65535, B &= 15, S < B && (_ += L[d++] << S, S += 8, S < B && (_ += L[d++] << S, S += 8)), F += _ & (1 << B) - 1, F > p) {
                          l.msg = "invalid distance too far back", c.mode = s;
                          break e;
                        }
                        if (_ >>>= B, S -= B, B = v - m, F > B) {
                          if (B = F - B, B > g && c.sane) {
                            l.msg = "invalid distance too far back", c.mode = s;
                            break e;
                          }
                          if (Z = 0, te = w, y === 0) {
                            if (Z += f - B, B < D) {
                              D -= B;
                              do
                                V[v++] = w[Z++];
                              while (--B);
                              Z = v - F, te = V;
                            }
                          } else if (y < B) {
                            if (Z += f + y - B, B -= y, B < D) {
                              D -= B;
                              do
                                V[v++] = w[Z++];
                              while (--B);
                              if (Z = 0, y < D) {
                                B = y, D -= B;
                                do
                                  V[v++] = w[Z++];
                                while (--B);
                                Z = v - F, te = V;
                              }
                            }
                          } else if (Z += y - B, B < D) {
                            D -= B;
                            do
                              V[v++] = w[Z++];
                            while (--B);
                            Z = v - F, te = V;
                          }
                          for (; D > 2; )
                            V[v++] = te[Z++], V[v++] = te[Z++], V[v++] = te[Z++], D -= 3;
                          D && (V[v++] = te[Z++], D > 1 && (V[v++] = te[Z++]));
                        } else {
                          Z = v - F;
                          do
                            V[v++] = V[Z++], V[v++] = V[Z++], V[v++] = V[Z++], D -= 3;
                          while (D > 2);
                          D && (V[v++] = V[Z++], D > 1 && (V[v++] = V[Z++]));
                        }
                      } else if (B & 64) {
                        l.msg = "invalid distance code", c.mode = s;
                        break e;
                      } else {
                        N = C[(N & 65535) + (_ & (1 << B) - 1)];
                        continue n;
                      }
                      break;
                    }
                } else if (B & 64)
                  if (B & 32) {
                    c.mode = o;
                    break e;
                  } else {
                    l.msg = "invalid literal/length code", c.mode = s;
                    break e;
                  }
                else {
                  N = A[(N & 65535) + (_ & (1 << B) - 1)];
                  continue t;
                }
                break;
              }
          } while (d < h && v < b);
        D = S >> 3, d -= D, S -= D << 3, _ &= (1 << S) - 1, l.next_in = d, l.next_out = v, l.avail_in = d < h ? 5 + (h - d) : 5 - (d - h), l.avail_out = v < b ? 257 + (b - v) : 257 - (v - b), c.hold = _, c.bits = S;
      };
    }, {}], 49: [function(n, r, i) {
      var s = n("../utils/common"), o = n("./adler32"), a = n("./crc32"), l = n("./inffast"), u = n("./inftrees"), c = 0, d = 1, h = 2, v = 4, m = 5, b = 6, p = 0, f = 1, g = 2, y = -2, w = -3, _ = -4, S = -5, A = 8, C = 1, k = 2, O = 3, N = 4, B = 5, D = 6, F = 7, Z = 8, te = 9, L = 10, V = 11, H = 12, ie = 13, ne = 14, Y = 15, de = 16, ue = 17, Te = 18, _e = 19, Fe = 20, Ce = 21, tt = 22, je = 23, $e = 24, ht = 25, nt = 26, Et = 27, yt = 28, Nt = 29, ot = 30, bt = 31, Kt = 32, wt = 852, xt = 592, lt = 15, qe = lt;
      function Rt(G) {
        return (G >>> 24 & 255) + (G >>> 8 & 65280) + ((G & 65280) << 8) + ((G & 255) << 24);
      }
      function be() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new s.Buf16(320), this.work = new s.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function Ue(G) {
        var ce;
        return !G || !G.state ? y : (ce = G.state, G.total_in = G.total_out = ce.total = 0, G.msg = "", ce.wrap && (G.adler = ce.wrap & 1), ce.mode = C, ce.last = 0, ce.havedict = 0, ce.dmax = 32768, ce.head = null, ce.hold = 0, ce.bits = 0, ce.lencode = ce.lendyn = new s.Buf32(wt), ce.distcode = ce.distdyn = new s.Buf32(xt), ce.sane = 1, ce.back = -1, p);
      }
      function at(G) {
        var ce;
        return !G || !G.state ? y : (ce = G.state, ce.wsize = 0, ce.whave = 0, ce.wnext = 0, Ue(G));
      }
      function Pt(G, ce) {
        var T, z;
        return !G || !G.state || (z = G.state, ce < 0 ? (T = 0, ce = -ce) : (T = (ce >> 4) + 1, ce < 48 && (ce &= 15)), ce && (ce < 8 || ce > 15)) ? y : (z.window !== null && z.wbits !== ce && (z.window = null), z.wrap = T, z.wbits = ce, at(G));
      }
      function Qt(G, ce) {
        var T, z;
        return G ? (z = new be(), G.state = z, z.window = null, T = Pt(G, ce), T !== p && (G.state = null), T) : y;
      }
      function Ie(G) {
        return Qt(G, qe);
      }
      var Ve = !0, Je, He;
      function Qe(G) {
        if (Ve) {
          var ce;
          for (Je = new s.Buf32(512), He = new s.Buf32(32), ce = 0; ce < 144; )
            G.lens[ce++] = 8;
          for (; ce < 256; )
            G.lens[ce++] = 9;
          for (; ce < 280; )
            G.lens[ce++] = 7;
          for (; ce < 288; )
            G.lens[ce++] = 8;
          for (u(d, G.lens, 0, 288, Je, 0, G.work, { bits: 9 }), ce = 0; ce < 32; )
            G.lens[ce++] = 5;
          u(h, G.lens, 0, 32, He, 0, G.work, { bits: 5 }), Ve = !1;
        }
        G.lencode = Je, G.lenbits = 9, G.distcode = He, G.distbits = 5;
      }
      function At(G, ce, T, z) {
        var ae, E = G.state;
        return E.window === null && (E.wsize = 1 << E.wbits, E.wnext = 0, E.whave = 0, E.window = new s.Buf8(E.wsize)), z >= E.wsize ? (s.arraySet(E.window, ce, T - E.wsize, E.wsize, 0), E.wnext = 0, E.whave = E.wsize) : (ae = E.wsize - E.wnext, ae > z && (ae = z), s.arraySet(E.window, ce, T - z, ae, E.wnext), z -= ae, z ? (s.arraySet(E.window, ce, T - z, z, 0), E.wnext = z, E.whave = E.wsize) : (E.wnext += ae, E.wnext === E.wsize && (E.wnext = 0), E.whave < E.wsize && (E.whave += ae))), 0;
      }
      function P(G, ce) {
        var T, z, ae, E, J, se, I, W, re, Pe, Oe, Be, Ye, ln, Wt = 0, pt, Zt, fn, An, as, ls, Jt, Ln, un = new s.Buf8(4), ur, Xn, _a = (
          /* permutation of code lengths */
          [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
        );
        if (!G || !G.state || !G.output || !G.input && G.avail_in !== 0)
          return y;
        T = G.state, T.mode === H && (T.mode = ie), J = G.next_out, ae = G.output, I = G.avail_out, E = G.next_in, z = G.input, se = G.avail_in, W = T.hold, re = T.bits, Pe = se, Oe = I, Ln = p;
        e:
          for (; ; )
            switch (T.mode) {
              case C:
                if (T.wrap === 0) {
                  T.mode = ie;
                  break;
                }
                for (; re < 16; ) {
                  if (se === 0)
                    break e;
                  se--, W += z[E++] << re, re += 8;
                }
                if (T.wrap & 2 && W === 35615) {
                  T.check = 0, un[0] = W & 255, un[1] = W >>> 8 & 255, T.check = a(T.check, un, 2, 0), W = 0, re = 0, T.mode = k;
                  break;
                }
                if (T.flags = 0, T.head && (T.head.done = !1), !(T.wrap & 1) || /* check if zlib header allowed */
                (((W & 255) << 8) + (W >> 8)) % 31) {
                  G.msg = "incorrect header check", T.mode = ot;
                  break;
                }
                if ((W & 15) !== A) {
                  G.msg = "unknown compression method", T.mode = ot;
                  break;
                }
                if (W >>>= 4, re -= 4, Jt = (W & 15) + 8, T.wbits === 0)
                  T.wbits = Jt;
                else if (Jt > T.wbits) {
                  G.msg = "invalid window size", T.mode = ot;
                  break;
                }
                T.dmax = 1 << Jt, G.adler = T.check = 1, T.mode = W & 512 ? L : H, W = 0, re = 0;
                break;
              case k:
                for (; re < 16; ) {
                  if (se === 0)
                    break e;
                  se--, W += z[E++] << re, re += 8;
                }
                if (T.flags = W, (T.flags & 255) !== A) {
                  G.msg = "unknown compression method", T.mode = ot;
                  break;
                }
                if (T.flags & 57344) {
                  G.msg = "unknown header flags set", T.mode = ot;
                  break;
                }
                T.head && (T.head.text = W >> 8 & 1), T.flags & 512 && (un[0] = W & 255, un[1] = W >>> 8 & 255, T.check = a(T.check, un, 2, 0)), W = 0, re = 0, T.mode = O;
              case O:
                for (; re < 32; ) {
                  if (se === 0)
                    break e;
                  se--, W += z[E++] << re, re += 8;
                }
                T.head && (T.head.time = W), T.flags & 512 && (un[0] = W & 255, un[1] = W >>> 8 & 255, un[2] = W >>> 16 & 255, un[3] = W >>> 24 & 255, T.check = a(T.check, un, 4, 0)), W = 0, re = 0, T.mode = N;
              case N:
                for (; re < 16; ) {
                  if (se === 0)
                    break e;
                  se--, W += z[E++] << re, re += 8;
                }
                T.head && (T.head.xflags = W & 255, T.head.os = W >> 8), T.flags & 512 && (un[0] = W & 255, un[1] = W >>> 8 & 255, T.check = a(T.check, un, 2, 0)), W = 0, re = 0, T.mode = B;
              case B:
                if (T.flags & 1024) {
                  for (; re < 16; ) {
                    if (se === 0)
                      break e;
                    se--, W += z[E++] << re, re += 8;
                  }
                  T.length = W, T.head && (T.head.extra_len = W), T.flags & 512 && (un[0] = W & 255, un[1] = W >>> 8 & 255, T.check = a(T.check, un, 2, 0)), W = 0, re = 0;
                } else
                  T.head && (T.head.extra = null);
                T.mode = D;
              case D:
                if (T.flags & 1024 && (Be = T.length, Be > se && (Be = se), Be && (T.head && (Jt = T.head.extra_len - T.length, T.head.extra || (T.head.extra = new Array(T.head.extra_len)), s.arraySet(
                  T.head.extra,
                  z,
                  E,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  Be,
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  Jt
                )), T.flags & 512 && (T.check = a(T.check, z, Be, E)), se -= Be, E += Be, T.length -= Be), T.length))
                  break e;
                T.length = 0, T.mode = F;
              case F:
                if (T.flags & 2048) {
                  if (se === 0)
                    break e;
                  Be = 0;
                  do
                    Jt = z[E + Be++], T.head && Jt && T.length < 65536 && (T.head.name += String.fromCharCode(Jt));
                  while (Jt && Be < se);
                  if (T.flags & 512 && (T.check = a(T.check, z, Be, E)), se -= Be, E += Be, Jt)
                    break e;
                } else
                  T.head && (T.head.name = null);
                T.length = 0, T.mode = Z;
              case Z:
                if (T.flags & 4096) {
                  if (se === 0)
                    break e;
                  Be = 0;
                  do
                    Jt = z[E + Be++], T.head && Jt && T.length < 65536 && (T.head.comment += String.fromCharCode(Jt));
                  while (Jt && Be < se);
                  if (T.flags & 512 && (T.check = a(T.check, z, Be, E)), se -= Be, E += Be, Jt)
                    break e;
                } else
                  T.head && (T.head.comment = null);
                T.mode = te;
              case te:
                if (T.flags & 512) {
                  for (; re < 16; ) {
                    if (se === 0)
                      break e;
                    se--, W += z[E++] << re, re += 8;
                  }
                  if (W !== (T.check & 65535)) {
                    G.msg = "header crc mismatch", T.mode = ot;
                    break;
                  }
                  W = 0, re = 0;
                }
                T.head && (T.head.hcrc = T.flags >> 9 & 1, T.head.done = !0), G.adler = T.check = 0, T.mode = H;
                break;
              case L:
                for (; re < 32; ) {
                  if (se === 0)
                    break e;
                  se--, W += z[E++] << re, re += 8;
                }
                G.adler = T.check = Rt(W), W = 0, re = 0, T.mode = V;
              case V:
                if (T.havedict === 0)
                  return G.next_out = J, G.avail_out = I, G.next_in = E, G.avail_in = se, T.hold = W, T.bits = re, g;
                G.adler = T.check = 1, T.mode = H;
              case H:
                if (ce === m || ce === b)
                  break e;
              case ie:
                if (T.last) {
                  W >>>= re & 7, re -= re & 7, T.mode = Et;
                  break;
                }
                for (; re < 3; ) {
                  if (se === 0)
                    break e;
                  se--, W += z[E++] << re, re += 8;
                }
                switch (T.last = W & 1, W >>>= 1, re -= 1, W & 3) {
                  case 0:
                    T.mode = ne;
                    break;
                  case 1:
                    if (Qe(T), T.mode = Fe, ce === b) {
                      W >>>= 2, re -= 2;
                      break e;
                    }
                    break;
                  case 2:
                    T.mode = ue;
                    break;
                  case 3:
                    G.msg = "invalid block type", T.mode = ot;
                }
                W >>>= 2, re -= 2;
                break;
              case ne:
                for (W >>>= re & 7, re -= re & 7; re < 32; ) {
                  if (se === 0)
                    break e;
                  se--, W += z[E++] << re, re += 8;
                }
                if ((W & 65535) !== (W >>> 16 ^ 65535)) {
                  G.msg = "invalid stored block lengths", T.mode = ot;
                  break;
                }
                if (T.length = W & 65535, W = 0, re = 0, T.mode = Y, ce === b)
                  break e;
              case Y:
                T.mode = de;
              case de:
                if (Be = T.length, Be) {
                  if (Be > se && (Be = se), Be > I && (Be = I), Be === 0)
                    break e;
                  s.arraySet(ae, z, E, Be, J), se -= Be, E += Be, I -= Be, J += Be, T.length -= Be;
                  break;
                }
                T.mode = H;
                break;
              case ue:
                for (; re < 14; ) {
                  if (se === 0)
                    break e;
                  se--, W += z[E++] << re, re += 8;
                }
                if (T.nlen = (W & 31) + 257, W >>>= 5, re -= 5, T.ndist = (W & 31) + 1, W >>>= 5, re -= 5, T.ncode = (W & 15) + 4, W >>>= 4, re -= 4, T.nlen > 286 || T.ndist > 30) {
                  G.msg = "too many length or distance symbols", T.mode = ot;
                  break;
                }
                T.have = 0, T.mode = Te;
              case Te:
                for (; T.have < T.ncode; ) {
                  for (; re < 3; ) {
                    if (se === 0)
                      break e;
                    se--, W += z[E++] << re, re += 8;
                  }
                  T.lens[_a[T.have++]] = W & 7, W >>>= 3, re -= 3;
                }
                for (; T.have < 19; )
                  T.lens[_a[T.have++]] = 0;
                if (T.lencode = T.lendyn, T.lenbits = 7, ur = { bits: T.lenbits }, Ln = u(c, T.lens, 0, 19, T.lencode, 0, T.work, ur), T.lenbits = ur.bits, Ln) {
                  G.msg = "invalid code lengths set", T.mode = ot;
                  break;
                }
                T.have = 0, T.mode = _e;
              case _e:
                for (; T.have < T.nlen + T.ndist; ) {
                  for (; Wt = T.lencode[W & (1 << T.lenbits) - 1], pt = Wt >>> 24, Zt = Wt >>> 16 & 255, fn = Wt & 65535, !(pt <= re); ) {
                    if (se === 0)
                      break e;
                    se--, W += z[E++] << re, re += 8;
                  }
                  if (fn < 16)
                    W >>>= pt, re -= pt, T.lens[T.have++] = fn;
                  else {
                    if (fn === 16) {
                      for (Xn = pt + 2; re < Xn; ) {
                        if (se === 0)
                          break e;
                        se--, W += z[E++] << re, re += 8;
                      }
                      if (W >>>= pt, re -= pt, T.have === 0) {
                        G.msg = "invalid bit length repeat", T.mode = ot;
                        break;
                      }
                      Jt = T.lens[T.have - 1], Be = 3 + (W & 3), W >>>= 2, re -= 2;
                    } else if (fn === 17) {
                      for (Xn = pt + 3; re < Xn; ) {
                        if (se === 0)
                          break e;
                        se--, W += z[E++] << re, re += 8;
                      }
                      W >>>= pt, re -= pt, Jt = 0, Be = 3 + (W & 7), W >>>= 3, re -= 3;
                    } else {
                      for (Xn = pt + 7; re < Xn; ) {
                        if (se === 0)
                          break e;
                        se--, W += z[E++] << re, re += 8;
                      }
                      W >>>= pt, re -= pt, Jt = 0, Be = 11 + (W & 127), W >>>= 7, re -= 7;
                    }
                    if (T.have + Be > T.nlen + T.ndist) {
                      G.msg = "invalid bit length repeat", T.mode = ot;
                      break;
                    }
                    for (; Be--; )
                      T.lens[T.have++] = Jt;
                  }
                }
                if (T.mode === ot)
                  break;
                if (T.lens[256] === 0) {
                  G.msg = "invalid code -- missing end-of-block", T.mode = ot;
                  break;
                }
                if (T.lenbits = 9, ur = { bits: T.lenbits }, Ln = u(d, T.lens, 0, T.nlen, T.lencode, 0, T.work, ur), T.lenbits = ur.bits, Ln) {
                  G.msg = "invalid literal/lengths set", T.mode = ot;
                  break;
                }
                if (T.distbits = 6, T.distcode = T.distdyn, ur = { bits: T.distbits }, Ln = u(h, T.lens, T.nlen, T.ndist, T.distcode, 0, T.work, ur), T.distbits = ur.bits, Ln) {
                  G.msg = "invalid distances set", T.mode = ot;
                  break;
                }
                if (T.mode = Fe, ce === b)
                  break e;
              case Fe:
                T.mode = Ce;
              case Ce:
                if (se >= 6 && I >= 258) {
                  G.next_out = J, G.avail_out = I, G.next_in = E, G.avail_in = se, T.hold = W, T.bits = re, l(G, Oe), J = G.next_out, ae = G.output, I = G.avail_out, E = G.next_in, z = G.input, se = G.avail_in, W = T.hold, re = T.bits, T.mode === H && (T.back = -1);
                  break;
                }
                for (T.back = 0; Wt = T.lencode[W & (1 << T.lenbits) - 1], pt = Wt >>> 24, Zt = Wt >>> 16 & 255, fn = Wt & 65535, !(pt <= re); ) {
                  if (se === 0)
                    break e;
                  se--, W += z[E++] << re, re += 8;
                }
                if (Zt && !(Zt & 240)) {
                  for (An = pt, as = Zt, ls = fn; Wt = T.lencode[ls + ((W & (1 << An + as) - 1) >> An)], pt = Wt >>> 24, Zt = Wt >>> 16 & 255, fn = Wt & 65535, !(An + pt <= re); ) {
                    if (se === 0)
                      break e;
                    se--, W += z[E++] << re, re += 8;
                  }
                  W >>>= An, re -= An, T.back += An;
                }
                if (W >>>= pt, re -= pt, T.back += pt, T.length = fn, Zt === 0) {
                  T.mode = nt;
                  break;
                }
                if (Zt & 32) {
                  T.back = -1, T.mode = H;
                  break;
                }
                if (Zt & 64) {
                  G.msg = "invalid literal/length code", T.mode = ot;
                  break;
                }
                T.extra = Zt & 15, T.mode = tt;
              case tt:
                if (T.extra) {
                  for (Xn = T.extra; re < Xn; ) {
                    if (se === 0)
                      break e;
                    se--, W += z[E++] << re, re += 8;
                  }
                  T.length += W & (1 << T.extra) - 1, W >>>= T.extra, re -= T.extra, T.back += T.extra;
                }
                T.was = T.length, T.mode = je;
              case je:
                for (; Wt = T.distcode[W & (1 << T.distbits) - 1], pt = Wt >>> 24, Zt = Wt >>> 16 & 255, fn = Wt & 65535, !(pt <= re); ) {
                  if (se === 0)
                    break e;
                  se--, W += z[E++] << re, re += 8;
                }
                if (!(Zt & 240)) {
                  for (An = pt, as = Zt, ls = fn; Wt = T.distcode[ls + ((W & (1 << An + as) - 1) >> An)], pt = Wt >>> 24, Zt = Wt >>> 16 & 255, fn = Wt & 65535, !(An + pt <= re); ) {
                    if (se === 0)
                      break e;
                    se--, W += z[E++] << re, re += 8;
                  }
                  W >>>= An, re -= An, T.back += An;
                }
                if (W >>>= pt, re -= pt, T.back += pt, Zt & 64) {
                  G.msg = "invalid distance code", T.mode = ot;
                  break;
                }
                T.offset = fn, T.extra = Zt & 15, T.mode = $e;
              case $e:
                if (T.extra) {
                  for (Xn = T.extra; re < Xn; ) {
                    if (se === 0)
                      break e;
                    se--, W += z[E++] << re, re += 8;
                  }
                  T.offset += W & (1 << T.extra) - 1, W >>>= T.extra, re -= T.extra, T.back += T.extra;
                }
                if (T.offset > T.dmax) {
                  G.msg = "invalid distance too far back", T.mode = ot;
                  break;
                }
                T.mode = ht;
              case ht:
                if (I === 0)
                  break e;
                if (Be = Oe - I, T.offset > Be) {
                  if (Be = T.offset - Be, Be > T.whave && T.sane) {
                    G.msg = "invalid distance too far back", T.mode = ot;
                    break;
                  }
                  Be > T.wnext ? (Be -= T.wnext, Ye = T.wsize - Be) : Ye = T.wnext - Be, Be > T.length && (Be = T.length), ln = T.window;
                } else
                  ln = ae, Ye = J - T.offset, Be = T.length;
                Be > I && (Be = I), I -= Be, T.length -= Be;
                do
                  ae[J++] = ln[Ye++];
                while (--Be);
                T.length === 0 && (T.mode = Ce);
                break;
              case nt:
                if (I === 0)
                  break e;
                ae[J++] = T.length, I--, T.mode = Ce;
                break;
              case Et:
                if (T.wrap) {
                  for (; re < 32; ) {
                    if (se === 0)
                      break e;
                    se--, W |= z[E++] << re, re += 8;
                  }
                  if (Oe -= I, G.total_out += Oe, T.total += Oe, Oe && (G.adler = T.check = /*UPDATE(state.check, put - _out, _out);*/
                  T.flags ? a(T.check, ae, Oe, J - Oe) : o(T.check, ae, Oe, J - Oe)), Oe = I, (T.flags ? W : Rt(W)) !== T.check) {
                    G.msg = "incorrect data check", T.mode = ot;
                    break;
                  }
                  W = 0, re = 0;
                }
                T.mode = yt;
              case yt:
                if (T.wrap && T.flags) {
                  for (; re < 32; ) {
                    if (se === 0)
                      break e;
                    se--, W += z[E++] << re, re += 8;
                  }
                  if (W !== (T.total & 4294967295)) {
                    G.msg = "incorrect length check", T.mode = ot;
                    break;
                  }
                  W = 0, re = 0;
                }
                T.mode = Nt;
              case Nt:
                Ln = f;
                break e;
              case ot:
                Ln = w;
                break e;
              case bt:
                return _;
              case Kt:
              default:
                return y;
            }
        return G.next_out = J, G.avail_out = I, G.next_in = E, G.avail_in = se, T.hold = W, T.bits = re, (T.wsize || Oe !== G.avail_out && T.mode < ot && (T.mode < Et || ce !== v)) && At(G, G.output, G.next_out, Oe - G.avail_out), Pe -= G.avail_in, Oe -= G.avail_out, G.total_in += Pe, G.total_out += Oe, T.total += Oe, T.wrap && Oe && (G.adler = T.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        T.flags ? a(T.check, ae, Oe, G.next_out - Oe) : o(T.check, ae, Oe, G.next_out - Oe)), G.data_type = T.bits + (T.last ? 64 : 0) + (T.mode === H ? 128 : 0) + (T.mode === Fe || T.mode === Y ? 256 : 0), (Pe === 0 && Oe === 0 || ce === v) && Ln === p && (Ln = S), Ln;
      }
      function he(G) {
        if (!G || !G.state)
          return y;
        var ce = G.state;
        return ce.window && (ce.window = null), G.state = null, p;
      }
      function ge(G, ce) {
        var T;
        return !G || !G.state || (T = G.state, !(T.wrap & 2)) ? y : (T.head = ce, ce.done = !1, p);
      }
      function Ne(G, ce) {
        var T = ce.length, z, ae, E;
        return !G || !G.state || (z = G.state, z.wrap !== 0 && z.mode !== V) ? y : z.mode === V && (ae = 1, ae = o(ae, ce, T, 0), ae !== z.check) ? w : (E = At(G, ce, T, T), E ? (z.mode = bt, _) : (z.havedict = 1, p));
      }
      i.inflateReset = at, i.inflateReset2 = Pt, i.inflateResetKeep = Ue, i.inflateInit = Ie, i.inflateInit2 = Qt, i.inflate = P, i.inflateEnd = he, i.inflateGetHeader = ge, i.inflateSetDictionary = Ne, i.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(n, r, i) {
      var s = n("../utils/common"), o = 15, a = 852, l = 592, u = 0, c = 1, d = 2, h = [
        /* Length codes 257..285 base */
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        13,
        15,
        17,
        19,
        23,
        27,
        31,
        35,
        43,
        51,
        59,
        67,
        83,
        99,
        115,
        131,
        163,
        195,
        227,
        258,
        0,
        0
      ], v = [
        /* Length codes 257..285 extra */
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        17,
        17,
        17,
        17,
        18,
        18,
        18,
        18,
        19,
        19,
        19,
        19,
        20,
        20,
        20,
        20,
        21,
        21,
        21,
        21,
        16,
        72,
        78
      ], m = [
        /* Distance codes 0..29 base */
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        13,
        17,
        25,
        33,
        49,
        65,
        97,
        129,
        193,
        257,
        385,
        513,
        769,
        1025,
        1537,
        2049,
        3073,
        4097,
        6145,
        8193,
        12289,
        16385,
        24577,
        0,
        0
      ], b = [
        /* Distance codes 0..29 extra */
        16,
        16,
        16,
        16,
        17,
        17,
        18,
        18,
        19,
        19,
        20,
        20,
        21,
        21,
        22,
        22,
        23,
        23,
        24,
        24,
        25,
        25,
        26,
        26,
        27,
        27,
        28,
        28,
        29,
        29,
        64,
        64
      ];
      r.exports = function(f, g, y, w, _, S, A, C) {
        var k = C.bits, O = 0, N = 0, B = 0, D = 0, F = 0, Z = 0, te = 0, L = 0, V = 0, H = 0, ie, ne, Y, de, ue, Te = null, _e = 0, Fe, Ce = new s.Buf16(o + 1), tt = new s.Buf16(o + 1), je = null, $e = 0, ht, nt, Et;
        for (O = 0; O <= o; O++)
          Ce[O] = 0;
        for (N = 0; N < w; N++)
          Ce[g[y + N]]++;
        for (F = k, D = o; D >= 1 && Ce[D] === 0; D--)
          ;
        if (F > D && (F = D), D === 0)
          return _[S++] = 1 << 24 | 64 << 16 | 0, _[S++] = 1 << 24 | 64 << 16 | 0, C.bits = 1, 0;
        for (B = 1; B < D && Ce[B] === 0; B++)
          ;
        for (F < B && (F = B), L = 1, O = 1; O <= o; O++)
          if (L <<= 1, L -= Ce[O], L < 0)
            return -1;
        if (L > 0 && (f === u || D !== 1))
          return -1;
        for (tt[1] = 0, O = 1; O < o; O++)
          tt[O + 1] = tt[O] + Ce[O];
        for (N = 0; N < w; N++)
          g[y + N] !== 0 && (A[tt[g[y + N]]++] = N);
        if (f === u ? (Te = je = A, Fe = 19) : f === c ? (Te = h, _e -= 257, je = v, $e -= 257, Fe = 256) : (Te = m, je = b, Fe = -1), H = 0, N = 0, O = B, ue = S, Z = F, te = 0, Y = -1, V = 1 << F, de = V - 1, f === c && V > a || f === d && V > l)
          return 1;
        for (; ; ) {
          ht = O - te, A[N] < Fe ? (nt = 0, Et = A[N]) : A[N] > Fe ? (nt = je[$e + A[N]], Et = Te[_e + A[N]]) : (nt = 32 + 64, Et = 0), ie = 1 << O - te, ne = 1 << Z, B = ne;
          do
            ne -= ie, _[ue + (H >> te) + ne] = ht << 24 | nt << 16 | Et | 0;
          while (ne !== 0);
          for (ie = 1 << O - 1; H & ie; )
            ie >>= 1;
          if (ie !== 0 ? (H &= ie - 1, H += ie) : H = 0, N++, --Ce[O] === 0) {
            if (O === D)
              break;
            O = g[y + A[N]];
          }
          if (O > F && (H & de) !== Y) {
            for (te === 0 && (te = F), ue += B, Z = O - te, L = 1 << Z; Z + te < D && (L -= Ce[Z + te], !(L <= 0)); )
              Z++, L <<= 1;
            if (V += 1 << Z, f === c && V > a || f === d && V > l)
              return 1;
            Y = H & de, _[Y] = F << 24 | Z << 16 | ue - S | 0;
          }
        }
        return H !== 0 && (_[ue + H] = O - te << 24 | 64 << 16 | 0), C.bits = F, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(n, r, i) {
      r.exports = {
        2: "need dictionary",
        /* Z_NEED_DICT       2  */
        1: "stream end",
        /* Z_STREAM_END      1  */
        0: "",
        /* Z_OK              0  */
        "-1": "file error",
        /* Z_ERRNO         (-1) */
        "-2": "stream error",
        /* Z_STREAM_ERROR  (-2) */
        "-3": "data error",
        /* Z_DATA_ERROR    (-3) */
        "-4": "insufficient memory",
        /* Z_MEM_ERROR     (-4) */
        "-5": "buffer error",
        /* Z_BUF_ERROR     (-5) */
        "-6": "incompatible version"
        /* Z_VERSION_ERROR (-6) */
      };
    }, {}], 52: [function(n, r, i) {
      var s = n("../utils/common"), o = 4, a = 0, l = 1, u = 2;
      function c(P) {
        for (var he = P.length; --he >= 0; )
          P[he] = 0;
      }
      var d = 0, h = 1, v = 2, m = 3, b = 258, p = 29, f = 256, g = f + 1 + p, y = 30, w = 19, _ = 2 * g + 1, S = 15, A = 16, C = 7, k = 256, O = 16, N = 17, B = 18, D = (
        /* extra bits for each length code */
        [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
      ), F = (
        /* extra bits for each distance code */
        [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
      ), Z = (
        /* extra bits for each bit length code */
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
      ), te = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], L = 512, V = new Array((g + 2) * 2);
      c(V);
      var H = new Array(y * 2);
      c(H);
      var ie = new Array(L);
      c(ie);
      var ne = new Array(b - m + 1);
      c(ne);
      var Y = new Array(p);
      c(Y);
      var de = new Array(y);
      c(de);
      function ue(P, he, ge, Ne, G) {
        this.static_tree = P, this.extra_bits = he, this.extra_base = ge, this.elems = Ne, this.max_length = G, this.has_stree = P && P.length;
      }
      var Te, _e, Fe;
      function Ce(P, he) {
        this.dyn_tree = P, this.max_code = 0, this.stat_desc = he;
      }
      function tt(P) {
        return P < 256 ? ie[P] : ie[256 + (P >>> 7)];
      }
      function je(P, he) {
        P.pending_buf[P.pending++] = he & 255, P.pending_buf[P.pending++] = he >>> 8 & 255;
      }
      function $e(P, he, ge) {
        P.bi_valid > A - ge ? (P.bi_buf |= he << P.bi_valid & 65535, je(P, P.bi_buf), P.bi_buf = he >> A - P.bi_valid, P.bi_valid += ge - A) : (P.bi_buf |= he << P.bi_valid & 65535, P.bi_valid += ge);
      }
      function ht(P, he, ge) {
        $e(
          P,
          ge[he * 2],
          ge[he * 2 + 1]
          /*.Len*/
        );
      }
      function nt(P, he) {
        var ge = 0;
        do
          ge |= P & 1, P >>>= 1, ge <<= 1;
        while (--he > 0);
        return ge >>> 1;
      }
      function Et(P) {
        P.bi_valid === 16 ? (je(P, P.bi_buf), P.bi_buf = 0, P.bi_valid = 0) : P.bi_valid >= 8 && (P.pending_buf[P.pending++] = P.bi_buf & 255, P.bi_buf >>= 8, P.bi_valid -= 8);
      }
      function yt(P, he) {
        var ge = he.dyn_tree, Ne = he.max_code, G = he.stat_desc.static_tree, ce = he.stat_desc.has_stree, T = he.stat_desc.extra_bits, z = he.stat_desc.extra_base, ae = he.stat_desc.max_length, E, J, se, I, W, re, Pe = 0;
        for (I = 0; I <= S; I++)
          P.bl_count[I] = 0;
        for (ge[P.heap[P.heap_max] * 2 + 1] = 0, E = P.heap_max + 1; E < _; E++)
          J = P.heap[E], I = ge[ge[J * 2 + 1] * 2 + 1] + 1, I > ae && (I = ae, Pe++), ge[J * 2 + 1] = I, !(J > Ne) && (P.bl_count[I]++, W = 0, J >= z && (W = T[J - z]), re = ge[J * 2], P.opt_len += re * (I + W), ce && (P.static_len += re * (G[J * 2 + 1] + W)));
        if (Pe !== 0) {
          do {
            for (I = ae - 1; P.bl_count[I] === 0; )
              I--;
            P.bl_count[I]--, P.bl_count[I + 1] += 2, P.bl_count[ae]--, Pe -= 2;
          } while (Pe > 0);
          for (I = ae; I !== 0; I--)
            for (J = P.bl_count[I]; J !== 0; )
              se = P.heap[--E], !(se > Ne) && (ge[se * 2 + 1] !== I && (P.opt_len += (I - ge[se * 2 + 1]) * ge[se * 2], ge[se * 2 + 1] = I), J--);
        }
      }
      function Nt(P, he, ge) {
        var Ne = new Array(S + 1), G = 0, ce, T;
        for (ce = 1; ce <= S; ce++)
          Ne[ce] = G = G + ge[ce - 1] << 1;
        for (T = 0; T <= he; T++) {
          var z = P[T * 2 + 1];
          z !== 0 && (P[T * 2] = nt(Ne[z]++, z));
        }
      }
      function ot() {
        var P, he, ge, Ne, G, ce = new Array(S + 1);
        for (ge = 0, Ne = 0; Ne < p - 1; Ne++)
          for (Y[Ne] = ge, P = 0; P < 1 << D[Ne]; P++)
            ne[ge++] = Ne;
        for (ne[ge - 1] = Ne, G = 0, Ne = 0; Ne < 16; Ne++)
          for (de[Ne] = G, P = 0; P < 1 << F[Ne]; P++)
            ie[G++] = Ne;
        for (G >>= 7; Ne < y; Ne++)
          for (de[Ne] = G << 7, P = 0; P < 1 << F[Ne] - 7; P++)
            ie[256 + G++] = Ne;
        for (he = 0; he <= S; he++)
          ce[he] = 0;
        for (P = 0; P <= 143; )
          V[P * 2 + 1] = 8, P++, ce[8]++;
        for (; P <= 255; )
          V[P * 2 + 1] = 9, P++, ce[9]++;
        for (; P <= 279; )
          V[P * 2 + 1] = 7, P++, ce[7]++;
        for (; P <= 287; )
          V[P * 2 + 1] = 8, P++, ce[8]++;
        for (Nt(V, g + 1, ce), P = 0; P < y; P++)
          H[P * 2 + 1] = 5, H[P * 2] = nt(P, 5);
        Te = new ue(V, D, f + 1, g, S), _e = new ue(H, F, 0, y, S), Fe = new ue(new Array(0), Z, 0, w, C);
      }
      function bt(P) {
        var he;
        for (he = 0; he < g; he++)
          P.dyn_ltree[he * 2] = 0;
        for (he = 0; he < y; he++)
          P.dyn_dtree[he * 2] = 0;
        for (he = 0; he < w; he++)
          P.bl_tree[he * 2] = 0;
        P.dyn_ltree[k * 2] = 1, P.opt_len = P.static_len = 0, P.last_lit = P.matches = 0;
      }
      function Kt(P) {
        P.bi_valid > 8 ? je(P, P.bi_buf) : P.bi_valid > 0 && (P.pending_buf[P.pending++] = P.bi_buf), P.bi_buf = 0, P.bi_valid = 0;
      }
      function wt(P, he, ge, Ne) {
        Kt(P), Ne && (je(P, ge), je(P, ~ge)), s.arraySet(P.pending_buf, P.window, he, ge, P.pending), P.pending += ge;
      }
      function xt(P, he, ge, Ne) {
        var G = he * 2, ce = ge * 2;
        return P[G] < P[ce] || P[G] === P[ce] && Ne[he] <= Ne[ge];
      }
      function lt(P, he, ge) {
        for (var Ne = P.heap[ge], G = ge << 1; G <= P.heap_len && (G < P.heap_len && xt(he, P.heap[G + 1], P.heap[G], P.depth) && G++, !xt(he, Ne, P.heap[G], P.depth)); )
          P.heap[ge] = P.heap[G], ge = G, G <<= 1;
        P.heap[ge] = Ne;
      }
      function qe(P, he, ge) {
        var Ne, G, ce = 0, T, z;
        if (P.last_lit !== 0)
          do
            Ne = P.pending_buf[P.d_buf + ce * 2] << 8 | P.pending_buf[P.d_buf + ce * 2 + 1], G = P.pending_buf[P.l_buf + ce], ce++, Ne === 0 ? ht(P, G, he) : (T = ne[G], ht(P, T + f + 1, he), z = D[T], z !== 0 && (G -= Y[T], $e(P, G, z)), Ne--, T = tt(Ne), ht(P, T, ge), z = F[T], z !== 0 && (Ne -= de[T], $e(P, Ne, z)));
          while (ce < P.last_lit);
        ht(P, k, he);
      }
      function Rt(P, he) {
        var ge = he.dyn_tree, Ne = he.stat_desc.static_tree, G = he.stat_desc.has_stree, ce = he.stat_desc.elems, T, z, ae = -1, E;
        for (P.heap_len = 0, P.heap_max = _, T = 0; T < ce; T++)
          ge[T * 2] !== 0 ? (P.heap[++P.heap_len] = ae = T, P.depth[T] = 0) : ge[T * 2 + 1] = 0;
        for (; P.heap_len < 2; )
          E = P.heap[++P.heap_len] = ae < 2 ? ++ae : 0, ge[E * 2] = 1, P.depth[E] = 0, P.opt_len--, G && (P.static_len -= Ne[E * 2 + 1]);
        for (he.max_code = ae, T = P.heap_len >> 1; T >= 1; T--)
          lt(P, ge, T);
        E = ce;
        do
          T = P.heap[
            1
            /*SMALLEST*/
          ], P.heap[
            1
            /*SMALLEST*/
          ] = P.heap[P.heap_len--], lt(
            P,
            ge,
            1
            /*SMALLEST*/
          ), z = P.heap[
            1
            /*SMALLEST*/
          ], P.heap[--P.heap_max] = T, P.heap[--P.heap_max] = z, ge[E * 2] = ge[T * 2] + ge[z * 2], P.depth[E] = (P.depth[T] >= P.depth[z] ? P.depth[T] : P.depth[z]) + 1, ge[T * 2 + 1] = ge[z * 2 + 1] = E, P.heap[
            1
            /*SMALLEST*/
          ] = E++, lt(
            P,
            ge,
            1
            /*SMALLEST*/
          );
        while (P.heap_len >= 2);
        P.heap[--P.heap_max] = P.heap[
          1
          /*SMALLEST*/
        ], yt(P, he), Nt(ge, ae, P.bl_count);
      }
      function be(P, he, ge) {
        var Ne, G = -1, ce, T = he[0 * 2 + 1], z = 0, ae = 7, E = 4;
        for (T === 0 && (ae = 138, E = 3), he[(ge + 1) * 2 + 1] = 65535, Ne = 0; Ne <= ge; Ne++)
          ce = T, T = he[(Ne + 1) * 2 + 1], !(++z < ae && ce === T) && (z < E ? P.bl_tree[ce * 2] += z : ce !== 0 ? (ce !== G && P.bl_tree[ce * 2]++, P.bl_tree[O * 2]++) : z <= 10 ? P.bl_tree[N * 2]++ : P.bl_tree[B * 2]++, z = 0, G = ce, T === 0 ? (ae = 138, E = 3) : ce === T ? (ae = 6, E = 3) : (ae = 7, E = 4));
      }
      function Ue(P, he, ge) {
        var Ne, G = -1, ce, T = he[0 * 2 + 1], z = 0, ae = 7, E = 4;
        for (T === 0 && (ae = 138, E = 3), Ne = 0; Ne <= ge; Ne++)
          if (ce = T, T = he[(Ne + 1) * 2 + 1], !(++z < ae && ce === T)) {
            if (z < E)
              do
                ht(P, ce, P.bl_tree);
              while (--z !== 0);
            else
              ce !== 0 ? (ce !== G && (ht(P, ce, P.bl_tree), z--), ht(P, O, P.bl_tree), $e(P, z - 3, 2)) : z <= 10 ? (ht(P, N, P.bl_tree), $e(P, z - 3, 3)) : (ht(P, B, P.bl_tree), $e(P, z - 11, 7));
            z = 0, G = ce, T === 0 ? (ae = 138, E = 3) : ce === T ? (ae = 6, E = 3) : (ae = 7, E = 4);
          }
      }
      function at(P) {
        var he;
        for (be(P, P.dyn_ltree, P.l_desc.max_code), be(P, P.dyn_dtree, P.d_desc.max_code), Rt(P, P.bl_desc), he = w - 1; he >= 3 && P.bl_tree[te[he] * 2 + 1] === 0; he--)
          ;
        return P.opt_len += 3 * (he + 1) + 5 + 5 + 4, he;
      }
      function Pt(P, he, ge, Ne) {
        var G;
        for ($e(P, he - 257, 5), $e(P, ge - 1, 5), $e(P, Ne - 4, 4), G = 0; G < Ne; G++)
          $e(P, P.bl_tree[te[G] * 2 + 1], 3);
        Ue(P, P.dyn_ltree, he - 1), Ue(P, P.dyn_dtree, ge - 1);
      }
      function Qt(P) {
        var he = 4093624447, ge;
        for (ge = 0; ge <= 31; ge++, he >>>= 1)
          if (he & 1 && P.dyn_ltree[ge * 2] !== 0)
            return a;
        if (P.dyn_ltree[9 * 2] !== 0 || P.dyn_ltree[10 * 2] !== 0 || P.dyn_ltree[13 * 2] !== 0)
          return l;
        for (ge = 32; ge < f; ge++)
          if (P.dyn_ltree[ge * 2] !== 0)
            return l;
        return a;
      }
      var Ie = !1;
      function Ve(P) {
        Ie || (ot(), Ie = !0), P.l_desc = new Ce(P.dyn_ltree, Te), P.d_desc = new Ce(P.dyn_dtree, _e), P.bl_desc = new Ce(P.bl_tree, Fe), P.bi_buf = 0, P.bi_valid = 0, bt(P);
      }
      function Je(P, he, ge, Ne) {
        $e(P, (d << 1) + (Ne ? 1 : 0), 3), wt(P, he, ge, !0);
      }
      function He(P) {
        $e(P, h << 1, 3), ht(P, k, V), Et(P);
      }
      function Qe(P, he, ge, Ne) {
        var G, ce, T = 0;
        P.level > 0 ? (P.strm.data_type === u && (P.strm.data_type = Qt(P)), Rt(P, P.l_desc), Rt(P, P.d_desc), T = at(P), G = P.opt_len + 3 + 7 >>> 3, ce = P.static_len + 3 + 7 >>> 3, ce <= G && (G = ce)) : G = ce = ge + 5, ge + 4 <= G && he !== -1 ? Je(P, he, ge, Ne) : P.strategy === o || ce === G ? ($e(P, (h << 1) + (Ne ? 1 : 0), 3), qe(P, V, H)) : ($e(P, (v << 1) + (Ne ? 1 : 0), 3), Pt(P, P.l_desc.max_code + 1, P.d_desc.max_code + 1, T + 1), qe(P, P.dyn_ltree, P.dyn_dtree)), bt(P), Ne && Kt(P);
      }
      function At(P, he, ge) {
        return P.pending_buf[P.d_buf + P.last_lit * 2] = he >>> 8 & 255, P.pending_buf[P.d_buf + P.last_lit * 2 + 1] = he & 255, P.pending_buf[P.l_buf + P.last_lit] = ge & 255, P.last_lit++, he === 0 ? P.dyn_ltree[ge * 2]++ : (P.matches++, he--, P.dyn_ltree[(ne[ge] + f + 1) * 2]++, P.dyn_dtree[tt(he) * 2]++), P.last_lit === P.lit_bufsize - 1;
      }
      i._tr_init = Ve, i._tr_stored_block = Je, i._tr_flush_block = Qe, i._tr_tally = At, i._tr_align = He;
    }, { "../utils/common": 41 }], 53: [function(n, r, i) {
      function s() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      }
      r.exports = s;
    }, {}], 54: [function(n, r, i) {
      (function(s) {
        (function(o, a) {
          if (o.setImmediate)
            return;
          var l = 1, u = {}, c = !1, d = o.document, h;
          function v(C) {
            typeof C != "function" && (C = new Function("" + C));
            for (var k = new Array(arguments.length - 1), O = 0; O < k.length; O++)
              k[O] = arguments[O + 1];
            var N = { callback: C, args: k };
            return u[l] = N, h(l), l++;
          }
          function m(C) {
            delete u[C];
          }
          function b(C) {
            var k = C.callback, O = C.args;
            switch (O.length) {
              case 0:
                k();
                break;
              case 1:
                k(O[0]);
                break;
              case 2:
                k(O[0], O[1]);
                break;
              case 3:
                k(O[0], O[1], O[2]);
                break;
              default:
                k.apply(a, O);
                break;
            }
          }
          function p(C) {
            if (c)
              setTimeout(p, 0, C);
            else {
              var k = u[C];
              if (k) {
                c = !0;
                try {
                  b(k);
                } finally {
                  m(C), c = !1;
                }
              }
            }
          }
          function f() {
            h = function(C) {
              process.nextTick(function() {
                p(C);
              });
            };
          }
          function g() {
            if (o.postMessage && !o.importScripts) {
              var C = !0, k = o.onmessage;
              return o.onmessage = function() {
                C = !1;
              }, o.postMessage("", "*"), o.onmessage = k, C;
            }
          }
          function y() {
            var C = "setImmediate$" + Math.random() + "$", k = function(O) {
              O.source === o && typeof O.data == "string" && O.data.indexOf(C) === 0 && p(+O.data.slice(C.length));
            };
            o.addEventListener ? o.addEventListener("message", k, !1) : o.attachEvent("onmessage", k), h = function(O) {
              o.postMessage(C + O, "*");
            };
          }
          function w() {
            var C = new MessageChannel();
            C.port1.onmessage = function(k) {
              var O = k.data;
              p(O);
            }, h = function(k) {
              C.port2.postMessage(k);
            };
          }
          function _() {
            var C = d.documentElement;
            h = function(k) {
              var O = d.createElement("script");
              O.onreadystatechange = function() {
                p(k), O.onreadystatechange = null, C.removeChild(O), O = null;
              }, C.appendChild(O);
            };
          }
          function S() {
            h = function(C) {
              setTimeout(p, 0, C);
            };
          }
          var A = Object.getPrototypeOf && Object.getPrototypeOf(o);
          A = A && A.setTimeout ? A : o, {}.toString.call(o.process) === "[object process]" ? f() : g() ? y() : o.MessageChannel ? w() : d && "onreadystatechange" in d.createElement("script") ? _() : S(), A.setImmediate = v, A.clearImmediate = m;
        })(typeof self > "u" ? typeof s > "u" ? this : s : self);
      }).call(this, typeof yn < "u" ? yn : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(qM);
class JM {
  constructor() {
    this.zip = void 0, this.urlCache = {}, this.checkRequirements();
  }
  /**
   * Checks to see if JSZip exists in global namspace,
   * Requires JSZip if it isn't there
   * @private
   */
  checkRequirements() {
    try {
      this.zip = new Sd();
    } catch {
      throw new Error("JSZip lib not loaded");
    }
  }
  /**
   * Open an archive
   * @param  {binary} input
   * @param  {boolean} [isBase64] tells JSZip if the input data is base64 encoded
   * @return {Promise} zipfile
   */
  open(e, n) {
    return this.zip.loadAsync(e, { base64: n });
  }
  /**
   * Load and Open an archive
   * @param  {string} zipUrl
   * @param  {boolean} [isBase64] tells JSZip if the input data is base64 encoded
   * @return {Promise} zipfile
   */
  openUrl(e, n) {
    return Zo(e, "binary").then(function(r) {
      return this.zip.loadAsync(r, { base64: n });
    }.bind(this));
  }
  /**
   * Request a url from the archive
   * @param  {string} url  a url to request from the archive
   * @param  {string} [type] specify the type of the returned result
   * @return {Promise<Blob | string | JSON | Document | XMLDocument>}
   */
  request(e, n) {
    var r = new vt(), i, s = new ui(e);
    return n || (n = s.extension), n == "blob" ? i = this.getBlob(e) : i = this.getText(e), i ? i.then(function(o) {
      let a = this.handleResponse(o, n);
      r.resolve(a);
    }.bind(this)) : r.reject({
      message: "File not found in the epub: " + e,
      stack: new Error().stack
    }), r.promise;
  }
  /**
   * Handle the response from request
   * @private
   * @param  {any} response
   * @param  {string} [type]
   * @return {any} the parsed result
   */
  handleResponse(e, n) {
    var r;
    return n == "json" ? r = JSON.parse(e) : Qo(n) ? r = Pr(e, "text/xml") : n == "xhtml" ? r = Pr(e, "application/xhtml+xml") : n == "html" || n == "htm" ? r = Pr(e, "text/html") : r = e, r;
  }
  /**
   * Get a Blob from Archive by Url
   * @param  {string} url
   * @param  {string} [mimeType]
   * @return {Blob}
   */
  getBlob(e, n) {
    var r = window.decodeURIComponent(e.substr(1)), i = this.zip.file(r);
    if (i)
      return n = n || Ps.lookup(i.name), i.async("uint8array").then(function(s) {
        return new Blob([s], { type: n });
      });
  }
  /**
   * Get Text from Archive by Url
   * @param  {string} url
   * @param  {string} [encoding]
   * @return {string}
   */
  getText(e, n) {
    var r = window.decodeURIComponent(e.substr(1)), i = this.zip.file(r);
    if (i)
      return i.async("string").then(function(s) {
        return s;
      });
  }
  /**
   * Get a base64 encoded result from Archive by Url
   * @param  {string} url
   * @param  {string} [mimeType]
   * @return {string} base64 encoded
   */
  getBase64(e, n) {
    var r = window.decodeURIComponent(e.substr(1)), i = this.zip.file(r);
    if (i)
      return n = n || Ps.lookup(i.name), i.async("base64").then(function(s) {
        return "data:" + n + ";base64," + s;
      });
  }
  /**
   * Create a Url from an unarchived item
   * @param  {string} url
   * @param  {object} [options.base64] use base64 encoding or blob url
   * @return {Promise} url promise with Url string
   */
  createUrl(e, n) {
    var r = new vt(), i = window.URL || window.webkitURL || window.mozURL, s, o, a = n && n.base64;
    return e in this.urlCache ? (r.resolve(this.urlCache[e]), r.promise) : (a ? (o = this.getBase64(e), o && o.then(function(l) {
      this.urlCache[e] = l, r.resolve(l);
    }.bind(this))) : (o = this.getBlob(e), o && o.then(function(l) {
      s = i.createObjectURL(l), this.urlCache[e] = s, r.resolve(s);
    }.bind(this))), o || r.reject({
      message: "File not found in the epub: " + e,
      stack: new Error().stack
    }), r.promise);
  }
  /**
   * Revoke Temp Url for a archive item
   * @param  {string} url url of the item in the archive
   */
  revokeUrl(e) {
    var n = window.URL || window.webkitURL || window.mozURL, r = this.urlCache[e];
    r && n.revokeObjectURL(r);
  }
  destroy() {
    var e = window.URL || window.webkitURL || window.mozURL;
    for (let n in this.urlCache)
      e.revokeObjectURL(n);
    this.zip = void 0, this.urlCache = {};
  }
}
var ql = {}, YM = {
  get exports() {
    return ql;
  },
  set exports(t) {
    ql = t;
  }
};
/*!
    localForage -- Offline Storage, Improved
    Version 1.10.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
(function(t, e) {
  (function(n) {
    t.exports = n();
  })(function() {
    return function n(r, i, s) {
      function o(u, c) {
        if (!i[u]) {
          if (!r[u]) {
            var d = typeof Ei == "function" && Ei;
            if (!c && d)
              return d(u, !0);
            if (a)
              return a(u, !0);
            var h = new Error("Cannot find module '" + u + "'");
            throw h.code = "MODULE_NOT_FOUND", h;
          }
          var v = i[u] = { exports: {} };
          r[u][0].call(v.exports, function(m) {
            var b = r[u][1][m];
            return o(b || m);
          }, v, v.exports, n, r, i, s);
        }
        return i[u].exports;
      }
      for (var a = typeof Ei == "function" && Ei, l = 0; l < s.length; l++)
        o(s[l]);
      return o;
    }({ 1: [function(n, r, i) {
      (function(s) {
        var o = s.MutationObserver || s.WebKitMutationObserver, a;
        if (o) {
          var l = 0, u = new o(m), c = s.document.createTextNode("");
          u.observe(c, {
            characterData: !0
          }), a = function() {
            c.data = l = ++l % 2;
          };
        } else if (!s.setImmediate && typeof s.MessageChannel < "u") {
          var d = new s.MessageChannel();
          d.port1.onmessage = m, a = function() {
            d.port2.postMessage(0);
          };
        } else
          "document" in s && "onreadystatechange" in s.document.createElement("script") ? a = function() {
            var p = s.document.createElement("script");
            p.onreadystatechange = function() {
              m(), p.onreadystatechange = null, p.parentNode.removeChild(p), p = null;
            }, s.document.documentElement.appendChild(p);
          } : a = function() {
            setTimeout(m, 0);
          };
        var h, v = [];
        function m() {
          h = !0;
          for (var p, f, g = v.length; g; ) {
            for (f = v, v = [], p = -1; ++p < g; )
              f[p]();
            g = v.length;
          }
          h = !1;
        }
        r.exports = b;
        function b(p) {
          v.push(p) === 1 && !h && a();
        }
      }).call(this, typeof yn < "u" ? yn : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 2: [function(n, r, i) {
      var s = n(1);
      function o() {
      }
      var a = {}, l = ["REJECTED"], u = ["FULFILLED"], c = ["PENDING"];
      r.exports = d;
      function d(_) {
        if (typeof _ != "function")
          throw new TypeError("resolver must be a function");
        this.state = c, this.queue = [], this.outcome = void 0, _ !== o && b(this, _);
      }
      d.prototype.catch = function(_) {
        return this.then(null, _);
      }, d.prototype.then = function(_, S) {
        if (typeof _ != "function" && this.state === u || typeof S != "function" && this.state === l)
          return this;
        var A = new this.constructor(o);
        if (this.state !== c) {
          var C = this.state === u ? _ : S;
          v(A, C, this.outcome);
        } else
          this.queue.push(new h(A, _, S));
        return A;
      };
      function h(_, S, A) {
        this.promise = _, typeof S == "function" && (this.onFulfilled = S, this.callFulfilled = this.otherCallFulfilled), typeof A == "function" && (this.onRejected = A, this.callRejected = this.otherCallRejected);
      }
      h.prototype.callFulfilled = function(_) {
        a.resolve(this.promise, _);
      }, h.prototype.otherCallFulfilled = function(_) {
        v(this.promise, this.onFulfilled, _);
      }, h.prototype.callRejected = function(_) {
        a.reject(this.promise, _);
      }, h.prototype.otherCallRejected = function(_) {
        v(this.promise, this.onRejected, _);
      };
      function v(_, S, A) {
        s(function() {
          var C;
          try {
            C = S(A);
          } catch (k) {
            return a.reject(_, k);
          }
          C === _ ? a.reject(_, new TypeError("Cannot resolve promise with itself")) : a.resolve(_, C);
        });
      }
      a.resolve = function(_, S) {
        var A = p(m, S);
        if (A.status === "error")
          return a.reject(_, A.value);
        var C = A.value;
        if (C)
          b(_, C);
        else {
          _.state = u, _.outcome = S;
          for (var k = -1, O = _.queue.length; ++k < O; )
            _.queue[k].callFulfilled(S);
        }
        return _;
      }, a.reject = function(_, S) {
        _.state = l, _.outcome = S;
        for (var A = -1, C = _.queue.length; ++A < C; )
          _.queue[A].callRejected(S);
        return _;
      };
      function m(_) {
        var S = _ && _.then;
        if (_ && (typeof _ == "object" || typeof _ == "function") && typeof S == "function")
          return function() {
            S.apply(_, arguments);
          };
      }
      function b(_, S) {
        var A = !1;
        function C(B) {
          A || (A = !0, a.reject(_, B));
        }
        function k(B) {
          A || (A = !0, a.resolve(_, B));
        }
        function O() {
          S(k, C);
        }
        var N = p(O);
        N.status === "error" && C(N.value);
      }
      function p(_, S) {
        var A = {};
        try {
          A.value = _(S), A.status = "success";
        } catch (C) {
          A.status = "error", A.value = C;
        }
        return A;
      }
      d.resolve = f;
      function f(_) {
        return _ instanceof this ? _ : a.resolve(new this(o), _);
      }
      d.reject = g;
      function g(_) {
        var S = new this(o);
        return a.reject(S, _);
      }
      d.all = y;
      function y(_) {
        var S = this;
        if (Object.prototype.toString.call(_) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var A = _.length, C = !1;
        if (!A)
          return this.resolve([]);
        for (var k = new Array(A), O = 0, N = -1, B = new this(o); ++N < A; )
          D(_[N], N);
        return B;
        function D(F, Z) {
          S.resolve(F).then(te, function(L) {
            C || (C = !0, a.reject(B, L));
          });
          function te(L) {
            k[Z] = L, ++O === A && !C && (C = !0, a.resolve(B, k));
          }
        }
      }
      d.race = w;
      function w(_) {
        var S = this;
        if (Object.prototype.toString.call(_) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var A = _.length, C = !1;
        if (!A)
          return this.resolve([]);
        for (var k = -1, O = new this(o); ++k < A; )
          N(_[k]);
        return O;
        function N(B) {
          S.resolve(B).then(function(D) {
            C || (C = !0, a.resolve(O, D));
          }, function(D) {
            C || (C = !0, a.reject(O, D));
          });
        }
      }
    }, { 1: 1 }], 3: [function(n, r, i) {
      (function(s) {
        typeof s.Promise != "function" && (s.Promise = n(2));
      }).call(this, typeof yn < "u" ? yn : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { 2: 2 }], 4: [function(n, r, i) {
      var s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(R) {
        return typeof R;
      } : function(R) {
        return R && typeof Symbol == "function" && R.constructor === Symbol && R !== Symbol.prototype ? "symbol" : typeof R;
      };
      function o(R, $) {
        if (!(R instanceof $))
          throw new TypeError("Cannot call a class as a function");
      }
      function a() {
        try {
          if (typeof indexedDB < "u")
            return indexedDB;
          if (typeof webkitIndexedDB < "u")
            return webkitIndexedDB;
          if (typeof mozIndexedDB < "u")
            return mozIndexedDB;
          if (typeof OIndexedDB < "u")
            return OIndexedDB;
          if (typeof msIndexedDB < "u")
            return msIndexedDB;
        } catch {
          return;
        }
      }
      var l = a();
      function u() {
        try {
          if (!l || !l.open)
            return !1;
          var R = typeof openDatabase < "u" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform), $ = typeof fetch == "function" && fetch.toString().indexOf("[native code") !== -1;
          return (!R || $) && typeof indexedDB < "u" && // some outdated implementations of IDB that appear on Samsung
          // and HTC Android devices <4.4 are missing IDBKeyRange
          // See: https://github.com/mozilla/localForage/issues/128
          // See: https://github.com/mozilla/localForage/issues/272
          typeof IDBKeyRange < "u";
        } catch {
          return !1;
        }
      }
      function c(R, $) {
        R = R || [], $ = $ || {};
        try {
          return new Blob(R, $);
        } catch (q) {
          if (q.name !== "TypeError")
            throw q;
          for (var M = typeof BlobBuilder < "u" ? BlobBuilder : typeof MSBlobBuilder < "u" ? MSBlobBuilder : typeof MozBlobBuilder < "u" ? MozBlobBuilder : WebKitBlobBuilder, Q = new M(), ee = 0; ee < R.length; ee += 1)
            Q.append(R[ee]);
          return Q.getBlob($.type);
        }
      }
      typeof Promise > "u" && n(3);
      var d = Promise;
      function h(R, $) {
        $ && R.then(function(M) {
          $(null, M);
        }, function(M) {
          $(M);
        });
      }
      function v(R, $, M) {
        typeof $ == "function" && R.then($), typeof M == "function" && R.catch(M);
      }
      function m(R) {
        return typeof R != "string" && (console.warn(R + " used as a key, but it is not a string."), R = String(R)), R;
      }
      function b() {
        if (arguments.length && typeof arguments[arguments.length - 1] == "function")
          return arguments[arguments.length - 1];
      }
      var p = "local-forage-detect-blob-support", f = void 0, g = {}, y = Object.prototype.toString, w = "readonly", _ = "readwrite";
      function S(R) {
        for (var $ = R.length, M = new ArrayBuffer($), Q = new Uint8Array(M), ee = 0; ee < $; ee++)
          Q[ee] = R.charCodeAt(ee);
        return M;
      }
      function A(R) {
        return new d(function($) {
          var M = R.transaction(p, _), Q = c([""]);
          M.objectStore(p).put(Q, "key"), M.onabort = function(ee) {
            ee.preventDefault(), ee.stopPropagation(), $(!1);
          }, M.oncomplete = function() {
            var ee = navigator.userAgent.match(/Chrome\/(\d+)/), q = navigator.userAgent.match(/Edge\//);
            $(q || !ee || parseInt(ee[1], 10) >= 43);
          };
        }).catch(function() {
          return !1;
        });
      }
      function C(R) {
        return typeof f == "boolean" ? d.resolve(f) : A(R).then(function($) {
          return f = $, f;
        });
      }
      function k(R) {
        var $ = g[R.name], M = {};
        M.promise = new d(function(Q, ee) {
          M.resolve = Q, M.reject = ee;
        }), $.deferredOperations.push(M), $.dbReady ? $.dbReady = $.dbReady.then(function() {
          return M.promise;
        }) : $.dbReady = M.promise;
      }
      function O(R) {
        var $ = g[R.name], M = $.deferredOperations.pop();
        if (M)
          return M.resolve(), M.promise;
      }
      function N(R, $) {
        var M = g[R.name], Q = M.deferredOperations.pop();
        if (Q)
          return Q.reject($), Q.promise;
      }
      function B(R, $) {
        return new d(function(M, Q) {
          if (g[R.name] = g[R.name] || Y(), R.db)
            if ($)
              k(R), R.db.close();
            else
              return M(R.db);
          var ee = [R.name];
          $ && ee.push(R.version);
          var q = l.open.apply(l, ee);
          $ && (q.onupgradeneeded = function(pe) {
            var we = q.result;
            try {
              we.createObjectStore(R.storeName), pe.oldVersion <= 1 && we.createObjectStore(p);
            } catch (Se) {
              if (Se.name === "ConstraintError")
                console.warn('The database "' + R.name + '" has been upgraded from version ' + pe.oldVersion + " to version " + pe.newVersion + ', but the storage "' + R.storeName + '" already exists.');
              else
                throw Se;
            }
          }), q.onerror = function(pe) {
            pe.preventDefault(), Q(q.error);
          }, q.onsuccess = function() {
            var pe = q.result;
            pe.onversionchange = function(we) {
              we.target.close();
            }, M(pe), O(R);
          };
        });
      }
      function D(R) {
        return B(R, !1);
      }
      function F(R) {
        return B(R, !0);
      }
      function Z(R, $) {
        if (!R.db)
          return !0;
        var M = !R.db.objectStoreNames.contains(R.storeName), Q = R.version < R.db.version, ee = R.version > R.db.version;
        if (Q && (R.version !== $ && console.warn('The database "' + R.name + `" can't be downgraded from version ` + R.db.version + " to version " + R.version + "."), R.version = R.db.version), ee || M) {
          if (M) {
            var q = R.db.version + 1;
            q > R.version && (R.version = q);
          }
          return !0;
        }
        return !1;
      }
      function te(R) {
        return new d(function($, M) {
          var Q = new FileReader();
          Q.onerror = M, Q.onloadend = function(ee) {
            var q = btoa(ee.target.result || "");
            $({
              __local_forage_encoded_blob: !0,
              data: q,
              type: R.type
            });
          }, Q.readAsBinaryString(R);
        });
      }
      function L(R) {
        var $ = S(atob(R.data));
        return c([$], { type: R.type });
      }
      function V(R) {
        return R && R.__local_forage_encoded_blob;
      }
      function H(R) {
        var $ = this, M = $._initReady().then(function() {
          var Q = g[$._dbInfo.name];
          if (Q && Q.dbReady)
            return Q.dbReady;
        });
        return v(M, R, R), M;
      }
      function ie(R) {
        k(R);
        for (var $ = g[R.name], M = $.forages, Q = 0; Q < M.length; Q++) {
          var ee = M[Q];
          ee._dbInfo.db && (ee._dbInfo.db.close(), ee._dbInfo.db = null);
        }
        return R.db = null, D(R).then(function(q) {
          return R.db = q, Z(R) ? F(R) : q;
        }).then(function(q) {
          R.db = $.db = q;
          for (var pe = 0; pe < M.length; pe++)
            M[pe]._dbInfo.db = q;
        }).catch(function(q) {
          throw N(R, q), q;
        });
      }
      function ne(R, $, M, Q) {
        Q === void 0 && (Q = 1);
        try {
          var ee = R.db.transaction(R.storeName, $);
          M(null, ee);
        } catch (q) {
          if (Q > 0 && (!R.db || q.name === "InvalidStateError" || q.name === "NotFoundError"))
            return d.resolve().then(function() {
              if (!R.db || q.name === "NotFoundError" && !R.db.objectStoreNames.contains(R.storeName) && R.version <= R.db.version)
                return R.db && (R.version = R.db.version + 1), F(R);
            }).then(function() {
              return ie(R).then(function() {
                ne(R, $, M, Q - 1);
              });
            }).catch(M);
          M(q);
        }
      }
      function Y() {
        return {
          // Running localForages sharing a database.
          forages: [],
          // Shared database.
          db: null,
          // Database readiness (promise).
          dbReady: null,
          // Deferred operations on the database.
          deferredOperations: []
        };
      }
      function de(R) {
        var $ = this, M = {
          db: null
        };
        if (R)
          for (var Q in R)
            M[Q] = R[Q];
        var ee = g[M.name];
        ee || (ee = Y(), g[M.name] = ee), ee.forages.push($), $._initReady || ($._initReady = $.ready, $.ready = H);
        var q = [];
        function pe() {
          return d.resolve();
        }
        for (var we = 0; we < ee.forages.length; we++) {
          var Se = ee.forages[we];
          Se !== $ && q.push(Se._initReady().catch(pe));
        }
        var Ee = ee.forages.slice(0);
        return d.all(q).then(function() {
          return M.db = ee.db, D(M);
        }).then(function(ke) {
          return M.db = ke, Z(M, $._defaultConfig.version) ? F(M) : ke;
        }).then(function(ke) {
          M.db = ee.db = ke, $._dbInfo = M;
          for (var We = 0; We < Ee.length; We++) {
            var ct = Ee[We];
            ct !== $ && (ct._dbInfo.db = M.db, ct._dbInfo.version = M.version);
          }
        });
      }
      function ue(R, $) {
        var M = this;
        R = m(R);
        var Q = new d(function(ee, q) {
          M.ready().then(function() {
            ne(M._dbInfo, w, function(pe, we) {
              if (pe)
                return q(pe);
              try {
                var Se = we.objectStore(M._dbInfo.storeName), Ee = Se.get(R);
                Ee.onsuccess = function() {
                  var ke = Ee.result;
                  ke === void 0 && (ke = null), V(ke) && (ke = L(ke)), ee(ke);
                }, Ee.onerror = function() {
                  q(Ee.error);
                };
              } catch (ke) {
                q(ke);
              }
            });
          }).catch(q);
        });
        return h(Q, $), Q;
      }
      function Te(R, $) {
        var M = this, Q = new d(function(ee, q) {
          M.ready().then(function() {
            ne(M._dbInfo, w, function(pe, we) {
              if (pe)
                return q(pe);
              try {
                var Se = we.objectStore(M._dbInfo.storeName), Ee = Se.openCursor(), ke = 1;
                Ee.onsuccess = function() {
                  var We = Ee.result;
                  if (We) {
                    var ct = We.value;
                    V(ct) && (ct = L(ct));
                    var kt = R(ct, We.key, ke++);
                    kt !== void 0 ? ee(kt) : We.continue();
                  } else
                    ee();
                }, Ee.onerror = function() {
                  q(Ee.error);
                };
              } catch (We) {
                q(We);
              }
            });
          }).catch(q);
        });
        return h(Q, $), Q;
      }
      function _e(R, $, M) {
        var Q = this;
        R = m(R);
        var ee = new d(function(q, pe) {
          var we;
          Q.ready().then(function() {
            return we = Q._dbInfo, y.call($) === "[object Blob]" ? C(we.db).then(function(Se) {
              return Se ? $ : te($);
            }) : $;
          }).then(function(Se) {
            ne(Q._dbInfo, _, function(Ee, ke) {
              if (Ee)
                return pe(Ee);
              try {
                var We = ke.objectStore(Q._dbInfo.storeName);
                Se === null && (Se = void 0);
                var ct = We.put(Se, R);
                ke.oncomplete = function() {
                  Se === void 0 && (Se = null), q(Se);
                }, ke.onabort = ke.onerror = function() {
                  var kt = ct.error ? ct.error : ct.transaction.error;
                  pe(kt);
                };
              } catch (kt) {
                pe(kt);
              }
            });
          }).catch(pe);
        });
        return h(ee, M), ee;
      }
      function Fe(R, $) {
        var M = this;
        R = m(R);
        var Q = new d(function(ee, q) {
          M.ready().then(function() {
            ne(M._dbInfo, _, function(pe, we) {
              if (pe)
                return q(pe);
              try {
                var Se = we.objectStore(M._dbInfo.storeName), Ee = Se.delete(R);
                we.oncomplete = function() {
                  ee();
                }, we.onerror = function() {
                  q(Ee.error);
                }, we.onabort = function() {
                  var ke = Ee.error ? Ee.error : Ee.transaction.error;
                  q(ke);
                };
              } catch (ke) {
                q(ke);
              }
            });
          }).catch(q);
        });
        return h(Q, $), Q;
      }
      function Ce(R) {
        var $ = this, M = new d(function(Q, ee) {
          $.ready().then(function() {
            ne($._dbInfo, _, function(q, pe) {
              if (q)
                return ee(q);
              try {
                var we = pe.objectStore($._dbInfo.storeName), Se = we.clear();
                pe.oncomplete = function() {
                  Q();
                }, pe.onabort = pe.onerror = function() {
                  var Ee = Se.error ? Se.error : Se.transaction.error;
                  ee(Ee);
                };
              } catch (Ee) {
                ee(Ee);
              }
            });
          }).catch(ee);
        });
        return h(M, R), M;
      }
      function tt(R) {
        var $ = this, M = new d(function(Q, ee) {
          $.ready().then(function() {
            ne($._dbInfo, w, function(q, pe) {
              if (q)
                return ee(q);
              try {
                var we = pe.objectStore($._dbInfo.storeName), Se = we.count();
                Se.onsuccess = function() {
                  Q(Se.result);
                }, Se.onerror = function() {
                  ee(Se.error);
                };
              } catch (Ee) {
                ee(Ee);
              }
            });
          }).catch(ee);
        });
        return h(M, R), M;
      }
      function je(R, $) {
        var M = this, Q = new d(function(ee, q) {
          if (R < 0) {
            ee(null);
            return;
          }
          M.ready().then(function() {
            ne(M._dbInfo, w, function(pe, we) {
              if (pe)
                return q(pe);
              try {
                var Se = we.objectStore(M._dbInfo.storeName), Ee = !1, ke = Se.openKeyCursor();
                ke.onsuccess = function() {
                  var We = ke.result;
                  if (!We) {
                    ee(null);
                    return;
                  }
                  R === 0 || Ee ? ee(We.key) : (Ee = !0, We.advance(R));
                }, ke.onerror = function() {
                  q(ke.error);
                };
              } catch (We) {
                q(We);
              }
            });
          }).catch(q);
        });
        return h(Q, $), Q;
      }
      function $e(R) {
        var $ = this, M = new d(function(Q, ee) {
          $.ready().then(function() {
            ne($._dbInfo, w, function(q, pe) {
              if (q)
                return ee(q);
              try {
                var we = pe.objectStore($._dbInfo.storeName), Se = we.openKeyCursor(), Ee = [];
                Se.onsuccess = function() {
                  var ke = Se.result;
                  if (!ke) {
                    Q(Ee);
                    return;
                  }
                  Ee.push(ke.key), ke.continue();
                }, Se.onerror = function() {
                  ee(Se.error);
                };
              } catch (ke) {
                ee(ke);
              }
            });
          }).catch(ee);
        });
        return h(M, R), M;
      }
      function ht(R, $) {
        $ = b.apply(this, arguments);
        var M = this.config();
        R = typeof R != "function" && R || {}, R.name || (R.name = R.name || M.name, R.storeName = R.storeName || M.storeName);
        var Q = this, ee;
        if (!R.name)
          ee = d.reject("Invalid arguments");
        else {
          var q = R.name === M.name && Q._dbInfo.db, pe = q ? d.resolve(Q._dbInfo.db) : D(R).then(function(we) {
            var Se = g[R.name], Ee = Se.forages;
            Se.db = we;
            for (var ke = 0; ke < Ee.length; ke++)
              Ee[ke]._dbInfo.db = we;
            return we;
          });
          R.storeName ? ee = pe.then(function(we) {
            if (we.objectStoreNames.contains(R.storeName)) {
              var Se = we.version + 1;
              k(R);
              var Ee = g[R.name], ke = Ee.forages;
              we.close();
              for (var We = 0; We < ke.length; We++) {
                var ct = ke[We];
                ct._dbInfo.db = null, ct._dbInfo.version = Se;
              }
              var kt = new d(function(Ot, rn) {
                var Xt = l.open(R.name, Se);
                Xt.onerror = function(er) {
                  var no = Xt.result;
                  no.close(), rn(er);
                }, Xt.onupgradeneeded = function() {
                  var er = Xt.result;
                  er.deleteObjectStore(R.storeName);
                }, Xt.onsuccess = function() {
                  var er = Xt.result;
                  er.close(), Ot(er);
                };
              });
              return kt.then(function(Ot) {
                Ee.db = Ot;
                for (var rn = 0; rn < ke.length; rn++) {
                  var Xt = ke[rn];
                  Xt._dbInfo.db = Ot, O(Xt._dbInfo);
                }
              }).catch(function(Ot) {
                throw (N(R, Ot) || d.resolve()).catch(function() {
                }), Ot;
              });
            }
          }) : ee = pe.then(function(we) {
            k(R);
            var Se = g[R.name], Ee = Se.forages;
            we.close();
            for (var ke = 0; ke < Ee.length; ke++) {
              var We = Ee[ke];
              We._dbInfo.db = null;
            }
            var ct = new d(function(kt, Ot) {
              var rn = l.deleteDatabase(R.name);
              rn.onerror = function() {
                var Xt = rn.result;
                Xt && Xt.close(), Ot(rn.error);
              }, rn.onblocked = function() {
                console.warn('dropInstance blocked for database "' + R.name + '" until all open connections are closed');
              }, rn.onsuccess = function() {
                var Xt = rn.result;
                Xt && Xt.close(), kt(Xt);
              };
            });
            return ct.then(function(kt) {
              Se.db = kt;
              for (var Ot = 0; Ot < Ee.length; Ot++) {
                var rn = Ee[Ot];
                O(rn._dbInfo);
              }
            }).catch(function(kt) {
              throw (N(R, kt) || d.resolve()).catch(function() {
              }), kt;
            });
          });
        }
        return h(ee, $), ee;
      }
      var nt = {
        _driver: "asyncStorage",
        _initStorage: de,
        _support: u(),
        iterate: Te,
        getItem: ue,
        setItem: _e,
        removeItem: Fe,
        clear: Ce,
        length: tt,
        key: je,
        keys: $e,
        dropInstance: ht
      };
      function Et() {
        return typeof openDatabase == "function";
      }
      var yt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Nt = "~~local_forage_type~", ot = /^~~local_forage_type~([^~]+)~/, bt = "__lfsc__:", Kt = bt.length, wt = "arbf", xt = "blob", lt = "si08", qe = "ui08", Rt = "uic8", be = "si16", Ue = "si32", at = "ur16", Pt = "ui32", Qt = "fl32", Ie = "fl64", Ve = Kt + wt.length, Je = Object.prototype.toString;
      function He(R) {
        var $ = R.length * 0.75, M = R.length, Q, ee = 0, q, pe, we, Se;
        R[R.length - 1] === "=" && ($--, R[R.length - 2] === "=" && $--);
        var Ee = new ArrayBuffer($), ke = new Uint8Array(Ee);
        for (Q = 0; Q < M; Q += 4)
          q = yt.indexOf(R[Q]), pe = yt.indexOf(R[Q + 1]), we = yt.indexOf(R[Q + 2]), Se = yt.indexOf(R[Q + 3]), ke[ee++] = q << 2 | pe >> 4, ke[ee++] = (pe & 15) << 4 | we >> 2, ke[ee++] = (we & 3) << 6 | Se & 63;
        return Ee;
      }
      function Qe(R) {
        var $ = new Uint8Array(R), M = "", Q;
        for (Q = 0; Q < $.length; Q += 3)
          M += yt[$[Q] >> 2], M += yt[($[Q] & 3) << 4 | $[Q + 1] >> 4], M += yt[($[Q + 1] & 15) << 2 | $[Q + 2] >> 6], M += yt[$[Q + 2] & 63];
        return $.length % 3 === 2 ? M = M.substring(0, M.length - 1) + "=" : $.length % 3 === 1 && (M = M.substring(0, M.length - 2) + "=="), M;
      }
      function At(R, $) {
        var M = "";
        if (R && (M = Je.call(R)), R && (M === "[object ArrayBuffer]" || R.buffer && Je.call(R.buffer) === "[object ArrayBuffer]")) {
          var Q, ee = bt;
          R instanceof ArrayBuffer ? (Q = R, ee += wt) : (Q = R.buffer, M === "[object Int8Array]" ? ee += lt : M === "[object Uint8Array]" ? ee += qe : M === "[object Uint8ClampedArray]" ? ee += Rt : M === "[object Int16Array]" ? ee += be : M === "[object Uint16Array]" ? ee += at : M === "[object Int32Array]" ? ee += Ue : M === "[object Uint32Array]" ? ee += Pt : M === "[object Float32Array]" ? ee += Qt : M === "[object Float64Array]" ? ee += Ie : $(new Error("Failed to get type for BinaryArray"))), $(ee + Qe(Q));
        } else if (M === "[object Blob]") {
          var q = new FileReader();
          q.onload = function() {
            var pe = Nt + R.type + "~" + Qe(this.result);
            $(bt + xt + pe);
          }, q.readAsArrayBuffer(R);
        } else
          try {
            $(JSON.stringify(R));
          } catch (pe) {
            console.error("Couldn't convert value into a JSON string: ", R), $(null, pe);
          }
      }
      function P(R) {
        if (R.substring(0, Kt) !== bt)
          return JSON.parse(R);
        var $ = R.substring(Ve), M = R.substring(Kt, Ve), Q;
        if (M === xt && ot.test($)) {
          var ee = $.match(ot);
          Q = ee[1], $ = $.substring(ee[0].length);
        }
        var q = He($);
        switch (M) {
          case wt:
            return q;
          case xt:
            return c([q], { type: Q });
          case lt:
            return new Int8Array(q);
          case qe:
            return new Uint8Array(q);
          case Rt:
            return new Uint8ClampedArray(q);
          case be:
            return new Int16Array(q);
          case at:
            return new Uint16Array(q);
          case Ue:
            return new Int32Array(q);
          case Pt:
            return new Uint32Array(q);
          case Qt:
            return new Float32Array(q);
          case Ie:
            return new Float64Array(q);
          default:
            throw new Error("Unkown type: " + M);
        }
      }
      var he = {
        serialize: At,
        deserialize: P,
        stringToBuffer: He,
        bufferToString: Qe
      };
      function ge(R, $, M, Q) {
        R.executeSql("CREATE TABLE IF NOT EXISTS " + $.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], M, Q);
      }
      function Ne(R) {
        var $ = this, M = {
          db: null
        };
        if (R)
          for (var Q in R)
            M[Q] = typeof R[Q] != "string" ? R[Q].toString() : R[Q];
        var ee = new d(function(q, pe) {
          try {
            M.db = openDatabase(M.name, String(M.version), M.description, M.size);
          } catch (we) {
            return pe(we);
          }
          M.db.transaction(function(we) {
            ge(we, M, function() {
              $._dbInfo = M, q();
            }, function(Se, Ee) {
              pe(Ee);
            });
          }, pe);
        });
        return M.serializer = he, ee;
      }
      function G(R, $, M, Q, ee, q) {
        R.executeSql(M, Q, ee, function(pe, we) {
          we.code === we.SYNTAX_ERR ? pe.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [$.storeName], function(Se, Ee) {
            Ee.rows.length ? q(Se, we) : ge(Se, $, function() {
              Se.executeSql(M, Q, ee, q);
            }, q);
          }, q) : q(pe, we);
        }, q);
      }
      function ce(R, $) {
        var M = this;
        R = m(R);
        var Q = new d(function(ee, q) {
          M.ready().then(function() {
            var pe = M._dbInfo;
            pe.db.transaction(function(we) {
              G(we, pe, "SELECT * FROM " + pe.storeName + " WHERE key = ? LIMIT 1", [R], function(Se, Ee) {
                var ke = Ee.rows.length ? Ee.rows.item(0).value : null;
                ke && (ke = pe.serializer.deserialize(ke)), ee(ke);
              }, function(Se, Ee) {
                q(Ee);
              });
            });
          }).catch(q);
        });
        return h(Q, $), Q;
      }
      function T(R, $) {
        var M = this, Q = new d(function(ee, q) {
          M.ready().then(function() {
            var pe = M._dbInfo;
            pe.db.transaction(function(we) {
              G(we, pe, "SELECT * FROM " + pe.storeName, [], function(Se, Ee) {
                for (var ke = Ee.rows, We = ke.length, ct = 0; ct < We; ct++) {
                  var kt = ke.item(ct), Ot = kt.value;
                  if (Ot && (Ot = pe.serializer.deserialize(Ot)), Ot = R(Ot, kt.key, ct + 1), Ot !== void 0) {
                    ee(Ot);
                    return;
                  }
                }
                ee();
              }, function(Se, Ee) {
                q(Ee);
              });
            });
          }).catch(q);
        });
        return h(Q, $), Q;
      }
      function z(R, $, M, Q) {
        var ee = this;
        R = m(R);
        var q = new d(function(pe, we) {
          ee.ready().then(function() {
            $ === void 0 && ($ = null);
            var Se = $, Ee = ee._dbInfo;
            Ee.serializer.serialize($, function(ke, We) {
              We ? we(We) : Ee.db.transaction(function(ct) {
                G(ct, Ee, "INSERT OR REPLACE INTO " + Ee.storeName + " (key, value) VALUES (?, ?)", [R, ke], function() {
                  pe(Se);
                }, function(kt, Ot) {
                  we(Ot);
                });
              }, function(ct) {
                if (ct.code === ct.QUOTA_ERR) {
                  if (Q > 0) {
                    pe(z.apply(ee, [R, Se, M, Q - 1]));
                    return;
                  }
                  we(ct);
                }
              });
            });
          }).catch(we);
        });
        return h(q, M), q;
      }
      function ae(R, $, M) {
        return z.apply(this, [R, $, M, 1]);
      }
      function E(R, $) {
        var M = this;
        R = m(R);
        var Q = new d(function(ee, q) {
          M.ready().then(function() {
            var pe = M._dbInfo;
            pe.db.transaction(function(we) {
              G(we, pe, "DELETE FROM " + pe.storeName + " WHERE key = ?", [R], function() {
                ee();
              }, function(Se, Ee) {
                q(Ee);
              });
            });
          }).catch(q);
        });
        return h(Q, $), Q;
      }
      function J(R) {
        var $ = this, M = new d(function(Q, ee) {
          $.ready().then(function() {
            var q = $._dbInfo;
            q.db.transaction(function(pe) {
              G(pe, q, "DELETE FROM " + q.storeName, [], function() {
                Q();
              }, function(we, Se) {
                ee(Se);
              });
            });
          }).catch(ee);
        });
        return h(M, R), M;
      }
      function se(R) {
        var $ = this, M = new d(function(Q, ee) {
          $.ready().then(function() {
            var q = $._dbInfo;
            q.db.transaction(function(pe) {
              G(pe, q, "SELECT COUNT(key) as c FROM " + q.storeName, [], function(we, Se) {
                var Ee = Se.rows.item(0).c;
                Q(Ee);
              }, function(we, Se) {
                ee(Se);
              });
            });
          }).catch(ee);
        });
        return h(M, R), M;
      }
      function I(R, $) {
        var M = this, Q = new d(function(ee, q) {
          M.ready().then(function() {
            var pe = M._dbInfo;
            pe.db.transaction(function(we) {
              G(we, pe, "SELECT key FROM " + pe.storeName + " WHERE id = ? LIMIT 1", [R + 1], function(Se, Ee) {
                var ke = Ee.rows.length ? Ee.rows.item(0).key : null;
                ee(ke);
              }, function(Se, Ee) {
                q(Ee);
              });
            });
          }).catch(q);
        });
        return h(Q, $), Q;
      }
      function W(R) {
        var $ = this, M = new d(function(Q, ee) {
          $.ready().then(function() {
            var q = $._dbInfo;
            q.db.transaction(function(pe) {
              G(pe, q, "SELECT key FROM " + q.storeName, [], function(we, Se) {
                for (var Ee = [], ke = 0; ke < Se.rows.length; ke++)
                  Ee.push(Se.rows.item(ke).key);
                Q(Ee);
              }, function(we, Se) {
                ee(Se);
              });
            });
          }).catch(ee);
        });
        return h(M, R), M;
      }
      function re(R) {
        return new d(function($, M) {
          R.transaction(function(Q) {
            Q.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(ee, q) {
              for (var pe = [], we = 0; we < q.rows.length; we++)
                pe.push(q.rows.item(we).name);
              $({
                db: R,
                storeNames: pe
              });
            }, function(ee, q) {
              M(q);
            });
          }, function(Q) {
            M(Q);
          });
        });
      }
      function Pe(R, $) {
        $ = b.apply(this, arguments);
        var M = this.config();
        R = typeof R != "function" && R || {}, R.name || (R.name = R.name || M.name, R.storeName = R.storeName || M.storeName);
        var Q = this, ee;
        return R.name ? ee = new d(function(q) {
          var pe;
          R.name === M.name ? pe = Q._dbInfo.db : pe = openDatabase(R.name, "", "", 0), R.storeName ? q({
            db: pe,
            storeNames: [R.storeName]
          }) : q(re(pe));
        }).then(function(q) {
          return new d(function(pe, we) {
            q.db.transaction(function(Se) {
              function Ee(kt) {
                return new d(function(Ot, rn) {
                  Se.executeSql("DROP TABLE IF EXISTS " + kt, [], function() {
                    Ot();
                  }, function(Xt, er) {
                    rn(er);
                  });
                });
              }
              for (var ke = [], We = 0, ct = q.storeNames.length; We < ct; We++)
                ke.push(Ee(q.storeNames[We]));
              d.all(ke).then(function() {
                pe();
              }).catch(function(kt) {
                we(kt);
              });
            }, function(Se) {
              we(Se);
            });
          });
        }) : ee = d.reject("Invalid arguments"), h(ee, $), ee;
      }
      var Oe = {
        _driver: "webSQLStorage",
        _initStorage: Ne,
        _support: Et(),
        iterate: T,
        getItem: ce,
        setItem: ae,
        removeItem: E,
        clear: J,
        length: se,
        key: I,
        keys: W,
        dropInstance: Pe
      };
      function Be() {
        try {
          return typeof localStorage < "u" && "setItem" in localStorage && // in IE8 typeof localStorage.setItem === 'object'
          !!localStorage.setItem;
        } catch {
          return !1;
        }
      }
      function Ye(R, $) {
        var M = R.name + "/";
        return R.storeName !== $.storeName && (M += R.storeName + "/"), M;
      }
      function ln() {
        var R = "_localforage_support_test";
        try {
          return localStorage.setItem(R, !0), localStorage.removeItem(R), !1;
        } catch {
          return !0;
        }
      }
      function Wt() {
        return !ln() || localStorage.length > 0;
      }
      function pt(R) {
        var $ = this, M = {};
        if (R)
          for (var Q in R)
            M[Q] = R[Q];
        return M.keyPrefix = Ye(R, $._defaultConfig), Wt() ? ($._dbInfo = M, M.serializer = he, d.resolve()) : d.reject();
      }
      function Zt(R) {
        var $ = this, M = $.ready().then(function() {
          for (var Q = $._dbInfo.keyPrefix, ee = localStorage.length - 1; ee >= 0; ee--) {
            var q = localStorage.key(ee);
            q.indexOf(Q) === 0 && localStorage.removeItem(q);
          }
        });
        return h(M, R), M;
      }
      function fn(R, $) {
        var M = this;
        R = m(R);
        var Q = M.ready().then(function() {
          var ee = M._dbInfo, q = localStorage.getItem(ee.keyPrefix + R);
          return q && (q = ee.serializer.deserialize(q)), q;
        });
        return h(Q, $), Q;
      }
      function An(R, $) {
        var M = this, Q = M.ready().then(function() {
          for (var ee = M._dbInfo, q = ee.keyPrefix, pe = q.length, we = localStorage.length, Se = 1, Ee = 0; Ee < we; Ee++) {
            var ke = localStorage.key(Ee);
            if (ke.indexOf(q) === 0) {
              var We = localStorage.getItem(ke);
              if (We && (We = ee.serializer.deserialize(We)), We = R(We, ke.substring(pe), Se++), We !== void 0)
                return We;
            }
          }
        });
        return h(Q, $), Q;
      }
      function as(R, $) {
        var M = this, Q = M.ready().then(function() {
          var ee = M._dbInfo, q;
          try {
            q = localStorage.key(R);
          } catch {
            q = null;
          }
          return q && (q = q.substring(ee.keyPrefix.length)), q;
        });
        return h(Q, $), Q;
      }
      function ls(R) {
        var $ = this, M = $.ready().then(function() {
          for (var Q = $._dbInfo, ee = localStorage.length, q = [], pe = 0; pe < ee; pe++) {
            var we = localStorage.key(pe);
            we.indexOf(Q.keyPrefix) === 0 && q.push(we.substring(Q.keyPrefix.length));
          }
          return q;
        });
        return h(M, R), M;
      }
      function Jt(R) {
        var $ = this, M = $.keys().then(function(Q) {
          return Q.length;
        });
        return h(M, R), M;
      }
      function Ln(R, $) {
        var M = this;
        R = m(R);
        var Q = M.ready().then(function() {
          var ee = M._dbInfo;
          localStorage.removeItem(ee.keyPrefix + R);
        });
        return h(Q, $), Q;
      }
      function un(R, $, M) {
        var Q = this;
        R = m(R);
        var ee = Q.ready().then(function() {
          $ === void 0 && ($ = null);
          var q = $;
          return new d(function(pe, we) {
            var Se = Q._dbInfo;
            Se.serializer.serialize($, function(Ee, ke) {
              if (ke)
                we(ke);
              else
                try {
                  localStorage.setItem(Se.keyPrefix + R, Ee), pe(q);
                } catch (We) {
                  (We.name === "QuotaExceededError" || We.name === "NS_ERROR_DOM_QUOTA_REACHED") && we(We), we(We);
                }
            });
          });
        });
        return h(ee, M), ee;
      }
      function ur(R, $) {
        if ($ = b.apply(this, arguments), R = typeof R != "function" && R || {}, !R.name) {
          var M = this.config();
          R.name = R.name || M.name, R.storeName = R.storeName || M.storeName;
        }
        var Q = this, ee;
        return R.name ? ee = new d(function(q) {
          R.storeName ? q(Ye(R, Q._defaultConfig)) : q(R.name + "/");
        }).then(function(q) {
          for (var pe = localStorage.length - 1; pe >= 0; pe--) {
            var we = localStorage.key(pe);
            we.indexOf(q) === 0 && localStorage.removeItem(we);
          }
        }) : ee = d.reject("Invalid arguments"), h(ee, $), ee;
      }
      var Xn = {
        _driver: "localStorageWrapper",
        _initStorage: pt,
        _support: Be(),
        iterate: An,
        getItem: fn,
        setItem: un,
        removeItem: Ln,
        clear: Zt,
        length: Jt,
        key: as,
        keys: ls,
        dropInstance: ur
      }, _a = function($, M) {
        return $ === M || typeof $ == "number" && typeof M == "number" && isNaN($) && isNaN(M);
      }, db = function($, M) {
        for (var Q = $.length, ee = 0; ee < Q; ) {
          if (_a($[ee], M))
            return !0;
          ee++;
        }
        return !1;
      }, Zf = Array.isArray || function(R) {
        return Object.prototype.toString.call(R) === "[object Array]";
      }, to = {}, Xf = {}, us = {
        INDEXEDDB: nt,
        WEBSQL: Oe,
        LOCALSTORAGE: Xn
      }, fb = [us.INDEXEDDB._driver, us.WEBSQL._driver, us.LOCALSTORAGE._driver], Sa = ["dropInstance"], Su = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(Sa), hb = {
        description: "",
        driver: fb.slice(),
        name: "localforage",
        // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
        // we can use without a prompt.
        size: 4980736,
        storeName: "keyvaluepairs",
        version: 1
      };
      function pb(R, $) {
        R[$] = function() {
          var M = arguments;
          return R.ready().then(function() {
            return R[$].apply(R, M);
          });
        };
      }
      function Eu() {
        for (var R = 1; R < arguments.length; R++) {
          var $ = arguments[R];
          if ($)
            for (var M in $)
              $.hasOwnProperty(M) && (Zf($[M]) ? arguments[0][M] = $[M].slice() : arguments[0][M] = $[M]);
        }
        return arguments[0];
      }
      var vb = function() {
        function R($) {
          o(this, R);
          for (var M in us)
            if (us.hasOwnProperty(M)) {
              var Q = us[M], ee = Q._driver;
              this[M] = ee, to[ee] || this.defineDriver(Q);
            }
          this._defaultConfig = Eu({}, hb), this._config = Eu({}, this._defaultConfig, $), this._driverSet = null, this._initDriver = null, this._ready = !1, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch(function() {
          });
        }
        return R.prototype.config = function(M) {
          if ((typeof M > "u" ? "undefined" : s(M)) === "object") {
            if (this._ready)
              return new Error("Can't call config() after localforage has been used.");
            for (var Q in M) {
              if (Q === "storeName" && (M[Q] = M[Q].replace(/\W/g, "_")), Q === "version" && typeof M[Q] != "number")
                return new Error("Database version must be a number.");
              this._config[Q] = M[Q];
            }
            return "driver" in M && M.driver ? this.setDriver(this._config.driver) : !0;
          } else
            return typeof M == "string" ? this._config[M] : this._config;
        }, R.prototype.defineDriver = function(M, Q, ee) {
          var q = new d(function(pe, we) {
            try {
              var Se = M._driver, Ee = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
              if (!M._driver) {
                we(Ee);
                return;
              }
              for (var ke = Su.concat("_initStorage"), We = 0, ct = ke.length; We < ct; We++) {
                var kt = ke[We], Ot = !db(Sa, kt);
                if ((Ot || M[kt]) && typeof M[kt] != "function") {
                  we(Ee);
                  return;
                }
              }
              var rn = function() {
                for (var no = function(yb) {
                  return function() {
                    var bb = new Error("Method " + yb + " is not implemented by the current driver"), eh = d.reject(bb);
                    return h(eh, arguments[arguments.length - 1]), eh;
                  };
                }, xu = 0, mb = Sa.length; xu < mb; xu++) {
                  var Au = Sa[xu];
                  M[Au] || (M[Au] = no(Au));
                }
              };
              rn();
              var Xt = function(no) {
                to[Se] && console.info("Redefining LocalForage driver: " + Se), to[Se] = M, Xf[Se] = no, pe();
              };
              "_support" in M ? M._support && typeof M._support == "function" ? M._support().then(Xt, we) : Xt(!!M._support) : Xt(!0);
            } catch (er) {
              we(er);
            }
          });
          return v(q, Q, ee), q;
        }, R.prototype.driver = function() {
          return this._driver || null;
        }, R.prototype.getDriver = function(M, Q, ee) {
          var q = to[M] ? d.resolve(to[M]) : d.reject(new Error("Driver not found."));
          return v(q, Q, ee), q;
        }, R.prototype.getSerializer = function(M) {
          var Q = d.resolve(he);
          return v(Q, M), Q;
        }, R.prototype.ready = function(M) {
          var Q = this, ee = Q._driverSet.then(function() {
            return Q._ready === null && (Q._ready = Q._initDriver()), Q._ready;
          });
          return v(ee, M, M), ee;
        }, R.prototype.setDriver = function(M, Q, ee) {
          var q = this;
          Zf(M) || (M = [M]);
          var pe = this._getSupportedDrivers(M);
          function we() {
            q._config.driver = q.driver();
          }
          function Se(We) {
            return q._extend(We), we(), q._ready = q._initStorage(q._config), q._ready;
          }
          function Ee(We) {
            return function() {
              var ct = 0;
              function kt() {
                for (; ct < We.length; ) {
                  var Ot = We[ct];
                  return ct++, q._dbInfo = null, q._ready = null, q.getDriver(Ot).then(Se).catch(kt);
                }
                we();
                var rn = new Error("No available storage method found.");
                return q._driverSet = d.reject(rn), q._driverSet;
              }
              return kt();
            };
          }
          var ke = this._driverSet !== null ? this._driverSet.catch(function() {
            return d.resolve();
          }) : d.resolve();
          return this._driverSet = ke.then(function() {
            var We = pe[0];
            return q._dbInfo = null, q._ready = null, q.getDriver(We).then(function(ct) {
              q._driver = ct._driver, we(), q._wrapLibraryMethodsWithReady(), q._initDriver = Ee(pe);
            });
          }).catch(function() {
            we();
            var We = new Error("No available storage method found.");
            return q._driverSet = d.reject(We), q._driverSet;
          }), v(this._driverSet, Q, ee), this._driverSet;
        }, R.prototype.supports = function(M) {
          return !!Xf[M];
        }, R.prototype._extend = function(M) {
          Eu(this, M);
        }, R.prototype._getSupportedDrivers = function(M) {
          for (var Q = [], ee = 0, q = M.length; ee < q; ee++) {
            var pe = M[ee];
            this.supports(pe) && Q.push(pe);
          }
          return Q;
        }, R.prototype._wrapLibraryMethodsWithReady = function() {
          for (var M = 0, Q = Su.length; M < Q; M++)
            pb(this, Su[M]);
        }, R.prototype.createInstance = function(M) {
          return new R(M);
        }, R;
      }(), gb = new vb();
      r.exports = gb;
    }, { 3: 3 }] }, {}, [4])(4);
  });
})(YM);
class lb {
  constructor(e, n, r) {
    this.urlCache = {}, this.storage = void 0, this.name = e, this.requester = n || Zo, this.resolver = r, this.online = !0, this.checkRequirements(), this.addListeners();
  }
  /**
   * Checks to see if localForage exists in global namspace,
   * Requires localForage if it isn't there
   * @private
   */
  checkRequirements() {
    try {
      let e;
      typeof ql > "u" && (e = ql), this.storage = e.createInstance({
        name: this.name
      });
    } catch {
      throw new Error("localForage lib not loaded");
    }
  }
  /**
   * Add online and offline event listeners
   * @private
   */
  addListeners() {
    this._status = this.status.bind(this), window.addEventListener("online", this._status), window.addEventListener("offline", this._status);
  }
  /**
   * Remove online and offline event listeners
   * @private
   */
  removeListeners() {
    window.removeEventListener("online", this._status), window.removeEventListener("offline", this._status), this._status = void 0;
  }
  /**
   * Update the online / offline status
   * @private
   */
  status(e) {
    let n = navigator.onLine;
    this.online = n, n ? this.emit("online", this) : this.emit("offline", this);
  }
  /**
   * Add all of a book resources to the store
   * @param  {Resources} resources  book resources
   * @param  {boolean} [force] force resaving resources
   * @return {Promise<object>} store objects
   */
  add(e, n) {
    let r = e.resources.map((i) => {
      let { href: s } = i, o = this.resolver(s), a = window.encodeURIComponent(o);
      return this.storage.getItem(a).then((l) => !l || n ? this.requester(o, "binary").then((u) => this.storage.setItem(a, u)) : l);
    });
    return Promise.all(r);
  }
  /**
   * Put binary data from a url to storage
   * @param  {string} url  a url to request from storage
   * @param  {boolean} [withCredentials]
   * @param  {object} [headers]
   * @return {Promise<Blob>}
   */
  put(e, n, r) {
    let i = window.encodeURIComponent(e);
    return this.storage.getItem(i).then((s) => s || this.requester(e, "binary", n, r).then((o) => this.storage.setItem(i, o)));
  }
  /**
   * Request a url
   * @param  {string} url  a url to request from storage
   * @param  {string} [type] specify the type of the returned result
   * @param  {boolean} [withCredentials]
   * @param  {object} [headers]
   * @return {Promise<Blob | string | JSON | Document | XMLDocument>}
   */
  request(e, n, r, i) {
    return this.online ? this.requester(e, n, r, i).then((s) => (this.put(e), s)) : this.retrieve(e, n);
  }
  /**
   * Request a url from storage
   * @param  {string} url  a url to request from storage
   * @param  {string} [type] specify the type of the returned result
   * @return {Promise<Blob | string | JSON | Document | XMLDocument>}
   */
  retrieve(e, n) {
    new vt();
    var r, i = new ui(e);
    return n || (n = i.extension), n == "blob" ? r = this.getBlob(e) : r = this.getText(e), r.then((s) => {
      var o = new vt(), a;
      return s ? (a = this.handleResponse(s, n), o.resolve(a)) : o.reject({
        message: "File not found in storage: " + e,
        stack: new Error().stack
      }), o.promise;
    });
  }
  /**
   * Handle the response from request
   * @private
   * @param  {any} response
   * @param  {string} [type]
   * @return {any} the parsed result
   */
  handleResponse(e, n) {
    var r;
    return n == "json" ? r = JSON.parse(e) : Qo(n) ? r = Pr(e, "text/xml") : n == "xhtml" ? r = Pr(e, "application/xhtml+xml") : n == "html" || n == "htm" ? r = Pr(e, "text/html") : r = e, r;
  }
  /**
   * Get a Blob from Storage by Url
   * @param  {string} url
   * @param  {string} [mimeType]
   * @return {Blob}
   */
  getBlob(e, n) {
    let r = window.encodeURIComponent(e);
    return this.storage.getItem(r).then(function(i) {
      if (i)
        return n = n || Ps.lookup(e), new Blob([i], { type: n });
    });
  }
  /**
   * Get Text from Storage by Url
   * @param  {string} url
   * @param  {string} [mimeType]
   * @return {string}
   */
  getText(e, n) {
    let r = window.encodeURIComponent(e);
    return n = n || Ps.lookup(e), this.storage.getItem(r).then(function(i) {
      var s = new vt(), o = new FileReader(), a;
      if (i)
        return a = new Blob([i], { type: n }), o.addEventListener("loadend", () => {
          s.resolve(o.result);
        }), o.readAsText(a, n), s.promise;
    });
  }
  /**
   * Get a base64 encoded result from Storage by Url
   * @param  {string} url
   * @param  {string} [mimeType]
   * @return {string} base64 encoded
   */
  getBase64(e, n) {
    let r = window.encodeURIComponent(e);
    return n = n || Ps.lookup(e), this.storage.getItem(r).then((i) => {
      var s = new vt(), o = new FileReader(), a;
      if (i)
        return a = new Blob([i], { type: n }), o.addEventListener("loadend", () => {
          s.resolve(o.result);
        }), o.readAsDataURL(a, n), s.promise;
    });
  }
  /**
   * Create a Url from a stored item
   * @param  {string} url
   * @param  {object} [options.base64] use base64 encoding or blob url
   * @return {Promise} url promise with Url string
   */
  createUrl(e, n) {
    var r = new vt(), i = window.URL || window.webkitURL || window.mozURL, s, o, a = n && n.base64;
    return e in this.urlCache ? (r.resolve(this.urlCache[e]), r.promise) : (a ? (o = this.getBase64(e), o && o.then(function(l) {
      this.urlCache[e] = l, r.resolve(l);
    }.bind(this))) : (o = this.getBlob(e), o && o.then(function(l) {
      s = i.createObjectURL(l), this.urlCache[e] = s, r.resolve(s);
    }.bind(this))), o || r.reject({
      message: "File not found in storage: " + e,
      stack: new Error().stack
    }), r.promise);
  }
  /**
   * Revoke Temp Url for a archive item
   * @param  {string} url url of the item in the store
   */
  revokeUrl(e) {
    var n = window.URL || window.webkitURL || window.mozURL, r = this.urlCache[e];
    r && n.revokeObjectURL(r);
  }
  destroy() {
    var e = window.URL || window.webkitURL || window.mozURL;
    for (let n in this.urlCache)
      e.revokeObjectURL(n);
    this.urlCache = {}, this.removeListeners();
  }
}
Vr(lb.prototype);
class oc {
  constructor(e) {
    this.interactive = "", this.fixedLayout = "", this.openToSpread = "", this.orientationLock = "", e && this.parse(e);
  }
  /**
   * Parse XML
   * @param  {document} displayOptionsDocument XML
   * @return {DisplayOptions} self
   */
  parse(e) {
    if (!e)
      return this;
    const n = zt(e, "display_options");
    return n ? (li(n, "option").forEach((i) => {
      let s = "";
      switch (i.childNodes.length && (s = i.childNodes[0].nodeValue), i.attributes.name.value) {
        case "interactive":
          this.interactive = s;
          break;
        case "fixed-layout":
          this.fixedLayout = s;
          break;
        case "open-to-spread":
          this.openToSpread = s;
          break;
        case "orientation-lock":
          this.orientationLock = s;
          break;
      }
    }), this) : this;
  }
  destroy() {
    this.interactive = void 0, this.fixedLayout = void 0, this.openToSpread = void 0, this.orientationLock = void 0;
  }
}
const Nv = "META-INF/container.xml", QM = "META-INF/com.apple.ibooks.display-options.xml", dr = {
  BINARY: "binary",
  BASE64: "base64",
  EPUB: "epub",
  OPF: "opf",
  MANIFEST: "json",
  DIRECTORY: "directory"
};
class Qf {
  constructor(e, n) {
    typeof n > "u" && typeof e != "string" && !(e instanceof Blob) && !(e instanceof ArrayBuffer) && (n = e, e = void 0), this.settings = En(this.settings || {}, {
      requestMethod: void 0,
      requestCredentials: void 0,
      requestHeaders: void 0,
      encoding: void 0,
      replacements: void 0,
      canonical: void 0,
      openAs: void 0,
      store: void 0
    }), En(this.settings, n), this.opening = new vt(), this.opened = this.opening.promise, this.isOpen = !1, this.loading = {
      manifest: new vt(),
      spine: new vt(),
      metadata: new vt(),
      cover: new vt(),
      navigation: new vt(),
      pageList: new vt(),
      resources: new vt(),
      displayOptions: new vt()
    }, this.loaded = {
      manifest: this.loading.manifest.promise,
      spine: this.loading.spine.promise,
      metadata: this.loading.metadata.promise,
      cover: this.loading.cover.promise,
      navigation: this.loading.navigation.promise,
      pageList: this.loading.pageList.promise,
      resources: this.loading.resources.promise,
      displayOptions: this.loading.displayOptions.promise
    }, this.ready = Promise.all([
      this.loaded.manifest,
      this.loaded.spine,
      this.loaded.metadata,
      this.loaded.cover,
      this.loaded.navigation,
      this.loaded.resources,
      this.loaded.displayOptions
    ]), this.isRendered = !1, this.request = this.settings.requestMethod || Zo, this.spine = new y6(), this.locations = new K0(this.spine, this.load.bind(this)), this.navigation = void 0, this.pageList = void 0, this.url = void 0, this.path = void 0, this.archived = !1, this.archive = void 0, this.storage = void 0, this.resources = void 0, this.rendition = void 0, this.container = void 0, this.packaging = void 0, this.displayOptions = void 0, this.settings.store && this.store(this.settings.store), e && this.open(e, this.settings.openAs).catch((r) => {
      var i = new Error("Cannot load book at " + e);
      this.emit(Re.BOOK.OPEN_FAILED, i);
    });
  }
  /**
   * Open a epub or url
   * @param {string | ArrayBuffer} input Url, Path or ArrayBuffer
   * @param {string} [what="binary", "base64", "epub", "opf", "json", "directory"] force opening as a certain type
   * @returns {Promise} of when the book has been loaded
   * @example book.open("/path/to/book.epub")
   */
  open(e, n) {
    var r, i = n || this.determineType(e);
    return i === dr.BINARY ? (this.archived = !0, this.url = new vr("/", ""), r = this.openEpub(e)) : i === dr.BASE64 ? (this.archived = !0, this.url = new vr("/", ""), r = this.openEpub(e, i)) : i === dr.EPUB ? (this.archived = !0, this.url = new vr("/", ""), r = this.request(e, "binary", this.settings.requestCredentials, this.settings.requestHeaders).then(this.openEpub.bind(this))) : i == dr.OPF ? (this.url = new vr(e), r = this.openPackaging(this.url.Path.toString())) : i == dr.MANIFEST ? (this.url = new vr(e), r = this.openManifest(this.url.Path.toString())) : (this.url = new vr(e), r = this.openContainer(Nv).then(this.openPackaging.bind(this))), r;
  }
  /**
   * Open an archived epub
   * @private
   * @param  {binary} data
   * @param  {string} [encoding]
   * @return {Promise}
   */
  openEpub(e, n) {
    return this.unarchive(e, n || this.settings.encoding).then(() => this.openContainer(Nv)).then((r) => this.openPackaging(r));
  }
  /**
   * Open the epub container
   * @private
   * @param  {string} url
   * @return {string} packagePath
   */
  openContainer(e) {
    return this.load(e).then((n) => (this.container = new b6(n), this.resolve(this.container.packagePath)));
  }
  /**
   * Open the Open Packaging Format Xml
   * @private
   * @param  {string} url
   * @return {Promise}
   */
  openPackaging(e) {
    return this.path = new ui(e), this.load(e).then((n) => (this.packaging = new Ev(n), this.unpack(this.packaging)));
  }
  /**
   * Open the manifest JSON
   * @private
   * @param  {string} url
   * @return {Promise}
   */
  openManifest(e) {
    return this.path = new ui(e), this.load(e).then((n) => (this.packaging = new Ev(), this.packaging.load(n), this.unpack(this.packaging)));
  }
  /**
   * Load a resource from the Book
   * @param  {string} path path to the resource to load
   * @return {Promise}     returns a promise with the requested resource
   */
  load(e) {
    var n = this.resolve(e);
    return this.archived ? this.archive.request(n) : this.request(n, null, this.settings.requestCredentials, this.settings.requestHeaders);
  }
  /**
   * Resolve a path to it's absolute position in the Book
   * @param  {string} path
   * @param  {boolean} [absolute] force resolving the full URL
   * @return {string}          the resolved path string
   */
  resolve(e, n) {
    if (e) {
      var r = e, i = e.indexOf("://") > -1;
      return i ? e : (this.path && (r = this.path.resolve(e)), n != !1 && this.url && (r = this.url.resolve(r)), r);
    }
  }
  /**
   * Get a canonical link to a path
   * @param  {string} path
   * @return {string} the canonical path string
   */
  canonical(e) {
    var n = e;
    return e ? (this.settings.canonical ? n = this.settings.canonical(e) : n = this.resolve(e, !0), n) : "";
  }
  /**
   * Determine the type of they input passed to open
   * @private
   * @param  {string} input
   * @return {string}  binary | directory | epub | opf
   */
  determineType(e) {
    var n, r, i;
    if (this.settings.encoding === "base64")
      return dr.BASE64;
    if (typeof e != "string")
      return dr.BINARY;
    if (n = new vr(e), r = n.path(), i = r.extension, i && (i = i.replace(/\?.*$/, "")), !i)
      return dr.DIRECTORY;
    if (i === "epub")
      return dr.EPUB;
    if (i === "opf")
      return dr.OPF;
    if (i === "json")
      return dr.MANIFEST;
  }
  /**
   * unpack the contents of the Books packaging
   * @private
   * @param {Packaging} packaging object
   */
  unpack(e) {
    this.package = e, this.packaging.metadata.layout === "" ? this.load(this.url.resolve(QM)).then((n) => {
      this.displayOptions = new oc(n), this.loading.displayOptions.resolve(this.displayOptions);
    }).catch((n) => {
      this.displayOptions = new oc(), this.loading.displayOptions.resolve(this.displayOptions);
    }) : (this.displayOptions = new oc(), this.loading.displayOptions.resolve(this.displayOptions)), this.spine.unpack(this.packaging, this.resolve.bind(this), this.canonical.bind(this)), this.resources = new E6(this.packaging.manifest, {
      archive: this.archive,
      resolver: this.resolve.bind(this),
      request: this.request.bind(this),
      replacements: this.settings.replacements || (this.archived ? "blobUrl" : "base64")
    }), this.loadNavigation(this.packaging).then(() => {
      this.loading.navigation.resolve(this.navigation);
    }), this.packaging.coverPath && (this.cover = this.resolve(this.packaging.coverPath)), this.loading.manifest.resolve(this.packaging.manifest), this.loading.metadata.resolve(this.packaging.metadata), this.loading.spine.resolve(this.spine), this.loading.cover.resolve(this.cover), this.loading.resources.resolve(this.resources), this.loading.pageList.resolve(this.pageList), this.isOpen = !0, this.archived || this.settings.replacements && this.settings.replacements != "none" ? this.replacements().then(() => {
      this.loaded.displayOptions.then(() => {
        this.opening.resolve(this);
      });
    }).catch((n) => {
      console.error(n);
    }) : this.loaded.displayOptions.then(() => {
      this.opening.resolve(this);
    });
  }
  /**
   * Load Navigation and PageList from package
   * @private
   * @param {Packaging} packaging
   */
  loadNavigation(e) {
    let n = e.navPath || e.ncxPath, r = e.toc;
    return r ? new Promise((i, s) => {
      this.navigation = new rc(r), e.pageList && (this.pageList = new ic(e.pageList)), i(this.navigation);
    }) : n ? this.load(n, "xml").then((i) => (this.navigation = new rc(i), this.pageList = new ic(i), this.navigation)) : new Promise((i, s) => {
      this.navigation = new rc(), this.pageList = new ic(), i(this.navigation);
    });
  }
  /**
   * Gets a Section of the Book from the Spine
   * Alias for `book.spine.get`
   * @param {string} target
   * @return {Section}
   */
  section(e) {
    return this.spine.get(e);
  }
  /**
   * Sugar to render a book to an element
   * @param  {element | string} element element or string to add a rendition to
   * @param  {object} [options]
   * @return {Rendition}
   */
  renderTo(e, n) {
    return this.rendition = new Yf(this, n), this.rendition.attachTo(e), this.rendition;
  }
  /**
   * Set if request should use withCredentials
   * @param {boolean} credentials
   */
  setRequestCredentials(e) {
    this.settings.requestCredentials = e;
  }
  /**
   * Set headers request should use
   * @param {object} headers
   */
  setRequestHeaders(e) {
    this.settings.requestHeaders = e;
  }
  /**
   * Unarchive a zipped epub
   * @private
   * @param  {binary} input epub data
   * @param  {string} [encoding]
   * @return {Archive}
   */
  unarchive(e, n) {
    return this.archive = new JM(), this.archive.open(e, n);
  }
  /**
   * Store the epubs contents
   * @private
   * @param  {binary} input epub data
   * @param  {string} [encoding]
   * @return {Store}
   */
  store(e) {
    let n = this.settings.replacements && this.settings.replacements !== "none", r = this.url, i = this.settings.requestMethod || Zo.bind(this);
    return this.storage = new lb(e, i, this.resolve.bind(this)), this.request = this.storage.request.bind(this.storage), this.opened.then(() => {
      this.archived && (this.storage.requester = this.archive.request.bind(this.archive));
      let s = (o, a) => {
        a.output = this.resources.substitute(o, a.url);
      };
      this.resources.settings.replacements = n || "blobUrl", this.resources.replacements().then(() => this.resources.replaceCss()), this.storage.on("offline", () => {
        this.url = new vr("/", ""), this.spine.hooks.serialize.register(s);
      }), this.storage.on("online", () => {
        this.url = r, this.spine.hooks.serialize.deregister(s);
      });
    }), this.storage;
  }
  /**
   * Get the cover url
   * @return {Promise<?string>} coverUrl
   */
  coverUrl() {
    return this.loaded.cover.then(() => this.cover ? this.archived ? this.archive.createUrl(this.cover) : this.cover : null);
  }
  /**
   * Load replacement urls
   * @private
   * @return {Promise} completed loading urls
   */
  replacements() {
    return this.spine.hooks.serialize.register((e, n) => {
      n.output = this.resources.substitute(e, n.url);
    }), this.resources.replacements().then(() => this.resources.replaceCss());
  }
  /**
   * Find a DOM Range for a given CFI Range
   * @param  {EpubCFI} cfiRange a epub cfi range
   * @return {Promise}
   */
  getRange(e) {
    var n = new gt(e), r = this.spine.get(n.spinePos), i = this.load.bind(this);
    return r ? r.load(i).then(function(s) {
      var o = n.toRange(r.document);
      return o;
    }) : new Promise((s, o) => {
      o("CFI could not be found");
    });
  }
  /**
   * Generates the Book Key using the identifier in the manifest or other string provided
   * @param  {string} [identifier] to use instead of metadata identifier
   * @return {string} key
   */
  key(e) {
    var n = e || this.packaging.metadata.identifier || this.url.filename;
    return `epubjs:${yu}:${n}`;
  }
  /**
   * Destroy the Book and all associated objects
   */
  destroy() {
    this.opened = void 0, this.loading = void 0, this.loaded = void 0, this.ready = void 0, this.isOpen = !1, this.isRendered = !1, this.spine && this.spine.destroy(), this.locations && this.locations.destroy(), this.pageList && this.pageList.destroy(), this.archive && this.archive.destroy(), this.resources && this.resources.destroy(), this.container && this.container.destroy(), this.packaging && this.packaging.destroy(), this.rendition && this.rendition.destroy(), this.displayOptions && this.displayOptions.destroy(), this.spine = void 0, this.locations = void 0, this.pageList = void 0, this.archive = void 0, this.resources = void 0, this.container = void 0, this.packaging = void 0, this.rendition = void 0, this.navigation = void 0, this.url = void 0, this.path = void 0, this.archived = !1;
  }
}
Vr(Qf.prototype);
function os(t, e) {
  return new Qf(t, e);
}
os.VERSION = yu;
typeof global < "u" && (global.EPUBJS_VERSION = yu);
os.Book = Qf;
os.Rendition = Yf;
os.Contents = Gf;
os.CFI = gt;
os.utils = d6;
function ZM(t, e) {
  t.addEventListener(
    "keyup",
    (n) => {
      n.key === "ArrowUp" || n.key === "ArrowRight" ? e("next") : (n.key === "ArrowDown" || n.key === "ArrowLeft") && e("prev");
    },
    !1
  );
}
function XM(t, e) {
  let i = 0, s;
  t.addEventListener("wheel", (o) => {
    o.ignore || (o.ignore = !0, clearTimeout(s), i += o.deltaY, s = setTimeout(() => {
      if (Math.abs(i) >= 750) {
        let a = Math.sign(i) > 0 ? "next" : "prev";
        e(a), i = 0;
      }
      i = 0;
    }, 50));
  });
}
function eL(t, e) {
  let s, o, a;
  t.addEventListener(
    "touchstart",
    (l) => {
      l.ignore || (l.ignore = !0, s = l.changedTouches[0].pageX, o = l.changedTouches[0].pageY, a = Date.now());
    },
    !1
  ), t.addEventListener(
    "touchend",
    (l) => {
      var h, v;
      if (l.ignore)
        return;
      l.ignore = !0;
      const u = l.changedTouches[0].pageX - s, c = l.changedTouches[0].pageY - o;
      Date.now() - a <= 500 && (Math.abs(u) >= 50 && Math.abs(c) <= 200 ? e(u < 0 ? "prev" : "next") : Math.abs(c) >= 50 && Math.abs(u) <= 200 ? e(c < 0 ? "up" : "down") : ((v = (h = t == null ? void 0 : t.defaultView) == null ? void 0 : h.getSelection()) == null || v.removeAllRanges(), t.dispatchEvent(
        new MouseEvent("click", {
          clientX: s,
          clientY: o
        })
      ), l.preventDefault()));
    },
    !1
  );
}
function tL(t, e, n) {
  t.addEventListener("mousedown", () => {
    t.getSelection().removeAllRanges(), n("cleared");
  }), t.addEventListener("mouseup", (r) => {
    if (r.ignore)
      return;
    r.ignore = !0;
    const i = t.getSelection(), s = i.toString();
    if (s === "")
      return;
    const o = i.getRangeAt(0), [a] = e.getContents(), l = a.cfiFromRange(o), u = o.getBoundingClientRect(), c = e.manager.container.getBoundingClientRect();
    let d = {
      left: `${c.x + u.x - (e.manager.scrollLeft || 0)}px`,
      top: `${c.y + u.y}px`,
      width: `${u.width}px`,
      height: `${u.height}px`
    };
    n("selected", d, s, l);
  });
}
const ub = ye({
  name: "EpubView",
  model: {
    prop: "location",
    event: "update:location"
  },
  emits: {
    "update:location"(t) {
      return !0;
    },
    select(t, e) {
      return !0;
    },
    keyup(t) {
      return !0;
    }
  },
  props: {
    url: {
      required: !0
      // type: Object as PropType<Props['url']>,
    },
    location: {
      // type: [Number, String],
    },
    tocChanged: {
      type: Function
    },
    getRendition: {
      type: Function
    },
    epubInitOptions: {
      type: Object,
      default: () => ({})
    },
    epubOptions: {
      type: Object,
      default: () => ({})
    }
  },
  setup(t, e) {
    const { emit: n, slots: r, expose: i } = e, s = ft(), o = Xe.bind(s), { url: a, location: l } = pn(t), { tocChanged: u, getRendition: c, epubInitOptions: d, epubOptions: h } = t, v = K(null), m = K([]), b = K(!1);
    let p = null, f = null;
    const g = async () => {
      p && p.destroy(), a.value && (p = os(a.value, d), p.loaded.navigation.then(({ toc: N }) => {
        b.value = !0, m.value = N, u && u(N), y();
      }));
    }, y = () => {
      var B, D;
      const N = v.value || ((B = s == null ? void 0 : s.refs) == null ? void 0 : B.viewer);
      f = p.renderTo(N, {
        width: "100%",
        height: "100%",
        ...h
      }), _(), c && c(f), typeof (l == null ? void 0 : l.value) == "string" || typeof (l == null ? void 0 : l.value) == "number" ? f.display(l.value) : m.value.length > 0 && ((D = m == null ? void 0 : m.value[0]) != null && D.href) ? f.display(m.value[0].href) : f.display();
    }, w = (N) => {
      N === "next" ? C() : N === "prev" && k();
    }, _ = () => {
      f && (f.on("rendered", (N, B) => {
        var D, F;
        (D = B == null ? void 0 : B.iframe) == null || D.contentWindow.focus(), (F = h == null ? void 0 : h.flow) != null && F.includes("scrolled") || XM(B.document, w), eL(B.document, w), ZM(B.document, w);
      }), f.on("locationChanged", S), f.on(
        "displayError",
        (N) => console.error("error rendering book", N)
      ), f.on(
        "selected",
        (N, B) => n("select", N, B)
      ), f.on("keyup", (N) => n("keyPress", N)));
    }, S = (N) => {
      const B = N.start;
      (l == null ? void 0 : l.value) !== B && n("update:location", B);
    };
    l && Ae(
      l,
      ((N, B = 1e3) => {
        let D;
        return function(...Z) {
          const te = () => {
            D = null, N(...Z);
          };
          clearTimeout(D), D = setTimeout(te, B);
        };
      })((N, B) => {
        N && N === B || (typeof N == "string" && (f == null || f.display(N)), typeof N == "number" && (f == null || f.display(N)));
      }),
      {
        immediate: !0
      }
    ), Ae(a, () => {
      g();
    });
    const C = () => {
      f == null || f.next();
    }, k = () => {
      f == null || f.prev();
    }, O = (N) => {
      typeof N == "string" && f.display(N), typeof N == "number" && f.display(N);
    };
    return Ct(() => {
      g();
    }), xn(() => {
      p == null || p.destroy();
    }), i ? i({ nextPage: C, prevPage: k, setLocation: O }) : ((B) => {
      if (!s)
        throw new Error("expose should be called in setup().");
      const D = Object.keys(B);
      D.forEach((F) => {
        s.proxy[F] = B[F];
      }), xn(() => {
        D.forEach((F) => {
          s.proxy[F] = void 0;
        });
      });
    })({ nextPage: C, prevPage: k, setLocation: O }), () => {
      var N;
      return o("div", { class: "reader" }, [
        o("div", { class: "viewHolder" }, [
          o("div", {
            ref: parseFloat(Lv) >= 2.7 ? v : "viewer",
            class: "view",
            id: "viewer",
            attrs: { id: "viewer" },
            style: {
              display: b.value ? null : "none"
            }
          }),
          !b.value && o("div", (N = r.loadingView) == null ? void 0 : N.call(r))
        ])
      ]);
    };
  }
});
const cb = ye({
  name: "TocComponent",
  props: {
    toc: {
      type: Array,
      default: () => []
    },
    current: {
      type: [String, Number],
      default: ""
    },
    setLocation: {
      type: Function,
      required: !0
    },
    isSubmenu: {
      type: Boolean,
      default: !1,
      required: !1
    }
  },
  setup(t) {
    const e = ft(), n = Xe.bind(e), { setLocation: r, isSubmenu: i } = t, { toc: s, current: o } = pn(t);
    return () => n(
      "div",
      null,
      s.value.map((a, l) => n("div", { key: l }, [
        n(
          "button",
          {
            class: [
              "tocAreaButton",
              a.href === o.value ? "active" : ""
            ],
            on: {
              click: () => {
                a.subitems.length > 0 ? (a.expansion = !a.expansion, r(a.href, !1)) : r(a.href);
              }
            },
            onClick: () => {
              a.subitems.length > 0 ? (a.expansion = !a.expansion, r(a.href, !1)) : r(a.href);
            }
          },
          [
            `${i ? " ".repeat(4) : ""}${a.label}`,
            // 展开
            a.subitems && a.subitems.length > 0 && n("div", {
              class: `${a.expansion ? "open" : ""} expansion`
            })
          ]
        ),
        //多级目录
        a.subitems && a.subitems.length > 0 && n(
          Sr,
          { name: "collapse-transition" },
          {
            default: () => n(
              "div",
              {
                style: {
                  display: a.expansion ? void 0 : "none"
                }
              },
              n(cb, {
                toc: a.subitems,
                current: o.value,
                setLocation: r,
                isSubmenu: !0,
                attrs: {
                  toc: s.value,
                  current: o.value,
                  setLocation: r,
                  isSubmenu: !0
                }
              })
            )
          }
        )
      ]))
    );
  }
});
ye({
  name: "VueReader",
  props: {
    url: {
      required: !0
      // type: [string | ArrayBuffer],
    },
    title: String,
    showToc: {
      type: Boolean,
      default: !0
    },
    tocChanged: {
      type: Function
    },
    getRendition: {
      type: Function
    }
  },
  setup(t, e) {
    const { emit: n, slots: r, expose: i, attrs: s } = e, o = ft(), a = Xe.bind(o), l = K(null), u = K(null), c = K(""), { tocChanged: d, getRendition: h } = t, { title: v, url: m, showToc: b } = pn(t), p = Mn({
      toc: [],
      //目录
      expandedToc: !1
      //目录展开
    }), { toc: f, expandedToc: g } = pn(p), y = K(""), w = () => {
      g.value = !g.value;
    }, _ = (O) => {
      f.value = O.map((N) => ({ ...N, expansion: !1 })), d && d(O);
    }, S = (O) => {
      h && h(O), O.on("relocated", (B) => {
        u.value = B;
      });
      const N = O.book;
      N.ready.then(() => {
        const B = N.package.metadata;
        y.value = B.title;
      });
    }, A = (O, N = !0) => {
      const B = l.value || (o == null ? void 0 : o.refs.epubRef);
      B == null || B.setLocation(O), c.value = O, g.value = !N;
    }, C = () => {
      const O = l.value || (o == null ? void 0 : o.refs.epubRef);
      O == null || O.nextPage();
    }, k = () => {
      const O = l.value || (o == null ? void 0 : o.refs.epubRef);
      O == null || O.prevPage();
    };
    return i ? i({ setLocation: A, next: C, pre: k }) : ((N) => {
      if (!o)
        throw new Error("expose should be called in setup().");
      const B = Object.keys(N);
      B.forEach((D) => {
        o.proxy[D] = N[D];
      }), xn(() => {
        B.forEach((D) => {
          o.proxy[D] = void 0;
        });
      });
    })({ setLocation: A, next: C, pre: k }), () => {
      var O, N, B, D, F;
      return a("div", { class: "container" }, [
        a(
          "div",
          { class: ["readerArea", { containerExpanded: g.value }] },
          [
            // 展开目录
            b.value && a(
              "button",
              {
                class: [
                  "tocButton",
                  { tocButtonExpanded: g.value }
                ],
                type: "button",
                on: {
                  click: w
                },
                onClick: w
              },
              [
                a("span", { class: "tocButtonBar", style: "top: 35%" }),
                a("span", { class: "tocButtonBar", style: "top: 66%" })
              ]
            ),
            // 书名
            a(
              "div",
              { class: "titleArea", title: y.value },
              r.title ? (O = r.title) == null ? void 0 : O.call(r) : v.value || y.value
            ),
            // 阅读区
            a(
              ub,
              {
                ref: parseFloat(Lv) < 2.7 ? "epubRef" : l,
                url: m.value,
                tocChanged: _,
                getRendition: S,
                ...s,
                //vue2
                attrs: {
                  url: m.value,
                  tocChanged: _,
                  getRendition: S,
                  ...s
                },
                on: {
                  ...e.listeners
                }
              },
              {
                // loading
                loadingView: () => {
                  var Z;
                  return a(
                    "div",
                    { class: "loadingView" },
                    r.loadingView ? (Z = r.loadingView) == null ? void 0 : Z.call(r) : "Loading..."
                  );
                }
              }
            ),
            // 翻页
            a(
              "button",
              {
                class: "arrow pre",
                on: {
                  click: k
                },
                onClick: k,
                domProps: {
                  disabled: (N = u.value) == null ? void 0 : N.atStart
                },
                disabled: (B = u.value) == null ? void 0 : B.atStart
              },
              "‹"
            ),
            a(
              "button",
              {
                class: "arrow next",
                on: {
                  click: C
                },
                onClick: C,
                domProps: {
                  disabled: (D = u.value) == null ? void 0 : D.atEnd
                },
                disabled: (F = u.value) == null ? void 0 : F.atEnd
              },
              "›"
            )
          ]
        ),
        // 目录
        b.value && a("div", [
          a(
            "div",
            { class: "tocArea" },
            a(cb, {
              toc: f.value,
              current: c.value,
              setLocation: A,
              attrs: {
                toc: f.value,
                current: c.value,
                setLocation: A
              }
            })
          ),
          // 目录遮罩
          g.value && a("div", {
            class: ["tocBackground"],
            onClick: w,
            on: {
              click: w
            }
          })
        ])
      ]);
    };
  }
});
const nL = (t) => (zv("data-v-3bf5a8c5"), t = t(), jv(), t), rL = /* @__PURE__ */ nL(() => /* @__PURE__ */ le("div", { class: "el-popover__title" }, "Table of Content", -1)), iL = {
  __name: "TocMenu",
  props: {
    toc: {
      default: () => [],
      type: Array
    }
  },
  emits: ["node-click"],
  setup(t, { emit: e }) {
    const n = t, r = Xs(), i = (s) => {
      e("node-click", s);
    };
    return (s, o) => {
      const a = rs, l = sD, u = da;
      return U(), xe(u, {
        "popper-class": `popper ${x(r).theme}`,
        placement: "bottom",
        width: 380,
        trigger: "hover",
        "popper-style": { height: "85%" }
      }, {
        reference: fe(() => [
          ve(a, {
            size: "small",
            icon: x(r2),
            circle: ""
          }, null, 8, ["icon"])
        ]),
        default: fe(() => [
          rL,
          ve(l, {
            data: n.toc,
            onNodeClick: i
          }, null, 8, ["data"])
        ]),
        _: 1
      }, 8, ["popper-class"]);
    };
  }
}, sL = /* @__PURE__ */ is(iL, [["__scopeId", "data-v-3bf5a8c5"]]);
const oL = { class: "el-popover__title" }, aL = {
  __name: "SearchMenu",
  props: {
    searchResult: {
      default: () => [],
      type: Array
    }
  },
  emits: ["search", "node-click"],
  setup(t, { emit: e }) {
    const n = t, r = Xs(), { searchResult: i } = pn(n), s = K(""), o = () => {
    }, a = () => {
      s.value;
    }, l = (c) => {
      e("node-click", c);
    };
    let u = null;
    return Ae(s, (c) => {
      c.length !== 0 && (clearTimeout(u), u = setTimeout(() => {
        e("search", c);
      }, 1e3));
    }), Ae(i, () => {
      a();
    }), (c, d) => {
      const h = rs, v = uu, m = W3, b = V3, p = da;
      return U(), xe(p, {
        "popper-class": `popper reader-${x(r).theme}`,
        width: "350",
        trigger: "hover",
        onShow: a,
        onHide: o
      }, {
        reference: fe(() => [
          ve(h, {
            size: "small",
            icon: x(C2),
            circle: ""
          }, null, 8, ["icon"])
        ]),
        default: fe(() => [
          le("div", oL, [
            ve(v, {
              modelValue: s.value,
              "onUpdate:modelValue": d[0] || (d[0] = (f) => s.value = f),
              size: "small",
              width: "300",
              placeholder: "search"
            }, null, 8, ["modelValue"])
          ]),
          (U(), xe(b, {
            key: x(i).length,
            "show-header": !1,
            data: x(i),
            onCellClick: l
          }, {
            default: fe(() => [
              ve(m, {
                prop: "label",
                width: "350"
              })
            ]),
            _: 1
          }, 8, ["data"]))
        ]),
        _: 1
      }, 8, ["popper-class"]);
    };
  }
};
const eo = (t) => (zv("data-v-b4a6d1f6"), t = t(), jv(), t), lL = { class: "table" }, uL = /* @__PURE__ */ eo(() => /* @__PURE__ */ le("td", null, "Flow", -1)), cL = /* @__PURE__ */ eo(() => /* @__PURE__ */ le("td", null, "Theme", -1)), dL = /* @__PURE__ */ eo(() => /* @__PURE__ */ le("td", null, "Line Spacing", -1)), fL = /* @__PURE__ */ eo(() => /* @__PURE__ */ le("td", null, "Font Size", -1)), hL = /* @__PURE__ */ eo(() => /* @__PURE__ */ le("td", null, "Font", -1)), pL = /* @__PURE__ */ eo(() => /* @__PURE__ */ le("td", null, "reset", -1)), vL = {
  __name: "ThemeMenu",
  emits: ["style-change", "theme-change", "flow-change"],
  setup(t, { emit: e }) {
    const n = Xs(), { lineSpacing: r, theme: i, flow: s, font: o, fontSize: a } = rw(n), l = () => {
      const u = {
        p: {
          "font-family": o.value !== "" ? `${o.value} !important` : "!invalid-hack",
          "font-size": a.value !== "" ? `${a.value} !important` : "!invalid-hack"
        },
        body: {
          "font-family": o.value !== "" ? `${o.value} !important` : "!invalid-hack"
          // "text-align": `${theme.ta} !important`,
        },
        "*": {
          "line-height": `${r.value} !important`,
          "font-size": a.value !== "" ? `${a.value}% !important` : "!invalid-hack"
        }
      };
      e("style-change", u);
    };
    return Ct(() => {
      l();
    }), Ae(
      () => [r, o, a],
      () => {
        l();
      },
      {
        deep: !0
      }
    ), Ae(i, (u) => {
      e("theme-change", u);
    }), Ae(s, (u) => {
      e("flow-change", u);
    }), (u, c) => {
      const d = rs, h = _4, v = w4, m = ty, b = VR, p = UR, f = da;
      return U(), xe(f, {
        "popper-class": x(i),
        trigger: "hover",
        width: 270
      }, {
        reference: fe(() => [
          ve(d, {
            size: "small",
            icon: x(zC),
            circle: ""
          }, null, 8, ["icon"])
        ]),
        default: fe(() => [
          le("table", lL, [
            le("tr", null, [
              uL,
              le("td", null, [
                ve(v, {
                  modelValue: x(s),
                  "onUpdate:modelValue": c[0] || (c[0] = (g) => on(s) ? s.value = g : null),
                  size: "small",
                  style: { "flex-wrap": "nowrap" }
                }, {
                  default: fe(() => [
                    ve(h, {
                      label: "paginated",
                      border: ""
                    }, {
                      default: fe(() => [
                        cn(" Paged ")
                      ]),
                      _: 1
                    }),
                    ve(h, {
                      label: "scrolled-doc",
                      border: ""
                    }, {
                      default: fe(() => [
                        cn(" Scrolled ")
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["modelValue"])
              ])
            ]),
            le("tr", null, [
              cL,
              le("td", null, [
                ve(v, {
                  modelValue: x(i),
                  "onUpdate:modelValue": c[1] || (c[1] = (g) => on(i) ? i.value = g : null),
                  size: "small"
                }, {
                  default: fe(() => [
                    ve(h, {
                      label: "default",
                      border: ""
                    }, {
                      default: fe(() => [
                        cn(" Light ")
                      ]),
                      _: 1
                    }),
                    ve(h, {
                      label: "tan",
                      border: ""
                    }, {
                      default: fe(() => [
                        cn(" Tan ")
                      ]),
                      _: 1
                    }),
                    ve(h, {
                      label: "dark",
                      border: ""
                    }, {
                      default: fe(() => [
                        cn(" Dark ")
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["modelValue"])
              ])
            ]),
            le("tr", null, [
              dL,
              le("td", null, [
                ve(m, {
                  modelValue: x(r),
                  "onUpdate:modelValue": c[2] || (c[2] = (g) => on(r) ? r.value = g : null),
                  precision: 2,
                  step: 0.1,
                  min: 1.3,
                  max: 2,
                  size: "small"
                }, null, 8, ["modelValue", "step", "min", "max"])
              ])
            ]),
            le("tr", null, [
              fL,
              le("td", null, [
                ve(m, {
                  modelValue: x(a),
                  "onUpdate:modelValue": c[3] || (c[3] = (g) => on(a) ? a.value = g : null),
                  step: 2,
                  min: 10,
                  max: 300,
                  size: "small"
                }, null, 8, ["modelValue"])
              ])
            ]),
            le("tr", null, [
              hL,
              le("td", null, [
                ve(p, {
                  teleported: !1,
                  modelValue: x(o),
                  "onUpdate:modelValue": c[4] || (c[4] = (g) => on(o) ? o.value = g : null),
                  class: "font-select",
                  width: "50",
                  size: "small"
                }, {
                  default: fe(() => [
                    ve(b, {
                      label: "Default",
                      value: ""
                    }),
                    ve(b, {
                      label: "Arial",
                      value: "Arial"
                    }),
                    ve(b, {
                      label: "Times New Roman",
                      value: "Times New Roman"
                    })
                  ]),
                  _: 1
                }, 8, ["modelValue"])
              ])
            ]),
            le("tr", null, [
              pL,
              le("td", null, [
                ve(d, {
                  onClick: x(n).reset
                }, {
                  default: fe(() => [
                    cn("reset all")
                  ]),
                  _: 1
                }, 8, ["onClick"])
              ])
            ])
          ])
        ]),
        _: 1
      }, 8, ["popper-class"]);
    };
  }
}, gL = /* @__PURE__ */ is(vL, [["__scopeId", "data-v-b4a6d1f6"]]);
const mL = {
  name: "BubleMenu",
  data() {
    return {
      isVisible: !1,
      translateTo: "gu",
      translatedText: "",
      text: ""
    };
  },
  methods: {
    setProps(t, e, n) {
      let r = this.$refs.popRef;
      r.style.left = t.left, r.style.top = t.top, r.style.width = t.width, r.style.height = t.height, console.log(t), this.text = e, this.cfiRange = n, this.translateText(), this.isVisible = !0;
    },
    hide() {
      this.isVisible = !1, this.text = "", this.translatedText = "No Data", this.cfiRange = "";
    },
    show() {
      this.isVisible = !0;
    },
    onHLBtn() {
      this.cfiRange !== "" && this.$emit("highlight-btn-click", this.cfiRange);
    },
    copyText() {
      const t = document.createElement("textarea");
      t.style.position = "absolute", t.style.left = "-9999px", t.value = this.text, document.body.appendChild(t), t.select(), document.execCommand("copy"), document.body.removeChild(t);
    },
    translateText() {
    }
  }
}, yL = { class: "el-popover__title" }, bL = /* @__PURE__ */ le("template", { slot: "prepend" }, [
  /* @__PURE__ */ cn(" Translate to ")
], -1), wL = {
  ref: "popRef",
  style: { position: "absolute", visibility: "hidden" }
};
function _L(t, e, n, r, i, s) {
  const o = rs, a = Tm, l = uu, u = da, c = iy;
  return U(), xe(u, {
    modelValue: i.isVisible,
    "onUpdate:modelValue": e[1] || (e[1] = (d) => i.isVisible = d),
    "popper-class": "buble",
    trigger: "manual"
  }, {
    reference: fe(() => [
      le("span", wL, null, 512)
    ]),
    default: fe(() => [
      ve(a, null, {
        default: fe(() => [
          ve(o, {
            size: "small",
            icon: "brush",
            onClick: s.onHLBtn
          }, null, 8, ["onClick"]),
          ve(o, {
            size: "small",
            icon: "copy-document",
            onClick: s.copyText
          }, null, 8, ["onClick"]),
          Bt(ve(o, {
            size: "small",
            icon: "collection"
          }, null, 512), [
            [c, void 0, "translatePop"]
          ])
        ]),
        _: 1
      }),
      ve(u, {
        ref: "translatePop",
        width: "200",
        trigger: "hover"
      }, {
        reference: fe(() => [
          cn(st(i.translatedText), 1)
        ]),
        default: fe(() => [
          le("div", yL, [
            ve(l, {
              modelValue: i.translateTo,
              "onUpdate:modelValue": e[0] || (e[0] = (d) => i.translateTo = d),
              placeholder: "Language Code",
              width: "30",
              size: "small"
            }, {
              default: fe(() => [
                bL
              ]),
              _: 1
            }, 8, ["modelValue"])
          ])
        ]),
        _: 1
      }, 512)
    ]),
    _: 1
  }, 8, ["modelValue"]);
}
const SL = /* @__PURE__ */ is(mL, [["render", _L]]), EL = async (t) => {
  const { toc: e } = t.navigation, { spine: n } = t, r = (l) => (l.startsWith("..") && (l = l.substring(2)), l.startsWith("/") && (l = l.substring(1)), l), i = (l) => l.split("#")[0], s = (l) => l.split("#")[1], o = [], a = async (l, u) => {
    for (let c = 0; c < l.length; c += 1) {
      const d = r(l[c].href), h = i(d), v = s(d), m = n.get(h);
      await m.load(t.load.bind(t));
      const b = m.document.getElementById(v), p = m.cfiFromElement(b), f = t.locations.percentageFromCfi(p);
      u[c] = {
        label: l[c].label.trim(),
        children: [],
        href: d,
        cfi: p,
        percentage: f
      }, l[c].subitems && await a(l[c].subitems, u[c].children);
    }
  };
  return await a(e, o), o;
}, xL = async (t, e, n) => {
  !t || typeof t != "string" || e.ready.then(() => e.locations.generate()).then(async (r) => {
    const i = e.package.metadata, s = {
      // id: key,
      title: i.title,
      author: i.creator,
      publisher: i.publisher,
      path: t,
      bookmarks: [],
      highlights: [],
      bgColorFromCover: "",
      toc: await EL(e),
      locations: r
    };
    n && n(s, e);
  });
}, AL = {
  body: {
    background: "#444 !important",
    color: "#fff !important"
  },
  "*": {
    color: "inherit !important",
    background: "inherit !important"
  },
  "a:link": {
    color: "#1e83d2 !important",
    "text-decoration": "none !important"
  },
  "a:link:hover": {
    background: "rgba(0, 0, 0, 0.1) !important"
  }
}, kL = {
  body: {
    background: "#fdf6e3 !important",
    color: "#002b36 !important"
  },
  "*": {
    color: "inherit !important",
    background: "inherit !important"
  },
  "a:link": {
    color: "#268bd2 !important",
    "text-decoration": "none !important"
  },
  "a:link:hover": {
    background: "rgba(0, 0, 0, 0.1) !important"
  }
};
const CL = {
  __name: "Reader",
  props: {
    bookInfo: {
      type: [Object, Number, ArrayBuffer]
    }
  },
  emits: ["update:showReader", "theme-change"],
  setup(t, { emit: e }) {
    const n = t, r = Xs(), i = K(!1), s = K({}), o = K(""), a = j(() => n.bookInfo.url ? `/books/${n.bookInfo.url}` : n.bookInfo);
    let l = null, u = null;
    const c = (ne) => {
      l = ne;
      const Y = l.book;
      l.on("rendered", (de, ue) => {
        tL(ue.document, l, H);
      }), l.on("relocated", (de) => {
        S.value.push(de.start.cfi), p.value = Y.locations.percentageFromCfi(de.start.cfi), b.value = Math.floor(p.value * 1e4) / 100;
      }), l.hooks.content.register(Z), Y.ready.then(() => {
        const de = Y.package.metadata;
        return console.log(Y.package.metadata), o.value = de.title, Y.locations.generate();
      }).then(async (de) => {
        l.themes.registerRules("dark", AL), l.themes.registerRules("tan", kL), l.ready = !0;
        const { theme: ue, flow: Te } = r;
        N(ue), B(Te), await xL(a.value, Y, (_e) => {
          s.value = _e, u = function Fe(Ce) {
            return [].concat(
              ...Ce.map((tt) => [tt].concat(...Fe(tt.children)))
            );
          }(_e.toc), u.sort((Fe, Ce) => Fe.percentage - Ce.percentage);
        });
      }).then(() => {
        i.value = !0;
      }).then(() => {
        i.value = !0;
      });
    }, d = K([]), h = K(""), v = (ne, Y) => {
      let de = "n/a";
      return ne.some((ue) => {
        if (ue.subitems.length > 0) {
          const Te = v(ue.subitems, Y);
          if (Te !== "n/a")
            return de = Te, !0;
        } else if (ue.href.includes(Y))
          return de = ue.label, !0;
      }), de;
    }, m = (ne) => {
      if (ne) {
        const { displayed: Y, href: de } = l.location.start;
        if (l.location.end, de !== "titlepage.xhtml") {
          const ue = v(d.value, de);
          h.value = `${Y.page}/${Y.total} ${ue}`;
        }
      }
    };
    Ct(() => {
    });
    const b = K(0), p = K(0), f = (ne) => {
      let Y = g(ne);
      return Y ? Y.label : "";
    }, g = (ne) => {
      if (!u)
        return {};
      ne /= 100;
      for (let Y = 0; Y < u.length; Y += 1)
        if (u[Y].percentage > ne)
          return u[Y - 1];
      return null;
    }, y = (ne) => {
      let Y = l.book.locations.cfiFromPercentage(ne / 100);
      l.display(Y);
    }, w = K(0);
    ((ne) => {
      var Y = XMLHttpRequest.prototype.open;
      XMLHttpRequest.prototype.open = function() {
        this.addEventListener(
          "progress",
          function(de) {
            de.lengthComputable && ne(de.loaded / de.total);
          },
          !1
        ), Y.apply(this, arguments);
      };
    })((ne) => {
      w.value = Math.round(ne * 100);
    });
    const S = K([]), A = () => {
      S.value.pop();
      let ne = S.value.pop();
      ne ? l.display(ne) : e("update:showReader", !1);
    }, C = () => {
      e("update:showReader", !1);
    }, k = (ne) => {
      console.log(ne.cfi, ne.href), l.display(ne.cfi || ne.href);
    }, O = K({}), N = (ne) => {
      l.themes.select(ne), r.theme = ne, F(), e("theme-change", ne);
    }, B = (ne) => {
      l.ready && l.flow(ne);
    }, D = (ne) => {
      O.value = ne, Z(), F();
    }, F = () => {
      l && l.manager && l.start();
    }, Z = () => {
      l && l.getContents().forEach((ne) => {
        ne.addStylesheetRules(O.value);
      });
    }, te = K([]), L = (ne) => {
      const Y = l.book;
      return Promise.all(
        Y.spine.spineItems.map(
          (de) => de.load(Y.load.bind(Y)).then(de.find.bind(de, ne)).finally(de.unload.bind(de))
        )
      ).then((de) => de.flat()).then((de) => {
        te.value = de.map((ue) => (ue.label = ue.excerpt, ue));
      }).then(() => {
      });
    }, V = K(null), H = (ne, Y, de, ue) => {
      if (ne === "cleared") {
        V.value.hide();
        return;
      }
      console.log(V.value), V.value.setProps(Y, de, ue), V.value.isBubleVisible = !0;
    }, ie = (ne) => {
      l.annotations.highlight(ne);
    };
    return (ne, Y) => {
      const de = rs, ue = Tm, Te = sy, _e = ey, Fe = MP, Ce = H4, tt = Xm, je = VD;
      return U(), xe(tt, { direction: "vertical" }, {
        default: fe(() => [
          ve(Ey, { title: o.value }, {
            default: fe(() => [
              ve(ue, null, {
                default: fe(() => [
                  ve(de, {
                    size: "small",
                    icon: x(fk),
                    circle: "",
                    onClick: A
                  }, null, 8, ["icon"]),
                  ve(de, {
                    size: "small",
                    icon: x(pC),
                    circle: "",
                    onClick: C
                  }, null, 8, ["icon"])
                ]),
                _: 1
              }),
              ve(sL, {
                toc: s.value.toc,
                onNodeClick: k
              }, null, 8, ["toc"]),
              ve(aL, {
                "search-result": te.value,
                onNodeClick: k,
                onSearch: L
              }, null, 8, ["search-result"]),
              ve(gL, {
                onThemeChange: N,
                onFlowChange: B,
                onStyleChange: D
              })
            ]),
            _: 1
          }, 8, ["title"]),
          ve(_e, { class: "container" }, {
            default: fe(() => [
              Bt((U(), xe(x(ub), {
                id: "reader",
                url: x(a),
                getRendition: c,
                title: h.value,
                epubOptions: {
                  allowPopups: !0,
                  allowScriptedContent: !0
                },
                "onUpdate:location": m
              }, {
                loadingView: fe(() => [
                  ve(Te, { percentage: w.value }, null, 8, ["percentage"])
                ]),
                _: 1
              }, 8, ["url", "title"])), [
                [je, !i.value]
              ])
            ]),
            _: 1
          }),
          ve(Ce, { height: "45" }, {
            default: fe(() => [
              ve(Fe, {
                modelValue: b.value,
                "onUpdate:modelValue": Y[0] || (Y[0] = ($e) => b.value = $e),
                step: 0.01,
                "format-tooltip": f,
                onChange: y
              }, null, 8, ["modelValue", "step"])
            ]),
            _: 1
          }),
          ve(SL, {
            ref_key: "bubleMenu",
            ref: V,
            onHighlightBtnClick: ie
          }, null, 512)
        ]),
        _: 1
      });
    };
  }
}, TL = /* @__PURE__ */ is(CL, [["__scopeId", "data-v-dc866de6"]]);
const OL = {
  name: "ReaderStart"
}, IL = /* @__PURE__ */ Object.assign(OL, {
  setup(t) {
    const e = Xs(), n = K(!1), r = K({}), i = (s) => {
      r.value = s, n.value = !0;
    };
    return (s, o) => (U(), oe("div", {
      id: "index",
      ref: "app",
      class: X("reader-" + x(e).theme)
    }, [
      ve(Sr, { name: "el-fade-in-linear" }, {
        default: fe(() => [
          n.value ? me("", !0) : (U(), xe(e8, {
            key: 0,
            "onUpdate:currentBook": i,
            showReader: n.value,
            "onUpdate:showReader": o[0] || (o[0] = (a) => n.value = a)
          }, null, 8, ["showReader"]))
        ]),
        _: 1
      }),
      ve(Sr, { name: "el-fade-in-linear" }, {
        default: fe(() => [
          n.value ? (U(), xe(TL, {
            key: 0,
            bookInfo: r.value,
            "onUpdate:showReader": o[1] || (o[1] = (a) => n.value = a)
          }, null, 8, ["bookInfo"])) : me("", !0)
        ]),
        _: 1
      })
    ], 2));
  }
}), NL = /* @__PURE__ */ is(IL, [["__scopeId", "data-v-e6b91ae5"]]), DL = {
  install: (t) => {
    const e = Xb();
    t.use(e), t.component("ReaderStart", NL);
  }
};
export {
  DL as default,
  Xs as useReaderStore
};
